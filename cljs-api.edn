{:release {:cljs-version "0.0-971",
           :cljs-tag "r971",
           :cljs-date "2012-01-27",
           :clj-version "1.3.0",
           :clj-tag "clojure-1.3.0",
           :treader-version nil,
           :treader-tag nil,
           :gclosure-lib "20110323-r790"},
 :clj-not-cljs #{"clojure.core/conj!"
                 "clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.data/EqualityPartition"
                 "clojure.core/*in*"
                 "clojure.core/unchecked-subtract-int"
                 "clojure.main/demunge"
                 "clojure.lang/Reversible"
                 "clojure.core/release-pending-sends"
                 "clojure.lang/AReference"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shorts"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.lang/AMapEntry"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.test/use-fixtures"
                 "clojure.java.io/file"
                 "clojure.lang/FnLoaderThunk"
                 "clojure.test/*load-tests*"
                 "clojure.lang/IMapEntry"
                 "clojure.test/deftest-"
                 "clojure.core/unchecked-add"
                 "clojure.core/assoc!"
                 "clojure.lang/Fn"
                 "clojure.core/doubles"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.core/unchecked-byte"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.lang/SeqIterator"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.lang/LazilyPersistentVector"
                 "clojure.lang/TransientVector"
                 "clojure.core/proxy-super"
                 "clojure.core/unchecked-divide-int"
                 "clojure.core/refer"
                 "clojure.lang/Numbers"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.lang/ILookupThunk"
                 "clojure.core/future-call"
                 "clojure.core/persistent!"
                 "clojure.pprint/print-table"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.lang/ITransientCollection"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.pprint/*print-base*"
                 "clojure.core/into-array"
                 "clojure.core/load-string"
                 "clojure.lang/LispReader"
                 "clojure.core/pmap"
                 "clojure.lang/ARef"
                 "clojure.test/file-position"
                 "clojure.lang/Repl"
                 "clojure.core/double-array"
                 "clojure.lang/RestFn"
                 "clojure.core/float"
                 "clojure.lang/Compiler"
                 "clojure.lang/IProxy"
                 "clojure.test/do-report"
                 "clojure.core/send"
                 "clojure.core/unchecked-float"
                 "clojure.test/testing"
                 "clojure.lang/Named"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.lang/ITransientAssociative"
                 "clojure.lang/Symbol"
                 "clojure.pprint/pprint-indent"
                 "clojure.lang/PersistentStructMap"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.lang/Util"
                 "clojure.core/agent-error"
                 "clojure.lang/PersistentTreeSet.EMPTY"
                 "clojure.lang/Obj"
                 "clojure.core/ns-refers"
                 "clojure.lang/Binding"
                 "clojure.core/num"
                 "clojure.lang/IPersistentMap"
                 "clojure.lang/IRef"
                 "clojure.core/*clojure-version*"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.lang/PersistentTreeSet"
                 "clojure.core/unchecked-short"
                 "clojure.java.io/make-writer"
                 "clojure.test/test-var"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/sorted-map"
                 "clojure.core/init-proxy"
                 "clojure.core/unchecked-inc-int"
                 "clojure.lang/IChunk"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.core/ints"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.lang/ITransientSet"
                 "clojure.reflect/type-reflect"
                 "clojure.test/testing-contexts-str"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.lang/LineNumberingPushbackReader"
                 "clojure.test/join-fixtures"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.test/run-tests"
                 "clojure.core/short"
                 "clojure.core/unchecked-dec-int"
                 "clojure.lang/TransientArrayMap"
                 "clojure.core/unchecked-subtract"
                 "clojure.lang/EnumerationSeq"
                 "clojure.core/sorted-map-by"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.test/successful?"
                 "clojure.core/await"
                 "clojure.test/testing-vars-str"
                 "clojure.core/supers"
                 "clojure.lang/ASeq"
                 "clojure.test/is"
                 "clojure.reflect/Field"
                 "clojure.core/sorted?"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.core/unchecked-negate"
                 "clojure.lang/Box"
                 "clojure.java.io/make-output-stream"
                 "clojure.lang/BigInt"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.lang/RSeq"
                 "clojure.lang/APersistentVector"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.core/require"
                 "clojure.pprint/pprint-tab"
                 "clojure.core/case"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.lang/IReference"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.lang/KeySeq"
                 "clojure.lang/ChunkBuffer"
                 "clojure.core/ref-set"
                 "clojure.core/booleans"
                 "clojure.lang/PersistentHashSet"
                 "clojure.test/run-all-tests"
                 "clojure.test.tap/with-tap-output"
                 "clojure.core/*print-length*"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/transient"
                 "clojure.core/with-redefs"
                 "clojure.core/use"
                 "clojure.lang/Intrinsics"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.lang/Compile"
                 "clojure.core/future?"
                 "clojure.lang/IEditableCollection"
                 "clojure.core/proxy-mappings"
                 "clojure.lang/Reflector"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/longs"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.core/bytes"
                 "clojure.lang/Namespace"
                 "clojure.lang/PersistentArrayMap"
                 "clojure.lang/PersistentArrayMap.EMPTY"
                 "clojure.lang/ILookupSite"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.lang/ArrayNode"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.lang/Agent"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.core/memfn"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.lang/ChunkedCons"
                 "clojure.core/ref"
                 "clojure.lang/Sorted"
                 "clojure.core/future-cancel"
                 "clojure.core/nthrest"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.test/compose-fixtures"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/sorted-set-by"
                 "clojure.core/with-in-str"
                 "clojure.core/test"
                 "clojure.core/list?"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.lang/ATransientSet"
                 "clojure.core/with-bindings*"
                 "clojure.test/test-ns"
                 "clojure.test/assert-predicate"
                 "clojure.lang/ArityException"
                 "clojure.core/to-array-2d"
                 "clojure.core/update-proxy"
                 "clojure.lang/APersistentMap"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/reversible?"
                 "clojure.lang/ITransientVector"
                 "clojure.core/promise"
                 "clojure.core/*compile-files*"
                 "clojure.core/print-str"
                 "clojure.core/pop!"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.core/unchecked-double"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.core/array-map"
                 "clojure.reflect/resolve-class"
                 "clojure.java.io/as-file"
                 "clojure.core/dissoc!"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/shuffle"
                 "clojure.core/*e"
                 "clojure.core/defonce"
                 "clojure.core/unchecked-inc"
                 "clojure.core/create-ns"
                 "clojure.lang/IObj"
                 "clojure.core/hash-set"
                 "clojure.repl/doc"
                 "clojure.lang/APersistentSet"
                 "clojure.core/aset-int"
                 "clojure.test/test-all-vars"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.lang/IBlockingDeref"
                 "clojure.core/int-array"
                 "clojure.test/with-test"
                 "clojure.core/unchecked-remainder-int"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.lang/ATransientMap"
                 "clojure.core/val"
                 "clojure.template/apply-template"
                 "clojure.core/cast"
                 "clojure.lang/XMLHandler"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.lang/PersistentHashMap.EMPTY"
                 "clojure.lang/ValSeq"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.lang/TransactionalHashMap"
                 "clojure.core/char"
                 "clojure.core/ensure"
                 "clojure.lang/AFunction"
                 "clojure.core/*print-level*"
                 "clojure.lang/IChunkedSeq"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.core/ifn?"
                 "clojure.lang/IKeywordLookup"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.lang/ArrayChunk"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.lang/PersistentTreeMap"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/make-array"
                 "clojure.core/bound-fn"
                 "clojure.core/special-symbol?"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/long"
                 "clojure.core/locking"
                 "clojure.lang/IType"
                 "clojure.core/char-array"
                 "clojure.lang/PersistentHashSet.EMPTY"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.lang/HashCollisionNode"
                 "clojure.core/future"
                 "clojure.lang/IteratorSeq"
                 "clojure.core/object-array"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.test/are"
                 "clojure.lang/AFn"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/rseq"
                 "clojure.core/thread-bound?"
                 "clojure.lang/MapEntry"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/floats"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.lang/BitmapIndexedNode.EMPTY"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/sorted-set"
                 "clojure.lang/IPersistentCollection"
                 "clojure.lang/PersistentHashMap"
                 "clojure.core/resolve"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/lazy-cat"
                 "clojure.core/file-seq"
                 "clojure.core/ns-interns"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core/comparator"
                 "clojure.core/get-thread-bindings"
                 "clojure.core/var"
                 "clojure.stacktrace/e"
                 "clojure.core/unchecked-add-int"
                 "clojure.lang/MapEquivalence"
                 "clojure.lang/DynamicClassLoader"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/key"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/unchecked-int"
                 "clojure.core/error-mode"
                 "clojure.lang/MethodImplCache"
                 "clojure.core/subseq"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.lang/RT"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.core/disj!"
                 "clojure.lang/Ref"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.lang/ProxyHandler"
                 "clojure.core/decimal?"
                 "clojure.core/pcalls"
                 "clojure.lang/KeywordLookupSite"
                 "clojure.lang/StringSeq"
                 "clojure.core/with-out-str"
                 "clojure.lang/NodeSeq"
                 "clojure.core/long-array"
                 "clojure.core/ns-unalias"
                 "clojure.core/double"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.lang/PersistentVector.EMPTY"
                 "clojure.reflect/TypeReference"
                 "clojure.lang/ArraySeq"
                 "clojure.lang/BitmapIndexedNode"
                 "clojure.lang/PersistentTreeMap.EMPTY"
                 "clojure.test/function?"
                 "clojure.data/Diff"
                 "clojure.pprint/pprint"
                 "clojure.test/deftest"
                 "clojure.core/unchecked-negate-int"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.lang/PersistentVector"
                 "clojure.core/pop-thread-bindings"
                 "clojure.data/diff"
                 "clojure.main/main"
                 "clojure.core/unchecked-multiply"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/chars"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.lang/LockingTransaction"
                 "clojure.lang/SeqEnumeration"
                 "clojure.test/try-expr"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.test/report"
                 "clojure.core/unchecked-char"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/println-str"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.lang/TransientHashSet"
                 "clojure.core/int"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.lang/ChunkedSeq"
                 "clojure.core/bound?"
                 "clojure.java.io/writer"
                 "clojure.core/prn-str"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.lang/Var"
                 "clojure.lang/Keyword"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.core/byte"
                 "clojure.lang/Settable"
                 "clojure.core/unchecked-dec"
                 "clojure.lang/Script"
                 "clojure.core/sequence"
                 "clojure.lang/ITransientMap"
                 "clojure.lang/IPersistentList"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.lang/TransientHashMap"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.core/unchecked-long"
                 "clojure.lang/Ratio"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core/unchecked-multiply-int"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"
                 "clojure.core/rsubseq"},
 :symbols {"cljs.core/keys" {:description "Returns a sequence of the keys in `hash-map`.",
                             :ns "cljs.core",
                             :name "keys",
                             :signature ["[hash-map]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/vals"],
                             :full-name-encode "cljs.core_keys",
                             :source {:code "(defn keys\n  [hash-map]\n  (seq (map first hash-map)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2420 2423]},
                             :full-name "cljs.core/keys",
                             :clj-symbol "clojure.core/keys",
                             :docstring "Returns a sequence of the map's keys."},
           "cljs.core/reset!" {:description "Sets the value of atom `a` to `new-value` without regard for the current value.\n\nReturns `new-value`.",
                               :ns "cljs.core",
                               :name "reset!",
                               :signature ["[a new-value]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/swap!"
                                         "cljs.core/compare-and-set!"
                                         "cljs.core/atom"],
                               :full-name-encode "cljs.core_resetBANG",
                               :source {:code "(defn reset!\n  [a new-value]\n  (when-let [validate (.-validator a)]\n    (assert (validate new-value) \"Validator rejected reference state\"))\n  (let [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (-notify-watches a old-value new-value))\n  new-value)",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3056 3065]},
                               :full-name "cljs.core/reset!",
                               :clj-symbol "clojure.core/reset!",
                               :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
           "clojure.set/select" {:description "Returns a set of the elements for which `pred` is true.",
                                 :ns "clojure.set",
                                 :name "select",
                                 :signature ["[pred xset]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/filter"],
                                 :full-name-encode "clojure.set_select",
                                 :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [61 65]},
                                 :full-name "clojure.set/select",
                                 :clj-symbol "clojure.set/select",
                                 :docstring "Returns a set of the elements for which pred is true"},
           "cljs.core/delay" {:ns "cljs.core",
                              :name "delay",
                              :signature ["[& body]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_delay",
                              :source {:code "(defn delay\n  [& body]\n  (Delay. (fn [] (apply identity body)) (atom nil)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3192 3198]},
                              :full-name "cljs.core/delay",
                              :clj-symbol "clojure.core/delay",
                              :docstring "Takes a body of expressions and yields a Delay object that will\ninvoke the body only the first time it is forced (with force or deref/@), and\nwill cache the result and return it on all subsequent force\ncalls."},
           "cljs.core/bit-not" {:description "Bitwise complement.  Same as `~x` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-not",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_bit-not",
                                :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [964 966]},
                                :extra-sources ({:code "(defmacro bit-not [x]\n  (list 'js* \"(~ ~{})\" x))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [140 141]}),
                                :examples [{:id "d4c5e3",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-not 2r1100)\n;;=> -13\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-not 12)\n;;=> -13\n```"}],
                                :full-name "cljs.core/bit-not",
                                :clj-symbol "clojure.core/bit-not",
                                :docstring "Bitwise complement"},
           "cljs.core/partition" {:description "Returns a lazy sequence of lists of `n` items each, at offsets `step` apart.\n\nIf `step` is not supplied, defaults to `n`, i.e. the partitions do not overlap.\n\nIf a `pad` collection is supplied, its elements will be used as necessary to\ncomplete the last partition up to `n` items.\n\nReturns a partition with less than `n` items if there are not enough padding\nelements.",
                                  :ns "cljs.core",
                                  :name "partition",
                                  :signature ["[n coll]"
                                              "[n step coll]"
                                              "[n step pad coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/partition-all"
                                            "cljs.core/split-at"
                                            "cljs.core/partition-by"],
                                  :full-name-encode "cljs.core_partition",
                                  :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (= n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (= n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1871 1891]},
                                  :full-name "cljs.core/partition",
                                  :clj-symbol "clojure.core/partition",
                                  :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition upto n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "cljs.core/parents" {:ns "cljs.core",
                                :name "parents",
                                :signature ["[tag]" "[h tag]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_parents",
                                :source {:code "(defn parents\n  ([tag] (parents @global-hierarchy tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3321 3327]},
                                :full-name "cljs.core/parents",
                                :clj-symbol "clojure.core/parents",
                                :docstring "Returns the immediate parents of tag, either via a Java type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/aclone" {:description "Creates a clone of the given JavaScript array `arr`.  The result is a new\nJavaScript array, which is a shallow copy, not a deep copy.",
                               :ns "cljs.core",
                               :name "aclone",
                               :signature ["[arr]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/array"
                                         "cljs.core/make-array"],
                               :full-name-encode "cljs.core_aclone",
                               :source {:code "(defn aclone\n  [array-like]\n  #_(goog.array.clone array-like)\n  (js* \"Array.prototype.slice.call(~{array-like})\"))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [65 69]},
                               :examples [{:id "422c4e",
                                           :content "```clj\n(def a #js [1 2 3])\n(def b (aclone a))\n(aset b 0 4)\n\na\n;;=> #js [1 2 3]\n\nb\n;;=> #js [4 2 3]\n```"}],
                               :full-name "cljs.core/aclone",
                               :clj-symbol "clojure.core/aclone",
                               :docstring "Returns a javascript array, cloned from the passed in array"},
           "cljs.core/reset-meta!" {:ns "cljs.core",
                                    :name "reset-meta!",
                                    :signature ["[iref m]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_reset-metaBANG",
                                    :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3123 3126]},
                                    :full-name "cljs.core/reset-meta!",
                                    :clj-symbol "clojure.core/reset-meta!",
                                    :docstring "Atomically resets the metadata for an atom"},
           "special/defrecord*" {:ns "special",
                                 :name "defrecord*",
                                 :type "special form",
                                 :source {:code "(defmethod parse 'defrecord*\n  [_ env [_ tsym fields] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :defrecord* :t t :fields fields}))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/clj/cljs/compiler.clj",
                                          :lines [862 873]},
                                 :full-name "special/defrecord*",
                                 :full-name-encode "special_defrecordSTAR",
                                 :history [["+" "0.0-927"]]},
           "cljs.reader/dispatch-macros" {:ns "cljs.reader",
                                          :name "dispatch-macros",
                                          :type "var",
                                          :source {:code "(def dispatch-macros\n  {\"{\" read-set\n   \"<\" (throwing-reader \"Unreadable form\")\n   \"\\\"\" read-regex\n   \"!\" read-comment\n   \"_\" read-discard})",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [331 336]},
                                          :full-name "cljs.reader/dispatch-macros",
                                          :full-name-encode "cljs.reader_dispatch-macros",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/current-repl-env" {:ns "cljs.repl.rhino",
                                               :name "current-repl-env",
                                               :type "var",
                                               :source {:code "(def current-repl-env (atom nil))",
                                                        :repo "clojurescript",
                                                        :tag "r971",
                                                        :filename "src/clj/cljs/repl/rhino.clj",
                                                        :lines [18]},
                                               :full-name "cljs.repl.rhino/current-repl-env",
                                               :full-name-encode "cljs.repl.rhino_current-repl-env",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/ICollection" {:ns "cljs.core",
                                    :name "ICollection",
                                    :type "protocol",
                                    :full-name-encode "cljs.core_ICollection",
                                    :source {:code "(defprotocol ICollection\n  (-conj [coll o]))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [124 125]},
                                    :methods [{:name "-conj",
                                               :signature ["[coll o]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/ICollection",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/every?" {:description "Returns true if `(pred x)` is logical true for every `x` in `coll`, else false.",
                               :ns "cljs.core",
                               :name "every?",
                               :signature ["[pred coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/some"
                                         "cljs.core/not-any?"],
                               :full-name-encode "cljs.core_everyQMARK",
                               :source {:code "(defn every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1443 1450]},
                               :full-name "cljs.core/every?",
                               :clj-symbol "clojure.core/every?",
                               :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
           "clojure.zip/node" {:ns "clojure.zip",
                               :name "node",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_node",
                               :source {:code "(defn node\n  [loc] (loc 0))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [60 62]},
                               :full-name "clojure.zip/node",
                               :clj-symbol "clojure.zip/node",
                               :docstring "Returns the node at loc"},
           "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                             :name "IEmptyableCollection",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IEmptyableCollection",
                                             :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [121 122]},
                                             :methods [{:name "-empty",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEmptyableCollection",
                                             :history [["+" "0.0-927"]]},
           "clojure.zip/right" {:ns "clojure.zip",
                                :name "right",
                                :signature ["[loc]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip_right",
                                :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [135 140]},
                                :full-name "clojure.zip/right",
                                :clj-symbol "clojure.zip/right",
                                :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
           "cljs.core/==" {:description "This is an equality check for numbers of different types that was carried over from Clojure,\nto allow compatibility when converting code to ClojureScript.\n\nSince there is only a single number type in JavaScript, 64-bit floating point, there is no\nreason to use the `==` operator in ClojureScript.\n\nBehavior on non-number arguments is undefined.",
                           :ns "cljs.core",
                           :name "==",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/="
                                     "cljs.core/identical?"],
                           :full-name-encode "cljs.core_EQEQ",
                           :source {:code "(defn ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [986 996]},
                           :extra-sources ({:code "(defmacro ==\n  ([x] true)\n  ([x y] (list 'js* \"(~{} === ~{})\" x y))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [107 110]}),
                           :examples [{:id "5ac342",
                                       :content "```clj\n(== 1 1)\n;;=> true\n\n(== 1 2)\n;;=> false\n```"}],
                           :full-name "cljs.core/==",
                           :clj-symbol "clojure.core/==",
                           :docstring "Returns non-nil if nums all have the equivalent\nvalue (type-independent), otherwise false"},
           "special/." {:description "For interop, the `.` special form allows access to member properties of the\ngiven JavaScript object `o`.\n\nIf the second operand is a symbol preceded with a hyphen as in `-p`, the\nexpression will result in the value of the property named `p`.\n\nIf the second operand is a symbol that is not preceded with a hyphen as in `m`,\nthe expression will evaluate to a call of the method named `m`.  Any additional\noperands will be passed as arguments to the method.\n\nThe __preferred, idiomatic__ way to access members of a JavaScript object is to\nuse the following sugar:\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Sugar</th>\n      <th>Expands To</th></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><pre>(.-p o)</pre></td>\n      <td><pre>(. o -p)</pre></td>\n    </tr>\n    <tr>\n      <td><pre>(.m o)</pre></td>\n      <td><pre>(. o m)</pre></td>\n    </tr>\n    <tr>\n      <td><pre>(.m o 1 2)</pre></td>\n      <td><pre>(. o m 1 2)</pre></td>\n    </tr>\n  </tbody>\n</table>",
                        :ns "special",
                        :name ".",
                        :signature ["[o -p]"
                                    "[o m]"
                                    "[o m 1 2]"
                                    "[o (m 1 2)]"],
                        :history [["+" "0.0-927"]],
                        :type "special form",
                        :related ["cljs.core/.." "cljs.core/aget"],
                        :full-name-encode "special_DOT",
                        :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+]] _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)\n         children    [enve]]\n     (case dot-action\n           ::access {:env env :op :dot :children children\n                     :target targetexpr\n                     :field field}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :children (into children argexprs)\n                       :target targetexpr\n                       :method method\n                       :args argexprs})))))",
                                 :repo "clojurescript",
                                 :tag "r971",
                                 :filename "src/clj/cljs/compiler.clj",
                                 :lines [941 956]},
                        :examples [{:id "22ccbb",
                                    :content "We can access the JavaScript properties of a string:\n\n```js\n// JavaScript\nvar m = \"Hello World\";\nm.length;\n//=> 11\n```\n\n```clj\n;; ClojureScript\n(def m \"Hello World\")\n(.-length m)\n;;=> 11\n```\n\nWe can also call member functions on the string:\n\n```js\n// JavaScript\nm.toUpperCase();\n//=> \"HELLO WORLD\"\n\nm.replace(\"H\", \"\");\n//=> \"ello World\";\n```\n\n```clj\n;; ClojureScript\n(.toUpperCase m)\n;;=> \"HELLO WORLD\"\n\n(.replace m \"H\" \"\")\n;;=> \"ello World\"\n```"}
                                   {:id "7c5e58",
                                    :content "Create a JavaScript object `o`:\n\n```clj\n(def o #js {:foo \"bar\"})\n```\n\nYou can get the value at property `\"foo\"` with any of the following:\n\n```clj\n(. o -foo)\n;;=> \"bar\"\n\n(.-foo o)\n;;=> \"bar\"\n\n(aget o \"foo\")\n;;=> \"bar\"\n```"}],
                        :full-name "special/.",
                        :clj-symbol "clojure.core/."},
           "syntax/Math-ns" {:ns "syntax",
                             :name "Math-ns",
                             :history [["+" "0.0-927"]],
                             :type "special namespace",
                             :full-name-encode "syntax_Math-ns",
                             :source {:repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form "Math/",
                             :full-name "syntax/Math-ns",
                             :clj-doc "http://clojure.org/java_interop#toc6"},
           "clojure.browser.net/*timeout*" {:ns "clojure.browser.net",
                                            :name "*timeout*",
                                            :type "var",
                                            :source {:code "(def *timeout* 10000)",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/cljs/clojure/browser/net.cljs",
                                                     :lines [21]},
                                            :full-name "clojure.browser.net/*timeout*",
                                            :full-name-encode "clojure.browser.net_STARtimeoutSTAR",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/remove-method" {:ns "cljs.core",
                                      :name "remove-method",
                                      :signature ["[multifn dispatch-val]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_remove-method",
                                      :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3531 3534]},
                                      :full-name "cljs.core/remove-method",
                                      :clj-symbol "clojure.core/remove-method",
                                      :docstring "Removes the method of multimethod associated with dispatch-value."},
           "syntax/symbol" {:description "Signifies a symbol.  When evaluated, its result will be the value that the symbol\nis bound to.\n\nSome naming rules:\n\n- must not begin with a number\n- can contain special characters `*`, `+`, `!`, `-`, `_`, `?`\n- symbols starting or ending with a decimal are reserved for interop purposes\n\nSymbols can have an optional namespace. For example, `foo/bar` evaluates to the\nvalue of the `bar` symbol of the `foo` namespace.\n\nTo access symbols in the global JavaScript context, use the namespace `js`.\nFor example, use `js/document` to get the global `document` JavaScript object.",
                            :ns "syntax",
                            :name "symbol",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/symbol"
                                      "cljs.core/symbol?"],
                            :full-name-encode "syntax_symbol",
                            :source {:repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form " ",
                            :examples [{:id "cd60a5",
                                        :content "The following has two symbols, `def` and `a`:\n\n```clj\n(def a 1)\n```\n\nThe evaluation of the symbols is controlled by the evaluation of the list `(def\na 1)`.  `def` evaluates to a special form, which suppresses the evaluation of\n`a` since it is just being used as a name for the bound value `1`.\n\nWhen a symbol is by itself, it will evaluated to 1:\n\n```clj\na\n;;=> 1\n```\n\nTo signify an unevaluated symbol, precede it with a quote:\n\n```clj\n'a\n;;=> a\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#symbols",
                            :full-name "syntax/symbol",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/frequencies" {:description "Returns a map from distinct items in `coll` to the number of times they appear.\n\n`(frequencies [:a :a :b])` => `{:a 2, :b 1}`",
                                    :ns "cljs.core",
                                    :name "frequencies",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/group-by"
                                              "cljs.core/distinct"],
                                    :full-name-encode "cljs.core_frequencies",
                                    :source {:code "(defn frequencies\n  [coll]\n  (reduce\n   (fn [counts x]\n     (assoc counts x (inc (get counts x 0))))\n   {}\n   coll))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2720 2728]},
                                    :full-name "cljs.core/frequencies",
                                    :clj-symbol "clojure.core/frequencies",
                                    :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
           "cljs.core/pop" {:description "For a list, returns a new list without the first item.\n\nFor a vector, returns a new vector without the last item.",
                            :ns "cljs.core",
                            :name "pop",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/peek"
                                      "cljs.core/rest"
                                      "cljs.core/conj"],
                            :full-name-encode "cljs.core_pop",
                            :source {:code "(defn pop\n  [coll]\n  (-pop coll))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [564 569]},
                            :examples [{:id "6bd9f7",
                                        :content "With vectors:\n\n```clj\n(pop [1 2 3])\n;;=> [1 2]\n\n(pop [1 2])\n;;=> [1]\n\n(pop [1])\n;;=> []\n\n(pop [])\n;; Error: Can't pop empty vector\n```"}
                                       {:id "81221f",
                                        :content "With lists:\n\n```clj\n(pop '(1 2 3))\n;;=> (2 3)\n\n(pop '(1 2))\n;;=> (2)\n\n(pop '(1))\n;;=> ()\n\n(pop '())\n;; Error: Can't pop empty list\n```"}],
                            :full-name "cljs.core/pop",
                            :clj-symbol "clojure.core/pop",
                            :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
           "cljs.core/not-every?" {:description "Returns false if `(pred x)` is logical true for every `x` in `coll`, else true.",
                                   :ns "cljs.core",
                                   :name "not-every?",
                                   :signature ["[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/every?"
                                             "cljs.core/not-any?"
                                             "cljs.core/some"],
                                   :full-name-encode "cljs.core_not-everyQMARK",
                                   :source {:code "(defn not-every?\n  [pred coll] (not (every? pred coll)))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1452 1455]},
                                   :full-name "cljs.core/not-every?",
                                   :clj-symbol "clojure.core/not-every?",
                                   :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
           "cljs.core/some-fn" {:description "Takes a set of predicate functions and returns a function `f` that returns the\nfirst logical true value returned by one of its composing predicates against any\nof its arguments, else it returns logical false.\n\nNote that `f` is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates.",
                                :ns "cljs.core",
                                :name "some-fn",
                                :signature ["[p]"
                                            "[p1 p2]"
                                            "[p1 p2 p3]"
                                            "[p1 p2 p3 & ps]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/every-pred"
                                          "cljs.core/some"
                                          "cljs.core/or"],
                                :full-name-encode "cljs.core_some-fn",
                                :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1640 1677]},
                                :full-name "cljs.core/some-fn",
                                :clj-symbol "clojure.core/some-fn",
                                :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
           "syntax/vector" {:description "Signifies a literal vector.",
                            :ns "syntax",
                            :name "vector",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/vector"
                                      "cljs.core/vec"],
                            :full-name-encode "syntax_vector",
                            :source {:repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form "[]",
                            :examples [{:id "18e143",
                                        :content "```clj\n[1 2 3]\n;;=> [1 2 3]\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#vectors",
                            :full-name "syntax/vector",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.event/remove-all" {:ns "clojure.browser.event",
                                               :name "remove-all",
                                               :type "function",
                                               :signature ["[opt_obj opt_type opt_capt]"],
                                               :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                        :repo "clojurescript",
                                                        :tag "r971",
                                                        :filename "src/cljs/clojure/browser/event.cljs",
                                                        :lines [98]},
                                               :full-name "clojure.browser.event/remove-all",
                                               :full-name-encode "clojure.browser.event_remove-all",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/doto" {:ns "cljs.core",
                             :name "doto",
                             :signature ["[x & forms]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core_doto",
                             :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [3395 3410]},
                             :full-name "cljs.core/doto",
                             :clj-symbol "clojure.core/doto",
                             :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
           "cljs.core/take-while" {:description "Returns a lazy sequence of successive items from `coll` while `(pred item)`\nreturns true. `pred` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                                   :ns "cljs.core",
                                   :name "take-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/drop-while"
                                             "cljs.core/split-with"],
                                   :full-name-encode "cljs.core_take-while",
                                   :source {:code "(defn take-while\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (when (pred (first s))\n       (cons (first s) (take-while pred (rest s)))))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2621 2628]},
                                   :full-name "cljs.core/take-while",
                                   :clj-symbol "clojure.core/take-while",
                                   :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects."},
           "cljs.repl/evaluate-form" {:ns "cljs.repl",
                                      :name "evaluate-form",
                                      :signature ["[repl-env env filename form]"
                                                  "[repl-env env filename form wrap]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl_evaluate-form",
                                      :source {:code "(defn evaluate-form\n  ([repl-env env filename form]\n     (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n     (try\n       (let [ast (comp/analyze env form)\n             js (comp/emits ast)\n             wrap-js (comp/emits (comp/analyze env (wrap form)))]\n         (when (= (:op ast) :ns)\n           (load-dependencies repl-env (into (vals (:requires ast))\n                                             (distinct (vals (:uses ast))))))\n         (when *cljs-verbose*\n           (print js))\n         (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n           (case (:status ret)\n             ;;we eat ns errors because we know goog.provide() will throw when reloaded\n             ;;TODO - file bug with google, this is bs error\n             ;;this is what you get when you try to 'teach new developers'\n             ;;via errors (goog/base.js 104)\n             :error (display-error ret form)\n             :exception (display-error ret form\n                          #(prn \"Error evaluating:\" form :as js))\n             :success (:value ret))))\n       (catch Throwable ex\n         (.printStackTrace ex)\n         (println (str ex))))))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [56 84]},
                                      :full-name "cljs.repl/evaluate-form",
                                      :docstring "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader."},
           "cljs.reader/escape-char-map" {:ns "cljs.reader",
                                          :name "escape-char-map",
                                          :type "var",
                                          :source {:code "(def escape-char-map {\\t \"\\t\"\n                      \\r \"\\r\"\n                      \\n \"\\n\"\n                      \\\\ \\\\\n                      \\\" \\\"\n                      \\b \"\\b\"\n                      \\f \"\\f\"})",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [137 143]},
                                          :full-name "cljs.reader/escape-char-map",
                                          :full-name-encode "cljs.reader_escape-char-map",
                                          :history [["+" "0.0-927"]]},
           "clojure.browser.event/all-listeners" {:ns "clojure.browser.event",
                                                  :name "all-listeners",
                                                  :type "function",
                                                  :signature ["[obj type capture]"],
                                                  :source {:code "(defn all-listeners [obj type capture])",
                                                           :repo "clojurescript",
                                                           :tag "r971",
                                                           :filename "src/cljs/clojure/browser/event.cljs",
                                                           :lines [90]},
                                                  :full-name "clojure.browser.event/all-listeners",
                                                  :full-name-encode "clojure.browser.event_all-listeners",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/vals" {:description "Returns a sequence of the values in `hash-map`.",
                             :ns "cljs.core",
                             :name "vals",
                             :signature ["[hash-map]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/keys"],
                             :full-name-encode "cljs.core_vals",
                             :source {:code "(defn vals\n  [hash-map]\n  (seq (map second hash-map)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2425 2428]},
                             :full-name "cljs.core/vals",
                             :clj-symbol "clojure.core/vals",
                             :docstring "Returns a sequence of the map's values."},
           "cljs.core/IDeref" {:ns "cljs.core",
                               :name "IDeref",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core_IDeref",
                               :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [159 160]},
                               :methods [{:name "-deref",
                                          :signature ["[o]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IDeref",
                               :clj-symbol "clojure.lang/IDeref"},
           "clojure.browser.dom/log-obj" {:ns "clojure.browser.dom",
                                          :name "log-obj",
                                          :type "function",
                                          :signature ["[obj]"],
                                          :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [22 23]},
                                          :full-name "clojure.browser.dom/log-obj",
                                          :full-name-encode "clojure.browser.dom_log-obj",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/for" {:description "List comprehension.\n\nTakes a vector of one or more binding-form/collection-expr pairs, each followed\nby zero or more modifiers, and yields a lazy sequence of evaluations of expr.\n\nCollections are iterated in a nested fashion, rightmost fastest, and nested\ncoll-exprs can refer to bindings created in prior binding-forms. Supported\nmodifiers are: `:let [binding-form expr ...]`, `:while test`, `:when test`.",
                            :ns "cljs.core",
                            :name "for",
                            :signature ["[seq-exprs body-expr]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/doseq"
                                      "cljs.core/doall"
                                      "special/recur"],
                            :full-name-encode "cljs.core_for",
                            :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (apply str msg)))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      `(fn ~giter [~gxs]\n                         (lazy-seq\n                           (loop [~gxs ~gxs]\n                             (when-first [~bind ~gxs]\n                               ~(do-mod mod-pairs)))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [553 600]},
                            :extra-sources ({:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce1 (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                             (loop [~gxs ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (chunk-buffer size#)]\n                                       (if (loop [~gi (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [~bind (.nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))",
                                             :repo "clojure",
                                             :tag "clojure-1.3.0",
                                             :filename "src/clj/clojure/core.clj",
                                             :lines [4074 4159]}),
                            :full-name "cljs.core/for",
                            :clj-symbol "clojure.core/for",
                            :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
           "cljs.repl/load-stream" {:ns "cljs.repl",
                                    :name "load-stream",
                                    :type "function",
                                    :signature ["[repl-env filename stream]"],
                                    :source {:code "(defn load-stream [repl-env filename stream]\n  (with-open [r (io/reader stream)]\n    (let [env {:ns (@comp/namespaces comp/*cljs-ns*) :context :statement :locals {}}\n          pbr (clojure.lang.LineNumberingPushbackReader. r)\n          eof (Object.)]\n      (loop [r (read pbr false eof false)]\n        (let [env (assoc env :ns (@comp/namespaces comp/*cljs-ns*))]\n          (when-not (identical? eof r)\n            (evaluate-form repl-env env filename r)\n            (recur (read pbr false eof false))))))))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [86 95]},
                                    :full-name "cljs.repl/load-stream",
                                    :full-name-encode "cljs.repl_load-stream",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/instance?" {:description "Returns true if `o` is an instance of type `t`, false otherwise.",
                                  :ns "cljs.core",
                                  :name "instance?",
                                  :signature ["[t o]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/type"],
                                  :full-name-encode "cljs.core_instanceQMARK",
                                  :source {:code "(defn instance? [t o]\n  (js* \"(~{o} != null && (~{o} instanceof ~{t} || ~{o}.constructor === ~{t} || ~{t} === Object))\"))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [655 656]},
                                  :full-name "cljs.core/instance?",
                                  :clj-symbol "clojure.core/instance?"},
           "cljs.reader/read-comment" {:ns "cljs.reader",
                                       :name "read-comment",
                                       :type "var",
                                       :source {:code "(def read-comment skip-line)",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [207]},
                                       :full-name "cljs.reader/read-comment",
                                       :full-name-encode "cljs.reader_read-comment",
                                       :history [["+" "0.0-927"]]},
           "cljs.reader/read-number" {:ns "cljs.reader",
                                      :name "read-number",
                                      :type "function",
                                      :signature ["[reader initch]"],
                                      :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (contains? macros ch))\n      (do\n        (unread reader ch)\n        (let [s (. buffer (toString))]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [220 230]},
                                      :full-name "cljs.reader/read-number",
                                      :full-name-encode "cljs.reader_read-number",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/ILookup" {:ns "cljs.core",
                                :name "ILookup",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_ILookup",
                                :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [137 138]},
                                :methods [{:name "-lookup",
                                           :signature ["[o k]"
                                                       "[o k not-found]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ILookup",
                                :clj-symbol "clojure.lang/ILookup"},
           "cljs.core/when" {:description "Evaluates `test`. If logical true, evaluates `body` in an implicit `do`.\n\n`when` is often used instead of `if` for conditions that do not have an \"else\".",
                             :ns "cljs.core",
                             :name "when",
                             :signature ["[test & body]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/when-not"
                                       "cljs.core/when-let"
                                       "special/if"],
                             :full-name-encode "cljs.core_when",
                             :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [454 458]},
                             :full-name "cljs.core/when",
                             :clj-symbol "clojure.core/when",
                             :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
           "clojure.browser.dom/set-value" {:ns "clojure.browser.dom",
                                            :name "set-value",
                                            :signature ["[e v]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom_set-value",
                                            :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [140 143]},
                                            :full-name "clojure.browser.dom/set-value",
                                            :docstring "Set the value property for an element."},
           "cljs.repl.browser/read-get" {:ns "cljs.repl.browser",
                                         :name "read-get",
                                         :type "function",
                                         :signature ["[line rdr]"],
                                         :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [153 158]},
                                         :full-name "cljs.repl.browser/read-get",
                                         :full-name-encode "cljs.repl.browser_read-get",
                                         :history [["+" "0.0-927"]]},
           "cljs.reader/read-past" {:ns "cljs.reader",
                                    :name "read-past",
                                    :signature ["[pred rdr]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader_read-past",
                                    :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [159 166]},
                                    :full-name "cljs.reader/read-past",
                                    :docstring "Read until first character that doesn't match pred, returning\nchar."},
           "cljs.repl.browser/load-javascript" {:ns "cljs.repl.browser",
                                                :name "load-javascript",
                                                :type "function",
                                                :signature ["[repl-env ns url]"],
                                                :source {:code "(defn load-javascript [repl-env ns url]\n  (let [missing (remove #(contains? @loaded-libs %) ns)]\n    (when (seq missing)\n      (let [ret (browser-eval (object-query-str ns))]\n        (when-not (and (= (:status ret) :success)\n                       (= (:value ret) \"true\"))\n          (browser-eval (slurp url))))\n      (swap! loaded-libs (partial apply conj) missing))))",
                                                         :repo "clojurescript",
                                                         :tag "r971",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [283
                                                                 290]},
                                                :full-name "cljs.repl.browser/load-javascript",
                                                :full-name-encode "cljs.repl.browser_load-javascript",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/to-array" {:ns "cljs.core",
                                 :name "to-array",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_to-array",
                                 :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1319 1327]},
                                 :full-name "cljs.core/to-array",
                                 :clj-symbol "clojure.core/to-array",
                                 :docstring "Naive impl of to-array as a start."},
           "cljs.core/interpose" {:description "Returns a lazy seq of the elements of `coll` separated by `sep`.",
                                  :ns "cljs.core",
                                  :name "interpose",
                                  :signature ["[sep coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/interleave"
                                            "clojure.string/join"],
                                  :full-name-encode "cljs.core_interpose",
                                  :source {:code "(defn interpose\n  [sep coll] (drop 1 (interleave (repeat sep) coll)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1799 1801]},
                                  :full-name "cljs.core/interpose",
                                  :clj-symbol "clojure.core/interpose",
                                  :docstring "Returns a lazy seq of the elements of coll separated by sep"},
           "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                    :name "ICrossPageChannel",
                                                    :type "protocol",
                                                    :full-name-encode "clojure.browser.net_ICrossPageChannel",
                                                    :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                             :repo "clojurescript",
                                                             :tag "r971",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [88
                                                                     89]},
                                                    :methods [{:name "register-service",
                                                               :signature ["[this service-name fn]"
                                                                           "[this service-name fn encode-json?]"],
                                                               :docstring nil}],
                                                    :full-name "clojure.browser.net/ICrossPageChannel",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "special/finally" {:description "`finally` should be the last form inside of a `try` expression. It is optional.\n\n`finally` clauses are always evaluated for their side effects whether there was\nan error or not, but they are never the return value of a `try` expression.",
                              :ns "special",
                              :name "finally",
                              :signature ["[expr*]"],
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :related ["special/try"
                                        "special/catch"
                                        "special/throw"],
                              :full-name-encode "special_finally",
                              :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [501 529]},
                              :full-name "special/finally",
                              :clj-symbol "clojure.core/finally",
                              :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/Cons" {:ns "cljs.core",
                             :name "Cons",
                             :signature ["[meta first rest]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_Cons",
                             :source {:code "(deftype Cons [meta first rest]\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1196 1221]},
                             :full-name "cljs.core/Cons",
                             :clj-symbol "clojure.lang/Cons"},
           "cljs.core/re-find" {:description "Returns the first regex match, if any, of `s` to `re`, using `re.exec(s)`.\n\nReturns a vector, containing first the matching substring, then any capturing\ngroups if the regular expression contains capturing groups.",
                                :ns "cljs.core",
                                :name "re-find",
                                :signature ["[re s]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_re-find",
                                :source {:code "(defn re-find\n  [re s]\n  (let [matches (.exec re s)]\n    (when-not (nil? matches)\n      (if (= (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2818 2828]},
                                :full-name "cljs.core/re-find",
                                :clj-symbol "clojure.core/re-find",
                                :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
           "cljs.core/IMeta" {:ns "cljs.core",
                              :name "IMeta",
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core_IMeta",
                              :source {:code "(defprotocol IMeta\n  (-meta [o]))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [165 166]},
                              :methods [{:name "-meta",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IMeta",
                              :clj-symbol "clojure.lang/IMeta"},
           "cljs.core/assoc-in" {:description "Associates a value in a nested associative structure, where `ks` is a sequence\nof keys and `v` is the new value. Returns a new nested structure.\n\nIf any levels do not exist, hash-maps will be created.",
                                 :ns "cljs.core",
                                 :name "assoc-in",
                                 :signature ["[m [k & ks] v]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/assoc"
                                           "cljs.core/update-in"
                                           "cljs.core/get-in"],
                                 :full-name-encode "cljs.core_assoc-in",
                                 :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1912 1919]},
                                 :examples [{:id "e76f20",
                                             :content "```clj\n(def users [{:name \"James\" :age 26}\n            {:name \"John\" :age 43}])\n```\n\nUpdate the age of the second (index 1) user:\n\n```clj\n(assoc-in users [1 :age] 44)\n;;=> [{:name \"James\", :age 26}\n;;    {:name \"John\", :age 44}]\n```\n\nInsert the password of the second (index 1) user:\n\n```clj\n(assoc-in users [1 :password] \"nhoJ\")\n;;=> [{:name \"James\", :age 26}\n;;    {:password \"nhoJ\", :name \"John\", :age 43}]\n```"}],
                                 :full-name "cljs.core/assoc-in",
                                 :clj-symbol "clojure.core/assoc-in",
                                 :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
           "clojure.string/join" {:description "Returns a string of all elements in `coll`, as returned by `(seq coll)`,\nseparated by an optional separator.",
                                  :ns "clojure.string",
                                  :name "join",
                                  :signature ["[coll]"
                                              "[separator coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string_join",
                                  :source {:code "(defn join\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (apply str (interpose separator coll))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [45 51]},
                                  :full-name "clojure.string/join",
                                  :clj-symbol "clojure.string/join",
                                  :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
           "clojure.zip/rights" {:ns "clojure.zip",
                                 :name "rights",
                                 :signature ["[loc]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_rights",
                                 :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [92 95]},
                                 :full-name "clojure.zip/rights",
                                 :clj-symbol "clojure.zip/rights",
                                 :docstring "Returns a seq of the right siblings of this loc"},
           "cljs.core/split-at" {:description "Returns a vector of `[(take n coll) (drop n coll)]`.",
                                 :ns "cljs.core",
                                 :name "split-at",
                                 :signature ["[n coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/split-with"
                                           "clojure.string/split"],
                                 :full-name-encode "cljs.core_split-at",
                                 :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1759 1762]},
                                 :full-name "cljs.core/split-at",
                                 :clj-symbol "clojure.core/split-at",
                                 :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
           "clojure.zip/append-child" {:ns "clojure.zip",
                                       :name "append-child",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_append-child",
                                       :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [200 204]},
                                       :full-name "clojure.zip/append-child",
                                       :clj-symbol "clojure.zip/append-child",
                                       :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
           "cljs.core/binding" {:description "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit `do`, then\nre-establishes the bindings that existed before.\n\nThe new bindings are made in parallel (unlike `let`); all init-exprs are\nevaluated before the vars are bound to their new values.",
                                :ns "cljs.core",
                                :name "binding",
                                :signature ["[bindings & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/let"],
                                :full-name-encode "cljs.core_binding",
                                :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map vector names vals)\n        resets (reverse (map vector names tempnames))]\n    `(let [~@(interleave tempnames names)]\n       (try\n        ~@(map\n           (fn [[k v]] (list 'set! k v))\n           binds)\n        ~@body\n        (finally\n         ~@(map\n            (fn [[k v]] (list 'set! k v))\n            resets))))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [434 457]},
                                :examples [{:id "7dd17f",
                                            :content "```clj\n(def ^:dynamic *foo* 1)\n\n(defn do-something []\n  (println *foo*))\n\n(binding [*foo* 2]\n  (do-something))\n;;=> prints 2\n\n*foo*\n;;=> 1\n```"}],
                                :full-name "cljs.core/binding",
                                :clj-symbol "clojure.core/binding",
                                :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
           "cljs.core/Set" {:ns "cljs.core",
                            :name "Set",
                            :type "type",
                            :signature ["[meta hash-map]"],
                            :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2470 2517]},
                            :full-name "cljs.core/Set",
                            :full-name-encode "cljs.core_Set",
                            :history [["+" "0.0-927"]]},
           "cljs.reader/macro-terminating?" {:ns "cljs.reader",
                                             :name "macro-terminating?",
                                             :type "function",
                                             :signature ["[ch]"],
                                             :source {:code "(defn macro-terminating? [ch]\n  (and (not= ch \"#\") (not= ch \\') (not= ch \":\") (contains? macros ch)))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/cljs/cljs/reader.cljs",
                                                      :lines [73 74]},
                                             :full-name "cljs.reader/macro-terminating?",
                                             :full-name-encode "cljs.reader_macro-terminatingQMARK",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/prefers" {:ns "cljs.core",
                                :name "prefers",
                                :signature ["[multifn]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_prefers",
                                :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3551 3553]},
                                :full-name "cljs.core/prefers",
                                :clj-symbol "clojure.core/prefers",
                                :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
           "cljs.core/vary-meta" {:description "Returns an object of the same type and value as `obj`, with\n`(apply f (meta obj) args)` as its metadata.",
                                  :ns "cljs.core",
                                  :name "vary-meta",
                                  :signature ["[obj f & args]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/alter-meta!"
                                            "cljs.core/with-meta"],
                                  :full-name-encode "cljs.core_vary-meta",
                                  :source {:code "(defn vary-meta\n [obj f & args]\n (with-meta obj (apply f (meta obj) args)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1426 1430]},
                                  :examples [{:id "8cca62",
                                              :content "```clj\n(def a ^:foo [1 2 3])\n(def b (vary-meta a assoc :bar true))\n\n(= a b)\n;;=> true\n\n(meta a)\n;;=> {:foo true}\n\n(meta b)\n;;=> {:foo true, :bar true}\n```"}],
                                  :full-name "cljs.core/vary-meta",
                                  :clj-symbol "clojure.core/vary-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
           "cljs.core/when-let" {:description "When `test` is logical true, evaluates `body` with the value of `test` bound to\n`x`.",
                                 :ns "cljs.core",
                                 :name "when-let",
                                 :signature ["[[x test] & body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/if-let"
                                           "cljs.core/when"
                                           "cljs.core/when-not"
                                           "special/if"
                                           "cljs.core/when-first"],
                                 :full-name-encode "cljs.core_when-let",
                                 :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args when-let\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                          :repo "clojure",
                                          :tag "clojure-1.3.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [1685 1698]},
                                 :full-name "cljs.core/when-let",
                                 :clj-symbol "clojure.core/when-let",
                                 :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
           "cljs.core/drop" {:description "Returns a lazy sequence of all but the first `n` items in `coll`.\n\nReturns a stateful transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "drop",
                             :signature ["[n]" "[n coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/take"
                                       "cljs.core/drop-last"
                                       "cljs.core/drop-while"
                                       "cljs.core/nthnext"
                                       "cljs.core/nthrest"],
                             :full-name-encode "cljs.core_drop",
                             :source {:code "(defn drop\n  [n coll]\n  (let [step (fn [n coll]\n               (let [s (seq coll)]\n                 (if (and (pos? n) s)\n                   (recur (dec n) (rest s))\n                   s)))]\n    (lazy-seq (step n coll))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1718 1726]},
                             :full-name "cljs.core/drop",
                             :clj-symbol "clojure.core/drop",
                             :docstring "Returns a lazy sequence of all but the first n items in coll."},
           "cljs.core/while" {:description "Repeatedly executes `body` while `test` expression is true. Presumes some\nside-effect will cause `test` to become false or nil.\n\nReturns nil.",
                              :ns "cljs.core",
                              :name "while",
                              :signature ["[test & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/loop"],
                              :full-name-encode "cljs.core_while",
                              :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                       :repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5569 5577]},
                              :full-name "cljs.core/while",
                              :clj-symbol "clojure.core/while",
                              :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
           "cljs.core/import-macros" {:ns "cljs.core",
                                      :name "import-macros",
                                      :type "macro",
                                      :signature ["[ns [& vars]]"],
                                      :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(def ~sym (deref ~var))) syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [27 34]},
                                      :full-name "cljs.core/import-macros",
                                      :full-name-encode "cljs.core_import-macros",
                                      :history [["+" "0.0-927"]]},
           "cljs.repl.browser/add-in-order" {:ns "cljs.repl.browser",
                                             :name "add-in-order",
                                             :type "function",
                                             :signature ["[{:keys [expecting fns]} order f]"],
                                             :source {:code "(defn add-in-order [{:keys [expecting fns]} order f]\n  {:expecting (or expecting order) :fns (assoc fns order f)})",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [203 204]},
                                             :full-name "cljs.repl.browser/add-in-order",
                                             :full-name-encode "cljs.repl.browser_add-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/string-print" {:ns "cljs.core",
                                     :name "string-print",
                                     :type "function",
                                     :signature ["[x]"],
                                     :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2852 2854]},
                                     :full-name "cljs.core/string-print",
                                     :full-name-encode "cljs.core_string-print",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/-" {:description "If no `y`s are supplied, returns the negation of `x`, else subtracts the `y`s\nfrom `x` and returns the result.",
                          :ns "cljs.core",
                          :name "-",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/+"],
                          :full-name-encode "cljs.core_-",
                          :source {:code "(defn -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [820 825]},
                          :extra-sources ({:code "(defmacro -\n  ([] 0)\n  ([x] (list 'js* \"(- ~{})\" x))\n  ([x y] (list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [69 73]}),
                          :examples [{:id "0a974e",
                                      :content "```clj\n(- 1)\n;;=> -1\n\n(- 6 3)\n;;=> 3\n\n(- 10 3 2)\n;;=> 5\n```"}],
                          :full-name "cljs.core/-",
                          :clj-symbol "clojure.core/-",
                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "clojure.zip/vector-zip" {:ns "clojure.zip",
                                     :name "vector-zip",
                                     :signature ["[root]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.zip_vector-zip",
                                     :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/clojure/zip.cljs",
                                              :lines [42 48]},
                                     :full-name "clojure.zip/vector-zip",
                                     :clj-symbol "clojure.zip/vector-zip",
                                     :docstring "Returns a zipper for nested vectors, given a root vector"},
           "cljs.core/js->clj" {:description "Recursively transforms JavaScript arrays into ClojureScript vectors, and\nJavaScript objects into ClojureScript maps.\n\nWith option `{:keywordize-keys true}` will convert object fields from strings to\nkeywords.\n\nNote that `js->clj` is not optimized for speed and the [transit.cljs] library is\nrecommended for parsing large amounts of JSON data.\n\n[transit.cljs]:http://swannodette.github.io/2014/07/26/transit--clojurescript/",
                                :ns "cljs.core",
                                :name "js->clj",
                                :signature ["[x]" "[x & opts]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/clj->js"],
                                :full-name-encode "cljs.core_js-GTclj",
                                :source {:code "(defn js->clj\n  [x & options]\n  (let [{:keys [keywordize-keys]} options\n        keyfn (if keywordize-keys keyword str)\n        f (fn thisfn [x]\n            (cond\n             (seq? x) (doall (map thisfn x))\n             (coll? x) (into (empty x) (map thisfn x))\n             (goog.isArray x) (vec (map thisfn x))\n             (goog.isObject x) (into {} (for [k (js-keys x)]\n                                          [(keyfn k)\n                                           (thisfn (aget x k))]))\n             :else x))]\n    (f x)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3216 3233]},
                                :examples [{:id "61d263",
                                            :content "Parse a JSON string:\n\n```clj\n(def json \"{\\\"foo\\\": 1, \\\"bar\\\": 2, \\\"baz\\\": [1,2,3]}\")\n(def a (.parse js/JSON json))\n;;=> #js {:foo 1, :bar 2, :baz #js [1 2 3]}\n```\n\nConvert JSON data `a` to ClojureScript data:\n\n```clj\n(js->clj a)\n;;=> {\"foo\" 1, \"bar\" 2, \"baz\" [1 2 3]}\n\n(js->clj a :keywordize-keys true)\n;;=> {:foo 1, :bar 2, :baz [1 2 3]}\n```"}],
                                :full-name "cljs.core/js->clj",
                                :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords."},
           "cljs.core/List" {:ns "cljs.core",
                             :name "List",
                             :signature ["[meta first rest count]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_List",
                             :source {:code "(deftype List [meta first rest count]\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] rest)\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count)))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1118 1150]},
                             :full-name "cljs.core/List",
                             :clj-symbol "clojure.lang/PersistentList"},
           "cljs.core/identical?" {:description "Returns true if `x` and `y` are the same object, false otherwise.",
                                   :ns "cljs.core",
                                   :name "identical?",
                                   :signature ["[x y]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/="
                                             "cljs.core/=="],
                                   :full-name-encode "cljs.core_identicalQMARK",
                                   :source {:code "(defn identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [201 204]},
                                   :extra-sources ({:code "(defmacro identical? [a b]\n  (list 'js* \"(~{} === ~{})\" a b))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [54 55]}),
                                   :full-name "cljs.core/identical?",
                                   :clj-symbol "clojure.core/identical?",
                                   :docstring "Tests if 2 arguments are the same object"},
           "cljs.core/*main-cli-fn*" {:ns "cljs.core",
                                      :name "*main-cli-fn*",
                                      :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                      :type "var",
                                      :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [52 56]},
                                      :full-name "cljs.core/*main-cli-fn*",
                                      :full-name-encode "cljs.core_STARmain-cli-fnSTAR",
                                      :history [["+" "0.0-927"]]},
           "clojure.browser.dom/html->dom" {:ns "clojure.browser.dom",
                                            :name "html->dom",
                                            :type "function",
                                            :signature ["[s]"],
                                            :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [99 100]},
                                            :full-name "clojure.browser.dom/html->dom",
                                            :full-name-encode "clojure.browser.dom_html-GTdom",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/some" {:description "Returns the first logical true value of `(pred x)` for any `x` in `coll`, else\nnil.\n\nA common idiom is to use a set as pred, for example this will return `:fred` if\n`:fred` is in the sequence, otherwise nil: `(some #{:fred} coll)`",
                             :ns "cljs.core",
                             :name "some",
                             :signature ["[pred coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/every?"
                                       "cljs.core/not-any?"
                                       "cljs.core/keep"
                                       "cljs.core/keep-indexed"
                                       "cljs.core/some-fn"],
                             :full-name-encode "cljs.core_some",
                             :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1457 1464]},
                             :full-name "cljs.core/some",
                             :clj-symbol "clojure.core/some",
                             :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
           "cljs.core/doall" {:description "Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.\n\n`doall` walks through the successive `next`s of the sequence, returning the head\nand causing the entire sequence to reside in memory at one time.",
                              :ns "cljs.core",
                              :name "doall",
                              :signature ["[coll]" "[n coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/dorun"
                                        "cljs.core/doseq"],
                              :full-name-encode "cljs.core_doall",
                              :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2793 2805]},
                              :full-name "cljs.core/doall",
                              :clj-symbol "clojure.core/doall",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
           "cljs.core/condp" {:description "Takes a binary predicate, an expression, and a set of clauses. There are two\nkinds of clauses:\n\nBinary clause: `test-expr` `result-expr`\n\nTernary clause: `test-expr` `:>>` `result-fn`<br />\n(Note: `:>>` is an ordinary keyword)\n\nFor each clause, `(pred test-expr expr)` is evaluated. If it returns logical\ntrue, the clause is a match.\n\nIf a binary clause matches, its `result-expr` is returned.\n\nIf a ternary clause matches, its `result-fn` is called with the result of the\npredicate and returned by `condp`. `result-fn` should take one argument.\n\nA single default expression can follow the clauses, and its value will be\nreturned if no clause matches.\n\nIf no default expression is provided and no clause matches, an Error is thrown.",
                              :ns "cljs.core",
                              :name "condp",
                              :signature ["[pred expr & clauses]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/cond" "special/if"],
                              :full-name-encode "cljs.core_condp",
                              :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (cond\n                  (= 0 n) `(throw (js/Error. (str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [459 499]},
                              :full-name "cljs.core/condp",
                              :clj-symbol "clojure.core/condp",
                              :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
           "clojure.zip/down" {:ns "clojure.zip",
                               :name "down",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_down",
                               :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [98 109]},
                               :full-name "clojure.zip/down",
                               :clj-symbol "clojure.zip/down",
                               :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
           "cljs.core/IPending" {:ns "cljs.core",
                                 :name "IPending",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IPending",
                                 :source {:code "(defprotocol IPending\n  (-realized? [d]))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [192 193]},
                                 :methods [{:name "-realized?",
                                            :signature ["[d]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IPending",
                                 :clj-symbol "clojure.lang/IPending"},
           "cljs.core/count" {:description "Returns the number of items in `x`.\n\n`count` works on arrays, lists, maps, sets, strings, and vectors.\n\n`(count nil)` returns 0.",
                              :ns "cljs.core",
                              :name "count",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_count",
                              :source {:code "(defn count\n  [coll]\n  (-count coll))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [498 502]},
                              :examples [{:id "96e470",
                                          :content "```clj\n(count [1 2 3])\n;;=> 3\n\n(count [])\n;;=> 0\n\n(count nil)\n;;=> 0\n\n(count #{:a :b})\n;;=> 2\n\n(count {:key \"value\" :key2 \"value2\"})\n;;=> 2\n```"}],
                              :full-name "cljs.core/count",
                              :clj-symbol "clojure.core/count",
                              :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
           "cljs.core/bit-test" {:description "Test bit at index `n`. Returns `true` if 1, and `false` if 0. Same as `(x & (1 << y)) != 0` in JavaScript.",
                                 :ns "cljs.core",
                                 :name "bit-test",
                                 :signature ["[x n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_bit-test",
                                 :source {:code "(defn bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [973 976]},
                                 :extra-sources ({:code "(defmacro bit-test [x n]\n  (list 'js* \"((~{} & (1 << ~{})) != 0)\" x n))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [165 166]}),
                                 :examples [{:id "f64664",
                                             :content "Bits can be entered using radix notation:\n\n```clj\n(bit-test 2r0100 2)\n;;=> true\n\n(bit-test 2r0100 1)\n;;=> false\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-test 4 2)\n;;=> true\n\n(bit-test 4 1)\n;;=> false\n```"}],
                                 :full-name "cljs.core/bit-test",
                                 :clj-symbol "clojure.core/bit-test",
                                 :docstring "Test bit at index n"},
           "cljs.core/loop" {:description "Evaluates the `body-exprs` in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs, just like a `let` form.\nActs as a `recur` target, which will allow tail-call optimization.",
                             :ns "cljs.core",
                             :name "loop",
                             :signature ["[[& bindings] & body-exprs]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["special/recur"],
                             :full-name-encode "cljs.core_loop",
                             :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args loop\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)\n              bfs (reduce1 (fn [ret [b v g]]\n                            (if (symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [4025 4048]},
                             :extra-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n loop (fn* loop [&form &env & decl] (cons 'loop* decl)))",
                                              :repo "clojure",
                                              :tag "clojure-1.3.0",
                                              :filename "src/clj/clojure/core.clj",
                                              :lines [37 40]}),
                             :examples [{:id "60291e",
                                         :content "```clj\n(loop [x 0]\n  (when (< x 10)\n    (println x)\n    (recur (+ x 2))))\n;; Prints:\n;; 0\n;; 2\n;; 4\n;; 6\n;; 8\n;;\n;;=> nil\n```"}],
                             :full-name "cljs.core/loop",
                             :clj-symbol "clojure.core/loop",
                             :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
           "cljs.core/subvec" {:description "Returns a persistent vector of the items in `v` from `start` inclusive to `end`\nexclusive.\n\nIf `end` is not supplied, defaults to `(count v)`.\n\nThis operation is O(1) and very fast, as the resulting vector shares structure\nwith the original and no trimming is done.",
                               :ns "cljs.core",
                               :name "subvec",
                               :signature ["[v start]"
                                           "[v start end]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/vector"
                                         "cljs.core/vector?"],
                               :full-name-encode "cljs.core_subvec",
                               :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (Subvec. nil v start end)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2099 2108]},
                               :full-name "cljs.core/subvec",
                               :clj-symbol "clojure.core/subvec",
                               :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
           "cljs.core/bit-clear" {:description "Clear bit at index `n`.  Same as `x & ~(1 << y)` in JavaScript.",
                                  :ns "cljs.core",
                                  :name "bit-clear",
                                  :signature ["[x n]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/bit-set"
                                            "cljs.core/bit-flip"],
                                  :full-name-encode "cljs.core_bit-clear",
                                  :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [954 957]},
                                  :extra-sources ({:code "(defmacro bit-clear [x n]\n  (list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [159 160]}),
                                  :examples [{:id "0f6748",
                                              :content "Bits can be entered using radix notation:\n\n```clj\n(bit-clear 2r1111 2)\n;;=> 11\n;; 11 = 2r1011\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-clear 15 2)\n;;=> 11\n```"}],
                                  :full-name "cljs.core/bit-clear",
                                  :clj-symbol "clojure.core/bit-clear",
                                  :docstring "Clear bit at index n"},
           "cljs.core/gensym" {:ns "cljs.core",
                               :name "gensym",
                               :signature ["[]" "[prefix-string]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_gensym",
                               :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3163 3171]},
                               :full-name "cljs.core/gensym",
                               :clj-symbol "clojure.core/gensym",
                               :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
           "special/recur" {:ns "special",
                            :name "recur",
                            :type "special form",
                            :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs] _]\n  (let [context (:context env)\n        frame (first *recur-frames*)]\n    (assert frame \"Can't recur here\")\n    (assert (= (count exprs) (count (:names frame))) \"recur argument count mismatch\")\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur}\n      :frame frame\n      :exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs))))))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [762 771]},
                            :full-name "special/recur",
                            :full-name-encode "special_recur",
                            :clj-symbol "clojure.core/recur",
                            :history [["+" "0.0-927"]]},
           "cljs.core/+" {:description "Returns the sum of nums.\n\n`(+)` returns 0.",
                          :ns "cljs.core",
                          :name "+",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/*" "cljs.core/-"],
                          :full-name-encode "cljs.core_PLUS",
                          :source {:code "(defn +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more] (reduce + (cljs.core/+ x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [813 818]},
                          :extra-sources ({:code "(defmacro +\n  ([] 0)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [63 67]}),
                          :examples [{:id "650668",
                                      :content "```clj\n(+)\n;;=> 0\n\n(+ 1)\n;;=> 1\n\n(+ -10)\n;;=> -10\n\n(+ 1 2)\n;;=> 3\n\n(+ 1 2 3)\n;;=> 6\n```"}],
                          :full-name "cljs.core/+",
                          :clj-symbol "clojure.core/+",
                          :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/comp" {:description "Takes a set of functions and returns a function that is the composition\nof those functions.\n\nThe returned function takes a variable number of arguments, applies the\nrightmost of `fns` to the arguments, whose result is subsequently applied to\nthe next left function, and so on.\n\n`((comp a b c) x y)` = `(a (b (c x y)))`",
                             :ns "cljs.core",
                             :name "comp",
                             :signature ["[& fns]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/partial"
                                       "cljs.core/juxt"],
                             :full-name-encode "cljs.core_comp",
                             :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g] \n     (fn \n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h] \n     (fn \n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1497 1524]},
                             :examples [{:id "5d3250",
                                         :content "```clj\n(def f (comp str inc +))\n(f 1 2 3)\n;;=> \"7\"\n```"}],
                             :full-name "cljs.core/comp",
                             :clj-symbol "clojure.core/comp",
                             :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
           "cljs.reader/desugar-meta" {:ns "cljs.reader",
                                       :name "desugar-meta",
                                       :type "function",
                                       :signature ["[f]"],
                                       :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [269 275]},
                                       :full-name "cljs.reader/desugar-meta",
                                       :full-name-encode "cljs.reader_desugar-meta",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl/load-namespace" {:ns "cljs.repl",
                                       :name "load-namespace",
                                       :signature ["[repl-env sym]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl_load-namespace",
                                       :source {:code "(defn load-namespace\n  [repl-env sym]\n  (let [sym (if (and (seq? sym)\n                     (= (first sym) 'quote))\n              (second sym)\n              sym)\n        opts {:output-dir (get repl-env :working-dir \".repl\")}\n        deps (->> (cljsc/add-dependencies opts {:requires [(name sym)] :type :seed})\n                  (remove (comp #{[\"goog\"]} :provides))\n                  (remove (comp #{:seed} :type))\n                  (map #(select-keys % [:provides :url])))]\n    (doseq [{:keys [url provides]} deps]\n      (-load repl-env provides url))))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [24 39]},
                                       :full-name "cljs.repl/load-namespace",
                                       :docstring "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once and\nonly once."},
           "cljs.core/pr" {:ns "cljs.core",
                           :name "pr",
                           :signature ["[& objs]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :full-name-encode "cljs.core_pr",
                           :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [2917 2923]},
                           :full-name "cljs.core/pr",
                           :clj-symbol "clojure.core/pr",
                           :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
           "clojure.string/upper-case" {:description "Converts string to all upper-case.",
                                        :ns "clojure.string",
                                        :name "upper-case",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_upper-case",
                                        :source {:code "(defn upper-case\n  [s]\n  (. s (toUpperCase)))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [53 56]},
                                        :full-name "clojure.string/upper-case",
                                        :clj-symbol "clojure.string/upper-case",
                                        :docstring "Converts string to all upper-case."},
           "syntax/string" {:description "Signifies a string.  ClojureScript strings are the same as JavaScript strings.\n\nStrings may span multiple lines.\n\nStandard escape characters such as `\\\"` are supported, as well as unicode\nescape characters:\n\n| unicode characters  | constraints                                   |\n|---------------------|-----------------------------------------------|\n| `\\uXXXX`            | XXXX must have 4 digits outside 0xD7FF-0xE000 |\n| `\\oXXX`             | XXX is octal between 0 and 0377               |",
                            :ns "syntax",
                            :name "string",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/str"],
                            :full-name-encode "syntax_string",
                            :source {:repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form "\"\"",
                            :examples [{:id "eb97ac",
                                        :content "```clj\n\"foo\"\n;;=> \"foo\"\n\n\"hello\n     world\"\n;;=> \"hello\\n     world\"\n```\n\nCharacters can be escaped:\n\n```clj\n(println \"foo\\nbar\")\n;; prints:\n;;   foo\n;;   bar\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#strings",
                            :full-name "syntax/string",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.event/expose" {:ns "clojure.browser.event",
                                           :name "expose",
                                           :type "function",
                                           :signature ["[e]"],
                                           :source {:code "(defn expose [e]\n  (goog.events/expose e))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [79 80]},
                                           :full-name "clojure.browser.event/expose",
                                           :full-name-encode "clojure.browser.event_expose",
                                           :history [["+" "0.0-927"]]},
           "clojure.browser.event/listen-once" {:ns "clojure.browser.event",
                                                :name "listen-once",
                                                :type "function",
                                                :signature ["[src type fn]"
                                                            "[src type fn capture?]"],
                                                :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (goog.events/listenOnce src\n                             (get (event-types src) type type)\n                             fn\n                             capture?)))",
                                                         :repo "clojurescript",
                                                         :tag "r971",
                                                         :filename "src/cljs/clojure/browser/event.cljs",
                                                         :lines [53
                                                                 60]},
                                                :full-name "clojure.browser.event/listen-once",
                                                :full-name-encode "clojure.browser.event_listen-once",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/empty?" {:description "Returns true if `coll` has no items - same as `(not (seq coll))`.\n\nPlease use the idiom `(seq x)` rather than `(not (empty? x))`.",
                               :ns "cljs.core",
                               :name "empty?",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/seq"],
                               :full-name-encode "cljs.core_emptyQMARK",
                               :source {:code "(defn empty?\n  [coll] (not (seq coll)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [586 589]},
                               :full-name "cljs.core/empty?",
                               :clj-symbol "clojure.core/empty?",
                               :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
           "cljs.core/newline" {:ns "cljs.core",
                                :name "newline",
                                :signature ["[opts]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_newline",
                                :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2896 2899]},
                                :full-name "cljs.core/newline",
                                :clj-symbol "clojure.core/newline"},
           "cljs.core/replace" {:description "Given a map of replacement pairs `smap` and a vector/collection `coll`, returns\na vector/seq with any elements `=` to a key in `smap` replaced with the\ncorresponding val in `smap`.\n\nReturns a transducer when `coll` is not provided.",
                                :ns "cljs.core",
                                :name "replace",
                                :signature ["[smap]" "[smap coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/map"
                                          "clojure.walk/prewalk-replace"
                                          "clojure.walk/postwalk-replace"],
                                :full-name-encode "cljs.core_replace",
                                :source {:code "(defn replace\n  [smap coll]\n  (if (vector? coll)\n    (let [n (count coll)]\n      (reduce (fn [v i]\n                (if-let [e (find smap (nth v i))]\n                  (assoc v i (second e))\n                  v))\n              coll (take n (iterate inc 0))))\n    (map #(if-let [e (find smap %)] (second e) %) coll)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2530 2542]},
                                :full-name "cljs.core/replace",
                                :clj-symbol "clojure.core/replace",
                                :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap"},
           "cljs.core/rand" {:description "Returns a random floating point number between 0 inclusive and `n` exclusive.\n\n`n` defaults to 1.",
                             :ns "cljs.core",
                             :name "rand",
                             :signature ["[]" "[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rand-int"
                                       "cljs.core/rand-nth"],
                             :full-name-encode "cljs.core_rand",
                             :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (js* \"Math.random() * ~{n}\")))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3265 3269]},
                             :extra-sources ({:code "(defn rand\n  ([]  (Math/random))\n  ([n] (* n (rand))))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [929 932]}),
                             :full-name "cljs.core/rand",
                             :clj-symbol "clojure.core/rand",
                             :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
           "cljs.core/add-watch" {:description "Adds a watch function `f` to atom `a` that will execute when the value of `a`\nchanges.\n\nThe watch function takes 4 arguments: a key, the atom, its old state, and its\nnew state.\n\n`key` should be a keyword and can be used with `remove-watch` to remove the\nwatch function.",
                                  :ns "cljs.core",
                                  :name "add-watch",
                                  :signature ["[a key f]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/remove-watch"],
                                  :full-name-encode "cljs.core_add-watch",
                                  :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3128 3150]},
                                  :examples [{:id "2f2fe0",
                                              :content "```clj\n(def a (atom {}))\n\n(add-watch a :logger\n  (fn [_key _atom old-state new-state]\n    (println \"old:\" old-state)\n    (println \"new:\" new-state)))\n\n(swap! a assoc :foo \"bar\")\n;;=> will print the following:\n;; old: {}\n;; new: {:foo \"bar\"}\n```"}],
                                  :full-name "cljs.core/add-watch",
                                  :clj-symbol "clojure.core/add-watch",
                                  :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0)) \n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
           "cljs.repl.rhino/loaded-libs" {:ns "cljs.repl.rhino",
                                          :name "loaded-libs",
                                          :type "var",
                                          :source {:code "(def loaded-libs (atom #{}))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [19]},
                                          :full-name "cljs.repl.rhino/loaded-libs",
                                          :full-name-encode "cljs.repl.rhino_loaded-libs",
                                          :history [["+" "0.0-927"]]},
           "clojure.string/capitalize" {:description "Converts first character of the string to upper-case, all other characters to\nlower-case.",
                                        :ns "clojure.string",
                                        :name "capitalize",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_capitalize",
                                        :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [63 70]},
                                        :full-name "clojure.string/capitalize",
                                        :clj-symbol "clojure.string/capitalize",
                                        :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
           "cljs.core/replicate" {:ns "cljs.core",
                                  :name "replicate",
                                  :signature ["[n x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_replicate",
                                  :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1769 1771]},
                                  :full-name "cljs.core/replicate",
                                  :clj-symbol "clojure.core/replicate",
                                  :docstring "Returns a lazy seq of n xs."},
           "special/do" {:ns "special",
                         :name "do",
                         :type "special form",
                         :source {:code "(defmethod parse 'do\n  [op env [_ & exprs] _]\n  (merge {:env env :op :do} (analyze-block env exprs)))",
                                  :repo "clojurescript",
                                  :tag "r971",
                                  :filename "src/clj/cljs/compiler.clj",
                                  :lines [725 727]},
                         :full-name "special/do",
                         :full-name-encode "special_do",
                         :clj-symbol "clojure.core/do",
                         :history [["+" "0.0-927"]]},
           "cljs.core/sequential?" {:description "Returns true if `coll` implements the `ISequential` protocol, false otherwise.\n\nLists and vectors are sequential.",
                                    :ns "cljs.core",
                                    :name "sequential?",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/seq?"
                                              "cljs.core/coll?"],
                                    :full-name-encode "cljs.core_sequentialQMARK",
                                    :source {:code "(defn sequential?\n  [x] (satisfies? ISequential x))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [609 611]},
                                    :full-name "cljs.core/sequential?",
                                    :clj-symbol "clojure.core/sequential?",
                                    :docstring "Returns true if coll satisfies ISequential"},
           "cljs.core/underive" {:ns "cljs.core",
                                 :name "underive",
                                 :signature ["[tag parent]"
                                             "[h tag parent]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_underive",
                                 :source {:code "(defn underive\n  ([tag parent]\n     ;; (alter-var-root #'global-hierarchy underive tag parent)\n     (swap! global-hierarchy underive tag parent) nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3380 3399]},
                                 :full-name "cljs.core/underive",
                                 :clj-symbol "clojure.core/underive",
                                 :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "cljs.core/get-method" {:ns "cljs.core",
                                   :name "get-method",
                                   :signature ["[multifn dispatch-val]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_get-method",
                                   :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3546 3549]},
                                   :full-name "cljs.core/get-method",
                                   :clj-symbol "clojure.core/get-method",
                                   :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
           "cljs.core/=" {:description "Returns true if the value of `x` equals the value of `y`, false otherwise.\n\n`=` is a value comparison, not an identity comparison.\n\nAll collections can be tested for value, regardless of \"depth\".",
                          :ns "cljs.core",
                          :name "=",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/=="
                                    "cljs.core/not="
                                    "cljs.core/identical?"],
                          :full-name-encode "cljs.core_EQ",
                          :source {:code "(defn =\n  [x y]\n  (-equiv x y))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [206 212]},
                          :examples [{:id "edffb6",
                                      :content "```clj\n(= 1)\n;;=> true\n\n(= 1 1)\n;;=> true\n\n(= 1 2)\n;;=> false\n\n(= 1 1 1)\n;;=> true\n\n(= 1 1 2)\n;;=> false\n```"}
                                     {:id "a2d064",
                                      :content "Sequences are considered equal in value if they have the same elements:\n\n```clj\n(= '(1 2) [1 2])\n;;=> true\n```\n\nBut you cannot compare JavaScript arrays until you convert them to sequences:\n\n```clj\n(def a #js [1 2])\n(def b #js [1 2])\n(= a b)\n;;=> false\n\n(= (seq a) (seq b))\n;;=> true\n```"}
                                     {:id "6c8424",
                                      :content "It is natural to compare deeply nested collections since value equality checks\nare cheap in ClojureScript:\n\n```clj\n(def a {:foo {:bar \"baz\"}})\n(def b {:foo {:bar \"baz\"}})\n(= a b)\n;;=> true\n\n(= [a b] [a b])\n;=> true\n```\n\nJavaScript objects cannot be compared in this way until they are converted to\nClojureScript collections:\n\n```clj\n(def a #js {:foo #js {:bar \"baz\"}})\n(def b #js {:foo #js {:bar \"baz\"}})\n(= a b)\n;;=> false\n\n(= (js->clj a)\n   (js->clj b))\n;;=> true\n```"}],
                          :full-name "cljs.core/=",
                          :clj-symbol "clojure.core/=",
                          :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
           "syntax/comment" {:description "\"Comments out\" everything after `;` on the current line.",
                             :ns "syntax",
                             :name "comment",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/ignore"
                                       "cljs.core/comment"],
                             :full-name-encode "syntax_comment",
                             :source {:repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form ";",
                             :examples [{:id "ab62d2",
                                         :content "Add comments to code:\n\n```clj\n(def a 1) ; this is a comment\n```\n\nIt is common to use `;;` for comments that have their own line:\n\n```clj\n;; this is comment is on its own line\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#comments",
                             :full-name "syntax/comment",
                             :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/defn-" {:description "Same as `defn`, but adds `{:private true}` metadata to the definition.\n\nNote: `:private` metadata is not currently enforced by the ClojureScript\ncompiler.",
                              :ns "cljs.core",
                              :name "defn-",
                              :signature ["[name & decls]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/defn"],
                              :full-name-encode "cljs.core_defn-",
                              :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                       :repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [4331 4335]},
                              :full-name "cljs.core/defn-",
                              :clj-symbol "clojure.core/defn-",
                              :docstring "same as defn, yielding non-public def"},
           "cljs.reader/read-symbol" {:ns "cljs.reader",
                                      :name "read-symbol",
                                      :type "function",
                                      :signature ["[reader initch]"],
                                      :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (gstring/contains token \"/\")\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\")) (.-length token)))\n      (get special-symbols token (symbol token)))))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [248 254]},
                                      :full-name "cljs.reader/read-symbol",
                                      :full-name-encode "cljs.reader_read-symbol",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/push-back-reader" {:ns "cljs.reader",
                                           :name "push-back-reader",
                                           :type "function",
                                           :signature ["[s]"],
                                           :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (atom 0) (atom nil)))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/cljs/reader.cljs",
                                                    :lines [30 32]},
                                           :full-name "cljs.reader/push-back-reader",
                                           :full-name-encode "cljs.reader_push-back-reader",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/deftype" {:ns "cljs.core",
                                :name "deftype",
                                :signature ["[t fields & impls]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_deftype",
                                :source {:code "(defmacro deftype [t fields & impls]\n  (let [adorn-params (fn [sig]\n                       (cons (vary-meta (second sig) assoc :cljs.compiler/fields fields)\n                             (nnext sig)))\n        ;;reshape for extend-type\n        dt->et (fn [specs]\n                 (loop [ret [] s specs]\n                   (if (seq s)\n                     (recur (-> ret\n                                (conj (first s))\n                                (into\n                                 (reduce (fn [v [f sigs]]\n                                           (conj v (cons f (map adorn-params sigs))))\n                                         []\n                                         (group-by first (take-while seq? (next s))))))\n                            (drop-while seq? (next s)))\n                     ret)))\n        r (:name (cljs.compiler/resolve-var (dissoc &env :locals) t))]\n    (if (seq impls)\n      `(do\n         (deftype* ~t ~fields)\n         (set! (.-cljs$core$IPrintable$_pr_seq ~t) (fn [this#] (list ~(str r))))\n         (extend-type ~t ~@(dt->et impls))\n         ~t)\n      `(do\n         (deftype* ~t ~fields)\n         (set! (.-cljs$core$IPrintable$_pr_seq ~t) (fn [this#] (list ~(str r))))\n         ~t))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [259 286]},
                                :full-name "cljs.core/deftype",
                                :clj-symbol "clojure.core/deftype"},
           "cljs.core/Subvec" {:ns "cljs.core",
                               :name "Subvec",
                               :type "type",
                               :signature ["[meta v start end]"],
                               :source {:code "(deftype Subvec [meta v start end]\n  IWithMeta\n  (-with-meta [coll meta] (Subvec. meta v start end))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (= start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (Subvec. meta v start (dec end))))\n\n  ICollection\n  (-conj [coll o]\n    (Subvec. meta (-assoc-n v end o) start (inc end)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (= i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (-nth v (+ start n)))\n  (-nth [coll n not-found]\n    (-nth v (+ start n) not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (let [v-pos (+ start key)]\n      (Subvec. meta (-assoc v v-pos val)\n               start (max end (inc v-pos)))))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2027 2097]},
                               :full-name "cljs.core/Subvec",
                               :full-name-encode "cljs.core_Subvec",
                               :history [["+" "0.0-927"]]},
           "cljs.repl.browser/run-in-order" {:ns "cljs.repl.browser",
                                             :name "run-in-order",
                                             :type "function",
                                             :signature ["[{:keys [expecting fns]}]"],
                                             :source {:code "(defn run-in-order [{:keys [expecting fns]}]\n  (loop [order expecting\n         fns fns]\n    (if-let [f (get fns order)]\n      (do (f)\n          (recur (inc order) (dissoc fns order)))\n      {:expecting order :fns fns})))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [206 212]},
                                             :full-name "cljs.repl.browser/run-in-order",
                                             :full-name-encode "cljs.repl.browser_run-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.browser/compile-client-js" {:ns "cljs.repl.browser",
                                                  :name "compile-client-js",
                                                  :type "function",
                                                  :signature ["[opts]"],
                                                  :source {:code "(defn compile-client-js [opts]\n  (cljsc/build '[(ns clojure.browser.repl.client\n                   (:require [goog.events :as event]\n                             [clojure.browser.repl :as repl]))\n                 (defn start [url]\n                   (event/listen js/window\n                                 \"load\"\n                                 (fn []\n                                   (repl/start-evaluator url))))]\n               {:optimizations (:optimizations opts)\n                :output-dir (:working-dir opts)}))",
                                                           :repo "clojurescript",
                                                           :tag "r971",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [302
                                                                   312]},
                                                  :full-name "cljs.repl.browser/compile-client-js",
                                                  :full-name-encode "cljs.repl.browser_compile-client-js",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "special/ns" {:description "Sets the namespace of the file.\n\n`ns` must be the first form in a `.cljs` file and there can only be one `ns`\ndeclaration per file. Namespaces must match the file name of their respective\n`.cljs` files, with the exception that dashes in namespaces become underscores\nin filenames. Thus, `(ns foo.bar-biz.baz)` should be the first form in file\n`foo/bar_biz/baz.cljs`.\n\n`references` can be zero or more forms used to import other namespaces, symbols,\nand libraries into the current namespace.",
                         :ns "special",
                         :name "ns",
                         :signature ["[name & references]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :full-name-encode "special_ns",
                         :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args] _]\n  (let [excludes\n        (reduce (fn [s [k exclude xs]]\n                  (if (= k :refer-clojure)\n                    (do\n                      (assert (= exclude :exclude) \"Only [:refer-clojure :exclude [names]] form supported\")\n                      (into s xs))\n                    s))\n                #{} args)\n        {uses :use requires :require uses-macros :use-macros requires-macros :require-macros :as params}\n        (reduce (fn [m [k & libs]]\n                  (assert (#{:use :use-macros :require :require-macros} k)\n                          \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")\n                  (assoc m k (into {}\n                                   (mapcat (fn [[lib kw expr]]\n                                             (case k\n                                               (:require :require-macros)\n                                               (do (assert (and expr (= :as kw))\n                                                           \"Only (:require [lib.ns :as alias]*) form of :require / :require-macros is supported\")\n                                                   [[expr lib]])\n                                               (:use :use-macros)\n                                               (do (assert (and expr (= :only kw))\n                                                           \"Only (:use [lib.ns :only [names]]*) form of :use / :use-macros is supported\")\n                                                   (map vector expr (repeat lib)))))\n                                           libs))))\n                {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (set! *cljs-ns* name)\n    (require 'cljs.core)\n    (doseq [nsym (concat (vals requires-macros) (vals uses-macros))]\n      (clojure.core/require nsym))\n    (swap! namespaces #(-> %\n                           (assoc-in [name :name] name)\n                           (assoc-in [name :excludes] excludes)\n                           (assoc-in [name :uses] uses)\n                           (assoc-in [name :requires] requires)\n                           (assoc-in [name :uses-macros] uses-macros)\n                           (assoc-in [name :requires-macros]\n                                     (into {} (map (fn [[alias nsym]]\n                                                     [alias (find-ns nsym)])\n                                                   requires-macros)))))\n    {:env env :op :ns :name name :uses uses :requires requires\n     :uses-macros uses-macros :requires-macros requires-macros :excludes excludes}))",
                                  :repo "clojurescript",
                                  :tag "r971",
                                  :filename "src/clj/cljs/compiler.clj",
                                  :lines [805 847]},
                         :full-name "special/ns",
                         :clj-symbol "clojure.core/ns"},
           "cljs.core/extend-protocol" {:ns "cljs.core",
                                        :name "extend-protocol",
                                        :signature ["[p & specs]"],
                                        :history [["+" "0.0-927"]],
                                        :type "macro",
                                        :full-name-encode "cljs.core_extend-protocol",
                                        :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                 :repo "clojure",
                                                 :tag "clojure-1.3.0",
                                                 :filename "src/clj/clojure/core_deftype.clj",
                                                 :lines [754 792]},
                                        :full-name "cljs.core/extend-protocol",
                                        :clj-symbol "clojure.core/extend-protocol",
                                        :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
           "cljs.reader/read" {:ns "cljs.reader",
                               :name "read",
                               :signature ["[reader eof-is-error sentinel is-recursive]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.reader_read",
                               :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [res\n                 (cond\n                  (macros ch) ((macros ch) reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (= res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/reader.cljs",
                                        :lines [338 354]},
                               :full-name "cljs.reader/read",
                               :clj-symbol "clojure.core/read",
                               :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
           "cljs.core/EmptyList" {:ns "cljs.core",
                                  :name "EmptyList",
                                  :signature ["[meta]"],
                                  :history [["+" "0.0-927"]],
                                  :type "type",
                                  :full-name-encode "cljs.core_EmptyList",
                                  :source {:code "(deftype EmptyList [meta]\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] #_(throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1152 1184]},
                                  :full-name "cljs.core/EmptyList",
                                  :clj-symbol "clojure.lang/EmptyList"},
           "clojure.walk/postwalk" {:ns "clojure.walk",
                                    :name "postwalk",
                                    :signature ["[f form]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.walk_postwalk",
                                    :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/clojure/walk.cljs",
                                             :lines [50 56]},
                                    :full-name "clojure.walk/postwalk",
                                    :clj-symbol "clojure.walk/postwalk",
                                    :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "clojure.zip/edit" {:ns "clojure.zip",
                               :name "edit",
                               :signature ["[loc f & args]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_edit",
                               :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [189 192]},
                               :full-name "clojure.zip/edit",
                               :clj-symbol "clojure.zip/edit",
                               :docstring "Replaces the node at this loc with the value of (f node args)"},
           "cljs.core/re-seq" {:description "Returns a lazy sequence of successive matches of regex `re` in string `s`.",
                               :ns "cljs.core",
                               :name "re-seq",
                               :signature ["[re s]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/re-find"
                                         "cljs.core/re-pattern"
                                         "cljs.core/re-matches"
                                         "cljs.core/subs"
                                         "clojure.string/split"],
                               :full-name-encode "cljs.core_re-seq",
                               :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (re-seq re post-match))))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2830 2837]},
                               :full-name "cljs.core/re-seq",
                               :clj-symbol "clojure.core/re-seq",
                               :docstring "Returns a lazy sequence of successive matches of re in s."},
           "cljs.reader/read-list" {:ns "cljs.reader",
                                    :name "read-list",
                                    :type "function",
                                    :signature ["[rdr _]"],
                                    :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [203 205]},
                                    :full-name "cljs.reader/read-list",
                                    :full-name-encode "cljs.reader_read-list",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/Atom" {:ns "cljs.core",
                             :name "Atom",
                             :signature ["[state meta validator watches]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_Atom",
                             :source {:code "(deftype Atom [state meta validator watches]\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IPrintable\n  (-pr-seq [a opts]\n    (concat  [\"#<Atom: \"] (-pr-seq state opts) \">\"))\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f)))\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3013 3037]},
                             :full-name "cljs.core/Atom",
                             :clj-symbol "clojure.lang/Atom"},
           "cljs.core/IMap" {:ns "cljs.core",
                             :name "IMap",
                             :type "protocol",
                             :full-name-encode "cljs.core_IMap",
                             :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (-dissoc [coll k]))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [145 147]},
                             :methods [{:name "-dissoc",
                                        :signature ["[coll k]"],
                                        :docstring nil}],
                             :full-name "cljs.core/IMap",
                             :history [["+" "0.0-927"]]},
           "cljs.reader/read-vector" {:ns "cljs.reader",
                                      :name "read-vector",
                                      :type "function",
                                      :signature ["[rdr _]"],
                                      :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [209 211]},
                                      :full-name "cljs.reader/read-vector",
                                      :full-name-encode "cljs.reader_read-vector",
                                      :history [["+" "0.0-927"]]},
           "clojure.set/join" {:ns "clojure.set",
                               :name "join",
                               :signature ["[xrel yrel]"
                                           "[xrel yrel km]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.set_join",
                               :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/set.cljs",
                                        :lines [102 130]},
                               :full-name "clojure.set/join",
                               :clj-symbol "clojure.set/join",
                               :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
           "cljs.core/HashMap" {:ns "cljs.core",
                                :name "HashMap",
                                :type "type",
                                :signature ["[meta count hashobj]"],
                                :source {:code "(deftype HashMap [meta count hashobj]\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (.-length bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2313 2400]},
                                :full-name "cljs.core/HashMap",
                                :full-name-encode "cljs.core_HashMap",
                                :history [["+" "0.0-927"]]},
           "cljs.repl.browser/handle-get" {:ns "cljs.repl.browser",
                                           :name "handle-get",
                                           :type "function",
                                           :signature ["[opts conn request]"],
                                           :source {:code "(defn handle-get [opts conn request]\n  (let [path (:path request)]\n    (if (.startsWith path \"/repl\")\n      (send-repl-client-page opts conn request)\n      (send-404 conn (:path request)))))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/clj/cljs/repl/browser.clj",
                                                    :lines [182 186]},
                                           :full-name "cljs.repl.browser/handle-get",
                                           :full-name-encode "cljs.repl.browser_handle-get",
                                           :history [["+" "0.0-927"]]},
           "cljs.reader/int-pattern" {:ns "cljs.reader",
                                      :name "int-pattern",
                                      :type "var",
                                      :source {:code "(def int-pattern (re-pattern \"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?\"))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [95]},
                                      :full-name "cljs.reader/int-pattern",
                                      :full-name-encode "cljs.reader_int-pattern",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/swap!" {:description "Atomically swaps the value of atom to be: `(apply f current-value-of-atom\nargs)`\n\nNote that `f` may be called multiple times, and thus should be free of side\neffects.\n\nReturns the value that was swapped in.",
                              :ns "cljs.core",
                              :name "swap!",
                              :signature ["[a f]"
                                          "[a f x]"
                                          "[a f x y]"
                                          "[a f x y & more]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/atom"
                                        "cljs.core/reset!"],
                              :full-name-encode "cljs.core_swapBANG",
                              :source {:code "(defn swap!\n  ([a f]\n     (reset! a (f (.-state a))))\n  ([a f x]\n     (reset! a (f (.-state a) x)))\n  ([a f x y]\n     (reset! a (f (.-state a) x y)))\n  ([a f x y z]\n     (reset! a (f (.-state a) x y z)))\n  ([a f x y z & more]\n     (reset! a (apply f (.-state a) x y z more))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3067 3081]},
                              :full-name "cljs.core/swap!",
                              :clj-symbol "clojure.core/swap!",
                              :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
           "cljs.core/dec" {:description "Returns a number one less than `x`.",
                            :ns "cljs.core",
                            :name "dec",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/inc"],
                            :full-name-encode "cljs.core_dec",
                            :source {:code "(defn dec\n  [x] (- x 1))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [889 891]},
                            :extra-sources ({:code "(defmacro dec [x]\n  `(- ~x 1))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [112 113]}),
                            :full-name "cljs.core/dec",
                            :clj-symbol "clojure.core/dec",
                            :docstring "Returns a number one less than num."},
           "clojure.browser.dom/remove-children" {:ns "clojure.browser.dom",
                                                  :name "remove-children",
                                                  :signature ["[id]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.dom_remove-children",
                                                  :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                           :repo "clojurescript",
                                                           :tag "r971",
                                                           :filename "src/cljs/clojure/browser/dom.cljs",
                                                           :lines [90
                                                                   94]},
                                                  :full-name "clojure.browser.dom/remove-children",
                                                  :docstring "Remove all children from the element with the passed id."},
           "cljs.core/get-validator" {:description "Returns the validator function for atom `a`.",
                                      :ns "cljs.core",
                                      :name "get-validator",
                                      :signature ["[a]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :related ["cljs.core/atom"
                                                "cljs.core/set-validator!"],
                                      :full-name-encode "cljs.core_get-validator",
                                      :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3109 3112]},
                                      :full-name "cljs.core/get-validator",
                                      :clj-symbol "clojure.core/get-validator",
                                      :docstring "Gets the validator-fn for a var/ref/agent/atom."},
           "cljs.core/coll?" {:description "Returns true if `x` is a collection, false otherwise.\n\nLists, maps, sets, and vectors are collections.",
                              :ns "cljs.core",
                              :name "coll?",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/seq?"
                                        "cljs.core/list?"
                                        "cljs.core/sequential?"],
                              :full-name-encode "cljs.core_collQMARK",
                              :source {:code "(defn coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [591 596]},
                              :examples [{:id "d30884",
                                          :content "```clj\n(coll? [1 2 3])\n;;=> true\n\n(coll? '(1 2 3))\n;;=> true\n\n(coll? #{1 2 3})\n;;=> true\n\n(coll? {:foo 1 :bar 2})\n;;=> true\n```\n\nNot collections:\n\n```clj\n(coll? \"foo\")\n;;=> false\n\n(coll? 123)\n;;=> false\n\n(coll? nil)\n;;=> false\n```"}],
                              :full-name "cljs.core/coll?",
                              :clj-symbol "clojure.core/coll?",
                              :docstring "Returns true if x satisfies ICollection"},
           "cljs.core/bit-or" {:description "Bitwise \"or\". Same as `x | y` in JavaScript.",
                               :ns "cljs.core",
                               :name "bit-or",
                               :signature ["[x y]" "[x y & more]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/bit-and"
                                         "cljs.core/bit-xor"],
                               :full-name-encode "cljs.core_bit-or",
                               :source {:code "(defn bit-or\n  [x y] (cljs.core/bit-or x y))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [946 948]},
                               :extra-sources ({:code "(defmacro bit-or\n  ([x y] (list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [147 149]}),
                               :examples [{:id "ecea10",
                                           :content "Bits can be entered using radix notation:\n\n```clj\n(bit-or 2r1100 2r1010)\n;;=> 14\n;; 14 = 2r1110\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-or 12 10)\n;;=> 14\n```"}],
                               :full-name "cljs.core/bit-or",
                               :clj-symbol "clojure.core/bit-or",
                               :docstring "Bitwise or"},
           "cljs.core/nfirst" {:description "Same as `(next (first coll))`.",
                               :ns "cljs.core",
                               :name "nfirst",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/next"],
                               :full-name-encode "cljs.core_nfirst",
                               :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [445 448]},
                               :examples [{:id "60b8a4",
                                           :content "```clj\n(nfirst [[1 2 3] [4 5]])\n;;=> (2 3)\n\n(nfirst [[1 2] [3 4]])\n;;=> (2)\n\n(nfirst [[1] [2 3]])\n;;=> nil\n\n(nfirst [[] [1 2]])\n;;=> nil\n```"}],
                               :full-name "cljs.core/nfirst",
                               :clj-symbol "clojure.core/nfirst",
                               :docstring "Same as (next (first x))"},
           "cljs.core/keep" {:description "Returns a lazy sequence of the non-nil results of `(f item)`. Note, this means\nfalse return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "keep",
                             :signature ["[f]" "[f coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/keep-indexed"
                                       "cljs.core/map"
                                       "cljs.core/filter"],
                             :full-name-encode "cljs.core_keep",
                             :source {:code "(defn keep\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [x (f (first s))]\n        (if (nil? x)\n          (keep f (rest s))\n          (cons x (keep f (rest s)))))))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1575 1585]},
                             :full-name "cljs.core/keep",
                             :clj-symbol "clojure.core/keep",
                             :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
           "cljs.core/take" {:description "Returns a lazy sequence of the first `n` items in `coll`. Returns all the items\nif there are fewer than `n`.\n\nReturns a stateful transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "take",
                             :signature ["[n]" "[n coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/drop"
                                       "cljs.core/take-while"
                                       "cljs.core/take-last"
                                       "cljs.core/take-nth"],
                             :full-name-encode "cljs.core_take",
                             :source {:code "(defn take\n  [n coll]\n  (lazy-seq\n   (when (pos? n)\n     (when-let [s (seq coll)]\n      (cons (first s) (take (dec n) (rest s)))))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1709 1716]},
                             :full-name "cljs.core/take",
                             :clj-symbol "clojure.core/take",
                             :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n."},
           "cljs.core/cond" {:description "`clauses` must be an even number of forms, ie: `(cond t1 e1, t2 e2, t3 e3)`.\nEach test `t` is evaluated one at a time. If a test returns logical true, `cond`\nevaluates and returns the corresponding expression `e` and does not evaluate any\nof the other tests or expressions.\n\nIt is idiomatic to provide a default case as the last test pair using the\nkeyword `:else` (a keyword always evaluates to logical true).\n\n`(cond)` returns nil.",
                             :ns "cljs.core",
                             :name "cond",
                             :signature ["[& clauses]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/condp"
                                       "cljs.core/case"
                                       "special/if"],
                             :full-name-encode "cljs.core_cond",
                             :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [534 547]},
                             :full-name "cljs.core/cond",
                             :clj-symbol "clojure.core/cond",
                             :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
           "cljs.core/bit-and" {:description "Bitwise \"and\".  Same as `x & y` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-and",
                                :signature ["[x y]" "[x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-or"],
                                :full-name-encode "cljs.core_bit-and",
                                :source {:code "(defn bit-and\n  [x y] (cljs.core/bit-and x y))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [942 944]},
                                :extra-sources ({:code "(defmacro bit-and\n  ([x y] (list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [143 145]}),
                                :examples [{:id "3c0470",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-and 2r1100 2r1010)\n;;=> 8\n;; 8 = 2r1000\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-and 12 10)\n;;=> 8\n```"}],
                                :full-name "cljs.core/bit-and",
                                :clj-symbol "clojure.core/bit-and",
                                :docstring "Bitwise and"},
           "cljs.core/ObjMap.fromObject" {:ns "cljs.core",
                                          :name "ObjMap.fromObject",
                                          :signature ["[ks obj]"],
                                          :history [["+" "0.0-927"]],
                                          :parent-type "ObjMap",
                                          :type "function",
                                          :full-name-encode "cljs.core_ObjMapDOTfromObject",
                                          :source {:code "(set! cljs.core.ObjMap/fromObject (fn [ks obj] (ObjMap. nil ks obj)))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [2306]},
                                          :full-name "cljs.core/ObjMap.fromObject"},
           "clojure.browser.event/unique-event-id" {:ns "clojure.browser.event",
                                                    :name "unique-event-id",
                                                    :type "function",
                                                    :signature ["[event-type]"],
                                                    :source {:code "(defn unique-event-id [event-type])",
                                                             :repo "clojurescript",
                                                             :tag "r971",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [92]},
                                                    :full-name "clojure.browser.event/unique-event-id",
                                                    :full-name-encode "clojure.browser.event_unique-event-id",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "clojure.set/project" {:ns "clojure.set",
                                  :name "project",
                                  :signature ["[xrel ks]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set_project",
                                  :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [67 70]},
                                  :full-name "clojure.set/project",
                                  :clj-symbol "clojure.set/project",
                                  :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
           "special/js*" {:ns "special",
                          :name "js*",
                          :type "special form",
                          :source {:code "(defmethod parse 'js*\n  [op env [_ form & args] _]\n  (assert (string? form))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (cons (subs s 0 idx) (seg (subs s (inc end))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       {:env env :op :js :segs (seg form) :args argexprs :children argexprs}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (cons (subs s 0 idx) (cons inner (interp (subs s (inc end)))))))))]\n      {:env env :op :js :code (apply str (interp form))})))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [958 979]},
                          :full-name "special/js*",
                          :full-name-encode "special_jsSTAR",
                          :history [["+" "0.0-927"]]},
           "syntax/quote" {:description "Prevent the evaluation of the following form.\n\n`'foo` = `(quote foo)`",
                           :ns "syntax",
                           :name "quote",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["special/quote"],
                           :full-name-encode "syntax_quote",
                           :source {:repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/jvm/clojure/lang/LispReader.java",
                                    :lines [nil]},
                           :syntax-form "'",
                           :examples [{:id "0d2c26",
                                       :content "```clj\n'foo\n;;=> foo\n\n'(a b c)\n;;=> (a b c)\n\n'[a b c]\n;;=> [a b c]\n\n'(a b (c d))\n;;=> (a b (c d))\n```"}],
                           :full-name "syntax/quote",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.string/trim-newline" {:description "Removes all trailing newline `\\n` or return `\\r` characters from string.\n\nSimilar to Perl's chomp.",
                                          :ns "clojure.string",
                                          :name "trim-newline",
                                          :signature ["[s]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.string_trim-newline",
                                          :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/clojure/string.cljs",
                                                   :lines [121 131]},
                                          :full-name "clojure.string/trim-newline",
                                          :clj-symbol "clojure.string/trim-newline",
                                          :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
           "specialrepl/in-ns" {:description "Only usable from a REPL.\n\nChanges to the namespace `name`, creating it if needed.\n\nSets `*cljs-ns*` to the namespace `name`.",
                                :ns "specialrepl",
                                :name "in-ns",
                                :signature ["[name]"],
                                :history [["+" "0.0-927"]],
                                :type "special form (repl)",
                                :full-name-encode "specialrepl_in-ns",
                                :source {:code "(defn repl\n  \"Note - repl will reload core.cljs every time, even if supplied old repl-env\"\n  [repl-env & {:keys [verbose warn-on-undeclared]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (= (first form) 'in-ns))\n           (do (set! comp/*cljs-ns* (second (second form))) (newline) (recur))\n           \n           (and (seq? form) ('#{load-file clojure.core/load-file} (first form)))\n           (do (load-file repl-env (second form)) (newline) (recur))\n           \n           (and (seq? form) ('#{load-namespace} (first form)))\n           (do (load-namespace repl-env (second form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/clj/cljs/repl.clj",
                                         :lines [133 162]},
                                :examples [{:id "e81eb3",
                                            :content "```clj\n(in-ns 'foo.core)\n```"}],
                                :full-name "specialrepl/in-ns",
                                :clj-symbol "clojure.core/in-ns"},
           "special/let*" {:ns "special",
                           :name "let*",
                           :type "special form",
                           :source {:code "(defmethod parse 'let*\n  [op encl-env form _]\n  (analyze-let encl-env form false))",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [754 756]},
                           :full-name "special/let*",
                           :full-name-encode "special_letSTAR",
                           :history [["+" "0.0-927"]]},
           "cljs.repl.browser/stop-server" {:ns "cljs.repl.browser",
                                            :name "stop-server",
                                            :type "function",
                                            :signature ["[]"],
                                            :source {:code "(defn stop-server\n  []\n  (.close (:socket @server-state)))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [254 256]},
                                            :full-name "cljs.repl.browser/stop-server",
                                            :full-name-encode "cljs.repl.browser_stop-server",
                                            :history [["+" "0.0-927"]]},
           "special/throw" {:description "`expr` is evaluated and thrown, hopefully to be caught by a `try` expression.\n\n`(throw (js/Error. \"Oops!\"))`",
                            :ns "special",
                            :name "throw",
                            :signature ["[expr]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :related ["special/try"
                                      "special/catch"
                                      "special/finally"],
                            :full-name-encode "special_throw",
                            :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [612 617]},
                            :full-name "special/throw",
                            :clj-symbol "clojure.core/throw"},
           "clojure.zip/insert-left" {:ns "clojure.zip",
                                      :name "insert-left",
                                      :signature ["[loc item]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.zip_insert-left",
                                      :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/clojure/zip.cljs",
                                               :lines [165 172]},
                                      :full-name "clojure.zip/insert-left",
                                      :clj-symbol "clojure.zip/insert-left",
                                      :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
           "cljs.core/true?" {:description "Returns true if `x` is the value true, false otherwise.",
                              :ns "cljs.core",
                              :name "true?",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/false?"],
                              :full-name-encode "cljs.core_trueQMARK",
                              :source {:code "(defn true?\n  [x] (cljs.core/true? x))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [648 650]},
                              :extra-sources ({:code "(defmacro true? [x]\n  (list 'js* \"~{} === true\" x))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [45 46]}),
                              :full-name "cljs.core/true?",
                              :clj-symbol "clojure.core/true?",
                              :docstring "Returns true if x is the value true, false otherwise."},
           "clojure.browser.net/xpc-connection" {:ns "clojure.browser.net",
                                                 :name "xpc-connection",
                                                 :signature ["[]"
                                                             "[config]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net_xpc-connection",
                                                 :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (goog.Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (goog.net.xpc.CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (goog.net.xpc.CrossPageChannel.\n      (.-strobj (reduce (fn [sum [k v]]\n                          (if-let [field (get xpc-config-fields k)]\n                            (assoc sum field v)\n                            sum))\n                       {}\n                       config)))))",
                                                          :repo "clojurescript",
                                                          :tag "r971",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [118
                                                                  140]},
                                                 :full-name "clojure.browser.net/xpc-connection",
                                                 :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API."},
           "cljs.core/not" {:description "Returns true if `x` is logical false, false otherwise.",
                            :ns "cljs.core",
                            :name "not",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/complement"
                                      "cljs.core/false?"],
                            :full-name-encode "cljs.core_not",
                            :source {:code "(defn not\n  [x] (if x false true))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [478 480]},
                            :full-name "cljs.core/not",
                            :clj-symbol "clojure.core/not",
                            :docstring "Returns true if x is logical false, false otherwise."},
           "cljs.core/js-obj" {:description "Returns a new JavaScript object using the supplied mappings.\n\n`keyvals` must be an even number of forms.",
                               :ns "cljs.core",
                               :name "js-obj",
                               :signature ["[& keyvals]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/array"],
                               :full-name-encode "cljs.core_js-obj",
                               :source {:code "(defn js-obj []\n  (js* \"{}\"))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [629 630]},
                               :examples [{:id "657cd7",
                                           :content "```clj\n(js-obj \"foo\" 1 \"bar\" 2)\n;;=> #js {:foo 1, :bar 2}\n```"}],
                               :full-name "cljs.core/js-obj"},
           "cljs.core/complement" {:description "Takes a function `f` and returns a function that takes the same arguments as\n`f`, has the same effects, if any, and returns the opposite truth value.",
                                   :ns "cljs.core",
                                   :name "complement",
                                   :signature ["[f]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/not"],
                                   :full-name-encode "cljs.core_complement",
                                   :source {:code "(defn complement\n  [f] \n  (fn \n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1483 1491]},
                                   :full-name "cljs.core/complement",
                                   :clj-symbol "clojure.core/complement",
                                   :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
           "cljs.core/spread" {:ns "cljs.core",
                               :name "spread",
                               :type "function",
                               :signature ["[arglist]"],
                               :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1338 1344]},
                               :full-name "cljs.core/spread",
                               :full-name-encode "cljs.core_spread",
                               :history [["+" "0.0-927"]]},
           "cljs.core/keyword" {:ns "cljs.core",
                                :name "keyword",
                                :signature ["[name]" "[ns name]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_keyword",
                                :source {:code "(defn keyword\n  ([name] (cond (keyword? name) name\n                (symbol? name) (str* \"\\uFDD0\" \"'\" (subs name 2))\n                :else (str* \"\\uFDD0\" \"'\" name)))\n  ([ns name] (keyword (str* ns \"/\" name))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1075 1081]},
                                :full-name "cljs.core/keyword",
                                :clj-symbol "clojure.core/keyword",
                                :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
           "syntax/keyword-qualify" {:ns "syntax",
                                     :name "keyword-qualify",
                                     :history [["+" "0.0-927"]],
                                     :type "syntax",
                                     :full-name-encode "syntax_keyword-qualify",
                                     :source {:repo "clojure",
                                              :tag "clojure-1.3.0",
                                              :filename "src/jvm/clojure/lang/LispReader.java",
                                              :lines [nil]},
                                     :syntax-form "::",
                                     :full-name "syntax/keyword-qualify",
                                     :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/sort" {:description "Returns a sorted sequence of the items in `coll`.\n\n`comp` can be a boolean-valued comparison funcion, or a -/0/+ valued comparator.\n\n`comp` defaults to `compare`.",
                             :ns "cljs.core",
                             :name "sort",
                             :signature ["[coll]" "[comp coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/sort-by"],
                             :full-name-encode "cljs.core_sort",
                             :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [751 763]},
                             :full-name "cljs.core/sort",
                             :clj-symbol "clojure.core/sort",
                             :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "clojure.string/trim" {:description "Removes whitespace from both ends of string.",
                                  :ns "clojure.string",
                                  :name "trim",
                                  :signature ["[s]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string_trim",
                                  :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [106 109]},
                                  :full-name "clojure.string/trim",
                                  :clj-symbol "clojure.string/trim",
                                  :docstring "Removes whitespace from both ends of string."},
           "cljs.core/meta" {:ns "cljs.core",
                             :name "meta",
                             :signature ["[o]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_meta",
                             :source {:code "(defn meta\n  [o]\n  (when (satisfies? IMeta o)\n    (-meta o)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [552 556]},
                             :full-name "cljs.core/meta",
                             :clj-symbol "clojure.core/meta",
                             :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
           "cljs.core/time" {:ns "cljs.core",
                             :name "time",
                             :signature ["[expr]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core_time",
                             :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.) ())\n         ret# ~expr]\n     (prn (str \"Elapsed time: \" (- (.getTime (js/Date.) ()) start#) \" msecs\"))\n     ret#))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [743 749]},
                             :full-name "cljs.core/time",
                             :clj-symbol "clojure.core/time",
                             :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
           "cljs.core/boolean" {:description "Return `false` if `x` is false or nil.  Otherwise return `true`.  This is the\ntruthiness condition used by `if` expressions.",
                                :ns "cljs.core",
                                :name "boolean",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["special/if"],
                                :full-name-encode "cljs.core_boolean",
                                :source {:code "(defn boolean [x]\n  (if x true false))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [665 666]},
                                :examples [{:id "9edf3a",
                                            :content "```clj\n(boolean 1)\n;;=> true\n\n(boolean 0)\n;;=> true\n\n(boolean nil)\n;;=> false\n```"}],
                                :full-name "cljs.core/boolean",
                                :clj-symbol "clojure.core/boolean"},
           "cljs.reader/read-token" {:ns "cljs.reader",
                                     :name "read-token",
                                     :type "function",
                                     :signature ["[rdr initch]"],
                                     :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (gstring/StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (. sb (toString)))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [76 84]},
                                     :full-name "cljs.reader/read-token",
                                     :full-name-encode "cljs.reader_read-token",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/update-in" {:description "\"Updates\" a value in a nested associative structure, where `ks` is a sequence of\nkeys and `f` is a function that will take the old value and any supplied\narguments and return the new value. Returns a new nested structure.\n\nIf any levels do not exist, hash-maps will be created.",
                                  :ns "cljs.core",
                                  :name "update-in",
                                  :signature ["[m [k & ks] f]"
                                              "[m [k & ks] f a]"
                                              "[m [k & ks] f a b]"
                                              "[m [k & ks] f a b c]"
                                              "[m [k & ks] f a b c & args]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/assoc-in"
                                            "cljs.core/get-in"],
                                  :full-name-encode "cljs.core_update-in",
                                  :source {:code "(defn update-in\n  ([m [k & ks] f & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f args))\n     (assoc m k (apply f (get m k) args)))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1921 1930]},
                                  :full-name "cljs.core/update-in",
                                  :clj-symbol "clojure.core/update-in",
                                  :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
           "cljs.core/map-indexed" {:description "Returns a lazy sequence consisting of the result of applying `f` to 0 and the\nfirst item of `coll`, followed by applying `f` to 1 and the second item in\n`coll`, etc, until `coll` is exhausted.\n\nFunction `f` should accept 2 arguments, index and item.",
                                    :ns "cljs.core",
                                    :name "map-indexed",
                                    :signature ["[f coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/map"
                                              "cljs.core/keep-indexed"],
                                    :full-name-encode "cljs.core_map-indexed",
                                    :source {:code "(defn map-indexed\n  [f coll]\n  (let [mapi (fn mpi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (cons (f idx (first s))\n                        (mpi (inc idx) (rest s))))))]\n    (mapi 0 coll)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1562 1573]},
                                    :full-name "cljs.core/map-indexed",
                                    :clj-symbol "clojure.core/map-indexed",
                                    :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
           "cljs.core/IStack" {:ns "cljs.core",
                               :name "IStack",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core_IStack",
                               :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (-pop [coll]))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [152 154]},
                               :methods [{:name "-peek",
                                          :signature ["[coll]"],
                                          :docstring nil}
                                         {:name "-pop",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IStack",
                               :clj-symbol "clojure.lang/IPersistentStack"},
           "cljs.core/IIndexed" {:ns "cljs.core",
                                 :name "IIndexed",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IIndexed",
                                 :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [130 131]},
                                 :methods [{:name "-nth",
                                            :signature ["[coll n]"
                                                        "[coll n not-found]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IIndexed",
                                 :clj-symbol "clojure.lang/Indexed"},
           "clojure.browser.repl/repl-print" {:ns "clojure.browser.repl",
                                              :name "repl-print",
                                              :type "function",
                                              :signature ["[data]"],
                                              :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [23 25]},
                                              :full-name "clojure.browser.repl/repl-print",
                                              :full-name-encode "clojure.browser.repl_repl-print",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.browser.net/xpc-config-fields" {:ns "clojure.browser.net",
                                                    :name "xpc-config-fields",
                                                    :type "var",
                                                    :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (js->clj goog.net.xpc.CfgFields))))",
                                                             :repo "clojurescript",
                                                             :tag "r971",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [75
                                                                     81]},
                                                    :full-name "clojure.browser.net/xpc-config-fields",
                                                    :full-name-encode "clojure.browser.net_xpc-config-fields",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/nnext" {:description "Same as `(next (next coll))`.",
                              :ns "cljs.core",
                              :name "nnext",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/next"],
                              :full-name-encode "cljs.core_nnext",
                              :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [455 458]},
                              :full-name "cljs.core/nnext",
                              :clj-symbol "clojure.core/nnext",
                              :docstring "Same as (next (next x))"},
           "cljs.core/*print-meta*" {:ns "cljs.core",
                                     :name "*print-meta*",
                                     :type "var",
                                     :source {:code "(def *print-meta* false)",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2903]},
                                     :full-name "cljs.core/*print-meta*",
                                     :full-name-encode "cljs.core_STARprint-metaSTAR",
                                     :clj-symbol "clojure.core/*print-meta*",
                                     :history [["+" "0.0-927"]]},
           "cljs.reader/read-dispatch" {:ns "cljs.reader",
                                        :name "read-dispatch",
                                        :type "function",
                                        :signature ["[rdr _]"],
                                        :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (get dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (reader-error rdr \"No dispatch macro for \" ch))))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [191 197]},
                                        :full-name "cljs.reader/read-dispatch",
                                        :full-name-encode "cljs.reader_read-dispatch",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/distinct" {:description "Returns a lazy sequence of the elements of `coll` with duplicates removed.",
                                 :ns "cljs.core",
                                 :name "distinct",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/distinct?"],
                                 :full-name-encode "cljs.core_distinct",
                                 :source {:code "(defn distinct\n  [coll]\n  (let [step (fn step [xs seen]\n               (lazy-seq\n                ((fn [[f :as xs] seen]\n                   (when-let [s (seq xs)]\n                     (if (contains? seen f)\n                       (recur (rest s) seen)\n                       (cons f (step (rest s) (conj seen f))))))\n                 xs seen)))]\n    (step coll #{})))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2544 2555]},
                                 :full-name "cljs.core/distinct",
                                 :clj-symbol "clojure.core/distinct",
                                 :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
           "cljs.reader/wrapping-reader" {:ns "cljs.reader",
                                          :name "wrapping-reader",
                                          :type "function",
                                          :signature ["[sym]"],
                                          :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [277 280]},
                                          :full-name "cljs.reader/wrapping-reader",
                                          :full-name-encode "cljs.reader_wrapping-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prn" {:ns "cljs.core",
                            :name "prn",
                            :signature ["[& objs]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core_prn",
                            :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (newline (pr-opts)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2938 2942]},
                            :full-name "cljs.core/prn",
                            :clj-symbol "clojure.core/prn",
                            :docstring "Same as pr followed by (newline)."},
           "clojure.zip/leftmost" {:ns "clojure.zip",
                                   :name "leftmost",
                                   :signature ["[loc]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip_leftmost",
                                   :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [157 163]},
                                   :full-name "clojure.zip/leftmost",
                                   :clj-symbol "clojure.zip/leftmost",
                                   :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
           "cljs.core/>=" {:description "Returns true if each successive number argument is less than or equal to the\nprevious one, false otherwise.",
                           :ns "cljs.core",
                           :name ">=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/>"],
                           :full-name-encode "cljs.core_GTEQ",
                           :source {:code "(defn >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [877 887]},
                           :extra-sources ({:code "(defmacro >=\n  ([x] true)\n  ([x y] (list 'js* \"(~{} >= ~{})\" x y))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [102 105]}),
                           :examples [{:id "de73d7",
                                       :content "```clj\n(>= 2 1)\n;;=> true\n\n(>= 2 2)\n;;=> true\n\n(>= 1 2)\n;;=> false\n\n(>= 6 5 4 3 2)\n;;=> true\n```"}],
                           :full-name "cljs.core/>=",
                           :clj-symbol "clojure.core/>=",
                           :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
           "cljs.repl.browser/read-request" {:ns "cljs.repl.browser",
                                             :name "read-request",
                                             :type "function",
                                             :signature ["[rdr]"],
                                             :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [160 164]},
                                             :full-name "cljs.repl.browser/read-request",
                                             :full-name-encode "cljs.repl.browser_read-request",
                                             :history [["+" "0.0-927"]]},
           "cljs.reader/macros" {:ns "cljs.reader",
                                 :name "macros",
                                 :type "var",
                                 :source {:code "(def macros\n     { \\\" read-string\n       \\: read-keyword\n       \\; not-implemented ;; never hit this\n       \\' (wrapping-reader 'quote)\n       \\@ (wrapping-reader 'deref)\n       \\^ read-meta\n       \\` not-implemented\n       \\~ not-implemented\n       \\( read-list\n       \\) read-unmatched-delimiter\n       \\[ read-vector\n       \\] read-unmatched-delimiter\n       \\{ read-map\n       \\} read-unmatched-delimiter\n       \\\\ read-char\n       \\% not-implemented\n       \\# read-dispatch\n       })",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/reader.cljs",
                                          :lines [310 328]},
                                 :full-name "cljs.reader/macros",
                                 :full-name-encode "cljs.reader_macros",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/doseq" {:description "Repeatedly executes `body` (presumably for side-effects) with bindings and\nfiltering as provided by `for`. Does not retain the head of the sequence.\n\nReturns nil.",
                              :ns "cljs.core",
                              :name "doseq",
                              :signature ["[seq-exprs & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/doall"
                                        "cljs.core/dorun"
                                        "cljs.core/for"
                                        "cljs.core/dotimes"],
                              :full-name-encode "cljs.core_doseq",
                              :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n                       \n                       seqsym (when-not (keyword? k) (gensym))\n                       recform (if (keyword? k) recform `(recur (first ~seqsym) ~seqsym))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     :else [true `(let [~seqsym (seq ~v)]\n                                    (when ~seqsym\n                                      (loop [~k (first ~seqsym) ~seqsym ~seqsym]\n                                       ~subform\n                                       (when-let [~seqsym (next ~seqsym)]\n                                        ~@(when needrec [recform])))))]))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [602 637]},
                              :full-name "cljs.core/doseq",
                              :clj-symbol "clojure.core/doseq",
                              :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
           "cljs.core/*" {:description "Returns the product of nums.\n\n`(*)` returns 1.",
                          :ns "cljs.core",
                          :name "*",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/+" "cljs.core//"],
                          :full-name-encode "cljs.core_STAR",
                          :source {:code "(defn *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [827 832]},
                          :extra-sources ({:code "(defmacro *\n  ([] 1)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [75 79]}),
                          :examples [{:id "bc4a1f",
                                      :content "```clj\n;; there is an implicit 1\n(*)\n;;=> 1\n\n;; the implicit 1 comes into play\n(* 6)\n;;=> 6\n\n(* 2 3)\n;;=> 6\n\n(* 2 3 4)\n;;=> 24\n```"}],
                          :full-name "cljs.core/*",
                          :clj-symbol "clojure.core/*",
                          :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/into" {:description "Returns a new collection consisting of `to` with all of the items of `from`\n\"added\" using `conj`.\n\nA transducer may be supplied as `xform`.",
                             :ns "cljs.core",
                             :name "into",
                             :signature ["[to from]"
                                         "[to xform from]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/conj"],
                             :full-name-encode "cljs.core_into",
                             :source {:code "(defn into\n  [to from]\n  (reduce -conj to from))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1865 1869]},
                             :full-name "cljs.core/into",
                             :clj-symbol "clojure.core/into",
                             :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined."},
           "cljs.core/defmethod" {:ns "cljs.core",
                                  :name "defmethod",
                                  :signature ["[multifn dispatch-val & fn-tail]"],
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core_defmethod",
                                  :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core.MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [738 741]},
                                  :full-name "cljs.core/defmethod",
                                  :clj-symbol "clojure.core/defmethod",
                                  :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
           "cljs.core/rest" {:description "Returns a possibly empty sequence of the items after the first item.\n\nCalls `seq` on its argument.",
                             :ns "cljs.core",
                             :name "rest",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/next"
                                       "cljs.core/first"
                                       "cljs.core/drop"
                                       "cljs.core/pop"],
                             :full-name-encode "cljs.core_rest",
                             :source {:code "(defn rest\n  [coll]\n  (-rest (seq coll)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [422 426]},
                             :examples [{:id "0869af",
                                         :content "```clj\n(rest [1 2 3])\n;;=> (2 3)\n\n(rest [1 2])\n;;=> (2)\n\n(rest [1])\n;;=> ()\n\n(rest [])\n;;=> ()\n```"}],
                             :full-name "cljs.core/rest",
                             :clj-symbol "clojure.core/rest",
                             :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
           "cljs.core/dotimes" {:description "Repeatedly executes `body` (presumably for side-effects) with `name` bound to\nintegers from 0 through `n`-1.",
                                :ns "cljs.core",
                                :name "dotimes",
                                :signature ["[[name n] & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/repeat"
                                          "cljs.core/for"
                                          "cljs.core/doseq"],
                                :full-name-encode "cljs.core_dotimes",
                                :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [668 680]},
                                :full-name "cljs.core/dotimes",
                                :clj-symbol "clojure.core/dotimes",
                                :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
           "clojure.zip/lefts" {:ns "clojure.zip",
                                :name "lefts",
                                :signature ["[loc]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip_lefts",
                                :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [87 90]},
                                :full-name "clojure.zip/lefts",
                                :clj-symbol "clojure.zip/lefts",
                                :docstring "Returns a seq of the left siblings of this loc"},
           "clojure.browser.dom/ensure-element" {:ns "clojure.browser.dom",
                                                 :name "ensure-element",
                                                 :signature ["[e]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom_ensure-element",
                                                 :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                          :repo "clojurescript",
                                                          :tag "r971",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [105
                                                                  110]},
                                                 :full-name "clojure.browser.dom/ensure-element",
                                                 :docstring "Coerce the argument to a dom element if possible."},
           "cljs.core/defmacro" {:ns "cljs.core",
                                 :name "defmacro",
                                 :signature ["[name doc-string? attr-map? [params*] body]"
                                             "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core_defmacro",
                                 :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                          :repo "clojure",
                                          :tag "clojure-1.3.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [405 449]},
                                 :full-name "cljs.core/defmacro",
                                 :clj-symbol "clojure.core/defmacro",
                                 :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
           "cljs.core/remove" {:description "Returns a lazy sequence of the items in `coll` for which `(pred item)` returns\nfalse.\n\n`pred` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                               :ns "cljs.core",
                               :name "remove",
                               :signature ["[pred]" "[pred coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/filter"],
                               :full-name-encode "cljs.core_remove",
                               :source {:code "(defn remove\n  [pred coll]\n  (filter (complement pred) coll))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1836 1840]},
                               :full-name "cljs.core/remove",
                               :clj-symbol "clojure.core/remove",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects."},
           "cljs.core/if-not" {:description "If `test` is false or nil, evaluates and returns `then`. Otherwise, evaluates\nand returns `else`. `else` defaults to nil if not provided.",
                               :ns "cljs.core",
                               :name "if-not",
                               :signature ["[test then]"
                                           "[test then else]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :related ["special/if"
                                         "cljs.core/when-not"],
                               :full-name-encode "cljs.core_if-not",
                               :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                        :repo "clojure",
                                        :tag "clojure-1.3.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [702 708]},
                               :full-name "cljs.core/if-not",
                               :clj-symbol "clojure.core/if-not",
                               :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
           "clojure.zip/path" {:ns "clojure.zip",
                               :name "path",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_path",
                               :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [82 85]},
                               :full-name "clojure.zip/path",
                               :clj-symbol "clojure.zip/path",
                               :docstring "Returns a seq of nodes leading to this loc"},
           "cljs.core/mapcat" {:description "Returns the result of applying `concat` to the result of applying `map` to `f`\nand `colls`.\n\nFunction `f` should return a collection.\n\nReturns a transducer when no collections are provided.",
                               :ns "cljs.core",
                               :name "mapcat",
                               :signature ["[f]" "[f & colls]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/map"
                                         "cljs.core/concat"],
                               :full-name-encode "cljs.core_mapcat",
                               :source {:code "(defn mapcat\n  ([f coll]\n    (flatten1 (map f coll)))\n  ([f coll & colls]\n    (flatten1 (apply map f coll colls))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1817 1823]},
                               :full-name "cljs.core/mapcat",
                               :clj-symbol "clojure.core/mapcat",
                               :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection."},
           "cljs.core/IWatchable" {:ns "cljs.core",
                                   :name "IWatchable",
                                   :type "protocol",
                                   :full-name-encode "cljs.core_IWatchable",
                                   :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [195 198]},
                                   :methods [{:name "-notify-watches",
                                              :signature ["[this oldval newval]"],
                                              :docstring nil}
                                             {:name "-add-watch",
                                              :signature ["[this key f]"],
                                              :docstring nil}
                                             {:name "-remove-watch",
                                              :signature ["[this key]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IWatchable",
                                   :history [["+" "0.0-927"]]},
           "clojure.zip/rightmost" {:ns "clojure.zip",
                                    :name "rightmost",
                                    :signature ["[loc]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip_rightmost",
                                    :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [142 148]},
                                    :full-name "clojure.zip/rightmost",
                                    :clj-symbol "clojure.zip/rightmost",
                                    :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
           "cljs.repl/load-file" {:ns "cljs.repl",
                                  :name "load-file",
                                  :type "function",
                                  :signature ["[repl-env f]"],
                                  :source {:code "(defn load-file\n  [repl-env f]\n  (binding [comp/*cljs-ns* 'cljs.user]\n    (let [res (if (= \\/ (first f)) f (io/resource f))]\n      (assert res (str \"Can't find \" f \" in classpath\"))\n      (load-stream repl-env f res))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [97 102]},
                                  :full-name "cljs.repl/load-file",
                                  :full-name-encode "cljs.repl_load-file",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/->" {:description "The thread-first macro \"threads\" an expression through several forms as the\nsecond item in a list.\n\nInserts `x` as the second item in the first form, making a list of it if it is\nnot a list already. If there are more forms, inserts the first form as the\nsecond item in second form, etc.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(-> x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x (d (a x b c)) y z)</pre></td></tr></tbody></table>",
                           :ns "cljs.core",
                           :name "->",
                           :signature ["[x & forms]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/->>"],
                           :full-name-encode "cljs.core_-GT",
                           :source {:code "(defmacro ->\n  ([x] x)\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n              (list form x)))\n  ([x form & more] `(-> (-> ~x ~form) ~@more)))",
                                    :repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1528 1538]},
                           :examples [{:id "19b460",
                                       :content "The first is arguably a bit more cumbersome to read than the second:\n\n```clj\n(first (.split (.replace (.toUpperCase \"a b c d\") \"A\" \"X\") \" \"))\n;;=> \"X\"\n\n(-> \"a b c d\"\n    .toUpperCase\n    (.replace \"A\" \"X\")\n    (.split \" \")\n    first)\n;;=> \"X\"\n```"}
                                      {:id "78ad8f",
                                       :content "It can also be useful for pulling values out of deeply-nested\ndata structures:\n\n```clj\n(def person\n  {:name \"Mark Volkmann\"\n   :address {:street \"644 Glen Summit\"\n             :city \"St. Charles\"\n             :state \"Missouri\"\n             :zip 63304}\n   :employer {:name \"Object Computing, Inc.\"\n              :address {:street \"12140 Woodcrest Dr.\"\n                        :city \"Creve Coeur\"\n                        :state \"Missouri\"\n                        :zip 63141}}})\n\n(-> person :employer :address :city)\n;;=> \"Creve Coeur\"\n```\n\nSame as above, but with more nesting:\n\n```clj\n(:city (:address (:employer person)))\n;;=> \"Creve Coeur\"\n```"}
                                      {:id "5fe621",
                                       :content "It can also help with arithmetic:\n\n```clj\n(def c 5)\n(-> c (+ 3) (/ 2) (- 1))\n;;=> 3\n```\n\nSame as above, but with more nesting:\n\n```clj\n(- (/ (+ c 3) 2) 1)\n;;=> 3\n```"}],
                           :full-name "cljs.core/->",
                           :clj-symbol "clojure.core/->",
                           :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
           "cljs.core/remove-all-methods" {:ns "cljs.core",
                                           :name "remove-all-methods",
                                           :signature ["[multifn]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_remove-all-methods",
                                           :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3526 3529]},
                                           :full-name "cljs.core/remove-all-methods",
                                           :clj-symbol "clojure.core/remove-all-methods",
                                           :docstring "Removes all of the methods of multimethod."},
           "clojure.string/replace-first" {:description "Replaces the first instance of `match` with `replacement` in `s`.\n\nThe options for match / replacement are:\n\n| match  | replacement |\n|--------|-------------|\n| string | string      |\n| regex  | string      |\n| regex  | function    |",
                                           :ns "clojure.string",
                                           :name "replace-first",
                                           :signature ["[s match replacement]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.string_replace-first",
                                           :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/clojure/string.cljs",
                                                    :lines [36 43]},
                                           :full-name "clojure.string/replace-first",
                                           :clj-symbol "clojure.string/replace-first",
                                           :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "clojure.browser.dom/get-value" {:ns "clojure.browser.dom",
                                            :name "get-value",
                                            :signature ["[e]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom_get-value",
                                            :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [129 132]},
                                            :full-name "clojure.browser.dom/get-value",
                                            :docstring "Get the value of an element."},
           "cljs.nodejs/process" {:ns "cljs.nodejs",
                                  :name "process",
                                  :type "var",
                                  :source {:code "(def process (js* \"process\"))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [8]},
                                  :full-name "cljs.nodejs/process",
                                  :full-name-encode "cljs.nodejs_process",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/not=" {:description "Returns the opposite of `=`.\n\nSame as `(not (= x y))`",
                             :ns "cljs.core",
                             :name "not=",
                             :signature ["[x]" "[x y]" "[x y & more]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/=" "cljs.core/not"],
                             :full-name-encode "cljs.core_notEQ",
                             :source {:code "(defn not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1432 1437]},
                             :full-name "cljs.core/not=",
                             :clj-symbol "clojure.core/not=",
                             :docstring "Same as (not (= obj1 obj2))"},
           "cljs.core/js-keys" {:description "Returns the keys for the JavaScript object `obj`.",
                                :ns "cljs.core",
                                :name "js-keys",
                                :signature ["[obj]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/keys"],
                                :full-name-encode "cljs.core_js-keys",
                                :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [632 635]},
                                :examples [{:id "5dd933",
                                            :content "```clj\n(js-keys #js {:foo 1 :bar 2})\n;;=> #js [\"foo\" \"bar\"]\n```"}],
                                :full-name "cljs.core/js-keys"},
           "cljs.repl.browser/browser-eval" {:ns "cljs.repl.browser",
                                             :name "browser-eval",
                                             :signature ["[form]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser_browser-eval",
                                             :source {:code "(defn browser-eval\n  [form]\n  (let [return-value (promise)]\n    (send-for-eval form\n                   (fn [val] (deliver return-value val)))\n    (let [ret @return-value]\n      (try (read-string ret)\n           (catch Exception e\n             {:status :error\n              :value (str \"Could not read return value: \" ret)})))))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [258 273]},
                                             :full-name "cljs.repl.browser/browser-eval",
                                             :docstring "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured."},
           "clojure.zip/seq-zip" {:ns "clojure.zip",
                                  :name "seq-zip",
                                  :signature ["[root]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_seq-zip",
                                  :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [34 40]},
                                  :full-name "clojure.zip/seq-zip",
                                  :clj-symbol "clojure.zip/seq-zip",
                                  :docstring "Returns a zipper for nested sequences, given a root sequence"},
           "cljs.repl.browser/server-state" {:ns "cljs.repl.browser",
                                             :name "server-state",
                                             :type "var",
                                             :source {:code "(defonce server-state (atom {:socket nil\n                             :connection nil\n                             :promised-conn nil\n                             :return-value-fn nil\n                             :client-js nil}))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [24 28]},
                                             :full-name "cljs.repl.browser/server-state",
                                             :full-name-encode "cljs.repl.browser_server-state",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/IVector" {:ns "cljs.core",
                                :name "IVector",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IVector",
                                :source {:code "(defprotocol IVector\n  (-assoc-n [coll n val]))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [156 157]},
                                :methods [{:name "-assoc-n",
                                           :signature ["[coll n val]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IVector",
                                :clj-symbol "clojure.lang/IPersistentVector"},
           "cljs.core/empty" {:description "Returns an empty collection of the same category as `coll`.\n\nReturns nil if `coll` is nil.",
                              :ns "cljs.core",
                              :name "empty",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/not-empty"],
                              :full-name-encode "cljs.core_empty",
                              :source {:code "(defn empty\n  [coll]\n  (-empty coll))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [493 496]},
                              :full-name "cljs.core/empty",
                              :clj-symbol "clojure.core/empty",
                              :docstring "Returns an empty collection of the same category as coll, or nil"},
           "cljs.core/re-matches" {:description "Returns the result of `(re-find re s)` if `re` fully matches `s`.",
                                   :ns "cljs.core",
                                   :name "re-matches",
                                   :signature ["[re s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_re-matches",
                                   :source {:code "(defn re-matches\n  [re s]\n  (let [matches (.exec re s)]\n    (when (= (first matches) s)\n      (if (= (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2809 2816]},
                                   :full-name "cljs.core/re-matches",
                                   :clj-symbol "clojure.core/re-matches",
                                   :docstring "Returns the result of (re-find re s) if re fully matches s."},
           "syntax/meta" {:description "Attaches metadata to the following form.\n\nMetadata is a map.  It can be attached to a collection or symbol.\n\nIf the provided metadata is a keyword, the resulting metadata will be a map\ncontaining that keyword with an associated value `true`.\n\nIf the provided metadata is a string or symbol, the resulting metadata will be\na map associating `:tag` with the value of the string or evaluated symbol.",
                          :ns "syntax",
                          :name "meta",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :related ["cljs.core/meta"
                                    "cljs.core/with-meta"
                                    "cljs.core/vary-meta"
                                    "cljs.core/alter-meta!"],
                          :full-name-encode "syntax_meta",
                          :source {:repo "clojure",
                                   :tag "clojure-1.3.0",
                                   :filename "src/jvm/clojure/lang/LispReader.java",
                                   :lines [nil]},
                          :syntax-form "^",
                          :examples [{:id "5b8fec",
                                      :content "Attach metadata to a collection:\n\n```clj\n^:foo [1 2 3]\n;;=> [1 2 3]\n```\n\nView the resulting metadata:\n\n```clj\n(meta ^:foo [1 2 3])\n;;=> {:foo true}\n\n(meta ^{:foo \"bar\"} [1 2 3])\n;;=> {:foo \"bar\"}\n\n(meta ^\"foo\" [1 2 3])\n;;=> {:tag \"foo\"}\n\n(def foo 1)\n(meta ^foo [1 2 3])\n;;=> {:tag 1}\n```\n\nChain metadata:\n\n```clj\n(meta ^:foo ^\"foo\" [1 2 3])\n;;=> {:foo true, :tag \"foo\"}\n```"}],
                          :full-name "syntax/meta",
                          :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                             :name "DOMBuilder",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.dom_DOMBuilder",
                                             :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/cljs/clojure/browser/dom.cljs",
                                                      :lines [16 17]},
                                             :methods [{:name "-element",
                                                        :signature ["[this]"
                                                                    "[this attrs-or-children]"
                                                                    "[this attrs children]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.dom/DOMBuilder",
                                             :history [["+" "0.0-927"]]},
           "syntax/regex" {:description "Signifies a regular expression. Represented as JavaScript regular expressions.\n\nAn inline modifier can be included at the beginning of the regex:\n\n|  modifier          | ClojureScript | JavaScript |\n|--------------------|---------------|------------|\n|  global match      | N/A           | `/foo/g`   |\n|  case-insensitive  | `#\"(?i)foo\"`  | `/foo/i`   |\n|  multi-line        | `#\"(?m)f.*o\"` | `/f.*o/m`  |\n\nGlobal matches (i.e. multiple matches per line) can be achieved using `re-seq`.",
                           :ns "syntax",
                           :name "regex",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["cljs.core/re-pattern"
                                     "cljs.core/re-find"
                                     "cljs.core/re-seq"
                                     "cljs.core/re-matches"],
                           :full-name-encode "syntax_regex",
                           :source {:repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/jvm/clojure/lang/LispReader.java",
                                    :lines [nil]},
                           :syntax-form "#\"\"",
                           :examples [{:id "dacf80",
                                       :content "```clj\n#\"foo\"\n;;=> #\"foo\"\n\n(re-seq #\"foo\" \"FOO BAR foo bar\")\n;;=> (\"foo\")\n```\n\nCase-insensitive matching:\n\n```clj\n#\"(?i)foo\"\n;;=> #\"foo\"\n\n(re-seq #\"(?i)foo\" \"FOO BAR foo bar\")\n;;=> (\"FOO\" \"foo\")\n```"}],
                           :full-name "syntax/regex",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/extend-type" {:ns "cljs.core",
                                    :name "extend-type",
                                    :signature ["[tsym & impls]"],
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_extend-type",
                                    :source {:code "(defmacro extend-type [tsym & impls]\n  (let [resolve #(let [ret (:name (cljs.compiler/resolve-var (dissoc &env :locals) %))]\n                   (assert ret (str \"Can't resolve: \" %))\n                   ret)\n        impl-map (loop [ret {} s impls]\n                   (if (seq s)\n                     (recur (assoc ret (first s) (take-while seq? (next s)))\n                            (drop-while seq? (next s)))\n                     ret))]\n    (if (base-type tsym)\n      (let [t (base-type tsym)\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n                                 pfn-prefix (subs (str psym) 0 (clojure.core/inc (.lastIndexOf (str psym) \".\")))]\n                             (cons `(aset ~psym ~t true)\n                                   (map (fn [[f & meths]]\n                                          `(aset ~(symbol (str pfn-prefix f)) ~t (fn* ~@meths)))\n                                        sigs))))]\n        `(do ~@(mapcat assign-impls impl-map)))\n      (let [t (resolve tsym)\n            prototype-prefix (str t \".prototype.\")\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n                                 pprefix (protocol-prefix psym)]\n                             (if (= p 'Object)\n                               (let [adapt-params (fn [[sig & body]]\n                                                    (let [[tname & args] sig]\n                                                      (list (with-meta (vec args) (meta sig))\n                                                            (list* 'this-as tname body))))]\n                                 (map (fn [[f & meths]]\n                                        `(set! ~(symbol (str prototype-prefix f)) (fn* ~@(map adapt-params meths))))\n                                      sigs))\n                               (cons `(set! ~(symbol (str prototype-prefix pprefix)) true)\n                                     (map (fn [[f & meths]]\n                                            (let [ifn? (= psym 'cljs.core.IFn)\n                                                  pf (if ifn?\n                                                       (str prototype-prefix 'call)\n                                                       (str prototype-prefix pprefix f))\n                                                  adapt-params (fn [[[tname :as args] & body]]\n                                                                 `(~args\n                                                                   (~'js* \"~{} = this\" ~tname)\n                                                                   ~@body))\n                                                  meths (if ifn?\n                                                          (map adapt-params meths)\n                                                          meths)]\n                                              `(set! ~(symbol pf) (fn* ~@meths))))\n                                          sigs)))))]\n        `(do ~@(mapcat assign-impls impl-map))))))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [210 257]},
                                    :full-name "cljs.core/extend-type",
                                    :clj-symbol "clojure.core/extend-type"},
           "cljs.core/ISeqable" {:ns "cljs.core",
                                 :name "ISeqable",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_ISeqable",
                                 :source {:code "(defprotocol ISeqable\n  (-seq [o]))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [180 181]},
                                 :methods [{:name "-seq",
                                            :signature ["[o]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/ISeqable",
                                 :clj-symbol "clojure.lang/Seqable"},
           "cljs.core/assoc" {:description "assoc(iate)\n\nWhen applied to a map, returns a new map that contains the mapping of key(s) to\nval(s).\n\nHas no effect on the map type (hashed/sorted).\n\nWhen applied to a vector, returns a new vector that contains value `v` at index\n`k`.",
                              :ns "cljs.core",
                              :name "assoc",
                              :signature ["[coll k v]"
                                          "[coll k v & kvs]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/assoc-in"
                                        "cljs.core/dissoc"
                                        "cljs.core/merge"],
                              :full-name-encode "cljs.core_assoc",
                              :source {:code "(defn assoc\n  ([coll k v]\n     (-assoc coll k v))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [521 532]},
                              :examples [{:id "2fa7e0",
                                          :content "```clj\n(def my-map {:foo 1})\n\n(assoc my-map :foo 2)\n;;=> {:foo 2}\n\n(assoc my-map :bar 2)\n;;=> {:foo 1 :bar 2}\n\n(assoc my-map :a 3 :b 4 :c 5 :d 6)\n;;=> {:foo 1 :a 3 :b 4 :c 5 :d 6}\n\n;; you must pass a value for every key\n(assoc my-map :foo)\n;;=> WARNING: Wrong number of args (2) passed to cljs.core/assoc\n```"}
                                         {:id "c06eac",
                                          :content "```clj\n(def my-vec [1 2 3])\n\n(assoc my-vec 0 \"foo\")\n;;=> [\"foo\" 2 3]\n\n(assoc my-vec 3 \"foo\")\n;;=> Error: Index 3 out of bounds  [0,0]\n```"}],
                              :full-name "cljs.core/assoc",
                              :clj-symbol "clojure.core/assoc",
                              :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
           "clojure.browser.repl/xpc-connection" {:ns "clojure.browser.repl",
                                                  :name "xpc-connection",
                                                  :type "var",
                                                  :source {:code "(def xpc-connection (atom nil))",
                                                           :repo "clojurescript",
                                                           :tag "r971",
                                                           :filename "src/cljs/clojure/browser/repl.cljs",
                                                           :lines [21]},
                                                  :full-name "clojure.browser.repl/xpc-connection",
                                                  :full-name-encode "clojure.browser.repl_xpc-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                          :name "IDerefWithTimeout",
                                          :type "protocol",
                                          :full-name-encode "cljs.core_IDerefWithTimeout",
                                          :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [162 163]},
                                          :methods [{:name "-deref-with-timeout",
                                                     :signature ["[o msec timeout-val]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IDerefWithTimeout",
                                          :history [["+" "0.0-927"]]},
           "syntax/eval" {:ns "syntax",
                          :name "eval",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :full-name-encode "syntax_eval",
                          :source {:repo "clojure",
                                   :tag "clojure-1.3.0",
                                   :filename "src/jvm/clojure/lang/LispReader.java",
                                   :lines [nil]},
                          :syntax-form "#=",
                          :full-name "syntax/eval",
                          :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L113"},
           "clojure.browser.repl/start-evaluator" {:ns "clojure.browser.repl",
                                                   :name "start-evaluator",
                                                   :signature ["[url]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.repl_start-evaluator",
                                                   :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText e/currentTarget\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                            :repo "clojurescript",
                                                            :tag "r971",
                                                            :filename "src/cljs/clojure/browser/repl.cljs",
                                                            :lines [60
                                                                    88]},
                                                   :full-name "clojure.browser.repl/start-evaluator",
                                                   :docstring "Start the REPL server connection."},
           "cljs.repl.browser/send-for-eval" {:ns "cljs.repl.browser",
                                              :name "send-for-eval",
                                              :signature ["[form return-value-fn]"
                                                          "[conn form return-value-fn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser_send-for-eval",
                                              :source {:code "(defn send-for-eval\n  ([form return-value-fn]\n     (send-for-eval @(connection) form return-value-fn))\n  ([conn form return-value-fn]\n     (do (set-return-value-fn return-value-fn)\n         (send-and-close conn 200 form \"text/javascript\"))))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [99 107]},
                                              :full-name "cljs.repl.browser/send-for-eval",
                                              :docstring "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received."},
           "clojure.browser.event/unlisten" {:ns "clojure.browser.event",
                                             :name "unlisten",
                                             :type "function",
                                             :signature ["[src type fn]"
                                                         "[src type fn capture?]"],
                                             :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (goog.events/unlisten src\n                           (get (event-types src) type type)\n                           fn\n                           capture?)))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/cljs/clojure/browser/event.cljs",
                                                      :lines [62 69]},
                                             :full-name "clojure.browser.event/unlisten",
                                             :full-name-encode "clojure.browser.event_unlisten",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.browser/constrain-order" {:ns "cljs.repl.browser",
                                                :name "constrain-order",
                                                :signature ["[order f]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser_constrain-order",
                                                :source {:code "(defn constrain-order\n  [order f]\n  (send-off ordering add-in-order order f)\n  (send-off ordering run-in-order))",
                                                         :repo "clojurescript",
                                                         :tag "r971",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [214
                                                                 219]},
                                                :full-name "cljs.repl.browser/constrain-order",
                                                :docstring "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order."},
           "cljs.core/fnil" {:description "Takes a function `f`, and returns a function that calls `f`, replacing a nil\nfirst argument to `f` with the supplied value `x`. Higher arity versions can\nreplace arguments in the second and third positions (`y`, `z`).\n\nNote that the function `f` can take any number of arguments, not just the one(s)\nbeing nil-patched.",
                             :ns "cljs.core",
                             :name "fnil",
                             :signature ["[f x]"
                                         "[f x y]"
                                         "[f x y z]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_fnil",
                             :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1539 1560]},
                             :full-name "cljs.core/fnil",
                             :clj-symbol "clojure.core/fnil",
                             :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
           "cljs.core/this-as" {:ns "cljs.core",
                                :name "this-as",
                                :signature ["[name & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_this-as",
                                :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (~'js* \"this\")]\n     ~@body))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [204 208]},
                                :full-name "cljs.core/this-as",
                                :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."},
           "cljs.repl.rhino/rhino-eval" {:ns "cljs.repl.rhino",
                                         :name "rhino-eval",
                                         :type "function",
                                         :signature ["[repl-env filename line js]"],
                                         :source {:code "(defn rhino-eval\n  [repl-env filename line js]\n  (try\n    (let [linenum (or line Integer/MIN_VALUE)]\n      {:status :success\n       :value (eval-result (-eval js repl-env filename linenum))})\n    (catch Throwable ex\n      {:status :exception\n       :value (.toString ex)\n       :stacktrace (stacktrace ex)})))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [57 66]},
                                         :full-name "cljs.repl.rhino/rhino-eval",
                                         :full-name-encode "cljs.repl.rhino_rhino-eval",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueueSeq" {:ns "cljs.core",
                                           :name "PersistentQueueSeq",
                                           :type "type",
                                           :signature ["[meta front rear]"],
                                           :source {:code "(deftype PersistentQueueSeq [meta front rear]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (-first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2112 2142]},
                                           :full-name "cljs.core/PersistentQueueSeq",
                                           :full-name-encode "cljs.core_PersistentQueueSeq",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/counted?" {:description "Returns true if `x` executes `count` in constant time, false otherwise.\n\nLists, maps, sets, strings, and vectors can be counted in constant time.",
                                 :ns "cljs.core",
                                 :name "counted?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_countedQMARK",
                                 :source {:code "(defn counted?\n  [x] (satisfies? ICounted x))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [613 615]},
                                 :full-name "cljs.core/counted?",
                                 :clj-symbol "clojure.core/counted?",
                                 :docstring "Returns true if coll implements count in constant time"},
           "cljs.repl.browser/read-headers" {:ns "cljs.repl.browser",
                                             :name "read-headers",
                                             :type "function",
                                             :signature ["[rdr]"],
                                             :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [135 140]},
                                             :full-name "cljs.repl.browser/read-headers",
                                             :full-name-encode "cljs.repl.browser_read-headers",
                                             :history [["+" "0.0-927"]]},
           "clojure.string/trimr" {:description "Removes whitespace from the right side of string.",
                                   :ns "clojure.string",
                                   :name "trimr",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string_trimr",
                                   :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [116 119]},
                                   :full-name "clojure.string/trimr",
                                   :clj-symbol "clojure.string/trimr",
                                   :docstring "Removes whitespace from the right side of string."},
           "cljs.core/force" {:ns "cljs.core",
                              :name "force",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_force",
                              :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3204 3209]},
                              :full-name "cljs.core/force",
                              :clj-symbol "clojure.core/force",
                              :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
           "cljs.core/compare-and-set!" {:description "Atomically sets the value of atom `a` to `newval` if and only if the current\nvalue of the atom is identical to `oldval`.\n\nReturns true if set happened, false otherwise.",
                                         :ns "cljs.core",
                                         :name "compare-and-set!",
                                         :signature ["[a oldval newval]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :related ["cljs.core/atom"
                                                   "cljs.core/reset!"
                                                   "cljs.core/swap!"],
                                         :full-name-encode "cljs.core_compare-and-setBANG",
                                         :source {:code "(defn compare-and-set!\n  [a oldval newval]\n  (if (= a.state oldval)\n    (do (reset! a newval) true)\n    false))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3083 3090]},
                                         :full-name "cljs.core/compare-and-set!",
                                         :clj-symbol "clojure.core/compare-and-set!",
                                         :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is identical to oldval. Returns true if\nset happened, else false."},
           "cljs.core/set?" {:description "Returns true if `x` is a set, false otherwise.",
                             :ns "cljs.core",
                             :name "set?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/set"],
                             :full-name-encode "cljs.core_setQMARK",
                             :source {:code "(defn set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [598 603]},
                             :full-name "cljs.core/set?",
                             :clj-symbol "clojure.core/set?",
                             :docstring "Returns true if x satisfies ISet"},
           "syntax/unquote-splicing" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nIntended for use inside a syntax-quote.\n\nForces evaluation of the following form and expands its children into the\nparent form.",
                                      :ns "syntax",
                                      :name "unquote-splicing",
                                      :history [["+" "0.0-927"]],
                                      :type "syntax",
                                      :related ["syntax/syntax-quote"
                                                "syntax/unquote"],
                                      :full-name-encode "syntax_unquote-splicing",
                                      :source {:repo "clojure",
                                               :tag "clojure-1.3.0",
                                               :filename "src/jvm/clojure/lang/LispReader.java",
                                               :lines [nil]},
                                      :syntax-form "~@",
                                      :examples [{:id "e6f73d",
                                                  :content "```clj\n(def foo '[a b c])\n`(~@foo)\n;;=> (a b c)\n```"}],
                                      :full-name "syntax/unquote-splicing",
                                      :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.string/escape" {:description "Return a new string, using `cmap` to escape each character `ch` from `s` as follows:\n\nIf `(cmap ch)` is nil, append ch to the new string.\n\nIf `(cmap ch)` is non-nil, append `(str (cmap ch))` instead.",
                                    :ns "clojure.string",
                                    :name "escape",
                                    :signature ["[s cmap]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string_escape",
                                    :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (gstring/StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [144 160]},
                                    :full-name "clojure.string/escape",
                                    :clj-symbol "clojure.string/escape",
                                    :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
           "cljs.core/remove-watch" {:description "Removes a watch function identified by `key` from atom `a`.  The function must\nhave originally been set by `add-watch`.",
                                     :ns "cljs.core",
                                     :name "remove-watch",
                                     :signature ["[a key]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/add-watch"],
                                     :full-name-encode "cljs.core_remove-watch",
                                     :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3152 3157]},
                                     :examples [{:id "70044a",
                                                 :content "```clj\n(def a (atom {}))\n\n(add-watch a :logger\n  (fn [_key _atom old-state new-state]\n    (println \"old:\" old-state)\n    (println \"new:\" new-state)))\n\n(swap! a assoc :foo \"bar\")\n;;=> will print the following:\n;; old: {}\n;; new: {:foo \"bar\"}\n\n(remove-watch a :logger)\n\n(swap! a assoc :foo 3)\n;;=> nothing will be printed...\n```"}],
                                     :full-name "cljs.core/remove-watch",
                                     :clj-symbol "clojure.core/remove-watch",
                                     :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
           "cljs.core/IMultiFn" {:ns "cljs.core",
                                 :name "IMultiFn",
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IMultiFn",
                                 :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-dispatch [mf args]))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3453 3461]},
                                 :methods [{:name "-reset",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-add-method",
                                            :signature ["[mf dispatch-val method]"],
                                            :docstring nil}
                                           {:name "-remove-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-prefer-method",
                                            :signature ["[mf dispatch-val dispatch-val-y]"],
                                            :docstring nil}
                                           {:name "-get-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-methods",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-prefers",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-dispatch",
                                            :signature ["[mf args]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IMultiFn",
                                 :history [["+" "0.0-927"]]},
           "clojure.zip/end?" {:ns "clojure.zip",
                               :name "end?",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_endQMARK",
                               :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [232 235]},
                               :full-name "clojure.zip/end?",
                               :clj-symbol "clojure.zip/end?",
                               :docstring "Returns true if loc represents the end of a depth-first walk"},
           "clojure.set/superset?" {:description "Returns true if `a` is a superset of `b`, false otherwise.\n\nIn other words, returns true if `a` contains all the elements of `b`.",
                                    :ns "clojure.set",
                                    :name "superset?",
                                    :signature ["[a b]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/set"
                                              "cljs.core/set?"
                                              "clojure.set/subset?"],
                                    :full-name-encode "clojure.set_supersetQMARK",
                                    :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/clojure/set.cljs",
                                             :lines [138 142]},
                                    :full-name "clojure.set/superset?",
                                    :clj-symbol "clojure.set/superset?",
                                    :docstring "Is set1 a superset of set2?"},
           "cljs.repl/repl" {:ns "cljs.repl",
                             :name "repl",
                             :signature ["[repl-env & {:keys [verbose warn-on-undeclared]}]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.repl_repl",
                             :source {:code "(defn repl\n  [repl-env & {:keys [verbose warn-on-undeclared]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (= (first form) 'in-ns))\n           (do (set! comp/*cljs-ns* (second (second form))) (newline) (recur))\n           \n           (and (seq? form) ('#{load-file clojure.core/load-file} (first form)))\n           (do (load-file repl-env (second form)) (newline) (recur))\n           \n           (and (seq? form) ('#{load-namespace} (first form)))\n           (do (load-namespace repl-env (second form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/clj/cljs/repl.clj",
                                      :lines [133 162]},
                             :full-name "cljs.repl/repl",
                             :docstring "Note - repl will reload core.cljs every time, even if supplied old repl-env"},
           "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                              :name "IConnection",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.net_IConnection",
                                              :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [32 44]},
                                              :methods [{:name "connect",
                                                         :signature ["[this]"
                                                                     "[this opt1]"
                                                                     "[this opt1 opt2]"
                                                                     "[this opt1 opt2 opt3]"],
                                                         :docstring nil}
                                                        {:name "transmit",
                                                         :signature ["[this opt]"
                                                                     "[this opt opt2]"
                                                                     "[this opt opt2 opt3]"
                                                                     "[this opt opt2 opt3 opt4]"
                                                                     "[this opt opt2 opt3 opt4 opt5]"],
                                                         :docstring nil}
                                                        {:name "close",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.net/IConnection",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/let" {:description "Binds expressions to symbols and makes those symbols available only within\n`body`.\n\n`bindings` should be a vector with an even number of forms, ie: `[a1 b1, a2 b2,\na3 b3]`. The first item in a pair (the `a`s) should be a symbol that is assigned\nthe evaluation of the second item (the `b`s). These symbols (the `a`s) are then\navailable within `body` (and not outside of `body`).\n\nAnother way to think about this is that the binding symbols in `let` are like\nlocal `def`s that are only available within `let`'s scope.\n\nIn addition to direct symbol binding, `let` supports a destructuring syntax to\n\"break apart\" collections into multiple symbols. This destructuring syntax is\nlike it's own [mini-language] and allows for succinct code.\n\n`let` is a wrapper over one of ClojureScript's [special forms] and is a\nfundamental building block of the language. Many macros rely on `let`s binding\nsyntax and scope rules.\n\n[mini-language]:http://blog.jayfields.com/2010/07/clojure-destructuring.html\n[special forms]:http://clojure.org/special_forms",
                            :ns "cljs.core",
                            :name "let",
                            :signature ["[bindings & body]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/letfn"
                                      "cljs.core/if-let"],
                            :full-name-encode "cljs.core_let",
                            :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args let\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                     :repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [3953 3964]},
                            :extra-sources ({:code "(def\n  ^{:macro true\n    :added \"1.0\"}\n  let (fn* let [&form &env & decl] (cons 'let* decl)))",
                                             :repo "clojure",
                                             :tag "clojure-1.3.0",
                                             :filename "src/clj/clojure/core.clj",
                                             :lines [32 35]}),
                            :full-name "cljs.core/let",
                            :clj-symbol "clojure.core/let",
                            :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
           "cljs.core/dorun" {:description "Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.\n\n`dorun` walks through the successive `next`s of the sequence and returns nil.",
                              :ns "cljs.core",
                              :name "dorun",
                              :signature ["[coll]" "[n coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/doall"],
                              :full-name-encode "cljs.core_dorun",
                              :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2780 2791]},
                              :full-name "cljs.core/dorun",
                              :clj-symbol "clojure.core/dorun",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
           "cljs.core/pr-str" {:ns "cljs.core",
                               :name "pr-str",
                               :signature ["[& objs]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_pr-str",
                               :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2912 2915]},
                               :full-name "cljs.core/pr-str",
                               :clj-symbol "clojure.core/pr-str",
                               :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintable."},
           "cljs.core/IPrintable" {:ns "cljs.core",
                                   :name "IPrintable",
                                   :type "protocol",
                                   :full-name-encode "cljs.core_IPrintable",
                                   :source {:code "(defprotocol IPrintable\n  (-pr-seq [o opts]))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [189 190]},
                                   :methods [{:name "-pr-seq",
                                              :signature ["[o opts]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IPrintable",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/defprotocol" {:ns "cljs.core",
                                    :name "defprotocol",
                                    :signature ["[psym & doc+methods]"],
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_defprotocol",
                                    :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (string? (first doc+methods)) (next doc+methods) doc+methods)\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         ((or\n                           (aget ~(fqn fname) (goog.typeOf ~(first sig)))\n                           (aget ~(fqn fname) \"_\")\n                           (throw (missing-protocol\n                                    ~(str psym \".\" fname) ~(first sig))))\n                          ~@sig))))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (str prefix (name fname)))]\n                   `(defn ~fname ~@(map #(expand-sig fname slot %) sigs))))]\n    `(do\n       (def ~psym (~'js* \"{}\"))\n       ~@(map method methods))))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [395 417]},
                                    :full-name "cljs.core/defprotocol",
                                    :clj-symbol "clojure.core/defprotocol"},
           "cljs.core/assert" {:description "Evaluates expression `expr` and throws an exception if it does not evaluate to\nlogical true.  Exception will include `message` if given.\n\nReturns `nil`.",
                               :ns "cljs.core",
                               :name "assert",
                               :signature ["[expr]" "[expr message]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core_assert",
                               :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [531 543]},
                               :extra-sources ({:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" (pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x))))))))",
                                                :repo "clojure",
                                                :tag "clojure-1.3.0",
                                                :filename "src/clj/clojure/core.clj",
                                                :lines [4222 4233]}),
                               :examples [{:id "1dc16f",
                                           :content "```clj\n(assert true)\n;;=> nil\n\n(assert false)\n;;=> Uncaught Error: Assert failed: false\n\n(assert (= 1 2) \"1 is not 2\")\n;;=> Uncaught Error: Assert failed: 1 is not 2\n;;   (= 1 2)\n```"}],
                               :full-name "cljs.core/assert",
                               :clj-symbol "clojure.core/assert",
                               :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
           "cljs.core/declare" {:description "Uses `def` to establish symbols of `names` with no bindings.\n\nUseful for making forward declarations.",
                                :ns "cljs.core",
                                :name "declare",
                                :signature ["[& names]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["special/def"],
                                :full-name-encode "cljs.core_declare",
                                :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                         :repo "clojure",
                                         :tag "clojure-1.3.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [2665 2668]},
                                :examples [{:id "5a2dc2",
                                            :content "```clj\na\n;; WARNING: Use of undeclared Var\n\n(declare a)\na\n;;=> nil\n```"}],
                                :full-name "cljs.core/declare",
                                :clj-symbol "clojure.core/declare",
                                :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
           "cljs.core/fn?" {:description "Returns true if `f` is a function, false otherwise.",
                            :ns "cljs.core",
                            :name "fn?",
                            :signature ["[f]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/ifn?"],
                            :full-name-encode "cljs.core_fnQMARK",
                            :source {:code "(defn fn? [f]\n  (goog/isFunction f))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [684 685]},
                            :full-name "cljs.core/fn?",
                            :clj-symbol "clojure.core/fn?"},
           "cljs.core/associative?" {:description "Returns true if `coll` implements the `IAssociative` protocol, false otherwise.\n\nMaps and vectors are associative.",
                                     :ns "cljs.core",
                                     :name "associative?",
                                     :signature ["[coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_associativeQMARK",
                                     :source {:code "(defn associative?\n  [x] (satisfies? IAssociative x))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [605 607]},
                                     :examples [{:id "29a37f",
                                                 :content "```clj\n(associative? [1 2 3])\n;;=> true\n\n(associative? {:a 1 :b 2})\n;;=> true\n\n(associative? #{1 2 3})\n;;=> false\n\n(associative? '(1 2 3))\n;;=> false\n```"}],
                                     :full-name "cljs.core/associative?",
                                     :clj-symbol "clojure.core/associative?",
                                     :docstring "Returns true if coll implements Associative"},
           "cljs.repl.rhino/load-javascript" {:ns "cljs.repl.rhino",
                                              :name "load-javascript",
                                              :type "function",
                                              :signature ["[repl-env ns url]"],
                                              :source {:code "(defn load-javascript [repl-env ns url]\n  (let [missing (remove #(contains? @loaded-libs %) ns)]\n    (when (seq missing)\n      (do (try \n            (-eval (io/reader url) repl-env (.toString url) 1)\n            ;; TODO: don't show errors for goog/base.js line number 105\n            (catch Throwable ex (println (.getMessage ex))))\n          (swap! loaded-libs (partial apply conj) missing)))))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/clj/cljs/repl/rhino.clj",
                                                       :lines [86 93]},
                                              :full-name "cljs.repl.rhino/load-javascript",
                                              :full-name-encode "cljs.repl.rhino_load-javascript",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/list*" {:description "Creates a new list containing the items prepended to the rest, the last of which\nwill be treated as a sequence.",
                              :ns "cljs.core",
                              :name "list*",
                              :signature ["[args]"
                                          "[a args]"
                                          "[a b args]"
                                          "[a b c args]"
                                          "[a b c d & more]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/list"],
                              :full-name-encode "cljs.core_listSTAR",
                              :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1366 1374]},
                              :full-name "cljs.core/list*",
                              :clj-symbol "clojure.core/list*",
                              :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
           "cljs.core/reduce" {:description "`f` should be a function of 2 arguments. If `val` is not supplied, returns the\nresult of applying `f` to the first 2 items in `coll`, then applying `f` to that\nresult and the 3rd item, etc.\n\nIf `coll` contains no items, `f` must accept no arguments as well, and `reduce`\nreturns the result of calling `f` with no arguments.\n\nIf `coll` has only 1 item, it is returned and `f` is not called.\n\nIf `val` is supplied, returns the result of applying `f` to `val` and the first\nitem in `coll`, then applying `f` to that result and the 2nd item, etc.\n\nIf `coll` contains no items, returns `val` and `f` is not called.",
                               :ns "cljs.core",
                               :name "reduce",
                               :signature ["[f coll]" "[f val coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/reductions"
                                         "cljs.core/apply"
                                         "cljs.core/frequencies"],
                               :full-name-encode "cljs.core_reduce",
                               :source {:code "(defn reduce\n  ([f coll]\n     (-reduce coll f))\n  ([f val coll]\n     (-reduce coll f val)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [775 788]},
                               :full-name "cljs.core/reduce",
                               :clj-symbol "clojure.core/reduce",
                               :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
           "clojure.browser.event/has-listener" {:ns "clojure.browser.event",
                                                 :name "has-listener",
                                                 :type "function",
                                                 :signature ["[obj opt_type opt_capture]"],
                                                 :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                          :repo "clojurescript",
                                                          :tag "r971",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [94]},
                                                 :full-name "clojure.browser.event/has-listener",
                                                 :full-name-encode "clojure.browser.event_has-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/compare" {:description "Comparator.\n\nReturns a negative number, zero, or a positive number when `x` is logically\n\"less than\", \"equal to\", or \"greater than\" `y`.\n\nUses `IComparable` if available and `google.array.defaultCompare` for objects of\nthe same type. nil is treated as a special case and is always less than any\nother object.",
                                :ns "cljs.core",
                                :name "compare",
                                :signature ["[x y]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/sort-by"
                                          "cljs.core/sorted-set-by"
                                          "cljs.core/sorted-map-by"],
                                :full-name-encode "cljs.core_compare",
                                :source {:code "(defn compare\n  [x y] (garray/defaultCompare x y))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [730 734]},
                                :examples [{:id "e13fa0",
                                            :content "```clj\n(compare 10 12)\n;;=> -1\n\n(compare 12 10)\n;;=> 1\n\n(compare 10 10)\n;;=> 0\n\n(compare 10 nil)\n;;=>  1\n\n(compare 10 (list 1 2 3))\n;; Error: compare on non-nil objects of different types\n```"}],
                                :full-name "cljs.core/compare",
                                :clj-symbol "clojure.core/compare",
                                :docstring "Comparator. Returns a negative number, zero, or a positive number\nwhen x is logically 'less than', 'equal to', or 'greater than'\ny. Uses google.array.defaultCompare."},
           "cljs.core/contains?" {:description "Returns true if `k` is present in `coll`, otherwise returns false.\n\nNote that for numerically indexed collections like vectors and arrays, this\ntests if the numeric key is within the range of indexes.\n\n`contains?` operates in constant or logarithmic time; it will not perform a\nlinear search for a value.",
                                  :ns "cljs.core",
                                  :name "contains?",
                                  :signature ["[coll k]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/some"
                                            "cljs.core/get"],
                                  :full-name-encode "cljs.core_containsQMARK",
                                  :source {:code "(defn contains?\n  [coll v]\n  (if (identical? (-lookup coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [693 702]},
                                  :full-name "cljs.core/contains?",
                                  :clj-symbol "clojure.core/contains?",
                                  :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
           "cljs.core/prefer-method" {:ns "cljs.core",
                                      :name "prefer-method",
                                      :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_prefer-method",
                                      :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3536 3540]},
                                      :full-name "cljs.core/prefer-method",
                                      :clj-symbol "clojure.core/prefer-method",
                                      :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
           "cljs.core/array-seq" {:description "Creates a `seq` from a JavaScript array, starting at index `i` if given.",
                                  :ns "cljs.core",
                                  :name "array-seq",
                                  :signature ["[array]" "[array i]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_array-seq",
                                  :source {:code "(defn array-seq [array i]\n  (prim-seq array i))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [375 376]},
                                  :examples [{:id "9ef6de",
                                              :content "```clj\n(array-seq #js [1 2 3])\n;;=> (1 2 3)\n\n(array-seq #js [1 2 3] 1)\n;;=> (2 3)\n```"}],
                                  :full-name "cljs.core/array-seq"},
           "cljs.repl.browser/create-client-js-file" {:ns "cljs.repl.browser",
                                                      :name "create-client-js-file",
                                                      :type "function",
                                                      :signature ["[opts file-path]"],
                                                      :source {:code "(defn create-client-js-file [opts file-path]\n  (let [file (io/file file-path)]\n    (when (not (.exists file))\n      (spit file (compile-client-js opts)))\n    file))",
                                                               :repo "clojurescript",
                                                               :tag "r971",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [314
                                                                       318]},
                                                      :full-name "cljs.repl.browser/create-client-js-file",
                                                      :full-name-encode "cljs.repl.browser_create-client-js-file",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "cljs.repl/*cljs-verbose*" {:ns "cljs.repl",
                                       :name "*cljs-verbose*",
                                       :type "dynamic var",
                                       :source {:code "(def ^:dynamic *cljs-verbose* false)",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [16]},
                                       :full-name "cljs.repl/*cljs-verbose*",
                                       :full-name-encode "cljs.repl_STARcljs-verboseSTAR",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue" {:ns "cljs.core",
                                        :name "PersistentQueue",
                                        :signature ["[meta count front rear]"],
                                        :history [["+" "0.0-927"]],
                                        :type "type",
                                        :full-name-encode "cljs.core_PersistentQueue",
                                        :source {:code "(deftype PersistentQueue [meta count front rear]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (-first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear)\n        (PersistentQueue. meta (dec count) (seq rear) []))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o))\n      (PersistentQueue. meta (inc count) (conj front o) [])))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.PersistentQueue/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear))\n        cljs.core.List/EMPTY)))\n\n  ICounted\n  (-count [coll] count))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [2144 2188]},
                                        :full-name "cljs.core/PersistentQueue",
                                        :clj-symbol "clojure.lang/PersistentQueue"},
           "cljs.core/drop-last" {:description "Return a lazy sequence of all but the last `n` items in `s`.\n\n`n` defaults to 1.",
                                  :ns "cljs.core",
                                  :name "drop-last",
                                  :signature ["[s]" "[n s]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/drop"
                                            "cljs.core/drop-while"],
                                  :full-name-encode "cljs.core_drop-last",
                                  :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1728 1731]},
                                  :full-name "cljs.core/drop-last",
                                  :clj-symbol "clojure.core/drop-last",
                                  :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
           "cljs.reader/read-string" {:ns "cljs.reader",
                                      :name "read-string",
                                      :signature ["[s]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader_read-string",
                                      :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r true nil false)))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [356 360]},
                                      :extra-sources ({:code "(defn read-string\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading string\")\n     (= \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (= \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/cljs/reader.cljs",
                                                       :lines [232
                                                               241]}),
                                      :full-name "cljs.reader/read-string",
                                      :clj-symbol "clojure.core/read-string",
                                      :docstring "Reads one object from the string s"},
           "cljs.core/vector?" {:description "Returns true if `x` is a vector, false otherwise.",
                                :ns "cljs.core",
                                :name "vector?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/vector"
                                          "cljs.core/vec"],
                                :full-name-encode "cljs.core_vectorQMARK",
                                :source {:code "(defn vector?\n  [x] (satisfies? IVector x))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [624 626]},
                                :full-name "cljs.core/vector?",
                                :clj-symbol "clojure.core/vector?",
                                :docstring "Return true if x satisfies IVector"},
           "cljs.core/defmulti" {:ns "cljs.core",
                                 :name "defmulti",
                                 :signature ["[mm-name & options]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core_defmulti",
                                 :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (string? (first options))\n                      (first options)\n                      nil)\n        options     (if (string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)]\n    (when (= (count options) 1)\n      (throw \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))\n    (let [options   (apply hash-map options)\n          default   (get options :default :default)\n          ;; hierarchy (get options :hierarchy #'cljs.core.global-hierarchy)\n\t  ]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n\t (let [method-table# (atom {})\n\t       prefer-table# (atom {})\n\t       method-cache# (atom {})\n\t       cached-hierarchy# (atom {})\n\t       hierarchy# (get ~options :hierarchy cljs.core/global-hierarchy)\n\t       ]\n\t   (cljs.core.MultiFn. ~(name mm-name) ~dispatch-fn ~default hierarchy#\n\t\t\t       method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [692 736]},
                                 :full-name "cljs.core/defmulti",
                                 :clj-symbol "clojure.core/defmulti",
                                 :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
           "cljs.core/List.EMPTY" {:ns "cljs.core",
                                   :name "List.EMPTY",
                                   :history [["+" "0.0-927"]],
                                   :parent-type "List",
                                   :type "var",
                                   :full-name-encode "cljs.core_ListDOTEMPTY",
                                   :source {:code "(set! cljs.core.List/EMPTY (EmptyList. nil))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1186]},
                                   :full-name "cljs.core/List.EMPTY",
                                   :clj-symbol "clojure.lang/PersistentList.EMPTY"},
           "clojure.browser.event/dispatch-event" {:ns "clojure.browser.event",
                                                   :name "dispatch-event",
                                                   :type "function",
                                                   :signature ["[src event]"],
                                                   :source {:code "(defn dispatch-event\n  [src event]\n  (goog.events/dispatchEvent src event))",
                                                            :repo "clojurescript",
                                                            :tag "r971",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [75
                                                                    77]},
                                                   :full-name "clojure.browser.event/dispatch-event",
                                                   :full-name-encode "clojure.browser.event_dispatch-event",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "clojure.string/split-lines" {:description "Splits `s` on `\\n` or `\\r\\n`.",
                                         :ns "clojure.string",
                                         :name "split-lines",
                                         :signature ["[s]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :related ["clojure.string/split"],
                                         :full-name-encode "clojure.string_split-lines",
                                         :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/clojure/string.cljs",
                                                  :lines [101 104]},
                                         :full-name "clojure.string/split-lines",
                                         :clj-symbol "clojure.string/split-lines",
                                         :docstring "Splits s on \n or \r\n."},
           "cljs.repl.browser/loaded-libs" {:ns "cljs.repl.browser",
                                            :name "loaded-libs",
                                            :type "var",
                                            :source {:code "(def loaded-libs (atom #{}))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [30]},
                                            :full-name "cljs.repl.browser/loaded-libs",
                                            :full-name-encode "cljs.repl.browser_loaded-libs",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/areduce" {:description "For quickly reducing an expression `expr` across a JavaScript array `a`.  The\nexpression can use `ret` as the current result, which is initialized to `init`.\nIt can also use `idx` to get the current index.",
                                :ns "cljs.core",
                                :name "areduce",
                                :signature ["[a idx ret init expr]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/reduce"],
                                :full-name-encode "cljs.core_areduce",
                                :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [657 666]},
                                :examples [{:id "20a389",
                                            :content "```clj\n(def a #js [1 2 3])\n(areduce a i ret 0 (+ ret (aget a i)))\n;;=> 6\n```"}],
                                :full-name "cljs.core/areduce",
                                :clj-symbol "clojure.core/areduce",
                                :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the \nevaluation of expr at each step, returning ret."},
           "cljs.core/disj" {:description "disj(oin). Returns a new set of the same (hashed/sorted) type, that does not\ncontain key(s).",
                             :ns "cljs.core",
                             :name "disj",
                             :signature ["[coll]"
                                         "[coll k]"
                                         "[coll k & ks]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/dissoc"
                                       "cljs.core/disj!"
                                       "clojure.set/difference"],
                             :full-name-encode "cljs.core_disj",
                             :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n     (-disjoin coll k))\n  ([coll k & ks]\n     (let [ret (disj coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [571 581]},
                             :full-name "cljs.core/disj",
                             :clj-symbol "clojure.core/disj",
                             :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "clojure.browser.net/event-types" {:ns "clojure.browser.net",
                                              :name "event-types",
                                              :type "var",
                                              :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (merge\n          (js->clj goog.net.EventType)))))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [23 30]},
                                              :full-name "clojure.browser.net/event-types",
                                              :full-name-encode "clojure.browser.net_event-types",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.string/lower-case" {:description "Converts string to all lower-case.",
                                        :ns "clojure.string",
                                        :name "lower-case",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_lower-case",
                                        :source {:code "(defn lower-case\n  [s]\n  (. s (toLowerCase)))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [58 61]},
                                        :full-name "clojure.string/lower-case",
                                        :clj-symbol "clojure.string/lower-case",
                                        :docstring "Converts string to all lower-case."},
           "cljs.core/*print-fn*" {:ns "cljs.core",
                                   :name "*print-fn*",
                                   :docstring "Each runtime environment provides a diffenent way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                   :type "function",
                                   :source {:code "(def\n  ^{:doc \"Each runtime environment provides a diffenent way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\"}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [15 21]},
                                   :full-name "cljs.core/*print-fn*",
                                   :full-name-encode "cljs.core_STARprint-fnSTAR",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/str" {:description "`(str)` and `(str nil)` return the empty string.\n\n`(str x)` returns `x.toString()`.\n\nWith more than one argument, returns the concatenation of the `str` values of\nthe arguments.",
                            :ns "cljs.core",
                            :name "str",
                            :signature ["[]" "[x]" "[x & ys]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core_str",
                            :source {:code "(defn str\n  ([] \"\")\n  ([x] (cond\n        (symbol? x) (. x (substring 2 (.-length x)))\n        (keyword? x) (str* \":\" (. x (substring 2 (.-length x))))\n        (nil? x) \"\"\n        :else (. x (toString))))\n  ([x & ys]\n     (apply str* x ys)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1049 1060]},
                            :full-name "cljs.core/str",
                            :clj-symbol "clojure.core/str",
                            :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
           "cljs.core/ISequential" {:ns "cljs.core",
                                    :name "ISequential",
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core_ISequential",
                                    :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [183 184]},
                                    :full-name "cljs.core/ISequential",
                                    :clj-symbol "clojure.lang/Sequential",
                                    :docstring "Marker interface indicating a persistent collection of sequential items"},
           "cljs.core/set" {:description "Returns a set of the distinct elements of `coll`.",
                            :ns "cljs.core",
                            :name "set",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/hash-set"
                                      "cljs.core/sorted-set"
                                      "cljs.core/conj"
                                      "cljs.core/disj"
                                      "cljs.core/distinct"
                                      "clojure.set/join"
                                      "clojure.set/select"
                                      "clojure.set/difference"
                                      "clojure.set/intersection"
                                      "clojure.set/union"
                                      "clojure.set/index"
                                      "clojure.set/project"
                                      "clojure.set/rename"
                                      "clojure.set/rename-keys"
                                      "clojure.set/map-invert"],
                            :full-name-encode "cljs.core_set",
                            :source {:code "(defn set\n  [coll]\n  (loop [in (seq coll)\n         out cljs.core.Set/EMPTY]\n    (if-not (empty? in)\n      (recur (rest in) (conj out (first in)))\n      out)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2521 2528]},
                            :full-name "cljs.core/set",
                            :clj-symbol "clojure.core/set",
                            :docstring "Returns a set of the distinct elements of coll."},
           "special/def" {:description "Creates a global variable with the name of `symbol` and a namespace of the\ncurrent namespace.\n\nIf `init` is supplied, it is evaluated and the result is assigned to `symbol`.\n\n`doc-string` is an optional documentation string.\n\n`def` is one of ClojureScript's [special forms](http://clojure.org/special_forms)\nand is used by many macros to define common elements (ie: `defn`, `defmacro`,\netc).",
                          :ns "special",
                          :name "def",
                          :signature ["[symbol]"
                                      "[symbol init]"
                                      "[symbol doc-string init]"],
                          :history [["+" "0.0-927"]],
                          :type "special form",
                          :related ["cljs.core/defn"
                                    "cljs.core/fn"
                                    "cljs.core/defmacro"
                                    "cljs.core/defmulti"],
                          :full-name-encode "special_def",
                          :source {:code "(defmethod parse 'def\n  [op env form name]\n  (let [pfn (fn ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)]\n    (assert (not (namespace sym)) \"Can't def ns-qualified name\")\n    (let [name (munge (:name (resolve-var (dissoc env :locals) sym)))\n          init-expr (when (contains? args :init) (disallowing-recur\n                                                  (analyze (assoc env :context :expr) (:init args) sym)))\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (swap! namespaces update-in [(-> env :ns :name) :defs sym]\n             (fn [m]\n               (let [m (assoc (or m {}) :name name)]\n                 (if-let [line (:line env)]\n                   (-> m\n                       (assoc :file *cljs-file*)\n                       (assoc :line line))\n                   m))))\n      (merge {:env env :op :def :form form\n              :name name :doc doc :init init-expr}\n             (when init-expr {:children [init-expr]})\n             (when export-as {:export export-as})))))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [654 679]},
                          :examples [{:id "a5f898",
                                      :content "```clj\n(def a)\na\n;;=> nil\n\n(def b 42)\nb\n;;=> 42\n\n(def c \"an optional docstring\" 42)\nc\n;;=> 42\n```"}],
                          :full-name "special/def",
                          :clj-symbol "clojure.core/def"},
           "cljs.core/print" {:ns "cljs.core",
                              :name "print",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_print",
                              :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2925 2930]},
                              :full-name "cljs.core/print",
                              :clj-symbol "clojure.core/print",
                              :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption."},
           "cljs.core/type" {:ns "cljs.core",
                             :name "type",
                             :signature ["[x]"],
                             :history [["+" "0.0-971"]],
                             :type "function",
                             :full-name-encode "cljs.core_type",
                             :source {:code "(defn type [x]\n  (js* \"(~{x}).constructor\"))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [219 220]},
                             :full-name "cljs.core/type",
                             :clj-symbol "clojure.core/type"},
           "clojure.string/blank?" {:description "True if `s` is nil, empty, or contains only whitespace.",
                                    :ns "clojure.string",
                                    :name "blank?",
                                    :signature ["[s]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string_blankQMARK",
                                    :source {:code "(defn blank?\n  [s]\n  (let [s (str s)]\n    (if (or\n         (not s)\n         (= \"\" s)\n         (re-matches #\"\\s+\" s))\n      true\n      false)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [133 142]},
                                    :full-name "clojure.string/blank?",
                                    :clj-symbol "clojure.string/blank?",
                                    :docstring "True is s is nil, empty, or contains only whitespace."},
           "syntax/keyword" {:description "Signifies a keyword, a string-like datatype often used as keys for maps.\nKeywords should not start with a number.\n\nKeywords can have an optional namespace. For example, `:foo/bar`. This is useful\nfor functions in a namespace to prevent key collisions on a globally accessible\nmap.\n\nPreceding a keyword with `::` will prepend the given keyword with the current\nnamespace.  For example, in the user namespace, `::foo` is read as `:user/foo`.\n\nIf a keyword is prefixed by `::` and is namespace-qualified, the namespace part is properly resolved.\nFor example, if `foo` is an alias of `cljs.core`, then `::foo/bar` evaluates to `:cljs.core/bar`.\nA reader exception is thrown if `foo` is not a namespace.",
                             :ns "syntax",
                             :name "keyword",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["cljs.core/keyword"
                                       "cljs.core/keyword?"],
                             :full-name-encode "syntax_keyword",
                             :source {:repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form ":",
                             :examples [{:id "e5fdbe",
                                         :content "```clj\n:foo\n;;=> :foo\n\n::foo\n;;=> :user/foo\n\n:a/foo\n;;=> :a/foo\n```"}
                                        {:id "9765fe",
                                         :content "A keyword is also callable for retrieving values from a map:\n\n```clj\n(def m {:foo 1})\n(:foo m)\n;;=> 1\n\n(def things [{:foo 1 :bar 2}\n             {:foo 3 :bar 4}\n             {:foo 5 :bar 6}])\n(map :foo things)\n;;=> (1 3 5)\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#keywords",
                             :full-name "syntax/keyword",
                             :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.dom/append" {:ns "clojure.browser.dom",
                                         :name "append",
                                         :type "function",
                                         :signature ["[parent & children]"],
                                         :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/clojure/browser/dom.cljs",
                                                  :lines [12 14]},
                                         :full-name "clojure.browser.dom/append",
                                         :full-name-encode "clojure.browser.dom_append",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/take-last" {:description "Returns a sequence of the last `n` items in `coll`.\n\nDepending on the type of collection, `take-last` may be no faster than linear\ntime. For vectors, please use `subvec`.",
                                  :ns "cljs.core",
                                  :name "take-last",
                                  :signature ["[n coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/last"
                                            "cljs.core/butlast"
                                            "cljs.core/drop-last"],
                                  :full-name-encode "cljs.core_take-last",
                                  :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1733 1740]},
                                  :full-name "cljs.core/take-last",
                                  :clj-symbol "clojure.core/take-last",
                                  :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
           "clojure.set/intersection" {:description "Return a set that is the intersection of the input sets.",
                                       :ns "clojure.set",
                                       :name "intersection",
                                       :signature ["[s1]"
                                                   "[s1 s2]"
                                                   "[s1 s2 & sets]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["clojure.set/union"
                                                 "clojure.set/difference"
                                                 "clojure.set/superset?"
                                                 "clojure.set/project"],
                                       :full-name-encode "clojure.set_intersection",
                                       :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/clojure/set.cljs",
                                                :lines [31 44]},
                                       :full-name "clojure.set/intersection",
                                       :clj-symbol "clojure.set/intersection",
                                       :docstring "Return a set that is the intersection of the input sets"},
           "cljs.core/fnext" {:description "Same as `(first (next coll))`",
                              :ns "cljs.core",
                              :name "fnext",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/ffirst"
                                        "cljs.core/second"],
                              :full-name-encode "cljs.core_fnext",
                              :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [450 453]},
                              :examples [{:id "92383f",
                                          :content "```clj\n(fnext [1 2 3])\n;;=> 2\n\n(fnext [1 2])\n;;=> 2\n\n(fnext [1])\n;;=> nil\n\n(fnext [])\n;;=> nil\n```"}],
                              :full-name "cljs.core/fnext",
                              :clj-symbol "clojure.core/fnext",
                              :docstring "Same as (first (next x))"},
           "cljs.core/apply" {:description "Applies function `f` to the argument list formed by prepending intervening\narguments to `args`.",
                              :ns "cljs.core",
                              :name "apply",
                              :signature ["[f args]"
                                          "[f x args]"
                                          "[f x y args]"
                                          "[f x y z args]"
                                          "[f a b c d & args]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/map"],
                              :full-name-encode "cljs.core_apply",
                              :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count args (inc fixed-arity))\n                 fixed-arity)\n           (.apply f f (to-array args))\n           (.cljs$lang$applyTo f args))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist))))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1378 1424]},
                              :examples [{:id "174052",
                                          :content "```clj\n(max 1 2 3)\n;;=> 3\n\n(apply max [1 2 3])\n;;=> 3\n\n(apply max 1 [2 3])\n;;=> 3\n```"}],
                              :full-name "cljs.core/apply",
                              :clj-symbol "clojure.core/apply",
                              :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
           "clojure.walk/prewalk" {:ns "clojure.walk",
                                   :name "prewalk",
                                   :signature ["[f form]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.walk_prewalk",
                                   :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/clojure/walk.cljs",
                                            :lines [58 62]},
                                   :full-name "clojure.walk/prewalk",
                                   :clj-symbol "clojure.walk/prewalk",
                                   :docstring "Like postwalk, but does pre-order traversal."},
           "cljs.core/flatten" {:description "Takes any nested combination of sequential things (lists, vectors, etc.) and\nreturns their contents as a single, flat sequence.\n\n`(flatten nil)` returns nil.",
                                :ns "cljs.core",
                                :name "flatten",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_flatten",
                                :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1857 1863]},
                                :full-name "cljs.core/flatten",
                                :clj-symbol "clojure.core/flatten",
                                :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
           "cljs.core/get" {:description "Returns the value mapped to key `k`.\n\nReturns `not-found` or nil if `k` is not present in `o`.",
                            :ns "cljs.core",
                            :name "get",
                            :signature ["[o k]" "[o k not-found]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/get-in"],
                            :full-name-encode "cljs.core_get",
                            :source {:code "(defn get\n  ([o k]\n     (-lookup o k))\n  ([o k not-found]\n     (-lookup o k not-found)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [514 519]},
                            :full-name "cljs.core/get",
                            :clj-symbol "clojure.core/get",
                            :docstring "Returns the value mapped to key, not-found or nil if key not present."},
           "cljs.core/.." {:description "For interop, the `..` macro allows method/property chaining on the given JavaScript object `o`.\n\nIt essentially combines the thread-first `->` macro with the `.` operator.",
                           :ns "cljs.core",
                           :name "..",
                           :signature ["[o form]" "[o form & more]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["special/."
                                     "cljs.core/->"
                                     "cljs.core/doto"],
                           :full-name-encode "cljs.core_DOTDOT",
                           :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                    :repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1510 1526]},
                           :examples [{:id "500658",
                                       :content "```js\n// JavaScript\n\"a b c d\".toUpperCase().replace(\"A\", \"X\")\n//=> \"X B C D\"\n```\n\n```clj\n;; ClojureScript\n(.. \"a b c d\"\n    toUpperCase\n    (replace \"A\" \"X\"))\n;;=> \"X B C D\"\n```\n\nThis is expanded to:\n\n```clj\n(. (. \"a b c d\" toUpperCase) (replace \"A\" \"X\"))\n```\n\n\nwhich is equivalent to:\n\n```clj\n(.replace (.toUpperCase \"a b c d\") \"A\" \"X\")\n;;=> \"X B C D\"\n```\n\nCompare to the equivalent form using the thread-first `->` macro:\n\n```clj\n(-> \"a b c d\"\n    .toUpperCase\n    (.replace \"A\" \"X\"))\n;;=> \"X B C D\"\n```"}],
                           :full-name "cljs.core/..",
                           :clj-symbol "clojure.core/..",
                           :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
           "cljs.core/Range" {:ns "cljs.core",
                              :name "Range",
                              :signature ["[meta start end step]"],
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core_Range",
                              :source {:code "(deftype Range [meta start end step]\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeq\n  (-first [rng] start)\n\n  (-rest [rng]\n    (if (-seq rng)\n      (Range. meta (+ start step) end step)\n      (list)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (hash-coll rng))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (js/Math.ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (= step 0))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (= step 0))\n        start\n        not-found)))\n\n  ISeqable\n  (-seq [rng]\n    (let [comp (if (pos? step) < >)]\n      (when (comp start end)\n        rng)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f s] (ci-reduce rng f s)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2630 2686]},
                              :full-name "cljs.core/Range",
                              :clj-symbol "clojure.lang/Range"},
           "cljs.core/zero?" {:description "Returns true if `n` is 0, false otherwise.",
                              :ns "cljs.core",
                              :name "zero?",
                              :signature ["[n]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/pos?"
                                        "cljs.core/neg?"],
                              :full-name-encode "cljs.core_zeroQMARK",
                              :source {:code "(defn zero? [n]\n  (cljs.core/zero? n))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1002 1003]},
                              :extra-sources ({:code "(defmacro zero? [x]\n  `(== ~x 0))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [118 119]}),
                              :full-name "cljs.core/zero?",
                              :clj-symbol "clojure.core/zero?"},
           "cljs.core/identity" {:description "Returns its argument.",
                                 :ns "cljs.core",
                                 :name "identity",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/nil?"],
                                 :full-name-encode "cljs.core_identity",
                                 :source {:code "(defn identity [x] x)",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1481]},
                                 :full-name "cljs.core/identity",
                                 :clj-symbol "clojure.core/identity"},
           "cljs.core/first" {:description "Returns the first item in `coll` and calls `seq` on its argument.\n\nReturns nil when `coll` is nil.",
                              :ns "cljs.core",
                              :name "first",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/rest"
                                        "cljs.core/next"
                                        "cljs.core/nth"
                                        "cljs.core/second"
                                        "cljs.core/take"
                                        "cljs.core/ffirst"],
                              :full-name-encode "cljs.core_first",
                              :source {:code "(defn first\n  [coll]\n  (when-let [s (seq coll)]\n    (-first s)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [415 420]},
                              :examples [{:id "40e413",
                                          :content "```clj\n(first [1 2 3])\n;;=> 1\n\n(first [])\n;;=> nil\n```"}],
                              :full-name "cljs.core/first",
                              :clj-symbol "clojure.core/first",
                              :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
           "cljs.reader/ratio-pattern" {:ns "cljs.reader",
                                        :name "ratio-pattern",
                                        :type "var",
                                        :source {:code "(def ratio-pattern (re-pattern \"([-+]?[0-9]+)/([0-9]+)\"))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [96]},
                                        :full-name "cljs.reader/ratio-pattern",
                                        :full-name-encode "cljs.reader_ratio-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/>" {:description "Returns true if each successive number argument is less than the previous\none, false otherwise.",
                          :ns "cljs.core",
                          :name ">",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/>="],
                          :full-name-encode "cljs.core_GT",
                          :source {:code "(defn >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [865 875]},
                          :extra-sources ({:code "(defmacro >\n  ([x] true)\n  ([x y] (list 'js* \"(~{} > ~{})\" x y))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [97 100]}),
                          :examples [{:id "67180c",
                                      :content "```clj\n(> 1 2)\n;;=> false\n\n(> 2 1)\n;;=> true\n\n(> 2 2)\n;;=> false\n\n(> 6 5 4 3 2)\n;;=> true\n```"}],
                          :full-name "cljs.core/>",
                          :clj-symbol "clojure.core/>",
                          :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
           "cljs.core/juxt" {:description "Takes a set of functions and returns a function that is the juxtaposition of\nthose functions.\n\nThe returned function takes a variable number of arguments, and returns a vector\ncontaining the result of applying each function to the arguments (left-to-\nright).\n\n`((juxt a b c) x)` => `[(a x) (b x) (c x)]`",
                             :ns "cljs.core",
                             :name "juxt",
                             :signature ["[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f g h & fs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/partial"
                                       "cljs.core/comp"],
                             :full-name-encode "cljs.core_juxt",
                             :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2744 2778]},
                             :full-name "cljs.core/juxt",
                             :clj-symbol "clojure.core/juxt",
                             :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
           "cljs.core/max" {:description "Returns the greatest number argument.",
                            :ns "cljs.core",
                            :name "max",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/min"
                                      "cljs.core/max-key"],
                            :full-name-encode "cljs.core_max",
                            :source {:code "(defn max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [893 898]},
                            :extra-sources ({:code "(defmacro max\n  ([x] x)\n  ([x y] (list 'js* \"((~{} > ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [127 130]}),
                            :full-name "cljs.core/max",
                            :clj-symbol "clojure.core/max",
                            :docstring "Returns the greatest of the nums."},
           "cljs.core/*3" {:description "Only usable from a REPL.\n\nHolds the result of the third to last expression.",
                           :ns "cljs.core",
                           :name "*3",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*2"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR3",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [31 33]},
                           :examples [{:id "d7a6e9",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n(+ 4 8)\n;;=> 12\n\n(+ 1 2)\n;;=> 3\n\n*3\n;;=> 10\n\n(inc *3)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*3",
                           :clj-symbol "clojure.core/*3",
                           :docstring "bound in a repl thread to the third most recent value printed"},
           "cljs.core/number?" {:description "Returns true if `n` is a number, false otherwise.",
                                :ns "cljs.core",
                                :name "number?",
                                :signature ["[n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/integer?"],
                                :full-name-encode "cljs.core_numberQMARK",
                                :source {:code "(defn number? [n]\n  (goog/isNumber n))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [681 682]},
                                :full-name "cljs.core/number?",
                                :clj-symbol "clojure.core/number?"},
           "cljs.core/array" {:description "Creates a JavaScript array containing `args`.\n\nThe tagged literal `#js [1 2 3]` is equivalent to `(array 1 2 3)`",
                              :ns "cljs.core",
                              :name "array",
                              :signature ["[& args]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/aclone"
                                        "cljs.core/make-array"
                                        "cljs.core/clj->js"],
                              :full-name-encode "cljs.core_array",
                              :source {:code "(defn array\n  [var-args]            ;; [& items]\n  (js* \"Array.prototype.slice.call(arguments)\"))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [71 75]},
                              :examples [{:id "3a546d",
                                          :content "```clj\n(array 1 2 3)\n;;=> #js [1 2 3]\n\n(apply array [1 2 3])\n;;=> #js [1 2 3]\n\n#js [1 2 3]\n;;=> #js [1 2 3]\n```"}
                                         {:id "cca945",
                                          :content "When creating nested JavaScript arrays, you can opt to use `clj->js` instead:\n\n```clj\n(array 1 2 (array 3 4))\n;;=> #js [1 2 #js [3 4]]\n\n(clj->js [1 2 [3 4]])\n;;=> #js [1 2 #js [3 4]]\n```"}],
                              :full-name "cljs.core/array",
                              :docstring "Creates a new javascript array.\n@param {...*} var_args"},
           "cljs.core/nthnext" {:description "Returns the `n`th `next` of `coll`.\n\nReturns `(seq coll)` when `n` is 0.",
                                :ns "cljs.core",
                                :name "nthnext",
                                :signature ["[coll n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/nth"
                                          "cljs.core/drop"
                                          "cljs.core/nthrest"],
                                :full-name-encode "cljs.core_nthnext",
                                :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1013 1019]},
                                :full-name "cljs.core/nthnext",
                                :clj-symbol "clojure.core/nthnext",
                                :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
           "cljs.core/re-pattern" {:description "Returns an instance of RegExp which has compiled the provided string.",
                                   :ns "cljs.core",
                                   :name "re-pattern",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_re-pattern",
                                   :source {:code "(defn re-pattern\n  [s]\n  (js/RegExp. s))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2839 2842]},
                                   :full-name "cljs.core/re-pattern",
                                   :clj-symbol "clojure.core/re-pattern",
                                   :docstring "Returns an instance of RegExp which has compiled the provided string."},
           "cljs.core/missing-protocol" {:ns "cljs.core",
                                         :name "missing-protocol",
                                         :type "function",
                                         :signature ["[proto obj]"],
                                         :source {:code "(defn missing-protocol [proto obj]\n  (js/Error (js* \"~{}+~{}+~{}+~{}+~{}+~{}\"\n                 \"No protocol method \" proto\n                 \" defined for type \" (goog/typeOf obj) \": \" obj)))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [58 61]},
                                         :full-name "cljs.core/missing-protocol",
                                         :full-name-encode "cljs.core_missing-protocol",
                                         :history [["+" "0.0-927"]]},
           "clojure.browser.dom/set-text" {:ns "clojure.browser.dom",
                                           :name "set-text",
                                           :signature ["[e s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.dom_set-text",
                                           :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/clojure/browser/dom.cljs",
                                                    :lines [122 127]},
                                           :full-name "clojure.browser.dom/set-text",
                                           :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned."},
           "clojure.zip/up" {:ns "clojure.zip",
                             :name "up",
                             :signature ["[loc]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "clojure.zip_up",
                             :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [111 122]},
                             :full-name "clojure.zip/up",
                             :clj-symbol "clojure.zip/up",
                             :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
           "cljs.core/IWithMeta" {:ns "cljs.core",
                                  :name "IWithMeta",
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IWithMeta",
                                  :source {:code "(defprotocol IWithMeta\n  (-with-meta [o meta]))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [168 169]},
                                  :methods [{:name "-with-meta",
                                             :signature ["[o meta]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IWithMeta",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/bit-and-not" {:description "Bitwise \"and\" `x` with bitwise \"not\" `y`.  Same as `x & ~y` in JavaScript.",
                                    :ns "cljs.core",
                                    :name "bit-and-not",
                                    :signature ["[x y]"
                                                "[x y & more]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/bit-and"
                                              "cljs.core/bit-not"],
                                    :full-name-encode "cljs.core_bit-and-not",
                                    :source {:code "(defn bit-and-not\n  [x y] (cljs.core/bit-and-not x y))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [950 952]},
                                    :extra-sources ({:code "(defmacro bit-and-not\n  ([x y] (list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/clj/cljs/core.clj",
                                                     :lines [155 157]}),
                                    :examples [{:id "16f35d",
                                                :content "Bits can be entered using radix notation:\n\n```clj\n(bit-and-not 2r1100 2r1010)\n;;=> 4\n;; 4 = 2r0100\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-and-not 12 10)\n;;=> 4\n```\n\nSame result using `bit-and` and `bit-not`:\n\n```clj\n(bit-and 12 (bit-not 10))\n;;=> 4\n```"}],
                                    :full-name "cljs.core/bit-and-not",
                                    :clj-symbol "clojure.core/bit-and-not",
                                    :docstring "Bitwise and"},
           "clojure.string/triml" {:description "Removes whitespace from the left side of string.",
                                   :ns "clojure.string",
                                   :name "triml",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string_triml",
                                   :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [111 114]},
                                   :full-name "clojure.string/triml",
                                   :clj-symbol "clojure.string/triml",
                                   :docstring "Removes whitespace from the left side of string."},
           "syntax/character" {:description "Signifies a single character string.  Carried over from Clojure for\ncompatibility.  They are represented as single character JavaScript strings.\n\n`\\c` = `\"c\"`\n\n| unicode characters  | constraints                                   |\n|---------------------|-----------------------------------------------|\n| `\\uXXXX`            | XXXX must have 4 digits outside 0xD7FF-0xE000 |\n| `\\oXXX`             | XXX is octal between 0 and 0377               |\n\n| special characters  | result   |\n|---------------------|----------|\n| `\\newline`          | `\"\\n\"`   |\n| `\\space`            | `\" \"`    |\n| `\\tab`              | `\"\\t\"`   |\n| `\\formfeed`         | `\"\\f\"`   |\n| `\\backspace`        | `\"\\b\"`   |\n| `\\return`           | `\"\\r\"`   |",
                               :ns "syntax",
                               :name "character",
                               :history [["+" "0.0-927"]],
                               :type "syntax",
                               :related ["syntax/string"
                                         "cljs.core/str"],
                               :full-name-encode "syntax_character",
                               :source {:repo "clojure",
                                        :tag "clojure-1.3.0",
                                        :filename "src/jvm/clojure/lang/LispReader.java",
                                        :lines [nil]},
                               :syntax-form "\\",
                               :examples [{:id "495a47",
                                           :content "```clj\n\\c\n;;=> \"c\"\n\n\\A\n;;=> \"A\"\n\n\\newline\n;;=> \"\\n\"\n\n\\u00a1\n;;=> \"¡\"\n\n\\o256\n;;=> \"®\"\n```"}],
                               :edn-doc "https://github.com/edn-format/edn#characters",
                               :full-name "syntax/character",
                               :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/unreadable" {:ns "syntax",
                                :name "unreadable",
                                :history [["+" "0.0-927"]],
                                :type "syntax",
                                :full-name-encode "syntax_unreadable",
                                :source {:repo "clojure",
                                         :tag "clojure-1.3.0",
                                         :filename "src/jvm/clojure/lang/LispReader.java",
                                         :lines [nil]},
                                :syntax-form "#<>",
                                :full-name "syntax/unreadable",
                                :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L115"},
           "clojure.string/split" {:description "Splits string on a regular expression. Optional argument limit is the maximum\nnumber of splits. Not lazy. Returns vector of the splits.",
                                   :ns "clojure.string",
                                   :name "split",
                                   :signature ["[s re]"
                                               "[s re limit]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/subs"
                                             "clojure.string/replace"
                                             "clojure.string/split-lines"],
                                   :full-name-encode "clojure.string_split",
                                   :source {:code "(defn split\n  ([s re]\n     (vec (.split (str s) re)))\n  ([s re limit]\n     (if (< limit 1)\n       (vec (.split (str s) re))\n       (loop [s s\n              limit limit\n              parts []]\n         (if (= limit 1)\n           (conj parts s)\n           (if-let [m (re-find re s)]\n             (let [index (.indexOf s m)]\n               (recur (.substring s (+ index (count m)))\n                      (dec limit)\n                      (conj parts (.substring s 0 index))))\n             (conj parts s)))))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [81 99]},
                                   :full-name "clojure.string/split",
                                   :clj-symbol "clojure.string/split",
                                   :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
           "cljs.core/hash-map" {:description "Returns a new hash map with supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                 :ns "cljs.core",
                                 :name "hash-map",
                                 :signature ["[& keyvals]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/array-map"
                                           "cljs.core/sorted-map"],
                                 :full-name-encode "cljs.core_hash-map",
                                 :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out cljs.core.HashMap/EMPTY]\n    (if in\n      (recur (nnext in) (assoc out (first in) (second in)))\n      out)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2411 2418]},
                                 :full-name "cljs.core/hash-map",
                                 :clj-symbol "clojure.core/hash-map",
                                 :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
           "cljs.core/rem" {:description "Returns the remainder of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).",
                            :ns "cljs.core",
                            :name "rem",
                            :signature ["[n d]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/quot"
                                      "cljs.core/mod"],
                            :full-name-encode "cljs.core_rem",
                            :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (js* \"(~{n} - (~{d} * ~{q}))\")))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [923 927]},
                            :full-name "cljs.core/rem",
                            :clj-symbol "clojure.core/rem",
                            :docstring "remainder of dividing numerator by denominator."},
           "cljs.core/IRecord" {:ns "cljs.core",
                                :name "IRecord",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IRecord",
                                :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [186 187]},
                                :full-name "cljs.core/IRecord",
                                :clj-symbol "clojure.lang/IRecord",
                                :docstring "Marker interface indicating a record object"},
           "cljs.core/constantly" {:description "Returns a function that takes any number of arguments and always returns `x`.",
                                   :ns "cljs.core",
                                   :name "constantly",
                                   :signature ["[x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/repeatedly"],
                                   :full-name-encode "cljs.core_constantly",
                                   :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1493 1495]},
                                   :full-name "cljs.core/constantly",
                                   :clj-symbol "clojure.core/constantly",
                                   :docstring "Returns a function that takes any number of arguments and returns x."},
           "clojure.browser.dom/get-element" {:ns "clojure.browser.dom",
                                              :name "get-element",
                                              :type "function",
                                              :signature ["[id]"],
                                              :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/clojure/browser/dom.cljs",
                                                       :lines [96 97]},
                                              :full-name "clojure.browser.dom/get-element",
                                              :full-name-encode "clojure.browser.dom_get-element",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/and" {:description "Evaluates arguments one at a time from left to right. If an argument returns\nlogical false (nil or false), `and` returns that value and doesn't evaluate any\nof the other arguments, otherwise it returns the value of the last argument.\n\n`(and)` returns true.",
                            :ns "cljs.core",
                            :name "and",
                            :signature ["[]" "[x]" "[x & next]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/or" "special/if"],
                            :full-name-encode "cljs.core_and",
                            :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))",
                                     :repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [777 787]},
                            :examples [{:id "a39a73",
                                        :content "```clj\n(and)\n;;=> true\n\n(and false)\n;;=> false\n\n(and true)\n;;=> true\n\n(and true true)\n;;=> true\n\n(and true false)\n;;=> false\n\n(and false false)\n;;=> false\n```"}
                                       {:id "766638",
                                        :content "`nil` and `false` are the only falsy values and everything else is truthy:\n\n```clj\n(and \"foo\" \"bar\")\n;;=> \"bar\"\n\n(and \"foo\" nil)\n;;=> nil\n\n(and \"foo\" false)\n;;=> false\n\n(and nil \"foo\")\n;;=> nil\n\n(and false \"foo\")\n;;=> false\n```"}],
                            :full-name "cljs.core/and",
                            :clj-symbol "clojure.core/and",
                            :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
           "clojure.browser.repl/wrap-message" {:ns "clojure.browser.repl",
                                                :name "wrap-message",
                                                :type "function",
                                                :signature ["[t data]"],
                                                :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                         :repo "clojurescript",
                                                         :tag "r971",
                                                         :filename "src/cljs/clojure/browser/repl.cljs",
                                                         :lines [57
                                                                 58]},
                                                :full-name "clojure.browser.repl/wrap-message",
                                                :full-name-encode "clojure.browser.repl_wrap-message",
                                                :history [["+"
                                                           "0.0-927"]]},
           "clojure.browser.event/unlisten-by-key" {:ns "clojure.browser.event",
                                                    :name "unlisten-by-key",
                                                    :type "function",
                                                    :signature ["[key]"],
                                                    :source {:code "(defn unlisten-by-key\n  [key]\n  (goog.events/unlistenByKey key))",
                                                             :repo "clojurescript",
                                                             :tag "r971",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [71
                                                                     73]},
                                                    :full-name "clojure.browser.event/unlisten-by-key",
                                                    :full-name-encode "clojure.browser.event_unlisten-by-key",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/try" {:ns "cljs.core",
                            :name "try",
                            :signature ["[& forms]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core_try",
                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [501 529]},
                            :full-name "cljs.core/try",
                            :clj-symbol "clojure.core/try",
                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/iterate" {:description "Returns a lazy sequence of `x`, `(f x)`, `(f (f x))` etc.\n\n`f` must be free of side-effects.",
                                :ns "cljs.core",
                                :name "iterate",
                                :signature ["[f x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/cycle"
                                          "cljs.core/repeatedly"
                                          "cljs.core/repeat"],
                                :full-name-encode "cljs.core_iterate",
                                :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1780 1783]},
                                :full-name "cljs.core/iterate",
                                :clj-symbol "clojure.core/iterate",
                                :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
           "cljs.core/lazy-seq" {:description "Returns a new lazy sequence.",
                                 :ns "cljs.core",
                                 :name "lazy-seq",
                                 :signature ["[& body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/lazy-cat"
                                           "cljs.core/realized?"
                                           "cljs.core/doall"
                                           "cljs.core/iterate"],
                                 :full-name-encode "cljs.core_lazy-seq",
                                 :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core.LazySeq nil false (fn [] ~@body)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [431 432]},
                                 :full-name "cljs.core/lazy-seq",
                                 :clj-symbol "clojure.core/lazy-seq"},
           "specialrepl/load-file" {:description "Only usable from a REPL.\n\nLoad file at `filename`, then compiles and evaluates its code.",
                                    :ns "specialrepl",
                                    :name "load-file",
                                    :signature ["[filename]"],
                                    :history [["+" "0.0-927"]],
                                    :type "special form (repl)",
                                    :full-name-encode "specialrepl_load-file",
                                    :source {:code "(defn repl\n  \"Note - repl will reload core.cljs every time, even if supplied old repl-env\"\n  [repl-env & {:keys [verbose warn-on-undeclared]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (= (first form) 'in-ns))\n           (do (set! comp/*cljs-ns* (second (second form))) (newline) (recur))\n           \n           (and (seq? form) ('#{load-file clojure.core/load-file} (first form)))\n           (do (load-file repl-env (second form)) (newline) (recur))\n           \n           (and (seq? form) ('#{load-namespace} (first form)))\n           (do (load-namespace repl-env (second form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [133 162]},
                                    :examples [{:id "0903c5",
                                                :content "```clj\n(load-file \"path/to/foo.cljs\")\n```"}],
                                    :full-name "specialrepl/load-file",
                                    :clj-symbol "clojure.core/load-file"},
           "cljs.core/IndexedSeq" {:ns "cljs.core",
                                   :name "IndexedSeq",
                                   :signature ["[a i]"],
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core_IndexedSeq",
                                   :source {:code "(deftype IndexedSeq [a i]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] (aget a i))\n  (-rest [_] (if (< (inc i) (.-length a))\n               (IndexedSeq. a (inc i))\n               (list)))\n\n  ICounted\n  (-count [_] (- (.-length a) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (.-length a))\n        (aget a i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (.-length a))\n        (aget a i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IReduce\n  (-reduce [_ f]\n    (ci-reduce a f (aget a i) (inc i)))\n  (-reduce [_ f start]\n    (ci-reduce a f start i))\n\n  IHash\n  (-hash [coll] (hash-coll coll)))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [332 369]},
                                   :full-name "cljs.core/IndexedSeq",
                                   :clj-symbol "clojure.lang/IndexedSeq"},
           "cljs.core/next" {:description "Returns a sequence of the items after the first and calls `seq` on its argument.\n\nReturns nil if `coll` is empty.",
                             :ns "cljs.core",
                             :name "next",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rest"
                                       "cljs.core/first"
                                       "cljs.core/fnext"],
                             :full-name-encode "cljs.core_next",
                             :source {:code "(defn next\n  [coll]\n  (when coll\n    (seq (rest coll))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [428 433]},
                             :examples [{:id "7db59a",
                                         :content "```clj\n(next [1 2 3])\n;;=> (2 3)\n\n(next [1 2])\n;;=> (2)\n\n(next [1])\n;;=> nil\n\n(next [])\n;;=> nil\n```"}],
                             :full-name "cljs.core/next",
                             :clj-symbol "clojure.core/next",
                             :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
           "cljs.core/*print-readably*" {:ns "cljs.core",
                                         :name "*print-readably*",
                                         :type "var",
                                         :source {:code "(def *print-readably* true)",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2902]},
                                         :full-name "cljs.core/*print-readably*",
                                         :full-name-encode "cljs.core_STARprint-readablySTAR",
                                         :clj-symbol "clojure.core/*print-readably*",
                                         :history [["+" "0.0-927"]]},
           "cljs.repl.browser/repl-client-js" {:ns "cljs.repl.browser",
                                               :name "repl-client-js",
                                               :type "function",
                                               :signature ["[]"],
                                               :source {:code "(defn repl-client-js []\n  (slurp @(:client-js @server-state)))",
                                                        :repo "clojurescript",
                                                        :tag "r971",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [166
                                                                167]},
                                               :full-name "cljs.repl.browser/repl-client-js",
                                               :full-name-encode "cljs.repl.browser_repl-client-js",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.repl.browser/parse-headers" {:ns "cljs.repl.browser",
                                              :name "parse-headers",
                                              :signature ["[header-lines]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser_parse-headers",
                                              :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [115
                                                               123]},
                                              :full-name "cljs.repl.browser/parse-headers",
                                              :docstring "Parse the headers of an HTTP POST request."},
           "cljs.core/last" {:description "Returns the last item in `coll` in linear time.\n\n`peek` is much faster than `last` for a vector.",
                             :ns "cljs.core",
                             :name "last",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/first"
                                       "cljs.core/next"
                                       "cljs.core/rest"
                                       "cljs.core/butlast"
                                       "cljs.core/take-last"],
                             :full-name-encode "cljs.core_last",
                             :source {:code "(defn last\n  [s]\n  (if (next s)\n    (recur (next s))\n    (first s)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [460 465]},
                             :examples [{:id "eb0836",
                                         :content "```clj\n(last [1 2 3])\n;;=> 3\n\n(last [1 2])\n;;=> 2\n\n(last [1])\n;;=> 1\n\n(last [])\n;;=> nil\n```"}],
                             :full-name "cljs.core/last",
                             :clj-symbol "clojure.core/last",
                             :docstring "Return the last item in coll, in linear time"},
           "cljs.core/bit-shift-left" {:description "Bitwise shift left `n` bits.  Same as `x << n` in JavaScript.",
                                       :ns "cljs.core",
                                       :name "bit-shift-left",
                                       :signature ["[x n]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["cljs.core/bit-shift-right"],
                                       :full-name-encode "cljs.core_bit-shift-left",
                                       :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [978 980]},
                                       :extra-sources ({:code "(defmacro bit-shift-left [x n]\n  (list 'js* \"(~{} << ~{})\" x n))",
                                                        :repo "clojurescript",
                                                        :tag "r971",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [168
                                                                169]}),
                                       :examples [{:id "67c34a",
                                                   :content "Bits can be entered using radix notation:\n\n```clj\n(bit-shift-left 2r0101 1)\n;;=> 10\n;; 10 = 2r1010\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-shift-left 5 1)\n;;=> 10\n```"}],
                                       :full-name "cljs.core/bit-shift-left",
                                       :clj-symbol "clojure.core/bit-shift-left",
                                       :docstring "Bitwise shift left"},
           "clojure.string/reverse" {:description "Returns `s` with its characters reversed.",
                                     :ns "clojure.string",
                                     :name "reverse",
                                     :signature ["[s]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string_reverse",
                                     :source {:code "(defn reverse\n  [s]\n  (.. s (split \"\") (reverse) (join \"\")))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [18 21]},
                                     :full-name "clojure.string/reverse",
                                     :clj-symbol "clojure.string/reverse",
                                     :docstring "Returns s with its characters reversed."},
           "cljs.core/min" {:description "Returns the least number argument.",
                            :ns "cljs.core",
                            :name "min",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/max"
                                      "cljs.core/min-key"],
                            :full-name-encode "cljs.core_min",
                            :source {:code "(defn min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [900 905]},
                            :extra-sources ({:code "(defmacro min\n  ([x] x)\n  ([x y] (list 'js* \"((~{} < ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [132 135]}),
                            :examples [{:id "ab2de5",
                                        :content "```clj\n(min 1 2 3 4)\n;; => 1\n```\n\nApply it to a collection:\n\n```clj\n(apply min [1 2 3 4])\n;; => 1\n```"}],
                            :full-name "cljs.core/min",
                            :clj-symbol "clojure.core/min",
                            :docstring "Returns the least of the nums."},
           "cljs.reader/escape-char" {:ns "cljs.reader",
                                      :name "escape-char",
                                      :type "function",
                                      :signature ["[buffer reader]"],
                                      :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (get escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (if (or (= \\u ch) (numeric? ch))\n        (read-unicode-char reader ch)\n        (reader-error reader \"Unsupported escape charater: \\\\\" ch)))))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [149 157]},
                                      :full-name "cljs.reader/escape-char",
                                      :full-name-encode "cljs.reader_escape-char",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/read-map" {:ns "cljs.reader",
                                   :name "read-map",
                                   :type "function",
                                   :signature ["[rdr _]"],
                                   :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [213 218]},
                                   :full-name "cljs.reader/read-map",
                                   :full-name-encode "cljs.reader_read-map",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/seq" {:description "Returns a sequence on the collection. If the collection is empty, returns nil.\n\n`(seq nil)` returns nil.\n\n`seq` also works on strings.",
                            :ns "cljs.core",
                            :name "seq",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/seq?"
                                      "cljs.core/empty?"],
                            :full-name-encode "cljs.core_seq",
                            :source {:code "(defn seq\n  [coll]\n  (when coll\n    (-seq coll)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [407 413]},
                            :full-name "cljs.core/seq",
                            :clj-symbol "clojure.core/seq",
                            :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
           "cljs.core/not-empty" {:description "Returns nil if `coll` is empty, else returns `coll`.",
                                  :ns "cljs.core",
                                  :name "not-empty",
                                  :signature ["[coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/empty"],
                                  :full-name-encode "cljs.core_not-empty",
                                  :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1439 1441]},
                                  :full-name "cljs.core/not-empty",
                                  :clj-symbol "clojure.core/not-empty",
                                  :docstring "If coll is empty, returns nil, else coll"},
           "syntax/hashbang" {:ns "syntax",
                              :name "hashbang",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :full-name-encode "syntax_hashbang",
                              :source {:repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/jvm/clojure/lang/LispReader.java",
                                       :lines [nil]},
                              :syntax-form "#!",
                              :full-name "syntax/hashbang",
                              :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L114"},
           "cljs.core/println" {:ns "cljs.core",
                                :name "println",
                                :signature ["[& objs]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_println",
                                :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (newline (pr-opts)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2932 2936]},
                                :full-name "cljs.core/println",
                                :clj-symbol "clojure.core/println",
                                :docstring "Same as print followed by (newline)"},
           "clojure.browser.repl/connect" {:ns "clojure.browser.repl",
                                           :name "connect",
                                           :signature ["[repl-server-url]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.repl_connect",
                                           :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection (net/xpc-connection\n                         {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n                          :evaluate-javascript\n                          (fn [js]\n                            (net/transmit\n                             repl-connection\n                             :send-result\n                             (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n                 (constantly nil)\n                 (fn [iframe]\n                   (set! iframe.style.display\n                         \"none\")))))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/clojure/browser/repl.cljs",
                                                    :lines [90 109]},
                                           :full-name "clojure.browser.repl/connect",
                                           :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function."},
           "clojure.browser.dom/insert-at" {:ns "clojure.browser.dom",
                                            :name "insert-at",
                                            :type "function",
                                            :signature ["[parent child index]"],
                                            :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [102 103]},
                                            :full-name "clojure.browser.dom/insert-at",
                                            :full-name-encode "clojure.browser.dom_insert-at",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/quot" {:description "Returns the quotient of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).",
                             :ns "cljs.core",
                             :name "quot",
                             :signature ["[n d]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rem"
                                       "cljs.core/mod"],
                             :full-name-encode "cljs.core_quot",
                             :source {:code "(defn quot\n  [n d]\n  (let [rem (mod n d)]\n    (fix (js* \"((~{n} - ~{rem}) / ~{d})\"))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [917 921]},
                             :full-name "cljs.core/quot",
                             :clj-symbol "clojure.core/quot",
                             :docstring "quot[ient] of dividing numerator by denominator."},
           "clojure.browser.event/get-listener" {:ns "clojure.browser.event",
                                                 :name "get-listener",
                                                 :type "function",
                                                 :signature ["[src type listener opt_capt opt_handler]"],
                                                 :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                          :repo "clojurescript",
                                                          :tag "r971",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [89]},
                                                 :full-name "clojure.browser.event/get-listener",
                                                 :full-name-encode "clojure.browser.event_get-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/filter" {:description "Returns a lazy sequence of the non-nil results of `(f item)`. Note, this means\nfalse return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                               :ns "cljs.core",
                               :name "filter",
                               :signature ["[f]" "[f coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/remove"
                                         "cljs.core/keep"],
                               :full-name-encode "cljs.core_filter",
                               :source {:code "(defn filter\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s) r (rest s)]\n        (if (pred f)\n          (cons f (filter pred r))\n          (filter pred r)))))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1825 1834]},
                               :full-name "cljs.core/filter",
                               :clj-symbol "clojure.core/filter",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "clojure.zip/branch?" {:ns "clojure.zip",
                                  :name "branch?",
                                  :signature ["[loc]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_branchQMARK",
                                  :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [64 67]},
                                  :full-name "clojure.zip/branch?",
                                  :clj-symbol "clojure.zip/branch?",
                                  :docstring "Returns true if the node at loc is a branch"},
           "special/if" {:description "If `test` is not false or nil, `then` is evaluated and returned. Otherwise,\n`else?` is evaluated and returned. `else?` defaults to nil if not provided.\n\n`if` is one of ClojureScript's [special forms](http://clojure.org/special_forms)\nand is a fundamental building block of the language. All other conditionals in\nClojureScript are based on `if`s notion of truthiness (ie: anything other than\nfalse or nil).",
                         :ns "special",
                         :name "if",
                         :signature ["[test then else?]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :related ["cljs.core/cond"
                                   "cljs.core/when"
                                   "cljs.core/if-let"
                                   "cljs.core/if-not"],
                         :full-name-encode "special_if",
                         :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name]\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (analyze env then)\n        else-expr (analyze env else)]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :children [test-expr then-expr else-expr]}))",
                                  :repo "clojurescript",
                                  :tag "r971",
                                  :filename "src/clj/cljs/compiler.clj",
                                  :lines [603 610]},
                         :examples [{:id "e591ff",
                                     :content "```clj\n(def v [1 2])\n\n(if (empty? v) \"empty!\" \"filled!\")\n;;=> \"filled!\"\n\n(str \"This vector is \"\n  (if (empty? v) \"empty!\" \"filled!\"))\n;;=> \"This vector is filled!\"\n```"}],
                         :full-name "special/if",
                         :clj-symbol "clojure.core/if"},
           "cljs.core/ObjMap" {:ns "cljs.core",
                               :name "ObjMap",
                               :type "type",
                               :signature ["[meta keys strobj]"],
                               :source {:code "(deftype ObjMap [meta keys strobj]\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.ObjMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (.-length keys))\n      (map #(vector % (aget strobj %)) keys)))\n\n  ICounted\n  (-count [coll] (.-length keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (obj-map-contains-key? k strobj (aget strobj k) not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (goog/isString k)\n      (let [new-strobj (goog.object/clone strobj)\n            overwrite? (.hasOwnProperty new-strobj k)]\n        (aset new-strobj k v)\n        (if overwrite?\n          (ObjMap. meta keys new-strobj)     ; overwrite\n          (let [new-keys (aclone keys)] ; append\n            (.push new-keys k)\n            (ObjMap. meta new-keys new-strobj))))\n      ; non-string key. game over.\n      (with-meta (into (hash-map k v) (seq coll)) meta)))\n  (-contains-key? [coll k]\n    (obj-map-contains-key? k strobj))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and (goog/isString k) (.hasOwnProperty strobj k))\n      (let [new-keys (aclone keys)\n            new-strobj (goog.object/clone strobj)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2235 2302]},
                               :full-name "cljs.core/ObjMap",
                               :full-name-encode "cljs.core_ObjMap",
                               :history [["+" "0.0-927"]]},
           "cljs.core/zipmap" {:description "Returns a map with `keys` mapped to corresponding `vals`.\n\n<pre>user=> (zipmap [:a :b :c :d] [1 2 3 4])\n{:a 1, :b 2, :c 3, :d 4}</pre>",
                               :ns "cljs.core",
                               :name "zipmap",
                               :signature ["[keys vals]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/interleave"],
                               :full-name-encode "cljs.core_zipmap",
                               :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2585 2595]},
                               :full-name "cljs.core/zipmap",
                               :clj-symbol "clojure.core/zipmap",
                               :docstring "Returns a map with the keys mapped to the corresponding vals."},
           "cljs.core/hash-combine" {:ns "cljs.core",
                                     :name "hash-combine",
                                     :type "function",
                                     :signature ["[seed hash]"],
                                     :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed (+ hash 0x9e3779b9\n                   (bit-shift-left seed 6)\n                   (bit-shift-right seed 2))))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1097 1101]},
                                     :full-name "cljs.core/hash-combine",
                                     :full-name-encode "cljs.core_hash-combine",
                                     :history [["+" "0.0-927"]]},
           "syntax/arg" {:ns "syntax",
                         :name "arg",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :full-name-encode "syntax_arg",
                         :source {:repo "clojure",
                                  :tag "clojure-1.3.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "%",
                         :full-name "syntax/arg",
                         :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/max-key" {:description "Returns the `x` for which `(k x)` is greatest.\n\n`(k x)` should return a number.",
                                :ns "cljs.core",
                                :name "max-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/max"
                                          "cljs.core/min-key"],
                                :full-name-encode "cljs.core_max-key",
                                :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2597 2602]},
                                :full-name "cljs.core/max-key",
                                :clj-symbol "clojure.core/max-key",
                                :docstring "Returns the x for which (k x), a number, is greatest."},
           "clojure.zip/insert-child" {:ns "clojure.zip",
                                       :name "insert-child",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_insert-child",
                                       :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [194 198]},
                                       :full-name "clojure.zip/insert-child",
                                       :clj-symbol "clojure.zip/insert-child",
                                       :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
           "cljs.repl.browser/send-404" {:ns "cljs.repl.browser",
                                         :name "send-404",
                                         :type "function",
                                         :signature ["[conn path]"],
                                         :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [91 97]},
                                         :full-name "cljs.repl.browser/send-404",
                                         :full-name-encode "cljs.repl.browser_send-404",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/defrecord" {:ns "cljs.core",
                                  :name "defrecord",
                                  :signature ["[rsym fields & impls]"],
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core_defrecord",
                                  :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [r (:name (cljs.compiler/resolve-var (dissoc &env :locals) rsym))]\n    `(let []\n       ~(emit-defrecord rsym r fields impls)\n       (set! (.-cljs$core$IPrintable$_pr_seq ~r) (fn [this#] (list ~(str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [386 393]},
                                  :full-name "cljs.core/defrecord",
                                  :clj-symbol "clojure.core/defrecord"},
           "cljs.repl.browser/repl-env" {:ns "cljs.repl.browser",
                                         :name "repl-env",
                                         :type "function",
                                         :signature ["[& {:as opts}]"],
                                         :source {:code "(defn repl-env [& {:as opts}]\n  (let [opts (merge {:port 9000 :optimizations :simple :working-dir \".repl\"} opts)]\n    (do (swap! server-state\n               (fn [old] (assoc old :client-js\n                               (future (create-client-js-file\n                                        opts\n                                        (io/file (:working-dir opts) \"client.js\"))))))\n        opts)))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [320 327]},
                                         :full-name "cljs.repl.browser/repl-env",
                                         :full-name-encode "cljs.repl.browser_repl-env",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/butlast" {:description "Returns a sequence of all but the last item in `s`.\n\n`butlast` runs in linear time.",
                                :ns "cljs.core",
                                :name "butlast",
                                :signature ["[s]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/first"
                                          "cljs.core/rest"
                                          "cljs.core/last"
                                          "cljs.core/next"
                                          "cljs.core/drop-last"
                                          "cljs.core/take-last"],
                                :full-name-encode "cljs.core_butlast",
                                :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2558 2562]},
                                :examples [{:id "7a4676",
                                            :content "```clj\n(butlast [1 2 3])\n;;=> (1 2)\n\n(butlast [1 2])\n;;=> (1)\n\n(butlast [1])\n;;=> nil\n\n(butlast [])\n;;=> nil\n```"}],
                                :full-name "cljs.core/butlast",
                                :clj-symbol "clojure.core/butlast"},
           "cljs.core/hash" {:ns "cljs.core",
                             :name "hash",
                             :signature ["[o]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_hash",
                             :source {:code "(defn hash [o]\n  (-hash o))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [583 584]},
                             :full-name "cljs.core/hash",
                             :clj-symbol "clojure.core/hash"},
           "cljs.core/bit-set" {:description "Set bit at index `n`.  Same as `x | (1 << y)` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-set",
                                :signature ["[x n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-clear"],
                                :full-name-encode "cljs.core_bit-set",
                                :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [968 971]},
                                :extra-sources ({:code "(defmacro bit-set [x n]\n  (list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [174 175]}),
                                :examples [{:id "6a8a49",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-set 2r1100 1)\n;;=> 14\n;; 14 = 2r1110\n```\n\nSame number in decimal:\n\n```clj\n(bit-set 12 1)\n;;=> 14\n```"}],
                                :full-name "cljs.core/bit-set",
                                :clj-symbol "clojure.core/bit-set",
                                :docstring "Set bit at index n"},
           "cljs.core/concat" {:description "Returns a lazy sequence representing the concatenation of the elements in the\nsupplied collections.",
                               :ns "cljs.core",
                               :name "concat",
                               :signature ["[]"
                                           "[x]"
                                           "[x y]"
                                           "[x y & zs]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/conj"
                                         "cljs.core/into"],
                               :full-name-encode "cljs.core_concat",
                               :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (cons (first s) (concat (rest s) y))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (cons (first xys) (cat (rest xys) zs))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1346 1364]},
                               :full-name "cljs.core/concat",
                               :clj-symbol "clojure.core/concat",
                               :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
           "cljs.core/conj" {:description "conj(oin)\n\nReturns a new collection with the `x`s \"added\" to `coll`.\n\nThe \"addition\" may happen at different \"places\" depending on the collection\ntype.\n\n`(conj nil item)` returns `(item)`.",
                             :ns "cljs.core",
                             :name "conj",
                             :signature ["[]"
                                         "[coll]"
                                         "[coll x]"
                                         "[coll x & xs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/cons"
                                       "cljs.core/into"
                                       "cljs.core/peek"
                                       "cljs.core/pop"],
                             :full-name-encode "cljs.core_conj",
                             :source {:code "(defn conj\n  ([coll x]\n     (-conj coll x))\n  ([coll x & xs]\n     (if xs\n       (recur (conj coll x) (first xs) (next xs))\n       (conj coll x))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [482 491]},
                             :full-name "cljs.core/conj",
                             :clj-symbol "clojure.core/conj",
                             :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
           "clojure.set/difference" {:description "Return a set that is the first set without elements of the remaining sets.",
                                     :ns "clojure.set",
                                     :name "difference",
                                     :signature ["[s1]"
                                                 "[s1 s2]"
                                                 "[s1 s2 & sets]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["clojure.set/union"
                                               "clojure.set/intersection"
                                               "clojure.set/superset?"
                                               "clojure.set/project"],
                                     :full-name-encode "clojure.set_difference",
                                     :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [46 58]},
                                     :full-name "clojure.set/difference",
                                     :clj-symbol "clojure.set/difference",
                                     :docstring "Return a set that is the first set without elements of the remaining sets"},
           "cljs.core/when-first" {:description "With `bindings` as `x`, `xs`, roughly the same as `(when (seq xs) (let [x (first\nxs)] body))` but `xs` is evaluated only once.",
                                   :ns "cljs.core",
                                   :name "when-first",
                                   :signature ["[bindings & body]"],
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core_when-first",
                                   :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args when-first\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when (seq ~xs)\n       (let [~x (first ~xs)]\n         ~@body))))",
                                            :repo "clojure",
                                            :tag "clojure-1.3.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [4050 4062]},
                                   :full-name "cljs.core/when-first",
                                   :clj-symbol "clojure.core/when-first",
                                   :docstring "bindings => x xs\n\nSame as (when (seq xs) (let [x (first xs)] body))"},
           "cljs.core/distinct?" {:description "Returns true if no two of the arguments are `=`",
                                  :ns "cljs.core",
                                  :name "distinct?",
                                  :signature ["[x]"
                                              "[x y]"
                                              "[x y & more]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/distinct"],
                                  :full-name-encode "cljs.core_distinctQMARK",
                                  :source {:code "(defn distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [712 726]},
                                  :examples [{:id "b32799",
                                              :content "```clj\n(distinct? 1)\n;;=> true\n\n(distinct? 1 2)\n;;=> true\n\n(distinct? 1 1)\n;;=> false\n\n(distinct? 1 2 3)\n;;=> true\n\n(distinct? 1 2 1)\n;;=> false\n```\n\nApply it a collection:\n\n```clj\n(apply distinct? [1 2 3])\n;;=> true\n\n(apply distinct? [1 2 1])\n;;=> false\n```"}],
                                  :full-name "cljs.core/distinct?",
                                  :clj-symbol "clojure.core/distinct?",
                                  :docstring "Returns true if no two of the arguments are ="},
           "syntax/set" {:description "Signifies a literal set.  Values must be unique.",
                         :ns "syntax",
                         :name "set",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["cljs.core/hash-set"
                                   "cljs.core/sorted-set"
                                   "cljs.core/sorted-set-by"],
                         :full-name-encode "syntax_set",
                         :source {:repo "clojure",
                                  :tag "clojure-1.3.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "#{}",
                         :examples [{:id "f11ab6",
                                     :content "```clj\n#{1 2 3}\n;;=> #{1 2 3}\n```\n\nDuplicate values will cause an error:\n\n```clj\n#{1 1 2 3}\n;; Error: Duplicate key: 1\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#sets",
                         :full-name "syntax/set",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.repl.rhino/repl-env" {:ns "cljs.repl.rhino",
                                       :name "repl-env",
                                       :signature ["[]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.rhino_repl-env",
                                       :source {:code "(defn repl-env\n  []\n  (let [cx (Context/enter)\n        scope (.initStandardObjects cx)\n        base (io/resource \"goog/base.js\")\n        deps (io/resource \"goog/deps.js\")\n        new-repl-env {:cx cx :scope scope}]\n    (assert base \"Can't find goog/base.js in classpath\")\n    (assert deps \"Can't find goog/deps.js in classpath\")\n    (swap! current-repl-env (fn [old] new-repl-env))\n    (with-open [r (io/reader base)]\n      (-eval r new-repl-env \"goog/base.js\" 1))\n    (-eval bootjs new-repl-env \"bootjs\" 1)\n    ;; Load deps.js line-by-line to avoid 64K method limit\n    (doseq [^String line (line-seq (io/reader deps))]\n      (-eval line new-repl-env \"goog/deps.js\" 1))\n    new-repl-env))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/clj/cljs/repl/rhino.clj",
                                                :lines [122 140]},
                                       :full-name "cljs.repl.rhino/repl-env",
                                       :docstring "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls."},
           "cljs.core/pos?" {:description "Returns true if `n` is greater than 0, false otherwise.",
                             :ns "cljs.core",
                             :name "pos?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/neg?"
                                       "cljs.core/zero?"],
                             :full-name-encode "cljs.core_posQMARK",
                             :source {:code "(defn pos?\n  [n] (cljs.core/pos? n))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [998 1000]},
                             :extra-sources ({:code "(defmacro pos? [x]\n  `(> ~x 0))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [121 122]}),
                             :full-name "cljs.core/pos?",
                             :clj-symbol "clojure.core/pos?",
                             :docstring "Returns true if num is greater than zero, else false"},
           "cljs.core/IHash" {:ns "cljs.core",
                              :name "IHash",
                              :type "protocol",
                              :full-name-encode "cljs.core_IHash",
                              :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [177 178]},
                              :methods [{:name "-hash",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IHash",
                              :history [["+" "0.0-927"]]},
           "cljs.core/is_proto_" {:ns "cljs.core",
                                  :name "is_proto_",
                                  :type "function",
                                  :signature ["[x]"],
                                  :source {:code "(defn is_proto_\n  [x]\n  (js* \"(~{x}).constructor.prototype === ~{x}\"))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [48 50]},
                                  :full-name "cljs.core/is_proto_",
                                  :full-name-encode "cljs.core_is_proto_",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/keep-indexed" {:description "Returns a lazy sequence of the non-nil results of `(f index item)`. Note, this\nmeans false return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a stateful transducer when no collection is provided.",
                                     :ns "cljs.core",
                                     :name "keep-indexed",
                                     :signature ["[f]" "[f coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/map-indexed"
                                               "cljs.core/keep"],
                                     :full-name-encode "cljs.core_keep-indexed",
                                     :source {:code "(defn keep-indexed\n  ([f coll]\n     (let [keepi (fn kpi [idx coll]\n                   (lazy-seq\n                    (when-let [s (seq coll)]\n                      (let [x (f idx (first s))]\n                        (if (nil? x)\n                          (kpi (inc idx) (rest s))\n                          (cons x (kpi (inc idx) (rest s))))))))]\n       (keepi 0 coll))))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1587 1599]},
                                     :full-name "cljs.core/keep-indexed",
                                     :clj-symbol "clojure.core/keep-indexed",
                                     :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
           "cljs.core/bit-shift-right" {:description "Bitwise shift right `n` bits.  Same as `x >> n` in JavaScript.",
                                        :ns "cljs.core",
                                        :name "bit-shift-right",
                                        :signature ["[x n]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :related ["cljs.core/bit-shift-left"
                                                  "cljs.core/unsigned-bit-shift-right"],
                                        :full-name-encode "cljs.core_bit-shift-right",
                                        :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [982 984]},
                                        :extra-sources ({:code "(defmacro bit-shift-right [x n]\n  (list 'js* \"(~{} >> ~{})\" x n))",
                                                         :repo "clojurescript",
                                                         :tag "r971",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [171
                                                                 172]}),
                                        :examples [{:id "5b75af",
                                                    :content "Bits can be entered using radix notation:\n\n```clj\n(bit-shift-right 2r1010 1)\n;;=> 5\n;; 5 = 2r0101\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-shift-right 10 1)\n;;=> 5\n```"}],
                                        :full-name "cljs.core/bit-shift-right",
                                        :clj-symbol "clojure.core/bit-shift-right",
                                        :docstring "Bitwise shift right"},
           "clojure.zip/insert-right" {:ns "clojure.zip",
                                       :name "insert-right",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_insert-right",
                                       :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [174 181]},
                                       :full-name "clojure.zip/insert-right",
                                       :clj-symbol "clojure.zip/insert-right",
                                       :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
           "cljs.core/make-hierarchy" {:ns "cljs.core",
                                       :name "make-hierarchy",
                                       :signature ["[]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core_make-hierarchy",
                                       :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [3293 3295]},
                                       :full-name "cljs.core/make-hierarchy",
                                       :clj-symbol "clojure.core/make-hierarchy",
                                       :docstring "Creates a hierarchy object for use with derive, isa? etc."},
           "cljs.core/repeat" {:description "Returns a lazy sequence of `x`s.\n\nThe length of the sequence is infinite, or `n` if provided.",
                               :ns "cljs.core",
                               :name "repeat",
                               :signature ["[x]" "[n x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/repeatedly"
                                         "cljs.core/cycle"
                                         "cljs.core/constantly"
                                         "cljs.core/dotimes"],
                               :full-name-encode "cljs.core_repeat",
                               :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1764 1767]},
                               :full-name "cljs.core/repeat",
                               :clj-symbol "clojure.core/repeat",
                               :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
           "syntax/syntax-quote" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nPrevent evaluation of the following form.\n\nAdds namespace-qualification to any symbols inside the following form by\nresolving them in the current context.\n\nAny non-namespaced symbols ending with `#` will resolve to a generated symbol\nof the same name with `_` and a unique ID appended.  All references to that\nsymbol within a syntax-quoted expression will resolve to the same generated\nsymbol.",
                                  :ns "syntax",
                                  :name "syntax-quote",
                                  :history [["+" "0.0-927"]],
                                  :type "syntax",
                                  :related ["syntax/quote"
                                            "syntax/unquote"
                                            "syntax/unquote-splicing"],
                                  :full-name-encode "syntax_syntax-quote",
                                  :source {:repo "clojure",
                                           :tag "clojure-1.3.0",
                                           :filename "src/jvm/clojure/lang/LispReader.java",
                                           :lines [nil]},
                                  :syntax-form "`",
                                  :examples [{:id "bffbdf",
                                              :content "```clj\n`foo\n;;=> cljs.user/foo\n\n`foo#\n;;=> foo__20418__auto__\n\n`(def foo 1)\n;;=> (def cljs.user/foo 1)\n```"}],
                                  :full-name "syntax/syntax-quote",
                                  :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.repl.rhino/goog-require" {:ns "cljs.repl.rhino",
                                           :name "goog-require",
                                           :type "function",
                                           :signature ["[rule]"],
                                           :source {:code "(defn goog-require [rule]\n  (when-not (contains? @loaded-libs rule)\n    (let [repl-env @current-repl-env\n          path (string/replace (comp/munge rule) \\. java.io.File/separatorChar)\n          cljs-path (str path \".cljs\")\n          js-path (str \"goog/\"\n                       (-eval (str \"goog.dependencies_.nameToPath['\" rule \"']\")\n                              repl-env\n                              \"<cljs repl>\"\n                              1))]\n      (if-let [res (io/resource cljs-path)]\n        (binding [comp/*cljs-ns* 'cljs.user]\n          (repl/load-stream repl-env res))\n        (if-let [res (io/resource js-path)]\n          (-eval (io/reader res) repl-env js-path 1)\n          (throw (Exception. (str \"Cannot find \" cljs-path \" or \" js-path \" in classpath\")))))\n      (swap! loaded-libs conj rule))))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/clj/cljs/repl/rhino.clj",
                                                    :lines [68 84]},
                                           :full-name "cljs.repl.rhino/goog-require",
                                           :full-name-encode "cljs.repl.rhino_goog-require",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/MultiFn" {:ns "cljs.core",
                                :name "MultiFn",
                                :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core_MultiFn",
                                :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n\n  (-dispatch [mf args] (do-dispatch mf dispatch-fn args))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3471 3518]},
                                :full-name "cljs.core/MultiFn",
                                :clj-symbol "clojure.lang/MultiFn"},
           "cljs.core/not-any?" {:description "Returns false if `(pred x)` is logical true for any `x` in `coll`, else true.",
                                 :ns "cljs.core",
                                 :name "not-any?",
                                 :signature ["[pred coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/every?"
                                           "cljs.core/some"],
                                 :full-name-encode "cljs.core_not-anyQMARK",
                                 :source {:code "(defn not-any?\n  [pred coll] (not (some pred coll)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1466 1469]},
                                 :full-name "cljs.core/not-any?",
                                 :clj-symbol "clojure.core/not-any?",
                                 :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
           "cljs.reader/read-regex" {:ns "cljs.reader",
                                     :name "read-regex",
                                     :type "function",
                                     :signature ["[rdr ch]"],
                                     :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-string rdr ch) re-pattern))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [301 303]},
                                     :full-name "cljs.reader/read-regex",
                                     :full-name-encode "cljs.reader_read-regex",
                                     :history [["+" "0.0-927"]]},
           "clojure.zip/next" {:ns "clojure.zip",
                               :name "next",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_next",
                               :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [206 219]},
                               :full-name "clojure.zip/next",
                               :clj-symbol "clojure.zip/next",
                               :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
           "syntax/dispatch" {:ns "syntax",
                              :name "dispatch",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :full-name-encode "syntax_dispatch",
                              :source {:repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/jvm/clojure/lang/LispReader.java",
                                       :lines [nil]},
                              :syntax-form "#",
                              :edn-doc "https://github.com/edn-format/edn#-dispatch-character",
                              :full-name "syntax/dispatch",
                              :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/IFn" {:ns "cljs.core",
                            :name "IFn",
                            :history [["+" "0.0-971"]],
                            :type "protocol",
                            :full-name-encode "cljs.core_IFn",
                            :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q s]\n    [this a b c d e f g h i j k l m n o p q s t]\n    [this a b c d e f g h i j k l m n o p q s t rest]))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [94 116]},
                            :methods [{:name "-invoke",
                                       :signature ["[this]"
                                                   "[this a]"
                                                   "[this a b]"
                                                   "[this a b c]"
                                                   "[this a b c d]"
                                                   "[this a b c d e]"
                                                   "[this a b c d e f]"
                                                   "[this a b c d e f g]"
                                                   "[this a b c d e f g h]"
                                                   "[this a b c d e f g h i]"
                                                   "[this a b c d e f g h i j]"
                                                   "[this a b c d e f g h i j k]"
                                                   "[this a b c d e f g h i j k l]"
                                                   "[this a b c d e f g h i j k l m]"
                                                   "[this a b c d e f g h i j k l m n]"
                                                   "[this a b c d e f g h i j k l m n o]"
                                                   "[this a b c d e f g h i j k l m n o p]"
                                                   "[this a b c d e f g h i j k l m n o p q]"
                                                   "[this a b c d e f g h i j k l m n o p q s]"
                                                   "[this a b c d e f g h i j k l m n o p q s t]"
                                                   "[this a b c d e f g h i j k l m n o p q s t rest]"],
                                       :docstring nil}],
                            :full-name "cljs.core/IFn",
                            :clj-symbol "clojure.lang/IFn"},
           "cljs.core/aget" {:description "Returns the value at index `i` from JavaScript arrays and objects.\n\nCan be used to retrieve nested properties with the additional `idxs` arguments.",
                             :ns "cljs.core",
                             :name "aget",
                             :signature ["[array i]"
                                         "[array i & idxs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/.."
                                       "cljs.core/aset"
                                       "cljs.core/get"
                                       "cljs.core/nth"],
                             :full-name-encode "cljs.core_aget",
                             :source {:code "(defn aget\n  [array i]\n  (cljs.core/aget array i))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [77 80]},
                             :extra-sources ({:code "(defmacro aget [a i]\n  (list 'js* \"(~{}[~{}])\" a i))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [57 58]}),
                             :examples [{:id "e36007",
                                         :content "```js\n// JavaScript\nvar a = {\"foo\": [5, 6]};\n\na[\"foo\"];\n//=> [5, 6]\n\na[\"foo\"][0];\n//=> 5\n```\n\n```clj\n;; ClojureScript\n(def a #js {:foo #js [5 6]})\n\n(aget a \"foo\")\n;;=> #js [5 6]\n\n(aget a \"foo\" 0)\n;;=> 5\n```"}
                                        {:id "c9029e",
                                         :content "```js\n// JavaScript\ndocument.location.href;\n//=> \"http://example.com\"\n```\n\nThe following are equivalent:\n\n```clj\n;; ClojureScript\n(aget js/document \"location\" \"href\")\n;;=> \"http://example.com\"\n\n(.. js/document -location -href)\n;;=> \"http://example.com\"\n```"}],
                             :full-name "cljs.core/aget",
                             :clj-symbol "clojure.core/aget",
                             :docstring "Returns the value at the index."},
           "cljs.core/if-let" {:description "When `test` is logical true, evaluates `then` with the value of `test` bound to\n`x`. Otherwise, evaluates `else` with no bindings.\n\n`else` defaults to nil.",
                               :ns "cljs.core",
                               :name "if-let",
                               :signature ["[[x test] then]"
                                           "[[x test] then else]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :related ["cljs.core/when-let"
                                         "special/if"],
                               :full-name-encode "cljs.core_if-let",
                               :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args if-let\n     (and (vector? bindings) (nil? oldform)) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                        :repo "clojure",
                                        :tag "clojure-1.3.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [1666 1683]},
                               :full-name "cljs.core/if-let",
                               :clj-symbol "clojure.core/if-let",
                               :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
           "cljs.core//" {:description "If no denominators are supplied, returns 1/numerator, else returns numerator\ndivided by all of the denominators.",
                          :ns "cljs.core",
                          :name "/",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/*" "cljs.core/quot"],
                          :full-name-encode "cljs.core_SLASH",
                          :source {:code "(defn /\n  ([x] (/ 1 x))\n  ([x y] (/ x y))\n  ([x y & more] (reduce / (/ x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [834 839]},
                          :extra-sources ({:code "(defmacro /\n  ([] 1)\n  ([x] `(/ 1 x))\n  ([x y] (list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [81 85]}),
                          :examples [{:id "824bb7",
                                      :content "```clj\n(/ 6 3)\n;;=> 2\n\n(/ 6 3 2)\n;;=> 1\n\n(/ 10)\n;;=> 0.1\n\n(/ 1 3)\n;;=> 0.3333333333333333\n```"}],
                          :full-name "cljs.core//",
                          :clj-symbol "clojure.core//",
                          :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/min-key" {:description "Returns the `x` for which `(k x)` is least.\n\n`(k x)` should return a number.",
                                :ns "cljs.core",
                                :name "min-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/min"
                                          "cljs.core/max-key"],
                                :full-name-encode "cljs.core_min-key",
                                :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2604 2609]},
                                :full-name "cljs.core/min-key",
                                :clj-symbol "clojure.core/min-key",
                                :docstring "Returns the x for which (k x), a number, is least."},
           "clojure.zip/root" {:ns "clojure.zip",
                               :name "root",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_root",
                               :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [124 133]},
                               :full-name "clojure.zip/root",
                               :clj-symbol "clojure.zip/root",
                               :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
           "cljs.core/drop-while" {:description "Returns a lazy sequence of the items in `coll` starting from the first item for\nwhich `(pred item)` returns logical false.\n\nReturns a stateful transducer when no collection is provided.",
                                   :ns "cljs.core",
                                   :name "drop-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/take-while"
                                             "cljs.core/split-with"],
                                   :full-name-encode "cljs.core_drop-while",
                                   :source {:code "(defn drop-while\n  [pred coll]\n  (let [step (fn [pred coll]\n               (let [s (seq coll)]\n                 (if (and s (pred (first s)))\n                   (recur pred (rest s))\n                   s)))]\n    (lazy-seq (step pred coll))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1742 1751]},
                                   :full-name "cljs.core/drop-while",
                                   :clj-symbol "clojure.core/drop-while",
                                   :docstring "Returns a lazy sequence of the items in coll starting from the first\nitem for which (pred item) returns nil."},
           "cljs.repl.browser/send-repl-client-page" {:ns "cljs.repl.browser",
                                                      :name "send-repl-client-page",
                                                      :type "function",
                                                      :signature ["[opts conn request]"],
                                                      :source {:code "(defn send-repl-client-page\n  [opts conn request]\n  (send-and-close conn 200\n    (str \"<html><head><meta charset=\\\"UTF-8\\\"></head><body>\n          <script type=\\\"text/javascript\\\">\"\n         (repl-client-js)\n         \"</script>\"\n         \"<script type=\\\"text/javascript\\\">\n          clojure.browser.repl.client.start(\\\"http://\" (-> request :headers :host) \"\\\");\n          </script>\"\n         \"</body></html>\")\n    \"text/html\"))",
                                                               :repo "clojurescript",
                                                               :tag "r971",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [169
                                                                       180]},
                                                      :full-name "cljs.repl.browser/send-repl-client-page",
                                                      :full-name-encode "cljs.repl.browser_send-repl-client-page",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "clojure.browser.repl/evaluate-javascript" {:ns "clojure.browser.repl",
                                                       :name "evaluate-javascript",
                                                       :signature ["[conn block]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.repl_evaluate-javascript",
                                                       :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch js/Error e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                :repo "clojurescript",
                                                                :tag "r971",
                                                                :filename "src/cljs/clojure/browser/repl.cljs",
                                                                :lines [27
                                                                        36]},
                                                       :full-name "clojure.browser.repl/evaluate-javascript",
                                                       :docstring "Process a single block of JavaScript received from the server"},
           "cljs.core/set-validator!" {:description "Sets a validator function for atom `a`.\n\n`fn` must be nil or a side-effect-free function of one argument, which will be\npassed the intended new state on any state change. `fn` should return false or\nthrow an Error if the new state is unacceptable.\n\nIf the current value of `a` is unacceptable to `fn` when `set-validator!` is\ncalled, an Error will be thrown and the validator will not be set.\n\n`(set-validator! my-atom nil)` will remove the validator from `my-atom`.",
                                       :ns "cljs.core",
                                       :name "set-validator!",
                                       :signature ["[a fn]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["cljs.core/atom"
                                                 "cljs.core/get-validator"],
                                       :full-name-encode "cljs.core_set-validatorBANG",
                                       :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [3099 3107]},
                                       :full-name "cljs.core/set-validator!",
                                       :clj-symbol "clojure.core/set-validator!",
                                       :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
           "cljs.core/<" {:description "Returns true if each successive number argument is greater than the previous\none, false otherwise.",
                          :ns "cljs.core",
                          :name "<",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/<="],
                          :full-name-encode "cljs.core_LT",
                          :source {:code "(defn <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [841 851]},
                          :extra-sources ({:code "(defmacro <\n  ([x] true)\n  ([x y] (list 'js* \"(~{} < ~{})\" x y))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [87 90]}),
                          :examples [{:id "02e6d3",
                                      :content "```clj\n(< 1 2)\n;;=> true\n\n(< 2 1)\n;;=> false\n\n(< 1 1)\n;;=> false\n\n(< 2 3 4 5 6)\n;;=> true\n```"}],
                          :full-name "cljs.core/<",
                          :clj-symbol "clojure.core/<",
                          :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
           "cljs.core/fn" {:description "Defines a function.\n\n`name?` is an optional name of the function to be used inside `body`. This is\nuseful for recursive calls. Note that `name?` in `fn` is not the same as the\n`name` argument to `defn`, which defines a global symbol for the function.\n\n`params*` are the arguments to the function and a binding form for the symbols\nthat the arguments will take inside the body of the function. Functions can have\narity of 0-20 and there is no runtime enforcement of arity when calling a\nfunction (just like in JavaScript).\n\n`prepost-map?` is an optional map with optional keys `:pre` and `:post` that\ncontain collections of [pre or post conditions](http://blog.fogus.me/2009/12/21/clojures-pre-and-post/)\nfor the function.\n\n`body` is a series of expressions that execute when the function is called. The\narguments to the function are mapped to symbols in `params*` and are available\nin `body`. The value of the last expression in `body` is the return value of\ncalling the function.",
                           :ns "cljs.core",
                           :name "fn",
                           :signature ["[name? [params*] prepost-map? body]"
                                       "[name? ([params*] prepost-map? body)+]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/defn"
                                     "cljs.core/defn-"],
                           :full-name-encode "cljs.core_fn",
                           :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) (list sigs) sigs)\n          psig (fn* [sig]\n                 (let [[params & body] sig\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                    :repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [3985 4023]},
                           :extra-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n fn (fn* fn [&form &env & decl] \n         (.withMeta ^clojure.lang.IObj (cons 'fn* decl) \n                    (.meta ^clojure.lang.IMeta &form))))",
                                            :repo "clojure",
                                            :tag "clojure-1.3.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [42 47]}),
                           :full-name "cljs.core/fn",
                           :clj-symbol "clojure.core/fn",
                           :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
           "cljs.core/split-with" {:description "Returns a vector of `[(take-while pred coll) (drop-while pred coll)]`",
                                   :ns "cljs.core",
                                   :name "split-with",
                                   :signature ["[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/split-at"
                                             "clojure.string/split"
                                             "cljs.core/take-while"
                                             "cljs.core/drop-while"],
                                   :full-name-encode "cljs.core_split-with",
                                   :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2704 2707]},
                                   :full-name "cljs.core/split-with",
                                   :clj-symbol "clojure.core/split-with",
                                   :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
           "cljs.core/IReduce" {:ns "cljs.core",
                                :name "IReduce",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IReduce",
                                :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [171 172]},
                                :methods [{:name "-reduce",
                                           :signature ["[coll f]"
                                                       "[coll f start]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IReduce",
                                :clj-symbol "clojure.lang/IReduce"},
           "cljs.reader/symbol-pattern" {:ns "cljs.reader",
                                         :name "symbol-pattern",
                                         :type "var",
                                         :source {:code "(def symbol-pattern (re-pattern \"[:]?([^0-9/].*/)?([^0-9/][^/]*)\"))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [98]},
                                         :full-name "cljs.reader/symbol-pattern",
                                         :full-name-encode "cljs.reader_symbol-pattern",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/repeatedly" {:description "Takes a function `f` of no args, presumably with side effects, and returns an\ninfinite (or length `n` if supplied) lazy sequence of calls to it.",
                                   :ns "cljs.core",
                                   :name "repeatedly",
                                   :signature ["[f]" "[n f]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/repeat"
                                             "cljs.core/iterate"
                                             "cljs.core/lazy-seq"
                                             "cljs.core/dotimes"
                                             "cljs.core/constantly"],
                                   :full-name-encode "cljs.core_repeatedly",
                                   :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1773 1778]},
                                   :full-name "cljs.core/repeatedly",
                                   :clj-symbol "clojure.core/repeatedly",
                                   :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
           "cljs.reader/read-delimited-list" {:ns "cljs.reader",
                                              :name "read-delimited-list",
                                              :type "function",
                                              :signature ["[delim rdr recursive?]"],
                                              :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a []]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF\"))\n      (if (= delim ch)\n        a\n        (if-let [macrofn (get macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (= mret rdr) a (conj a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (= o rdr) a (conj a o))))))))))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/cljs/reader.cljs",
                                                       :lines [168
                                                               181]},
                                              :full-name "cljs.reader/read-delimited-list",
                                              :full-name-encode "cljs.reader_read-delimited-list",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/undefined?" {:ns "cljs.core",
                                   :name "undefined?",
                                   :signature ["[x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_undefinedQMARK",
                                   :source {:code "(defn undefined? [x]\n  (cljs.core/undefined? x))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [652 653]},
                                   :extra-sources ({:code "(defmacro undefined? [x]\n  (list 'js* \"(void 0 === ~{})\" x))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [51 52]}),
                                   :full-name "cljs.core/undefined?"},
           "clojure.zip/prev" {:ns "clojure.zip",
                               :name "prev",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_prev",
                               :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [221 230]},
                               :full-name "clojure.zip/prev",
                               :clj-symbol "clojure.zip/prev",
                               :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
           "cljs.core/seq?" {:description "Returns true if `x` is a sequence, false otherwise.\n\nAll collections can be converted into a sequence using `seq`.",
                             :ns "cljs.core",
                             :name "seq?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/seq"
                                       "cljs.core/sequential?"
                                       "cljs.core/vector?"
                                       "cljs.core/coll?"
                                       "cljs.core/list?"
                                       "cljs.core/map?"
                                       "cljs.core/set?"],
                             :full-name-encode "cljs.core_seqQMARK",
                             :source {:code "(defn seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [658 663]},
                             :full-name "cljs.core/seq?",
                             :clj-symbol "clojure.core/seq?",
                             :docstring "Return true if s satisfies ISeq"},
           "cljs.core/odd?" {:description "Returns true if `n` is an odd number.\n\nThrows an exception if `n` is not an integer.",
                             :ns "cljs.core",
                             :name "odd?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/even?"],
                             :full-name-encode "cljs.core_oddQMARK",
                             :source {:code "(defn odd?\n  [n] (not (even? n)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1477 1479]},
                             :full-name "cljs.core/odd?",
                             :clj-symbol "clojure.core/odd?",
                             :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
           "cljs.core/cons" {:description "Returns a new sequence where `x` is the first element and `coll` is the rest.",
                             :ns "cljs.core",
                             :name "cons",
                             :signature ["[x coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/conj"],
                             :full-name-encode "cljs.core_cons",
                             :source {:code "(defn cons\n  [x seq]\n  (Cons. nil x seq))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1223 1226]},
                             :full-name "cljs.core/cons",
                             :clj-symbol "clojure.core/cons",
                             :docstring "Returns a new seq where x is the first element and seq is the rest."},
           "syntax/function" {:description "Create an anonymous function.\n\n`#(...)` = `(fn [args] (...))`\n\nUse `%` or `%1` to access the first argument.  Use `%2`, `%3` and so on to\naccess subsequent arguments.  Use `%&` to access the rest of the arguments past\nthe highest individually referenced argument.\n\nNote that `#(1)` does not create a function that returns `1`, for the same\nreason that `(1)` does evaluate to `1`.\n\n`#()` forms cannot be nested, since this would create an ambiguity between the\nautomatically assigned argument names.",
                              :ns "syntax",
                              :name "function",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :related ["cljs.core/fn"
                                        "cljs.core/defn"],
                              :full-name-encode "syntax_function",
                              :source {:repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/jvm/clojure/lang/LispReader.java",
                                       :lines [nil]},
                              :syntax-form "#()",
                              :examples [{:id "6a87de",
                                          :content "```clj\n(map #(* 2 %) [1 2 3])\n;;=> (2 4 6)\n\n(def f #(println %1 %2 %&))\n(f 1 2 3 4 5)\n;; prints: 1 2 (3 4)\n```"}],
                              :full-name "syntax/function",
                              :clj-doc "http://clojure.org/reader#toc2"},
           "special/deftype*" {:ns "special",
                               :name "deftype*",
                               :type "special form",
                               :source {:code "(defmethod parse 'deftype*\n  [_ env [_ tsym fields] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :deftype* :t t :fields fields}))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/clj/cljs/compiler.clj",
                                        :lines [849 860]},
                               :full-name "special/deftype*",
                               :full-name-encode "special_deftypeSTAR",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/read-set" {:ns "cljs.reader",
                                   :name "read-set",
                                   :type "function",
                                   :signature ["[rdr _]"],
                                   :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [297 299]},
                                   :full-name "cljs.reader/read-set",
                                   :full-name-encode "cljs.reader_read-set",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/descendants" {:ns "cljs.core",
                                    :name "descendants",
                                    :signature ["[tag]" "[h tag]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_descendants",
                                    :source {:code "(defn descendants\n  ([tag] (descendants @global-hierarchy tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3337 3344]},
                                    :full-name "cljs.core/descendants",
                                    :clj-symbol "clojure.core/descendants",
                                    :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on Java type inheritance\nrelationships."},
           "syntax/nil" {:description "`nil` is a representation of nothing.\n\nIt is common for operations to safely handle `nil` without\ncausing exceptions.\n\nExpressions evaluate to `nil` if there is no value to return.",
                         :ns "syntax",
                         :name "nil",
                         :history [["+" "0.0-927"]],
                         :type "special symbol",
                         :full-name-encode "syntax_nil",
                         :source {:repo "clojure",
                                  :tag "clojure-1.3.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "nil",
                         :examples [{:id "17b92a",
                                     :content "```clj\nnil\n;;=> nil\n```\n\n`nil` can sometimes mean \"not found\":\n\n```clj\n(:foo {})\n;;=> nil\n```\n\n`nil` can also mean that the operation didn't make sense:\n\n```clj\n(:foo nil)\n;;=> nil\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#nil",
                         :full-name "syntax/nil",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/map" {:description "Signifies a map.  Must contain pairs of key-values.  Keys and values can be any type.",
                         :ns "syntax",
                         :name "map",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["cljs.core/hash-map"
                                   "cljs.core/array-map"
                                   "cljs.core/sorted-map"
                                   "cljs.core/sorted-map-by"],
                         :full-name-encode "syntax_map",
                         :source {:repo "clojure",
                                  :tag "clojure-1.3.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "{}",
                         :examples [{:id "4696ad",
                                     :content "```clj\n{:foo 1 :bar 2}\n;;=> {:foo 1, :bar 2}\n```\n\nUse any value as a key:\n\n```clj\n(def m {[1 2] 3})\n(get m [1 2])\n;;=> 3\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#maps",
                         :full-name "syntax/map",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "special/new" {:ns "special",
                          :name "new",
                          :type "special form",
                          :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         argexprs (vec (map #(analyze enve %) args))]\n     {:env env :op :new :ctor ctorexpr :args argexprs :children (conj argexprs ctorexpr)})))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [777 783]},
                          :full-name "special/new",
                          :full-name-encode "special_new",
                          :clj-symbol "clojure.core/new",
                          :history [["+" "0.0-927"]]},
           "cljs.core/take-nth" {:description "Returns a lazy seq of every `n`th item in `coll`.\n\nReturns a stateful transducer when no collection is provided.",
                                 :ns "cljs.core",
                                 :name "take-nth",
                                 :signature ["[n]" "[n coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_take-nth",
                                 :source {:code "(defn take-nth\n  [n coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s) (take-nth n (drop n s))))))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2697 2702]},
                                 :full-name "cljs.core/take-nth",
                                 :clj-symbol "clojure.core/take-nth",
                                 :docstring "Returns a lazy seq of every nth item in coll."},
           "cljs.reader/throwing-reader" {:ns "cljs.reader",
                                          :name "throwing-reader",
                                          :type "function",
                                          :signature ["[msg]"],
                                          :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [282 285]},
                                          :full-name "cljs.reader/throwing-reader",
                                          :full-name-encode "cljs.reader_throwing-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/even?" {:description "Returns true if `n` is an even number.\n\nThrows an exception if `n` is not an integer.",
                              :ns "cljs.core",
                              :name "even?",
                              :signature ["[n]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/odd?"],
                              :full-name-encode "cljs.core_evenQMARK",
                              :source {:code "(defn even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1471 1475]},
                              :full-name "cljs.core/even?",
                              :clj-symbol "clojure.core/even?",
                              :docstring "Returns true if n is even, throws an exception if n is not an integer"},
           "syntax/number" {:description "Signifies a number.  ClojureScript numbers are the same as JavaScript numbers;\nthey are represented as double-precision 64-bit format IEEE 754 values.",
                            :ns "syntax",
                            :name "number",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :full-name-encode "syntax_number",
                            :source {:repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form " ",
                            :examples [{:id "f96060",
                                        :content "```clj\n123\n;;=> 123\n\n123.45\n;;=> 123.45\n```\n\nScientific notation;\n\n```clj\n12e3\n;;=> 12000\n\n1.2e-3\n;;=> 0.0012\n```\n\nStandard hex and octal notations:\n\n```clj\n0x1f\n;;=> 31\n\n010\n;;=> 8\n```\n\nRadix notation for using up to base 36.\n\n```clj\n2r10111\n;;=> 23\n\n8r32\n;;=> 26\n\n16rFF\n;;=> 255\n\n36rZ\n;;=> 35\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#integers",
                            :full-name "syntax/number",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "special/fn*" {:ns "special",
                          :name "fn*",
                          :type "special form",
                          :source {:code "(defmethod parse 'fn*\n  [op env [_ & args] name]\n  (let [[name meths] (if (symbol? (first args))\n                       [(first args) (next args)]\n                       [name (seq args)])\n        ;;turn (fn [] ...) into (fn ([]...))\n        meths (if (vector? (first meths)) (list meths) meths)\n        mname (when name (munge name))\n        locals (:locals env)\n        locals (if name (assoc locals name {:name mname}) locals)\n        menv (if (> (count meths) 1) (assoc env :context :expr) env)\n        methods (map #(analyze-fn-method menv locals %) meths)\n        max-fixed-arity (apply max (map :max-fixed-arity methods))\n        variadic (boolean (some :variadic methods))]\n    ;;todo - validate unique arities, at most one variadic, variadic takes max required args\n    {:env env :op :fn :name mname :methods methods :variadic variadic :recur-frames *recur-frames*\n     :jsdoc [(when variadic \"@param {...*} var_args\")]\n     :max-fixed-arity max-fixed-arity}))",
                                   :repo "clojurescript",
                                   :tag "r971",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [706 723]},
                          :full-name "special/fn*",
                          :full-name-encode "special_fnSTAR",
                          :history [["+" "0.0-927"]]},
           "clojure.set/subset?" {:description "Returns true if `a` is a subset of `b`, false otherwise.\n\nIn other words, returns true if all the elements of `a` can be found in `b`.",
                                  :ns "clojure.set",
                                  :name "subset?",
                                  :signature ["[a b]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/set"
                                            "cljs.core/set?"
                                            "clojure.set/superset?"],
                                  :full-name-encode "clojure.set_subsetQMARK",
                                  :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [132 136]},
                                  :full-name "clojure.set/subset?",
                                  :clj-symbol "clojure.set/subset?",
                                  :docstring "Is set1 a subset of set2?"},
           "cljs.core/flush" {:ns "cljs.core",
                              :name "flush",
                              :signature ["[]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_flush",
                              :source {:code "(defn flush [] ;stub\n  nil)",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2856 2857]},
                              :full-name "cljs.core/flush",
                              :clj-symbol "clojure.core/flush"},
           "cljs.reader/reader-error" {:ns "cljs.reader",
                                       :name "reader-error",
                                       :type "function",
                                       :signature ["[rdr & msg]"],
                                       :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (apply str msg)))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [69 71]},
                                       :full-name "cljs.reader/reader-error",
                                       :full-name-encode "cljs.reader_reader-error",
                                       :history [["+" "0.0-927"]]},
           "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                           :name "prewalk-replace",
                                           :signature ["[smap form]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk_prewalk-replace",
                                           :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [80 86]},
                                           :full-name "clojure.walk/prewalk-replace",
                                           :clj-symbol "clojure.walk/prewalk-replace",
                                           :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
           "cljs.core/*1" {:description "Only usable from a REPL.\n\nHolds the result of the last expression.",
                           :ns "cljs.core",
                           :name "*1",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*2"
                                     "cljs.core/*3"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR1",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [23 25]},
                           :examples [{:id "30a861",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n*1\n;;=> 10\n\n(inc *1)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*1",
                           :clj-symbol "clojure.core/*1",
                           :docstring "bound in a repl thread to the most recent value printed"},
           "cljs.core/Set.EMPTY" {:ns "cljs.core",
                                  :name "Set.EMPTY",
                                  :type "var",
                                  :parent-type "Set",
                                  :source {:code "(set! cljs.core.Set/EMPTY (Set. nil (hash-map)))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2519]},
                                  :full-name "cljs.core/Set.EMPTY",
                                  :full-name-encode "cljs.core_SetDOTEMPTY",
                                  :history [["+" "0.0-927"]]},
           "cljs.reader/read-unicode-char" {:ns "cljs.reader",
                                            :name "read-unicode-char",
                                            :type "function",
                                            :signature ["[reader initch]"],
                                            :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [145 147]},
                                            :full-name "cljs.reader/read-unicode-char",
                                            :full-name-encode "cljs.reader_read-unicode-char",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/dissoc" {:description "dissoc(iate)\n\nReturns a new map that does not contain a mapping for key(s).\n\nHas no effect on the map type (hashed/sorted).",
                               :ns "cljs.core",
                               :name "dissoc",
                               :signature ["[coll]"
                                           "[coll k]"
                                           "[coll k & ks]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/assoc"
                                         "cljs.core/disj"
                                         "cljs.core/select-keys"],
                               :full-name-encode "cljs.core_dissoc",
                               :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n     (-dissoc coll k))\n  ([coll k & ks]\n     (let [ret (dissoc coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [534 544]},
                               :examples [{:id "fd6ae9",
                                           :content "```clj\n(dissoc {:key \"value\" :key2 \"value2\"} :key)\n;;=> {:key2 \"value2\"}\n```"}],
                               :full-name "cljs.core/dissoc",
                               :clj-symbol "clojure.core/dissoc",
                               :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
           "cljs.core/ffirst" {:description "Same as `(first (first coll))`.",
                               :ns "cljs.core",
                               :name "ffirst",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/first"
                                         "cljs.core/fnext"
                                         "cljs.core/nfirst"],
                               :full-name-encode "cljs.core_ffirst",
                               :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [440 443]},
                               :examples [{:id "575ba2",
                                           :content "```clj\n(ffirst [[1 2] [3 4] [5 6]])\n;;=> 1\n```"}],
                               :full-name "cljs.core/ffirst",
                               :clj-symbol "clojure.core/ffirst",
                               :docstring "Same as (first (first x))"},
           "clojure.zip/replace" {:ns "clojure.zip",
                                  :name "replace",
                                  :signature ["[loc node]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_replace",
                                  :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [183 187]},
                                  :full-name "clojure.zip/replace",
                                  :clj-symbol "clojure.zip/replace",
                                  :docstring "Replaces the node at this loc, without moving"},
           "cljs.core/vec" {:description "Creates a new vector containing the contents of `coll`",
                            :ns "cljs.core",
                            :name "vec",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/vector"
                                      "cljs.core/vector?"],
                            :full-name-encode "cljs.core_vec",
                            :source {:code "(defn vec [coll]\n  (reduce conj cljs.core.Vector/EMPTY coll))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2022 2023]},
                            :full-name "cljs.core/vec",
                            :clj-symbol "clojure.core/vec"},
           "cljs.core/or" {:description "Evaluates arguments one at a time from left to right. If an argument returns\nlogical true, `or` returns that value and doesn't evaluate any of the other\narguments, otherwise it returns the value of the last argument.\n\n`(or)` returns nil.",
                           :ns "cljs.core",
                           :name "or",
                           :signature ["[]" "[x]" "[x & next]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/and" "special/if"],
                           :full-name-encode "cljs.core_or",
                           :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n      `(let [or# ~x]\n         (if or# or# (or ~@next)))))",
                                    :repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [789 799]},
                           :examples [{:id "d50433",
                                       :content "```clj\n(or)\n;;=> nil\n\n(or false)\n;;=> false\n\n(or true)\n;;=> true\n\n(or true true)\n;;=> true\n\n(or true false)\n;;=> true\n\n(or false false)\n;;=> false\n```"}
                                      {:id "62f291",
                                       :content "`nil` and `false` are the only falsy values and everything else is truthy:\n\n```clj\n(or \"foo\" \"bar\")\n;;=> \"bar\"\n\n(or \"foo\" nil)\n;;=> \"foo\"\n\n(or \"foo\" false)\n;;=> \"foo\"\n\n(or nil \"foo\")\n;;=> \"foo\"\n\n(or false \"foo\")\n;;=> \"foo\"\n```"}],
                           :full-name "cljs.core/or",
                           :clj-symbol "clojure.core/or",
                           :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
           "cljs.core/mod" {:description "Returns the modulus of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).\n\nTruncates toward negative infinity.",
                            :ns "cljs.core",
                            :name "mod",
                            :signature ["[n d]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/rem"],
                            :full-name-encode "cljs.core_mod",
                            :source {:code "(defn mod\n  [n d]\n  (cljs.core/mod n d))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [912 915]},
                            :extra-sources ({:code "(defmacro mod [num div]\n  (list 'js* \"(~{} % ~{})\" num div))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [137 138]}),
                            :examples [{:id "8165e8",
                                        :content "```clj\n(mod -5 3)\n;;=> 1\n\n(mod 5 3)\n;;=> 2\n\n(mod 5 0)\n;;=> NaN\n```"}],
                            :full-name "cljs.core/mod",
                            :clj-symbol "clojure.core/mod",
                            :docstring "Modulus of num and div. Truncates toward negative infinity."},
           "cljs.core/aset" {:description "Sets `val` at index `i` in JavaScript arrays and objects.\n\nCan be used to set nested properties with the additional `idxs` arguments.",
                             :ns "cljs.core",
                             :name "aset",
                             :signature ["[array i val]"
                                         "[array idx idx2 & idxv]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/aget"
                                       "special/set!"
                                       "cljs.core/assoc-in"],
                             :full-name-encode "cljs.core_aset",
                             :source {:code "(defn aset\n  [array i val]\n  (cljs.core/aset array i val))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [82 85]},
                             :extra-sources ({:code "(defmacro aset [a i v]\n  (list 'js* \"(~{}[~{}] = ~{})\" a i v))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [60 61]}),
                             :examples [{:id "d1aa58",
                                         :content "```js\n// JavaScript\nvar a = {\"foo\": 3, \"bar\": [4, 5]};\n\na[\"foo\"] = 4;\na;\n//=> {\"foo\": 4, \"bar\": [4, 5]}\n\na[\"bar\"][0] = 6;\na;\n//=> {\"foo\": 4, \"bar\": [6, 5]}\n```\n\n```clj\n;; ClojureScript\n(def a #js {:foo 3, :bar #js [4 5]})\n\n(aset a \"foo\" 4)\na\n;;=> #js {:foo 4, :bar #js [4 5]}\n\n(aset a \"bar\" 0 6)\na\n;;=> #js {:foo 4, :bar #js [6 5]}\n```"}
                                        {:id "34bbf3",
                                         :content "```js\n// JavaScript\ndocument.location.href = \"http://example.com\";\n```\n\n```clj\n;; ClojureScript\n(aset js/document \"location\" \"href\" \"http://example.com\")\n```"}],
                             :full-name "cljs.core/aset",
                             :clj-symbol "clojure.core/aset",
                             :docstring "Sets the value at the index."},
           "cljs.core/second" {:description "Returns the second item in `coll`.\n\nSame as `(first (next coll))`",
                               :ns "cljs.core",
                               :name "second",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/first"
                                         "cljs.core/nth"
                                         "cljs.core/fnext"
                                         "cljs.core/next"],
                               :full-name-encode "cljs.core_second",
                               :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [435 438]},
                               :full-name "cljs.core/second",
                               :clj-symbol "clojure.core/second",
                               :docstring "Same as (first (next x))"},
           "clojure.set/rename" {:ns "clojure.set",
                                 :name "rename",
                                 :signature ["[xrel kmap]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set_rename",
                                 :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [83 86]},
                                 :full-name "clojure.set/rename",
                                 :clj-symbol "clojure.set/rename",
                                 :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/delay?" {:ns "cljs.core",
                               :name "delay?",
                               :signature ["[x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_delayQMARK",
                               :source {:code "(defn delay?\n  [x] (instance? cljs.core.Delay x))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3200 3202]},
                               :full-name "cljs.core/delay?",
                               :clj-symbol "clojure.core/delay?",
                               :docstring "returns true if x is a Delay created with delay"},
           "clojure.zip/left" {:ns "clojure.zip",
                               :name "left",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_left",
                               :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [150 155]},
                               :full-name "clojure.zip/left",
                               :clj-symbol "clojure.zip/left",
                               :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
           "cljs.reader/not-implemented" {:ns "cljs.reader",
                                          :name "not-implemented",
                                          :type "function",
                                          :signature ["[rdr ch]"],
                                          :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [187 189]},
                                          :full-name "cljs.reader/not-implemented",
                                          :full-name-encode "cljs.reader_not-implemented",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/IAssociative" {:ns "cljs.core",
                                     :name "IAssociative",
                                     :history [["+" "0.0-927"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core_IAssociative",
                                     :source {:code "(defprotocol IAssociative\n  (-contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (-assoc [coll k v]))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [140 143]},
                                     :methods [{:name "-contains-key?",
                                                :signature ["[coll k]"],
                                                :docstring nil}
                                               {:name "-assoc",
                                                :signature ["[coll k v]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IAssociative",
                                     :clj-symbol "clojure.lang/Associative"},
           "cljs.core/ObjMap.EMPTY" {:ns "cljs.core",
                                     :name "ObjMap.EMPTY",
                                     :type "var",
                                     :parent-type "ObjMap",
                                     :source {:code "(set! cljs.core.ObjMap/EMPTY (ObjMap. nil (array) (js-obj)))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2304]},
                                     :full-name "cljs.core/ObjMap.EMPTY",
                                     :full-name-encode "cljs.core_ObjMapDOTEMPTY",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/group-by" {:description "Returns a map of the elements of `coll` keyed by the result of running `f` on\neach element.\n\nThe value at each key will be a vector of the corresponding elements in the\norder they appeared in `coll`.",
                                 :ns "cljs.core",
                                 :name "group-by",
                                 :signature ["[f coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/partition-by"
                                           "cljs.core/frequencies"],
                                 :full-name-encode "cljs.core_group-by",
                                 :source {:code "(defn group-by\n  [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} coll))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3282 3291]},
                                 :full-name "cljs.core/group-by",
                                 :clj-symbol "clojure.core/group-by",
                                 :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
           "cljs.core/symbol" {:ns "cljs.core",
                               :name "symbol",
                               :signature ["[name]" "[ns name]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_symbol",
                               :source {:code "(defn symbol\n  ([name] (cond (symbol? name) name\n                (keyword? name) (str* \"\\uFDD1\" \"'\" (subs name 2)))\n     :else (str* \"\\uFDD1\" \"'\" name))\n  ([ns name] (symbol (str* ns \"/\" name))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1068 1073]},
                               :full-name "cljs.core/symbol",
                               :clj-symbol "clojure.core/symbol",
                               :docstring "Returns a Symbol with the given namespace and name."},
           "cljs.core/Delay" {:ns "cljs.core",
                              :name "Delay",
                              :signature ["[f state]"],
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core_Delay",
                              :source {:code "(deftype Delay [f state]\n\n  IDeref\n  (-deref [_]\n    (when-not @state\n      (swap! state f))\n    @state)\n\n  IPending\n  (-realized? [d]\n    (not (nil? @state))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3180 3190]},
                              :full-name "cljs.core/Delay",
                              :clj-symbol "clojure.lang/Delay"},
           "cljs.core/methods" {:ns "cljs.core",
                                :name "methods",
                                :signature ["[multifn]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_methods",
                                :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3542 3544]},
                                :full-name "cljs.core/methods",
                                :clj-symbol "clojure.core/methods",
                                :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
           "cljs.core/vector" {:description "Creates a new vector containing `args`.",
                               :ns "cljs.core",
                               :name "vector",
                               :signature ["[& args]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/vec"
                                         "cljs.core/vector?"
                                         "cljs.core/pop"
                                         "cljs.core/into"],
                               :full-name-encode "cljs.core_vector",
                               :source {:code "(defn vector [& args] (vec args))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2025]},
                               :full-name "cljs.core/vector",
                               :clj-symbol "clojure.core/vector"},
           "cljs.core/rand-int" {:description "Returns a random integer between 0 inclusive and `n` exclusive.",
                                 :ns "cljs.core",
                                 :name "rand-int",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/rand"],
                                 :full-name-encode "cljs.core_rand-int",
                                 :source {:code "(defn rand-int\n  [n] (js* \"Math.floor(Math.random() * ~{n})\"))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3271 3273]},
                                 :extra-sources ({:code "(defn rand-int\n  [n] (fix (rand n)))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [934 936]}),
                                 :full-name "cljs.core/rand-int",
                                 :clj-symbol "clojure.core/rand-int",
                                 :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
           "cljs.core/PersistentQueue.EMPTY" {:ns "cljs.core",
                                              :name "PersistentQueue.EMPTY",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :parent-type "PersistentQueue",
                                              :type "var",
                                              :full-name-encode "cljs.core_PersistentQueueDOTEMPTY",
                                              :source {:code "(set! cljs.core.PersistentQueue/EMPTY (PersistentQueue. nil 0 nil []))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [2190]},
                                              :full-name "cljs.core/PersistentQueue.EMPTY",
                                              :clj-symbol "clojure.lang/PersistentQueue.EMPTY"},
           "cljs.core/letfn" {:description "Takes a vector of function definitions `fnspecs` and binds the functions to\ntheir names. All of the names are available in all of the definitions of the\nfunctions as well as `body`.\n\n`fnspecs` must be a vector with an even number of forms. See `let`.\n\n`letfn` is a wrapper over one of ClojureScript's [special forms].\n\n[special forms]:http://clojure.org/special_forms",
                              :ns "cljs.core",
                              :name "letfn",
                              :signature ["[fnspecs & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/let"],
                              :full-name-encode "cljs.core_letfn",
                              :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                       :repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5751 5762]},
                              :full-name "cljs.core/letfn",
                              :clj-symbol "clojure.core/letfn",
                              :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
           "cljs.reader/read-discard" {:ns "cljs.reader",
                                       :name "read-discard",
                                       :type "function",
                                       :signature ["[rdr _]"],
                                       :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [305 308]},
                                       :full-name "cljs.reader/read-discard",
                                       :full-name-encode "cljs.reader_read-discard",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/inc" {:description "Returns a number one greater than `x`.",
                            :ns "cljs.core",
                            :name "inc",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/dec"],
                            :full-name-encode "cljs.core_inc",
                            :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [307 309]},
                            :extra-sources ({:code "(defmacro inc [x]\n  `(+ ~x 1))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [115 116]}),
                            :full-name "cljs.core/inc",
                            :clj-symbol "clojure.core/inc",
                            :docstring "Returns a number one greater than num."},
           "cljs.core/name" {:description "Returns a string value of a keyword, string, or symbol.\n\n`(name :foo)` => `\"foo\"`\n\n`(name \"foo\")` => `\"foo\"`\n\n`(name 'foo)` => `\"foo\"`",
                             :ns "cljs.core",
                             :name "name",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_name",
                             :source {:code "(defn name\n  [x]\n  (cond\n    (string? x) x\n    (or (keyword? x) (symbol? x))\n      (let [i (.lastIndexOf x \"/\")]\n        (if (< i 0)\n          (subs x 2)\n          (subs x (inc i))))\n    :else (throw (js/Error. (str \"Doesn't support name: \" x)))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2564 2574]},
                             :full-name "cljs.core/name",
                             :clj-symbol "clojure.core/name",
                             :docstring "Returns the name String of a string, symbol or keyword."},
           "cljs.core/cycle" {:description "Returns an infinite lazy sequence of repetitions of the items in `coll`.",
                              :ns "cljs.core",
                              :name "cycle",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/lazy-seq"
                                        "cljs.core/repeatedly"],
                              :full-name-encode "cljs.core_cycle",
                              :source {:code "(defn cycle\n  [coll] (lazy-seq \n          (when-let [s (seq coll)] \n            (concat s (cycle s)))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1753 1757]},
                              :full-name "cljs.core/cycle",
                              :clj-symbol "clojure.core/cycle",
                              :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
           "cljs.core/map" {:description "Returns a lazy sequence of applying function `f` to every element of `coll`.\n\nWhen more than one collection is provided, returns a lazy sequence consisting of\nthe result of applying `f` to the set of first items of each `c`, followed by\napplying `f` to the set of second items in each `c`, until any one of the `c`s\nis exhausted. Any remaining items in other `c`s are ignored. Function `f` should\naccept number-of-`c`s arguments.\n\nReturns a transducer when no collection is provided.",
                            :ns "cljs.core",
                            :name "map",
                            :signature ["[f]"
                                        "[f coll]"
                                        "[f c1 c2]"
                                        "[f c1 c2 c3]"
                                        "[f c1 c2 c3 & colls]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/map-indexed"
                                      "cljs.core/amap"
                                      "cljs.core/mapcat"
                                      "cljs.core/keep"
                                      "cljs.core/juxt"],
                            :full-name-encode "cljs.core_map",
                            :source {:code "(defn map\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (cons (f (first s)) (map f (rest s))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1679 1707]},
                            :full-name "cljs.core/map",
                            :clj-symbol "clojure.core/map",
                            :docstring "Returns a lazy sequence consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "syntax/list" {:description "Signifies a literal list.  When evaluated, it is interpreted as a call to some\ncode.  The first argument is called with the subsequent arguments.",
                          :ns "syntax",
                          :name "list",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :related ["syntax/vector" "syntax/quote"],
                          :full-name-encode "syntax_list",
                          :source {:repo "clojure",
                                   :tag "clojure-1.3.0",
                                   :filename "src/jvm/clojure/lang/LispReader.java",
                                   :lines [nil]},
                          :syntax-form "()",
                          :examples [{:id "cd26b0",
                                      :content "The following is a list that is evaluated to create var `a`:\n\n```clj\n(def a 1)\n```\n\nAn empty list is unevaluated and left as an empty list:\n\n```clj\n()\n;;=> ()\n```\n\nTo signify an unevaluated list, precede it with a quote:\n\n```clj\n'(1 2 3)\n;;=> (1 2 3)\n```"}],
                          :edn-doc "https://github.com/edn-format/edn#lists",
                          :full-name "syntax/list",
                          :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/amap" {:description "For quickly creating a new JavaScript array by mapping an expression `expr`\nacross a JavaScript array `a`.  The expression can use `ret` as the current\nresult, which is initialized to `a`.  It can also use `idx` to get the current\nindex.",
                             :ns "cljs.core",
                             :name "amap",
                             :signature ["[a idx ret expr]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/map"],
                             :full-name-encode "cljs.core_amap",
                             :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [642 655]},
                             :examples [{:id "3a7471",
                                         :content "```clj\n(def a #js [1 2 3])\n(amap a i ret (* 10 (aget a i)))\n;;=> #js [10 20 30]\n```"}
                                        {:id "0f57af",
                                         :content "You can also use `ret` inside the mapped expression if you want to use the\ncurrent result:\n\n```clj\n(def a #js [1 2 3])\n(amap a i ret (+ (if (pos? i)\n                   (aget ret (dec i))\n                   0)\n                 (* 10 (aget a i))))\n;;=> #js [10 30 60]\n```"}],
                             :full-name "cljs.core/amap",
                             :clj-symbol "clojure.core/amap",
                             :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting \neach element of ret to the evaluation of expr, returning the new \narray ret."},
           "clojure.zip/children" {:ns "clojure.zip",
                                   :name "children",
                                   :signature ["[loc]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip_children",
                                   :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [69 74]},
                                   :full-name "clojure.zip/children",
                                   :clj-symbol "clojure.zip/children",
                                   :docstring "Returns a seq of the children of node at loc, which must be a branch"},
           "special/set!" {:description "Sets `js-var` to `val` using the JavaScript `=` operator.",
                           :ns "special",
                           :name "set!",
                           :signature ["[js-var val]"],
                           :history [["+" "0.0-927"]],
                           :type "special form",
                           :related ["cljs.core/aset"
                                     "cljs.core/reset!"],
                           :full-name-encode "special_setBANG",
                           :source {:code "(defmethod parse 'set!\n  [_ env [_ target val] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         targetexpr (if (symbol? target)\n                      (do\n                        (let [local (-> env :locals target)]\n                          (assert (or (nil? local)\n                                      (and (:field local)\n                                           (:mutable local)))\n                                  \"Can't set! local var or non-mutable field\"))\n                        (analyze-symbol enve target))\n                      (when (seq? target)\n                        (let [targetexpr (analyze-seq enve target nil)]\n                          (when (:field targetexpr)\n                            targetexpr))))\n         valexpr (analyze enve val)]\n     (assert targetexpr \"set! target must be a field or a symbol naming a var\")\n     {:env env :op :set! :target targetexpr :val valexpr :children [targetexpr valexpr]})))",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [785 803]},
                           :full-name "special/set!",
                           :clj-symbol "clojure.core/set!"},
           "cljs.core/when-not" {:description "Evaluates `test`. If logical false, evaluates `body` in an implicit `do`.",
                                 :ns "cljs.core",
                                 :name "when-not",
                                 :signature ["[test & body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/when"
                                           "cljs.core/when-let"
                                           "special/if"],
                                 :full-name-encode "cljs.core_when-not",
                                 :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                          :repo "clojure",
                                          :tag "clojure-1.3.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [460 464]},
                                 :full-name "cljs.core/when-not",
                                 :clj-symbol "clojure.core/when-not",
                                 :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
           "clojure.set/index" {:ns "clojure.set",
                                :name "index",
                                :signature ["[xrel ks]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set_index",
                                :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [88 96]},
                                :full-name "clojure.set/index",
                                :clj-symbol "clojure.set/index",
                                :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
           "cljs.repl.browser/send-and-close" {:ns "cljs.repl.browser",
                                               :name "send-and-close",
                                               :signature ["[conn status form]"
                                                           "[conn status form content-type]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser_send-and-close",
                                               :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                        :repo "clojurescript",
                                                        :tag "r971",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [68 89]},
                                               :full-name "cljs.repl.browser/send-and-close",
                                               :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response."},
           "clojure.browser.dom/log" {:ns "clojure.browser.dom",
                                      :name "log",
                                      :type "function",
                                      :signature ["[& args]"],
                                      :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/clojure/browser/dom.cljs",
                                               :lines [19 20]},
                                      :full-name "clojure.browser.dom/log",
                                      :full-name-encode "clojure.browser.dom_log",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.fromArray" {:ns "cljs.core",
                                         :name "Vector.fromArray",
                                         :signature ["[xs]"],
                                         :history [["+" "0.0-927"]],
                                         :parent-type "Vector",
                                         :type "function",
                                         :full-name-encode "cljs.core_VectorDOTfromArray",
                                         :source {:code "(set! cljs.core.Vector/fromArray (fn [xs] (Vector. nil xs)))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2020]},
                                         :full-name "cljs.core/Vector.fromArray"},
           "cljs.core/partition-by" {:description "Applies `f` to each value in `coll`, splitting it each time `f` returns a new\nvalue. Returns a lazy sequence of partitions.\n\nReturns a stateful transducer when no collection is provided.",
                                     :ns "cljs.core",
                                     :name "partition-by",
                                     :signature ["[f]" "[f coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/partition"
                                               "cljs.core/partition-all"
                                               "cljs.core/group-by"],
                                     :full-name-encode "cljs.core_partition-by",
                                     :source {:code "(defn partition-by\n  [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           fv (f fst)\n           run (cons fst (take-while #(= fv (f %)) (next s)))]\n       (cons run (partition-by f (seq (drop (count run) s))))))))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2709 2718]},
                                     :full-name "cljs.core/partition-by",
                                     :clj-symbol "clojure.core/partition-by",
                                     :docstring "Applies f to each value in coll, splitting it each time f returns\na new value.  Returns a lazy seq of partitions."},
           "cljs.core/sort-by" {:description "Returns a sorted sequence of the items in `coll`, where the sort order is\ndetermined by comparing `(keyfn item)`.\n\n`comp` can be boolean-valued comparison function, or a -/0/+ valued comparator.\n\n`comp` defaults to `compare`.",
                                :ns "cljs.core",
                                :name "sort-by",
                                :signature ["[keyfn coll]"
                                            "[keyfn comp coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/sort"
                                          "cljs.core/compare"],
                                :full-name-encode "cljs.core_sort-by",
                                :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [765 773]},
                                :full-name "cljs.core/sort-by",
                                :clj-symbol "clojure.core/sort-by",
                                :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.core/with-meta" {:description "Returns an object of the same type and value as `obj`, with map `m` as its\nmetadata.",
                                  :ns "cljs.core",
                                  :name "with-meta",
                                  :signature ["[obj m]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/alter-meta!"
                                            "cljs.core/vary-meta"],
                                  :full-name-encode "cljs.core_with-meta",
                                  :source {:code "(defn with-meta\n  [o meta]\n  (-with-meta o meta))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [546 550]},
                                  :examples [{:id "f189d4",
                                              :content "```clj\n(def a ^:foo [1 2 3])\n(def b (with-meta a {:bar true}))\n\n(= a b)\n;;=> true\n\n(meta a)\n;;=> {:foo true}\n\n(meta b)\n;;=> {:bar true}\n```"}],
                                  :full-name "cljs.core/with-meta",
                                  :clj-symbol "clojure.core/with-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
           "cljs.core/NeverEquiv" {:ns "cljs.core",
                                   :name "NeverEquiv",
                                   :type "type",
                                   :signature ["[]"],
                                   :source {:code "(deftype NeverEquiv []\n  IEquiv\n  (-equiv [o other] false))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2192 2194]},
                                   :full-name "cljs.core/NeverEquiv",
                                   :full-name-encode "cljs.core_NeverEquiv",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/select-keys" {:description "Returns a map containing only those entries in `map` whose key is in `keys`.",
                                    :ns "cljs.core",
                                    :name "select-keys",
                                    :signature ["[map keys]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_select-keys",
                                    :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        ret)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2454 2466]},
                                    :full-name "cljs.core/select-keys",
                                    :clj-symbol "clojure.core/select-keys",
                                    :docstring "Returns a map containing only those entries in map whose key is in keys"},
           "special/loop*" {:ns "special",
                            :name "loop*",
                            :type "special form",
                            :source {:code "(defmethod parse 'loop*\n  [op encl-env form _]\n  (analyze-let encl-env form true))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [758 760]},
                            :full-name "special/loop*",
                            :full-name-encode "special_loopSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.core/ISeq" {:ns "cljs.core",
                             :name "ISeq",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core_ISeq",
                             :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (-rest [coll]))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [133 135]},
                             :methods [{:name "-first",
                                        :signature ["[coll]"],
                                        :docstring nil}
                                       {:name "-rest",
                                        :signature ["[coll]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISeq",
                             :clj-symbol "clojure.lang/ISeq"},
           "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                            :name "postwalk-replace",
                                            :signature ["[smap form]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.walk_postwalk-replace",
                                            :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/cljs/clojure/walk.cljs",
                                                     :lines [88 94]},
                                            :full-name "clojure.walk/postwalk-replace",
                                            :clj-symbol "clojure.walk/postwalk-replace",
                                            :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
           "cljs.core/pr-with-opts" {:ns "cljs.core",
                                     :name "pr-with-opts",
                                     :signature ["[objs opts]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_pr-with-opts",
                                     :source {:code "(defn pr-with-opts\n  [objs opts]\n  (let [first-obj (first objs)]\n    (doseq [obj objs]\n      (when-not (identical? obj first-obj)\n        (string-print \" \"))\n      (doseq [string (pr-seq obj opts)]\n        (string-print string)))))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2885 2894]},
                                     :full-name "cljs.core/pr-with-opts",
                                     :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts"},
           "cljs.core/->>" {:description "The thread-last macro \"threads\" an expression through several forms as the last\nitem in a list.\n\nInserts `x` as the last item in the first form, making a list of it if it is not\na list already. If there are more forms, inserts the first form as the last item\nin second form, etc.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(->> x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x y z (d (a b c x)))</pre></td></tr></tbody></table>",
                            :ns "cljs.core",
                            :name "->>",
                            :signature ["[x & forms]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/->"],
                            :full-name-encode "cljs.core_-GTGT",
                            :source {:code "(defmacro ->>\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x)))\n  ([x form & more] `(->> (->> ~x ~form) ~@more)))",
                                     :repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [1540 1549]},
                            :examples [{:id "1dc72c",
                                        :content "Sequence transformation functions often take a sequence as the last argument,\nthus the thread-last macro is commonly used with them.  Here we compute the sum\nof the first 10 even squares:\n\n```clj\n(->> (range)\n     (map #(* % %))\n     (filter even?)\n     (take 10)\n     (reduce +))\n;;=> 1140\n```\n\nThis expands to:\n\n```clj\n(reduce +\n  (take 10\n    (filter even?\n      (map #(* % %)\n        (range)))))\n;;=> 1140\n```"}],
                            :full-name "cljs.core/->>",
                            :clj-symbol "clojure.core/->>",
                            :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
           "cljs.core/nil?" {:description "Returns true if `x` is nil, false otherwise.",
                             :ns "cljs.core",
                             :name "nil?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/true?"
                                       "cljs.core/false?"
                                       "cljs.core/identity"],
                             :full-name-encode "cljs.core_nilQMARK",
                             :source {:code "(defn nil?\n  [x]\n  (identical? x nil))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [214 217]},
                             :full-name "cljs.core/nil?",
                             :clj-symbol "clojure.core/nil?",
                             :docstring "Returns true if x is nil, false otherwise."},
           "cljs.repl.rhino/bootjs" {:ns "cljs.repl.rhino",
                                     :name "bootjs",
                                     :type "var",
                                     :return-type String,
                                     :source {:code "(def ^String bootjs (str \"goog.require = function(rule){\"\n                         \"Packages.clojure.lang.RT[\\\"var\\\"](\\\"cljs.repl.rhino\\\",\\\"goog-require\\\")\"\n                         \".invoke(rule);}\"))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/clj/cljs/repl/rhino.clj",
                                              :lines [22 24]},
                                     :full-name "cljs.repl.rhino/bootjs",
                                     :full-name-encode "cljs.repl.rhino_bootjs",
                                     :history [["+" "0.0-927"]]},
           "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                          :name "stringify-keys",
                                          :signature ["[m]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.walk_stringify-keys",
                                          :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/clojure/walk.cljs",
                                                   :lines [72 78]},
                                          :full-name "clojure.walk/stringify-keys",
                                          :clj-symbol "clojure.walk/stringify-keys",
                                          :docstring "Recursively transforms all map keys from keywords to strings."},
           "clojure.browser.repl/order" {:ns "clojure.browser.repl",
                                         :name "order",
                                         :type "var",
                                         :source {:code "(def order (atom 0))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/clojure/browser/repl.cljs",
                                                  :lines [55]},
                                         :full-name "clojure.browser.repl/order",
                                         :full-name-encode "clojure.browser.repl_order",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/memoize" {:description "Returns a memoized version of a referentially transparent function.\n\nA memoized version of a function keeps a cache of the mappings from arguments to\nresults in memory. When calls with the same arguments are repeated often, a\nmemoized function has higher performance at the expense of higher memory usage.",
                                :ns "cljs.core",
                                :name "memoize",
                                :signature ["[f]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_memoize",
                                :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [v (get @mem args)]\n        v\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3235 3247]},
                                :full-name "cljs.core/memoize",
                                :clj-symbol "clojure.core/memoize",
                                :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
           "cljs.core/pr-sequential" {:ns "cljs.core",
                                      :name "pr-sequential",
                                      :type "function",
                                      :signature ["[print-one begin sep end opts coll]"],
                                      :source {:code "(defn pr-sequential [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [2846 2850]},
                                      :full-name "cljs.core/pr-sequential",
                                      :full-name-encode "cljs.core_pr-sequential",
                                      :history [["+" "0.0-927"]]},
           "clojure.zip/make-node" {:ns "clojure.zip",
                                    :name "make-node",
                                    :signature ["[loc node children]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip_make-node",
                                    :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [76 80]},
                                    :full-name "clojure.zip/make-node",
                                    :clj-symbol "clojure.zip/make-node",
                                    :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
           "syntax/deref" {:description "Used to dereference a reference value (e.g. an atom).  Expands to `(deref ...)`.\n\n`@foo` = `(deref foo)`",
                           :ns "syntax",
                           :name "deref",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["cljs.core/deref"],
                           :full-name-encode "syntax_deref",
                           :source {:repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/jvm/clojure/lang/LispReader.java",
                                    :lines [nil]},
                           :syntax-form "@",
                           :examples [{:id "08f886",
                                       :content "```clj\n(def a (atom 1))\n@a\n;;=> 1\n\n(deref a)\n;;=> 1\n```"}],
                           :full-name "syntax/deref",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "specialrepl/load-namespace" {:description "Only usable from a REPL.\n\nLoad a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once\nand only once.",
                                         :ns "specialrepl",
                                         :name "load-namespace",
                                         :signature ["[name]"],
                                         :history [["+" "0.0-927"]],
                                         :type "special form (repl)",
                                         :full-name-encode "specialrepl_load-namespace",
                                         :source {:code "(defn repl\n  \"Note - repl will reload core.cljs every time, even if supplied old repl-env\"\n  [repl-env & {:keys [verbose warn-on-undeclared]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (= (first form) 'in-ns))\n           (do (set! comp/*cljs-ns* (second (second form))) (newline) (recur))\n           \n           (and (seq? form) ('#{load-file clojure.core/load-file} (first form)))\n           (do (load-file repl-env (second form)) (newline) (recur))\n           \n           (and (seq? form) ('#{load-namespace} (first form)))\n           (do (load-namespace repl-env (second form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/clj/cljs/repl.clj",
                                                  :lines [133 162]},
                                         :examples [{:id "0b1a1d",
                                                     :content "```clj\n(load-namespace 'clojure.set)\n```"}],
                                         :full-name "specialrepl/load-namespace"},
           "cljs.reader/float-pattern" {:ns "cljs.reader",
                                        :name "float-pattern",
                                        :type "var",
                                        :source {:code "(def float-pattern (re-pattern \"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\"))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [97]},
                                        :full-name "cljs.reader/float-pattern",
                                        :full-name-encode "cljs.reader_float-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/ancestors" {:ns "cljs.core",
                                  :name "ancestors",
                                  :signature ["[tag]" "[h tag]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_ancestors",
                                  :source {:code "(defn ancestors\n  ([tag] (ancestors @global-hierarchy tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3329 3335]},
                                  :full-name "cljs.core/ancestors",
                                  :clj-symbol "clojure.core/ancestors",
                                  :docstring "Returns the immediate and indirect parents of tag, either via a Java type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/integer?" {:description "Returns true if `n` is an integer, false otherwise.",
                                 :ns "cljs.core",
                                 :name "integer?",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/int"],
                                 :full-name-encode "cljs.core_integerQMARK",
                                 :source {:code "(defn integer?\n  [n]\n  (and (number? n)\n       (js* \"(~{n} == ~{n}.toFixed())\")))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [687 691]},
                                 :full-name "cljs.core/integer?",
                                 :clj-symbol "clojure.core/integer?",
                                 :docstring "Returns true if n is an integer.  Warning: returns true on underflow condition."},
           "cljs.core/HashMap.EMPTY" {:ns "cljs.core",
                                      :name "HashMap.EMPTY",
                                      :type "var",
                                      :parent-type "HashMap",
                                      :source {:code "(set! cljs.core.HashMap/EMPTY (HashMap. nil 0 (js-obj)))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [2402]},
                                      :full-name "cljs.core/HashMap.EMPTY",
                                      :full-name-encode "cljs.core_HashMapDOTEMPTY",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.EMPTY" {:ns "cljs.core",
                                     :name "Vector.EMPTY",
                                     :type "var",
                                     :parent-type "Vector",
                                     :source {:code "(set! cljs.core.Vector/EMPTY (Vector. nil (array)))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2018]},
                                     :full-name "cljs.core/Vector.EMPTY",
                                     :full-name-encode "cljs.core_VectorDOTEMPTY",
                                     :history [["+" "0.0-927"]]},
           "clojure.zip/xml-zip" {:ns "clojure.zip",
                                  :name "xml-zip",
                                  :signature ["[root]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_xml-zip",
                                  :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [50 58]},
                                  :full-name "clojure.zip/xml-zip",
                                  :clj-symbol "clojure.zip/xml-zip",
                                  :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
           "clojure.walk/walk" {:ns "clojure.walk",
                                :name "walk",
                                :signature ["[inner outer form]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.walk_walk",
                                :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/clojure/walk.cljs",
                                         :lines [37 48]},
                                :full-name "clojure.walk/walk",
                                :clj-symbol "clojure.walk/walk",
                                :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/bit-xor" {:description "Bitwise \"exclusive or\". Same as `x ^ y` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-xor",
                                :signature ["[x y]" "[x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-and"
                                          "cljs.core/bit-or"],
                                :full-name-encode "cljs.core_bit-xor",
                                :source {:code "(defn bit-xor\n  [x y] (cljs.core/bit-xor x y))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [938 940]},
                                :extra-sources ({:code "(defmacro bit-xor\n  ([x y] (list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [151 153]}),
                                :examples [{:id "3ccd99",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-xor 2r1100 2r1010)\n;;=> 6\n;; 6 = 2r0110\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-xor 12 10)\n;;=> 6\n```"}],
                                :full-name "cljs.core/bit-xor",
                                :clj-symbol "clojure.core/bit-xor",
                                :docstring "Bitwise exclusive or"},
           "clojure.set/union" {:description "Return a set that is the union of the input sets.",
                                :ns "clojure.set",
                                :name "union",
                                :signature ["[]"
                                            "[s1]"
                                            "[s1 s2]"
                                            "[s1 s2 & sets]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["clojure.set/intersection"
                                          "clojure.set/difference"
                                          "clojure.set/superset?"],
                                :full-name-encode "clojure.set_union",
                                :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [19 29]},
                                :full-name "clojure.set/union",
                                :clj-symbol "clojure.set/union",
                                :docstring "Return a set that is the union of the input sets"},
           "cljs.repl/IJavaScriptEnv" {:ns "cljs.repl",
                                       :name "IJavaScriptEnv",
                                       :type "protocol",
                                       :full-name-encode "cljs.repl_IJavaScriptEnv",
                                       :source {:code "(defprotocol IJavaScriptEnv\n  (-setup [this] \"initialize the environment\")\n  (-evaluate [this filename line js] \"evaluate a javascript string\")\n  (-load [this ns url] \"load code at url into the environment\")\n  (-tear-down [this] \"dispose of the environment\"))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [18 22]},
                                       :methods [{:name "-setup",
                                                  :signature ["[this]"],
                                                  :docstring "initialize the environment"}
                                                 {:name "-evaluate",
                                                  :signature ["[this filename line js]"],
                                                  :docstring "evaluate a javascript string"}
                                                 {:name "-load",
                                                  :signature ["[this ns url]"],
                                                  :docstring "load code at url into the environment"}
                                                 {:name "-tear-down",
                                                  :signature ["[this]"],
                                                  :docstring "dispose of the environment"}],
                                       :full-name "cljs.repl/IJavaScriptEnv",
                                       :history [["+" "0.0-927"]]},
           "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                         :name "PushbackReader",
                                         :type "protocol",
                                         :full-name-encode "cljs.reader_PushbackReader",
                                         :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [12 15]},
                                         :methods [{:name "read-char",
                                                    :signature ["[reader]"],
                                                    :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                   {:name "unread",
                                                    :signature ["[reader ch]"],
                                                    :docstring "Push back a single character on to the stream"}],
                                         :full-name "cljs.reader/PushbackReader",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/isa?" {:ns "cljs.core",
                             :name "isa?",
                             :signature ["[child parent]"
                                         "[h child parent]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_isaQMARK",
                             :source {:code "(defn isa?\n  ([child parent] (isa? @global-hierarchy child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (= (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (= i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3301 3319]},
                             :full-name "cljs.core/isa?",
                             :clj-symbol "clojure.core/isa?",
                             :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a Java type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
           "clojure.browser.net/xhr-connection" {:ns "clojure.browser.net",
                                                 :name "xhr-connection",
                                                 :signature ["[]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net_xhr-connection",
                                                 :source {:code "(defn xhr-connection\n  []\n  (goog.net.XhrIo.))",
                                                          :repo "clojurescript",
                                                          :tag "r971",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [83
                                                                  86]},
                                                 :full-name "clojure.browser.net/xhr-connection",
                                                 :docstring "Returns an XhrIo connection"},
           "cljs.core/subs" {:description "Returns the substring of `s` beginning at `start` inclusive, and ending at `end`\nexclusive.\n\n`end` defaults to the length of the string.",
                             :ns "cljs.core",
                             :name "subs",
                             :signature ["[s start]" "[s start end]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_subs",
                             :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1062 1066]},
                             :full-name "cljs.core/subs",
                             :clj-symbol "clojure.core/subs",
                             :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
           "syntax/unquote" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nIntended for use inside a syntax-quote.\n\nForces evaluation of the following form.",
                             :ns "syntax",
                             :name "unquote",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/syntax-quote"
                                       "syntax/unquote-splicing"],
                             :full-name-encode "syntax_unquote",
                             :source {:repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form "~",
                             :examples [{:id "1ff51e",
                                         :content "```clj\n(def foo 1)\n`~foo\n;;=> 1\n\n`(def foo ~foo)\n;;=> (def cljs.user/foo 1)\n```"}],
                             :full-name "syntax/unquote",
                             :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/symbol?" {:ns "cljs.core",
                                :name "symbol?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_symbolQMARK",
                                :source {:code "(defn symbol? [x]\n  (and (goog/isString x)\n       (= (.charAt x 0) \\uFDD1)))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [677 679]},
                                :full-name "cljs.core/symbol?",
                                :clj-symbol "clojure.core/symbol?"},
           "clojure.string/replace" {:description "Replaces all instance of `match` with `replacement` in `s`.\n\nThe options for match / replacement are:\n\n| match  | replacement |\n|--------|-------------|\n| string | string      |\n| regex  | string      |\n| regex  | function    |",
                                     :ns "clojure.string",
                                     :name "replace",
                                     :signature ["[s match replacement]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/subs"
                                               "clojure.string/split"
                                               "clojure.string/replace-first"],
                                     :full-name-encode "clojure.string_replace",
                                     :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [23 34]},
                                     :full-name "clojure.string/replace",
                                     :clj-symbol "clojure.string/replace",
                                     :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/string?" {:description "Returns true if `x` is a string, false otherwise.",
                                :ns "cljs.core",
                                :name "string?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_stringQMARK",
                                :source {:code "(defn string? [x]\n  (and (goog/isString x)\n       (not (or (= (.charAt x 0) \\uFDD0)\n                (= (.charAt x 0) \\uFDD1)))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [668 671]},
                                :full-name "cljs.core/string?",
                                :clj-symbol "clojure.core/string?"},
           "cljs.core/partition-all" {:description "Returns a lazy sequence of lists like `partition`, but may include partitions\nwith fewer than `n` items at the end.\n\nReturns a stateful transducer when no collection is provided.",
                                      :ns "cljs.core",
                                      :name "partition-all",
                                      :signature ["[n]"
                                                  "[n coll]"
                                                  "[n step coll]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :related ["cljs.core/partition"
                                                "cljs.core/partition-by"],
                                      :full-name-encode "cljs.core_partition-all",
                                      :source {:code "(defn partition-all\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [2611 2619]},
                                      :full-name "cljs.core/partition-all",
                                      :clj-symbol "clojure.core/partition-all",
                                      :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end."},
           "cljs.core/merge-with" {:description "Returns a map that consists of the rest of the maps `conj`-ed onto the first.\n\nIf a key occurs in more than one map, the mapping(s) from the latter (left-to-\nright) will be combined with the mapping in the result by calling `(f val-in-\nresult val-in-latter)`.",
                                   :ns "cljs.core",
                                   :name "merge-with",
                                   :signature ["[f & maps]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/merge"],
                                   :full-name-encode "cljs.core_merge-with",
                                   :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2438 2452]},
                                   :full-name "cljs.core/merge-with",
                                   :clj-symbol "clojure.core/merge-with",
                                   :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
           "clojure.browser.dom/set-properties" {:ns "clojure.browser.dom",
                                                 :name "set-properties",
                                                 :signature ["[e m]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom_set-properties",
                                                 :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (.-strobj m)))",
                                                          :repo "clojurescript",
                                                          :tag "r971",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [134
                                                                  138]},
                                                 :full-name "clojure.browser.dom/set-properties",
                                                 :docstring "Set properties on an element"},
           "cljs.core/trampoline" {:ns "cljs.core",
                                   :name "trampoline",
                                   :signature ["[f]" "[f & args]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_trampoline",
                                   :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3249 3263]},
                                   :full-name "cljs.core/trampoline",
                                   :clj-symbol "clojure.core/trampoline",
                                   :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
           "cljs.repl.browser/handle-connection" {:ns "cljs.repl.browser",
                                                  :name "handle-connection",
                                                  :type "function",
                                                  :signature ["[opts conn]"],
                                                  :source {:code "(defn handle-connection\n  [opts conn]\n  (let [rdr (BufferedReader. (InputStreamReader. (.getInputStream conn)))]\n    (if-let [request (read-request rdr)]\n      (case (:method request)\n        :get (handle-get opts conn request)\n        :post (handle-post conn (read-string (:content request)))\n        (.close conn))\n      (.close conn))))",
                                                           :repo "clojurescript",
                                                           :tag "r971",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [230
                                                                   238]},
                                                  :full-name "cljs.repl.browser/handle-connection",
                                                  :full-name-encode "cljs.repl.browser_handle-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "clojure.browser.repl/send-print" {:ns "clojure.browser.repl",
                                              :name "send-print",
                                              :signature ["[url data]"
                                                          "[url data n]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl_send-print",
                                              :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [41 53]},
                                              :full-name "clojure.browser.repl/send-print",
                                              :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times."},
           "cljs.core/ICounted" {:ns "cljs.core",
                                 :name "ICounted",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_ICounted",
                                 :source {:code "(defprotocol ICounted\n  (-count [coll] \"constant time count\"))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [118 119]},
                                 :methods [{:name "-count",
                                            :signature ["[coll]"],
                                            :docstring "constant time count"}],
                                 :full-name "cljs.core/ICounted",
                                 :clj-symbol "clojure.lang/Counted"},
           "cljs.core/IEquiv" {:ns "cljs.core",
                               :name "IEquiv",
                               :type "protocol",
                               :full-name-encode "cljs.core_IEquiv",
                               :source {:code "(defprotocol IEquiv\n  (-equiv [o other]))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [174 175]},
                               :methods [{:name "-equiv",
                                          :signature ["[o other]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IEquiv",
                               :history [["+" "0.0-927"]]},
           "cljs.core/js-delete" {:description "Deletes property `key` in JavaScript object `obj`.\n\nEquivalent to `delete obj[key]` in JavaScript.",
                                  :ns "cljs.core",
                                  :name "js-delete",
                                  :signature ["[obj key]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/dissoc"],
                                  :full-name-encode "cljs.core_js-delete",
                                  :source {:code "(defn js-delete [obj key]\n  (js* \"delete ~{obj}[~{key}]\"))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [637 638]},
                                  :examples [{:id "5b24ea",
                                              :content "```clj\n(def a #js {:foo 1 :bar 2})\n(js-delete a \"foo\")\n\na\n;;=> #js {:bar 2}\n```"}],
                                  :full-name "cljs.core/js-delete"},
           "cljs.core/comment" {:description "Ignores all `body` forms (i.e. \"commenting out\"). Returns nil.\n\nThis is often used near the bottom of a file to hold expressions that test\ndifferent functions during development.  Specific expressions within the\n`comment` can then be selected and evaluated from some editors.\n\nYou can also use `;` to \"comment out\" code until the end of a line.",
                                :ns "cljs.core",
                                :name "comment",
                                :signature ["[& body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_comment",
                                :source {:code "(defmacro comment\n  [& body])",
                                         :repo "clojure",
                                         :tag "clojure-1.3.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [4161 4164]},
                                :examples [{:id "482fd7",
                                            :content "```clj\n(comment 123)\n;;=> nil\n\n(comment\n  (foo 1 2 3)\n  (bar \"hello\"))\n;;=> nil\n```\n\nInner forms must still be syntactically correct:\n\n```clj\n(comment [1 2 3]])\n;; Error: Unmatched delimiter ]\n\n(comment a : b)\n;; Error: Invalid token :\n```"}],
                                :full-name "cljs.core/comment",
                                :clj-symbol "clojure.core/comment",
                                :docstring "Ignores body, yields nil"},
           "cljs.reader/special-symbols" {:ns "cljs.reader",
                                          :name "special-symbols",
                                          :type "var",
                                          :source {:code "(def special-symbols\n  {\"nil\" nil\n   \"true\" true\n   \"false\" false})",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [243 246]},
                                          :full-name "cljs.reader/special-symbols",
                                          :full-name-encode "cljs.reader_special-symbols",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/alength" {:description "For interop, it returns the length of a JavaScript array or string.",
                                :ns "cljs.core",
                                :name "alength",
                                :signature ["[a]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/count"],
                                :full-name-encode "cljs.core_alength",
                                :source {:code "(defn alength\n  [array]\n  (.-length array))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [87 90]},
                                :extra-sources ({:code "(defmacro alength [a]\n  (list 'js* \"~{}.length\" a))",
                                                 :repo "clojurescript",
                                                 :tag "r971",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [639 640]}),
                                :examples [{:id "26f79f",
                                            :content "```clj\n(def a #js [1 2 3])\n\n(alength a)\n;;=> 3\n\n(.-length a)\n;;=> 3\n\n(aget a \"length\")\n;;=> 3\n\n(count a)\n;;=> 3\n```"}],
                                :full-name "cljs.core/alength",
                                :clj-symbol "clojure.core/alength",
                                :docstring "Returns the length of the Java array. Works on arrays of all types."},
           "special/quote" {:ns "special",
                            :name "quote",
                            :type "special form",
                            :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _]\n  {:op :constant :env env :form x})",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [773 775]},
                            :full-name "special/quote",
                            :full-name-encode "special_quote",
                            :clj-symbol "clojure.core/quote",
                            :history [["+" "0.0-927"]]},
           "cljs.core/tree-seq" {:description "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n\n`branch?` must be a function of one argument that returns true if passed a node\nthat can have children (but may not).\n\n`children` must be a function of one argument that returns a sequence of the\nchildren. `children` will only be called on nodes for which `branch?` returns\ntrue.\n\n`root` is the root node of the tree.",
                                 :ns "cljs.core",
                                 :name "tree-seq",
                                 :signature ["[branch? children root]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_tree-seq",
                                 :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1842 1855]},
                                 :full-name "cljs.core/tree-seq",
                                 :clj-symbol "clojure.core/tree-seq",
                                 :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
           "cljs.reader/read-unmatched-delimiter" {:ns "cljs.reader",
                                                   :name "read-unmatched-delimiter",
                                                   :type "function",
                                                   :signature ["[rdr ch]"],
                                                   :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmached delimiter \" ch))",
                                                            :repo "clojurescript",
                                                            :tag "r971",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [199
                                                                    201]},
                                                   :full-name "cljs.reader/read-unmatched-delimiter",
                                                   :full-name-encode "cljs.reader_read-unmatched-delimiter",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/every-pred" {:description "Takes a set of predicate functions and returns a function `f` that returns true\nif all of its composing predicates return a logical true value against all of\nits arguments, else it returns false.\n\nNote that `f` is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates.",
                                   :ns "cljs.core",
                                   :name "every-pred",
                                   :signature ["[p]"
                                               "[p1 p2]"
                                               "[p1 p2 p3]"
                                               "[p1 p2 p3 & ps]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/some-fn"
                                             "cljs.core/and"],
                                   :full-name-encode "cljs.core_every-pred",
                                   :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1601 1638]},
                                   :full-name "cljs.core/every-pred",
                                   :clj-symbol "clojure.core/every-pred",
                                   :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
           "syntax/js-ns" {:ns "syntax",
                           :name "js-ns",
                           :syntax-form "js/",
                           :type "special namespace",
                           :full-name "syntax/js-ns",
                           :full-name-encode "syntax_js-ns",
                           :history [["+" "0.0-927"]]},
           "clojure.set/rename-keys" {:ns "clojure.set",
                                      :name "rename-keys",
                                      :signature ["[map kmap]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.set_rename-keys",
                                      :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (and (not= old new)\n                (contains? m old))\n         (-> m (assoc new (get m old)) (dissoc old))\n         m)) \n     map kmap))",
                                               :repo "clojurescript",
                                               :tag "r971",
                                               :filename "src/cljs/clojure/set.cljs",
                                               :lines [72 81]},
                                      :full-name "clojure.set/rename-keys",
                                      :clj-symbol "clojure.set/rename-keys",
                                      :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/peek" {:description "Returns the first element of a list; same as `first`.\n\nReturns the last element of a vector, and much more efficient than using `last`.\n\nReturns nil if `coll` is empty.",
                             :ns "cljs.core",
                             :name "peek",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/first"
                                       "cljs.core/pop"
                                       "cljs.core/conj"],
                             :full-name-encode "cljs.core_peek",
                             :source {:code "(defn peek\n  [coll]\n  (-peek coll))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [558 562]},
                             :examples [{:id "4abc4c",
                                         :content "With vectors:\n\n```clj\n(peek [1 2 3])\n;;=> 3\n\n(peek [1 2])\n;;=> 2\n\n(peek [1])\n;;=> 1\n\n(peek [])\n;;=> nil\n```"}
                                        {:id "d50bd0",
                                         :content "With lists:\n\n```clj\n(peek '(1 2 3))\n;;=> 1\n\n(peek '(1 2))\n;;=> 1\n\n(peek '(1))\n;;=> 1\n\n(peek '())\n;;=> nil\n```"}],
                             :full-name "cljs.core/peek",
                             :clj-symbol "clojure.core/peek",
                             :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
           "cljs.core/pr-str-with-opts" {:ns "cljs.core",
                                         :name "pr-str-with-opts",
                                         :signature ["[objs opts]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_pr-str-with-opts",
                                         :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (let [first-obj (first objs)\n        sb (gstring/StringBuffer.)]\n    (doseq [obj objs]\n      (when-not (identical? obj first-obj)\n        (.append sb \" \"))\n      (doseq [string (pr-seq obj opts)]\n        (.append sb string)))\n    (str sb)))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2872 2883]},
                                         :full-name "cljs.core/pr-str-with-opts",
                                         :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts"},
           "cljs.core/map?" {:description "Returns true if `x` is a map, false otherwise.",
                             :ns "cljs.core",
                             :name "map?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/hash-map"
                                       "cljs.core/sorted-map"],
                             :full-name-encode "cljs.core_mapQMARK",
                             :source {:code "(defn map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [617 622]},
                             :full-name "cljs.core/map?",
                             :clj-symbol "clojure.core/map?",
                             :docstring "Return true if x satisfies IMap"},
           "cljs.reader/StringPushbackReader" {:ns "cljs.reader",
                                               :name "StringPushbackReader",
                                               :type "type",
                                               :signature ["[s index-atom buffer-atom]"],
                                               :source {:code "(deftype StringPushbackReader [s index-atom buffer-atom]\n  PushbackReader\n  (read-char [reader]\n             (if (empty? @buffer-atom)\n               (let [idx @index-atom]\n                 (swap! index-atom inc)\n                 (nth s idx))\n               (let [buf @buffer-atom]\n                 (swap! buffer-atom rest)\n                 (first buf))))\n  (unread [reader ch] (swap! buffer-atom #(cons ch %))))",
                                                        :repo "clojurescript",
                                                        :tag "r971",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [18 28]},
                                               :full-name "cljs.reader/StringPushbackReader",
                                               :full-name-encode "cljs.reader_StringPushbackReader",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/HashMap.fromArrays" {:ns "cljs.core",
                                           :name "HashMap.fromArrays",
                                           :signature ["[ks vs]"],
                                           :history [["+" "0.0-927"]],
                                           :parent-type "HashMap",
                                           :type "function",
                                           :full-name-encode "cljs.core_HashMapDOTfromArrays",
                                           :source {:code "(set! cljs.core.HashMap/fromArrays (fn [ks vs]\n  (let [len (.-length ks)]\n    (loop [i 0, out cljs.core.HashMap/EMPTY]\n      (if (< i len)\n        (recur (inc i) (assoc out (aget ks i) (aget vs i)))\n        out)))))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2404 2409]},
                                           :full-name "cljs.core/HashMap.fromArrays"},
           "cljs.core/deref" {:description "Returns the current value of atom `x`.\n\nThe `@` reader macro is often used instead of `deref`. `@foo` is the same thing\nas `(deref foo)`.",
                              :ns "cljs.core",
                              :name "deref",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/atom"],
                              :full-name-encode "cljs.core_deref",
                              :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3095 3097]},
                              :full-name "cljs.core/deref",
                              :clj-symbol "clojure.core/deref"},
           "cljs.core/reductions" {:description "Returns a lazy sequence of the intermediate values of the reduction (as per\n`reduce`) of `coll` by `f`, starting with `init`.",
                                   :ns "cljs.core",
                                   :name "reductions",
                                   :signature ["[f coll]"
                                               "[f init coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/reduce"],
                                   :full-name-encode "cljs.core_reductions",
                                   :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2730 2742]},
                                   :full-name "cljs.core/reductions",
                                   :clj-symbol "clojure.core/reductions",
                                   :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
           "cljs.core/false?" {:description "Returns true if `x` is the value false, false otherwise.",
                               :ns "cljs.core",
                               :name "false?",
                               :signature ["[x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/true?"
                                         "cljs.core/not"],
                               :full-name-encode "cljs.core_falseQMARK",
                               :source {:code "(defn false?\n  [x] (cljs.core/false? x))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [644 646]},
                               :extra-sources ({:code "(defmacro false? [x]\n  (list 'js* \"~{} === false\" x))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [48 49]}),
                               :full-name "cljs.core/false?",
                               :clj-symbol "clojure.core/false?",
                               :docstring "Returns true if x is the value false, false otherwise."},
           "cljs.core/bit-flip" {:description "Flip bit at index `n`.  Same as `x ^ (1 << y)` in JavaScript.",
                                 :ns "cljs.core",
                                 :name "bit-flip",
                                 :signature ["[x n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/bit-set"
                                           "cljs.core/bit-clear"],
                                 :full-name-encode "cljs.core_bit-flip",
                                 :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [959 962]},
                                 :extra-sources ({:code "(defmacro bit-flip [x n]\n  (list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [162 163]}),
                                 :examples [{:id "5d7ee0",
                                             :content "Bits can be entered using radix notation:\n\n```clj\n(bit-flip 2r1111 2)\n;;=> 11\n;; 11 = 2r1011\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-flip 15 2)\n;;=> 11\n```"}],
                                 :full-name "cljs.core/bit-flip",
                                 :clj-symbol "clojure.core/bit-flip",
                                 :docstring "Flip bit at index n"},
           "cljs.core/ISet" {:ns "cljs.core",
                             :name "ISet",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core_ISet",
                             :source {:code "(defprotocol ISet\n  (-disjoin [coll v]))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [149 150]},
                             :methods [{:name "-disjoin",
                                        :signature ["[coll v]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISet",
                             :clj-symbol "clojure.lang/IPersistentSet"},
           "cljs.core/LazySeq" {:ns "cljs.core",
                                :name "LazySeq",
                                :signature ["[meta realized x]"],
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core_LazySeq",
                                :source {:code "(deftype LazySeq [meta realized x]\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta realized x))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first (lazy-seq-value coll)))\n  (-rest [coll] (rest (lazy-seq-value coll)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (seq (lazy-seq-value coll))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1290 1315]},
                                :full-name "cljs.core/LazySeq",
                                :clj-symbol "clojure.lang/LazySeq"},
           "cljs.repl.rhino/IEval" {:ns "cljs.repl.rhino",
                                    :name "IEval",
                                    :type "protocol",
                                    :full-name-encode "cljs.repl.rhino_IEval",
                                    :source {:code "(defprotocol IEval\n  (-eval [this env filename line]))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/clj/cljs/repl/rhino.clj",
                                             :lines [26 27]},
                                    :methods [{:name "-eval",
                                               :signature ["[this env filename line]"],
                                               :docstring nil}],
                                    :full-name "cljs.repl.rhino/IEval",
                                    :history [["+" "0.0-927"]]},
           "cljs.repl.browser/start-server" {:ns "cljs.repl.browser",
                                             :name "start-server",
                                             :signature ["[opts]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser_start-server",
                                             :source {:code "(defn start-server\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! server-state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                                      :repo "clojurescript",
                                                      :tag "r971",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [247 252]},
                                             :full-name "cljs.repl.browser/start-server",
                                             :docstring "Start the server on the specified port."},
           "cljs.core/*2" {:description "Only usable from a REPL.\n\nHolds the result of the second to last expression.",
                           :ns "cljs.core",
                           :name "*2",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*3"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR2",
                           :source {:code "(def \n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [27 29]},
                           :examples [{:id "208d41",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n(+ 4 8)\n;;=> 12\n\n*2\n;;=> 10\n\n(inc *2)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*2",
                           :clj-symbol "clojure.core/*2",
                           :docstring "bound in a repl thread to the second most recent value printed"},
           "clojure.browser.event/total-listener-count" {:ns "clojure.browser.event",
                                                         :name "total-listener-count",
                                                         :type "function",
                                                         :signature ["[]"],
                                                         :source {:code "(defn total-listener-count []\n  (goog.events/getTotalListenerCount))",
                                                                  :repo "clojurescript",
                                                                  :tag "r971",
                                                                  :filename "src/cljs/clojure/browser/event.cljs",
                                                                  :lines [85
                                                                          86]},
                                                         :full-name "clojure.browser.event/total-listener-count",
                                                         :full-name-encode "clojure.browser.event_total-listener-count",
                                                         :history [["+"
                                                                    "0.0-927"]]},
           "cljs.core/alter-meta!" {:description "Alter the metadata of `data` to be `(apply f its-current-meta args)`.\n\nMetadata of vars cannot be altered since they are statically determined at compile-time.",
                                    :ns "cljs.core",
                                    :name "alter-meta!",
                                    :signature ["[data f & args]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/with-meta"
                                              "cljs.core/vary-meta"],
                                    :full-name-encode "cljs.core_alter-metaBANG",
                                    :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3114 3121]},
                                    :examples [{:id "8378a0",
                                                :content "Metadata of symbols and collections can be altered:\n\n```clj\n(def a ^:foo [1 2 3])\n(meta a)\n;;=> {:foo true}\n\n(alter-meta! a assoc :bar true)\n(meta a)\n;;=> {:foo true, :bar true}\n```\n\nMetadata of vars cannot be altered:\n\n```clj\n(def a [1 2 3])\n(meta #'a)\n;;=> {:arglists (), :test nil, :name a, :column 1, :line 1, :file \"<cljs repl>\", :doc nil, :ns cljs.user}\n\n(alter-meta! #'a assoc :bar true)\n(:bar (meta #'a))\n;;=> nil\n```"}],
                                    :full-name "cljs.core/alter-meta!",
                                    :clj-symbol "clojure.core/alter-meta!",
                                    :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
           "clojure.browser.dom/click-element" {:ns "clojure.browser.dom",
                                                :name "click-element",
                                                :type "function",
                                                :signature ["[e]"],
                                                :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                         :repo "clojurescript",
                                                         :tag "r971",
                                                         :filename "src/cljs/clojure/browser/dom.cljs",
                                                         :lines [145
                                                                 147]},
                                                :full-name "clojure.browser.dom/click-element",
                                                :full-name-encode "clojure.browser.dom_click-element",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.repl.browser/server-loop" {:ns "cljs.repl.browser",
                                            :name "server-loop",
                                            :type "function",
                                            :signature ["[opts server-socket]"],
                                            :source {:code "(defn server-loop\n  [opts server-socket]\n  (let [conn (.accept server-socket)]\n    (do (.setKeepAlive conn true)\n        (future (handle-connection opts conn))\n        (recur opts server-socket))))",
                                                     :repo "clojurescript",
                                                     :tag "r971",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [240 245]},
                                            :full-name "cljs.repl.browser/server-loop",
                                            :full-name-encode "cljs.repl.browser_server-loop",
                                            :history [["+" "0.0-927"]]},
           "cljs.reader/read-meta" {:ns "cljs.reader",
                                    :name "read-meta",
                                    :type "function",
                                    :signature ["[rdr _]"],
                                    :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [287 295]},
                                    :full-name "cljs.reader/read-meta",
                                    :full-name-encode "cljs.reader_read-meta",
                                    :history [["+" "0.0-927"]]},
           "special/try*" {:ns "special",
                           :name "try*",
                           :type "special form",
                           :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze-block\n                   (assoc env :context :statement)\n                   fblock))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        mname (when name (munge name))\n        locals (if name\n                 (assoc locals name {:name mname})\n                 locals)\n        catch (when cblock\n                (analyze-block (assoc catchenv :locals locals) (rest cblock)))\n        body (if name (pop body) body)\n        try (when body\n              (analyze-block (if (or name finally) catchenv env) body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name mname\n     :catch catch\n     :children [try {:name mname} catch finally]}))",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [619 652]},
                           :full-name "special/try*",
                           :full-name-encode "special_trySTAR",
                           :history [["+" "0.0-927"]]},
           "syntax/ignore" {:description "Causes the following form to be completely skipped by the reader.  This is a\nmore complete removal than the `comment` macro which yields nil.",
                            :ns "syntax",
                            :name "ignore",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["syntax/comment"
                                      "cljs.core/comment"],
                            :full-name-encode "syntax_ignore",
                            :source {:repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form "#_",
                            :examples [{:id "f36d7a",
                                        :content "```clj\n{:foo #_bar 2}\n;;=> {:foo 2}\n```\n\nTo comment out the last line of a function without worrying about commenting out\nthe trailing parentheses:\n\n```clj\n(defn foo []\n  (println \"hello\")\n  #_(println \"world\"))\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#discard",
                            :full-name "syntax/ignore",
                            :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/range" {:description "Returns a lazy sequence of nums from `start` (inclusive) to `end` (exclusive),\nby `step`, where `start` defaults to 0, `step` to 1, and `end` to infinity.",
                              :ns "cljs.core",
                              :name "range",
                              :signature ["[]"
                                          "[end]"
                                          "[start end]"
                                          "[start end step]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/repeat"],
                              :full-name-encode "cljs.core_range",
                              :source {:code "(defn range\n  ([] (range 0 js/Number.MAX_VALUE 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2688 2695]},
                              :full-name "cljs.core/range",
                              :clj-symbol "clojure.core/range",
                              :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
           "cljs.repl.browser/read-post" {:ns "cljs.repl.browser",
                                          :name "read-post",
                                          :type "function",
                                          :signature ["[line rdr]"],
                                          :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/clj/cljs/repl/browser.clj",
                                                   :lines [142 151]},
                                          :full-name "cljs.repl.browser/read-post",
                                          :full-name-encode "cljs.repl.browser_read-post",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/reify" {:ns "cljs.core",
                              :name "reify",
                              :signature ["[& impls]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core_reify",
                              :source {:code "(defmacro reify [& impls]\n  (let [t (gensym \"t\")\n        locals (keys (:locals &env))]\n   `(do\n      (when (undefined? ~t)\n        (deftype ~t [~@locals ~'__meta]\n          cljs.core.IWithMeta\n          (~'-with-meta [~'_ ~'__meta]\n            (new ~t ~@locals ~'__meta))\n          cljs.core.IMeta\n          (~'-meta [~'_] ~'__meta)\n          ~@impls))\n      (new ~t ~@locals nil))))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [190 202]},
                              :full-name "cljs.core/reify",
                              :clj-symbol "clojure.core/reify"},
           "cljs.core/satisfies?" {:ns "cljs.core",
                                   :name "satisfies?",
                                   :signature ["[psym x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core_satisfiesQMARK",
                                   :source {:code "(defmacro satisfies?\n  [psym x]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        prefix (protocol-prefix p)]\n    `(let [x# ~x]\n       (if (and x#\n                (. x# ~(symbol (str \"-\" prefix)))        ;; Need prop lookup here\n                (not (. x# (~'hasOwnProperty ~prefix))))\n\t true\n\t (cljs.core/type_satisfies_ ~psym x#)))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [419 429]},
                                   :full-name "cljs.core/satisfies?",
                                   :clj-symbol "clojure.core/satisfies?",
                                   :docstring "Returns true if x satisfies the protocol"},
           "cljs.core/nth" {:description "Returns the value at index `n` or `not-found` if the index is out of bounds.\n\n`nth` will throw an exception if `n` is out of bounds and `not-found` is not\nsupplied.\n\n`nth` works for Strings, Arrays, Regex Matchers, Lists, and Sequences. For\nSequences, `nth` takes O(n) time.",
                            :ns "cljs.core",
                            :name "nth",
                            :signature ["[coll n]"
                                        "[coll n not-found]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/first"
                                      "cljs.core/second"
                                      "cljs.core/nthnext"
                                      "cljs.core/get"],
                            :full-name-encode "cljs.core_nth",
                            :source {:code "(defn nth\n  ([coll n]\n     (-nth coll (.floor js/Math n)))\n  ([coll n not-found]\n     (-nth coll (.floor js/Math n) not-found)))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [504 512]},
                            :full-name "cljs.core/nth",
                            :clj-symbol "clojure.core/nth",
                            :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
           "cljs.core/list" {:description "Creates a new list containing `items`.",
                             :ns "cljs.core",
                             :name "list",
                             :signature ["[& items]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/vector"
                                       "cljs.core/list?"],
                             :full-name-encode "cljs.core_list",
                             :source {:code "(defn list [& items]\n  (reduce conj () (reverse items)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1193 1194]},
                             :full-name "cljs.core/list",
                             :clj-symbol "clojure.core/list"},
           "cljs.core/defn" {:description "Defines a function.\n\n`doc-string?` is an optional documentation string.\n\n`attr-map?` is an optional map of [metadata](http://clojure.org/metadata) to\nattach to the global variable name.\n\n`prepost-map?` is an optional map with optional keys `:pre` and `:post` that\ncontain collections of [pre or post conditions](http://blog.fogus.me/2009/12/21/clojures-pre-and-post/)\nfor the function.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(defn foo [a b c]\n  (\\* a b c))</pre></td>\n      <td><pre>\n(def foo\n  (fn [a b c]\n    (\\* a b c)))</pre></td></tr></tbody></table>",
                             :ns "cljs.core",
                             :name "defn",
                             :signature ["[name doc-string? attr-map? [params*] prepost-map? body]"
                                         "[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["special/def"
                                       "cljs.core/defn-"
                                       "cljs.core/defmacro"
                                       "cljs.core/fn"],
                             :full-name-encode "cljs.core_defn",
                             :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [263 308]},
                             :full-name "cljs.core/defn",
                             :clj-symbol "clojure.core/defn",
                             :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata"},
           "cljs.core/rand-nth" {:description "Returns a random element from a sequential collection `coll`.\n\nHas the same performance characteristics as `nth`.",
                                 :ns "cljs.core",
                                 :name "rand-nth",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/rand"],
                                 :full-name-encode "cljs.core_rand-nth",
                                 :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3275 3280]},
                                 :full-name "cljs.core/rand-nth",
                                 :clj-symbol "clojure.core/rand-nth",
                                 :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
           "cljs.core/atom" {:description "Creates and returns an atom with an initial value of `x`.\n\n`opts` is an optional map with optional keys `:meta` and `:validator`.\n\n`:meta` should be a [metadata-map](http://clojure.org/metadata) for the atom.\n\n`:validator` should be a validator function for the atom. See `set-validator!`\nfor more information.",
                             :ns "cljs.core",
                             :name "atom",
                             :signature ["[x]" "[x opts]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/atom"
                                       "cljs.core/swap!"
                                       "cljs.core/reset!"
                                       "cljs.core/set-validator!"
                                       "cljs.core/get-validator"],
                             :full-name-encode "cljs.core_atom",
                             :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3039 3054]},
                             :examples [{:id "e6a38a",
                                         :content "```clj\n(def a (atom 1))\n\n@a\n;;=> 1\n\n(reset! a 2)\n@a\n;;=> 2\n\n(swap! a inc)\n@a\n;;=> 3\n```"}],
                             :full-name "cljs.core/atom",
                             :clj-symbol "clojure.core/atom",
                             :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
           "cljs.reader/read-keyword" {:ns "cljs.reader",
                                       :name "read-keyword",
                                       :type "function",
                                       :signature ["[reader initch]"],
                                       :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        [token ns name] (re-matches symbol-pattern token)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if ns?\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                :repo "clojurescript",
                                                :tag "r971",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [256 267]},
                                       :full-name "cljs.reader/read-keyword",
                                       :full-name-encode "cljs.reader_read-keyword",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/Vector" {:ns "cljs.core",
                               :name "Vector",
                               :type "type",
                               :signature ["[meta array]"],
                               :source {:code "(deftype Vector [meta array]\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (.-length array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (.-length array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (.-length array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (.-length array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (.-length array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (.-length array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n\t   (ci-reduce array f))\n  (-reduce [v f start]\n\t   (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1935 2016]},
                               :full-name "cljs.core/Vector",
                               :full-name-encode "cljs.core_Vector",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/skip-line" {:ns "cljs.reader",
                                    :name "skip-line",
                                    :signature ["[reader _]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader_skip-line",
                                    :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (= ch \\n) (= ch \\r) (nil? ch))\n        reader\n        (recur)))))",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [86 93]},
                                    :full-name "cljs.reader/skip-line",
                                    :docstring "Advances the reader to the end of a line. Returns the reader"},
           "cljs.core/namespace" {:ns "cljs.core",
                                  :name "namespace",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_namespace",
                                  :source {:code "(defn namespace\n  [x]\n  (if (or (keyword? x) (symbol? x))\n    (let [i (.lastIndexOf x \"/\")]\n      (when (> i -1)\n        (subs x 2 i)))\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2576 2583]},
                                  :full-name "cljs.core/namespace",
                                  :clj-symbol "clojure.core/namespace",
                                  :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
           "cljs.nodejs/require" {:ns "cljs.nodejs",
                                  :name "require",
                                  :type "var",
                                  :source {:code "(def require (js* \"require\"))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [7]},
                                  :full-name "cljs.nodejs/require",
                                  :full-name-encode "cljs.nodejs_require",
                                  :history [["+" "0.0-927"]]},
           "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                              :name "EventType",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.event_EventType",
                                              :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                       :repo "clojurescript",
                                                       :tag "r971",
                                                       :filename "src/cljs/clojure/browser/event.cljs",
                                                       :lines [17 18]},
                                              :methods [{:name "event-types",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.event/EventType",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.repl.rhino/rhino-setup" {:ns "cljs.repl.rhino",
                                          :name "rhino-setup",
                                          :type "function",
                                          :signature ["[repl-env]"],
                                          :source {:code "(defn rhino-setup [repl-env]\n  (let [env {:context :statement :locals {} :ns (@comp/namespaces comp/*cljs-ns*)}\n        scope (:scope repl-env)]\n    (repl/load-file repl-env \"cljs/core.cljs\")\n    (swap! loaded-libs conj \"cljs.core\")\n    (repl/evaluate-form repl-env\n                        env\n                        \"<cljs repl>\"\n                        '(ns cljs.user))\n    (ScriptableObject/putProperty scope\n                                  \"out\"\n                                  (Context/javaToJS System/out scope))\n    (repl/evaluate-form repl-env\n                        env\n                        \"<cljs repl>\"\n                        '(set! *print-fn* (fn [x] (.print js/out x))))))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [95 110]},
                                          :full-name "cljs.repl.rhino/rhino-setup",
                                          :full-name-encode "cljs.repl.rhino_rhino-setup",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/merge" {:description "Returns a map that consists of the rest of the maps `conj`-ed onto the first.\n\nIf a key occurs in more than one map, the mapping from the rightmost map will\n\"win\".",
                              :ns "cljs.core",
                              :name "merge",
                              :signature ["[& maps]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/merge-with"
                                        "cljs.core/hash-map"],
                              :full-name-encode "cljs.core_merge",
                              :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                       :repo "clojurescript",
                                       :tag "r971",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2430 2436]},
                              :full-name "cljs.core/merge",
                              :clj-symbol "clojure.core/merge",
                              :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
           "clojure.browser.repl/send-result" {:ns "clojure.browser.repl",
                                               :name "send-result",
                                               :type "function",
                                               :signature ["[connection url data]"],
                                               :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                        :repo "clojurescript",
                                                        :tag "r971",
                                                        :filename "src/cljs/clojure/browser/repl.cljs",
                                                        :lines [38 39]},
                                               :full-name "clojure.browser.repl/send-result",
                                               :full-name-encode "clojure.browser.repl_send-result",
                                               :history [["+"
                                                          "0.0-927"]]},
           "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                           :name "keywordize-keys",
                                           :signature ["[m]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk_keywordize-keys",
                                           :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [64 70]},
                                           :full-name "clojure.walk/keywordize-keys",
                                           :clj-symbol "clojure.walk/keywordize-keys",
                                           :docstring "Recursively transforms all map keys from strings to keywords."},
           "cljs.core/derive" {:ns "cljs.core",
                               :name "derive",
                               :signature ["[tag parent]"
                                           "[h tag parent]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_derive",
                               :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap! global-hierarchy derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3346 3378]},
                               :full-name "cljs.core/derive",
                               :clj-symbol "clojure.core/derive",
                               :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "clojure.zip/zipper" {:ns "clojure.zip",
                                 :name "zipper",
                                 :signature ["[branch? children make-node root]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_zipper",
                                 :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [18 32]},
                                 :full-name "clojure.zip/zipper",
                                 :clj-symbol "clojure.zip/zipper",
                                 :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
           "clojure.zip/remove" {:ns "clojure.zip",
                                 :name "remove",
                                 :signature ["[loc]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_remove",
                                 :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [237 251]},
                                 :full-name "clojure.zip/remove",
                                 :clj-symbol "clojure.zip/remove",
                                 :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
           "syntax/var" {:description "Accesses the var attached to the given symbol.\n\n`#'x` = `(var x)`",
                         :ns "syntax",
                         :name "var",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["special/var"],
                         :full-name-encode "syntax_var",
                         :source {:repo "clojure",
                                  :tag "clojure-1.3.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "#'",
                         :examples [{:id "673ef6",
                                     :content "Access the metadata of a var:\n\n```clj\n(def x 123)\n(meta #'x)\n;;=> {:arglists (), :test nil, :name x, :column 1, :line 1, :file \"<cljs repl>\", :doc nil, :ns cljs.user}\n```"}],
                         :full-name "syntax/var",
                         :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/find" {:description "Returns the map entry for key `k`, or nil if `k` is not found.",
                             :ns "cljs.core",
                             :name "find",
                             :signature ["[coll k]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/get"
                                       "cljs.core/get-in"],
                             :full-name-encode "cljs.core_find",
                             :source {:code "(defn find\n  [coll k]\n  (when (and coll\n             (associative? coll)\n             (contains? coll k))\n    [k (-lookup coll k)]))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [704 710]},
                             :full-name "cljs.core/find",
                             :clj-symbol "clojure.core/find",
                             :docstring "Returns the map entry for key, or nil if key not present."},
           "cljs.core/*print-dup*" {:ns "cljs.core",
                                    :name "*print-dup*",
                                    :type "var",
                                    :source {:code "(def *print-dup* false)",
                                             :repo "clojurescript",
                                             :tag "r971",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2904]},
                                    :full-name "cljs.core/*print-dup*",
                                    :full-name-encode "cljs.core_STARprint-dupSTAR",
                                    :clj-symbol "clojure.core/*print-dup*",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/partial" {:description "Takes a function `f` and fewer than the normal arguments to `f`. Returns a\nfunction that takes a variable number of additional arguments. When called, the\nreturned function calls `f` with the original arguments plus the additional\narguments.\n\n`((partial f a b) c d)` => `(f a b c d)`",
                                :ns "cljs.core",
                                :name "partial",
                                :signature ["[f]"
                                            "[f arg1]"
                                            "[f arg1 arg2]"
                                            "[f arg1 arg2 arg3]"
                                            "[f arg1 arg2 arg3 & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/comp"
                                          "cljs.core/juxt"],
                                :full-name-encode "cljs.core_partial",
                                :source {:code "(defn partial\n  ([f arg1]\n   (fn [& args] (apply f arg1 args)))\n  ([f arg1 arg2]\n   (fn [& args] (apply f arg1 arg2 args)))\n  ([f arg1 arg2 arg3]\n   (fn [& args] (apply f arg1 arg2 arg3 args)))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1526 1537]},
                                :full-name "cljs.core/partial",
                                :clj-symbol "clojure.core/partial",
                                :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
           "cljs.core/keyword?" {:ns "cljs.core",
                                 :name "keyword?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_keywordQMARK",
                                 :source {:code "(defn keyword? [x]\n  (and (goog/isString x)\n       (= (.charAt x 0) \\uFDD0)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [673 675]},
                                 :full-name "cljs.core/keyword?",
                                 :clj-symbol "clojure.core/keyword?"},
           "clojure.browser.event/fire-listeners" {:ns "clojure.browser.event",
                                                   :name "fire-listeners",
                                                   :type "function",
                                                   :signature ["[obj type capture event]"],
                                                   :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                            :repo "clojurescript",
                                                            :tag "r971",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [82
                                                                    83]},
                                                   :full-name "clojure.browser.event/fire-listeners",
                                                   :full-name-encode "clojure.browser.event_fire-listeners",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/interleave" {:description "Returns a lazy seq of the first item in each collection, then the second items,\nthen the third, etc.",
                                   :ns "cljs.core",
                                   :name "interleave",
                                   :signature ["[c1 c2]"
                                               "[c1 c2 & colls]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/interpose"
                                             "cljs.core/zipmap"],
                                   :full-name-encode "cljs.core_interleave",
                                   :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1785 1797]},
                                   :full-name "cljs.core/interleave",
                                   :clj-symbol "clojure.core/interleave",
                                   :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
           "cljs.core/*flush-on-newline*" {:ns "cljs.core",
                                           :name "*flush-on-newline*",
                                           :type "var",
                                           :source {:code "(def *flush-on-newline* true)",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2901]},
                                           :full-name "cljs.core/*flush-on-newline*",
                                           :full-name-encode "cljs.core_STARflush-on-newlineSTAR",
                                           :clj-symbol "clojure.core/*flush-on-newline*",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/get-in" {:description "Returns the value in a nested associative structure, where `ks` is a sequence of\nkeys.\n\nReturns nil if the key is not found, or `not-found` if supplied.",
                               :ns "cljs.core",
                               :name "get-in",
                               :signature ["[m ks]"
                                           "[m ks not-found]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/assoc-in"
                                         "cljs.core/update-in"
                                         "cljs.core/find"
                                         "cljs.core/get"],
                               :full-name-encode "cljs.core_get-in",
                               :source {:code "(defn get-in\n  ([m ks]\n     (reduce get m ks))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))",
                                        :repo "clojurescript",
                                        :tag "r971",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1893 1910]},
                               :full-name "cljs.core/get-in",
                               :clj-symbol "clojure.core/get-in",
                               :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of ke(ys. Returns nil if the key is not present,\nor the not-found value if supplied."},
           "clojure.browser.dom/element" {:ns "clojure.browser.dom",
                                          :name "element",
                                          :type "function",
                                          :signature ["[tag-or-text]"
                                                      "[tag & children]"],
                                          :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                   :repo "clojurescript",
                                                   :tag "r971",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [79 88]},
                                          :full-name "clojure.browser.dom/element",
                                          :full-name-encode "clojure.browser.dom_element",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prim-seq" {:ns "cljs.core",
                                 :name "prim-seq",
                                 :type "function",
                                 :signature ["[prim i]"],
                                 :source {:code "(defn prim-seq [prim i]\n  (when-not (= 0 (.-length prim))\n    (IndexedSeq. prim i)))",
                                          :repo "clojurescript",
                                          :tag "r971",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [371 373]},
                                 :full-name "cljs.core/prim-seq",
                                 :full-name-encode "cljs.core_prim-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/<=" {:description "Returns true if each successive number argument is greater than or equal to the\nprevious one, false otherwise.",
                           :ns "cljs.core",
                           :name "<=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/<"],
                           :full-name-encode "cljs.core_LTEQ",
                           :source {:code "(defn <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r971",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [853 863]},
                           :extra-sources ({:code "(defmacro <=\n  ([x] true)\n  ([x y] (list 'js* \"(~{} <= ~{})\" x y))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r971",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [92 95]}),
                           :examples [{:id "adb3fd",
                                       :content "```clj\n(<= 1 2)\n;;=> true\n\n(<= 2 2)\n;;=> true\n\n(<= 3 2)\n;;=> false\n\n(<= 2 3 4 5 6)\n;;=> true\n```"}],
                           :full-name "cljs.core/<=",
                           :clj-symbol "clojure.core/<=",
                           :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
           "clojure.set/map-invert" {:ns "clojure.set",
                                     :name "map-invert",
                                     :signature ["[m]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set_map-invert",
                                     :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [98 100]},
                                     :full-name "clojure.set/map-invert",
                                     :clj-symbol "clojure.set/map-invert",
                                     :docstring "Returns the map with the vals mapped to the keys."},
           "clojure.browser.event/listen" {:ns "clojure.browser.event",
                                           :name "listen",
                                           :type "function",
                                           :signature ["[src type fn]"
                                                       "[src type fn capture?]"],
                                           :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (goog.events/listen src\n                         (get (event-types src) type type)\n                         fn\n                         capture?)))",
                                                    :repo "clojurescript",
                                                    :tag "r971",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [44 51]},
                                           :full-name "clojure.browser.event/listen",
                                           :full-name-encode "clojure.browser.event_listen",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/neg?" {:description "Returns true if `n` is less than 0, false otherwise.",
                             :ns "cljs.core",
                             :name "neg?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/pos?"
                                       "cljs.core/zero?"],
                             :full-name-encode "cljs.core_negQMARK",
                             :source {:code "(defn neg?\n  [x] (cljs.core/neg? x))",
                                      :repo "clojurescript",
                                      :tag "r971",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1005 1007]},
                             :extra-sources ({:code "(defmacro neg? [x]\n  `(< ~x 0))",
                                              :repo "clojurescript",
                                              :tag "r971",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [124 125]}),
                             :full-name "cljs.core/neg?",
                             :clj-symbol "clojure.core/neg?",
                             :docstring "Returns true if num is less than zero, else false"},
           "clojure.browser.dom/replace-node" {:ns "clojure.browser.dom",
                                               :name "replace-node",
                                               :signature ["[old-node new-node]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.dom_replace-node",
                                               :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                        :repo "clojurescript",
                                                        :tag "r971",
                                                        :filename "src/cljs/clojure/browser/dom.cljs",
                                                        :lines [112
                                                                120]},
                                               :full-name "clojure.browser.dom/replace-node",
                                               :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string."},
           "syntax/boolean" {:description "`true` or `false`",
                             :ns "syntax",
                             :name "boolean",
                             :history [["+" "0.0-927"]],
                             :type "special symbol",
                             :related ["cljs.core/boolean"
                                       "special/if"
                                       "cljs.core/if-not"
                                       "cljs.core/not"
                                       "cljs.core/cond"],
                             :full-name-encode "syntax_boolean",
                             :source {:repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form ["true" "false"],
                             :examples [{:id "1afc59",
                                         :content "```clj\ntrue\n;;=> true\n\nfalse\n;;=> false\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#booleans",
                             :full-name "syntax/boolean",
                             :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/destructure" {:ns "syntax",
                                 :name "destructure",
                                 :history [["+" "0.0-927"]],
                                 :type "binding",
                                 :full-name-encode "syntax_destructure",
                                 :source {:code "(defn destructure [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n               (let [pvec\n                     (fn [bvec b val]\n                       (let [gvec (gensym \"vec__\")]\n                         (loop [ret (-> bvec (conj gvec) (conj val))\n                                n 0\n                                bs b\n                                seen-rest? false]\n                           (if (seq bs)\n                             (let [firstb (first bs)]\n                               (cond\n                                (= firstb '&) (recur (pb ret (second bs) (list `nthnext gvec n))\n                                                     n\n                                                     (nnext bs)\n                                                     true)\n                                (= firstb :as) (pb ret (second bs) gvec)\n                                :else (if seen-rest?\n                                        (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                        (recur (pb ret firstb  (list `nth gvec n nil))\n                                               (inc n)\n                                               (next bs)\n                                               seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (let [gmap (or (:as b) (gensym \"map__\"))\n                             defaults (:or b)]\n                         (loop [ret (-> bvec (conj gmap) (conj v)\n                                        (conj gmap) (conj `(if (seq? ~gmap) (apply hash-map ~gmap) ~gmap)))\n                                bes (reduce1\n                                     (fn [bes entry]\n                                       (reduce1 #(assoc %1 %2 ((val entry) %2))\n                                               (dissoc bes (key entry))\n                                               ((key entry) bes)))\n                                     (dissoc b :as :or)\n                                     {:keys #(keyword (str %)), :strs str, :syms #(list `quote %)})]\n                           (if (seq bes)\n                             (let [bb (key (first bes))\n                                   bk (val (first bes))\n                                   has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (list `get gmap bk (defaults bb))\n                                                   (list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                 (cond\n                  (symbol? b) (-> bvec (conj b) (conj v))\n                  (vector? b) (pvec bvec b v)\n                  (map? b) (pmap bvec b v)\n                  :else (throw (new Exception (str \"Unsupported binding form: \" b))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (reduce1 process-entry [] bents))))",
                                          :repo "clojure",
                                          :tag "clojure-1.3.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [3896 3951]},
                                 :syntax-form [":keys"
                                               ":syms"
                                               ":strs"
                                               ":or"
                                               ":as"
                                               "&"],
                                 :full-name "syntax/destructure",
                                 :clj-doc "http://clojure.org/special_forms#toc18"},
           "special/catch" {:description "`catch` should be used inside of a `try` expression.\n\n`exception-type` should be the type of exception thrown (usually `js/Error` or\n`js/Object`). When there is a match, the thrown exception will be bound to\n`name` inside of `expr*` and `expr*` will be evaluated and returned as the value\nof the `try` expression.",
                            :ns "special",
                            :name "catch",
                            :signature ["[exception-type name expr*]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :related ["special/try"
                                      "special/finally"
                                      "special/throw"],
                            :full-name-encode "special_catch",
                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                     :repo "clojurescript",
                                     :tag "r971",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [501 529]},
                            :full-name "special/catch",
                            :clj-symbol "clojure.core/catch",
                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/reverse" {:description "Returns a sequence of the items in `coll` in reverse order. Not lazy.",
                                :ns "cljs.core",
                                :name "reverse",
                                :signature ["[coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/rseq"],
                                :full-name-encode "cljs.core_reverse",
                                :source {:code "(defn reverse\n  [coll]\n  (reduce conj () coll))",
                                         :repo "clojurescript",
                                         :tag "r971",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1188 1191]},
                                :full-name "cljs.core/reverse",
                                :clj-symbol "clojure.core/reverse",
                                :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
           "cljs.repl.browser/ordering" {:ns "cljs.repl.browser",
                                         :name "ordering",
                                         :type "var",
                                         :source {:code "(def ordering (agent {:expecting nil :fns {}}))",
                                                  :repo "clojurescript",
                                                  :tag "r971",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [190]},
                                         :full-name "cljs.repl.browser/ordering",
                                         :full-name-encode "cljs.repl.browser_ordering",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/realized?" {:description "Returns true if a value has been produced for a lazy sequence.",
                                  :ns "cljs.core",
                                  :name "realized?",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/lazy-seq"],
                                  :full-name-encode "cljs.core_realizedQMARK",
                                  :source {:code "(defn realized?\n  [d]\n  (-realized? d))",
                                           :repo "clojurescript",
                                           :tag "r971",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3211 3214]},
                                  :full-name "cljs.core/realized?",
                                  :clj-symbol "clojure.core/realized?",
                                  :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}},
 :api {:syntax {:changes [{:cljs-version "0.0-927",
                           :cljs-date "2012-01-20",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790",
                           :added #{"syntax/Math-ns"
                                    "syntax/symbol"
                                    "syntax/vector"
                                    "syntax/string"
                                    "syntax/comment"
                                    "syntax/quote"
                                    "syntax/keyword-qualify"
                                    "syntax/meta"
                                    "syntax/regex"
                                    "syntax/eval"
                                    "syntax/unquote-splicing"
                                    "syntax/keyword"
                                    "syntax/character"
                                    "syntax/unreadable"
                                    "syntax/hashbang"
                                    "syntax/arg"
                                    "syntax/set"
                                    "syntax/syntax-quote"
                                    "syntax/dispatch"
                                    "syntax/function"
                                    "syntax/nil"
                                    "syntax/map"
                                    "syntax/number"
                                    "syntax/list"
                                    "syntax/deref"
                                    "syntax/unquote"
                                    "syntax/js-ns"
                                    "syntax/ignore"
                                    "syntax/var"
                                    "syntax/boolean"
                                    "syntax/destructure"}}
                          {:cljs-version "0.0-971",
                           :cljs-date "2012-01-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}],
                :symbol-names #{"syntax/Math-ns"
                                "syntax/symbol"
                                "syntax/vector"
                                "syntax/string"
                                "syntax/comment"
                                "syntax/quote"
                                "syntax/keyword-qualify"
                                "syntax/meta"
                                "syntax/regex"
                                "syntax/eval"
                                "syntax/unquote-splicing"
                                "syntax/keyword"
                                "syntax/character"
                                "syntax/unreadable"
                                "syntax/hashbang"
                                "syntax/arg"
                                "syntax/set"
                                "syntax/syntax-quote"
                                "syntax/dispatch"
                                "syntax/function"
                                "syntax/nil"
                                "syntax/map"
                                "syntax/number"
                                "syntax/list"
                                "syntax/deref"
                                "syntax/unquote"
                                "syntax/js-ns"
                                "syntax/ignore"
                                "syntax/var"
                                "syntax/boolean"
                                "syntax/destructure"}},
       :library {:changes [{:cljs-version "0.0-927",
                            :cljs-date "2012-01-20",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/keys"
                                     "cljs.core/reset!"
                                     "clojure.set/select"
                                     "cljs.core/delay"
                                     "cljs.core/bit-not"
                                     "cljs.core/partition"
                                     "cljs.core/parents"
                                     "cljs.core/aclone"
                                     "cljs.core/reset-meta!"
                                     "special/defrecord*"
                                     "cljs.reader/dispatch-macros"
                                     "cljs.core/ICollection"
                                     "cljs.core/every?"
                                     "clojure.zip/node"
                                     "cljs.core/IEmptyableCollection"
                                     "clojure.zip/right"
                                     "cljs.core/=="
                                     "special/."
                                     "clojure.browser.net/*timeout*"
                                     "cljs.core/remove-method"
                                     "cljs.core/frequencies"
                                     "cljs.core/pop"
                                     "cljs.core/not-every?"
                                     "cljs.core/some-fn"
                                     "clojure.browser.event/remove-all"
                                     "cljs.core/doto"
                                     "cljs.core/take-while"
                                     "cljs.reader/escape-char-map"
                                     "clojure.browser.event/all-listeners"
                                     "cljs.core/vals"
                                     "cljs.core/IDeref"
                                     "clojure.browser.dom/log-obj"
                                     "cljs.core/for"
                                     "cljs.core/instance?"
                                     "cljs.reader/read-comment"
                                     "cljs.reader/read-number"
                                     "cljs.core/ILookup"
                                     "cljs.core/when"
                                     "clojure.browser.dom/set-value"
                                     "cljs.reader/read-past"
                                     "cljs.core/to-array"
                                     "cljs.core/interpose"
                                     "clojure.browser.net/ICrossPageChannel"
                                     "special/finally"
                                     "cljs.core/Cons"
                                     "cljs.core/re-find"
                                     "cljs.core/IMeta"
                                     "cljs.core/assoc-in"
                                     "clojure.string/join"
                                     "clojure.zip/rights"
                                     "cljs.core/split-at"
                                     "clojure.zip/append-child"
                                     "cljs.core/binding"
                                     "cljs.core/Set"
                                     "cljs.reader/macro-terminating?"
                                     "cljs.core/prefers"
                                     "cljs.core/vary-meta"
                                     "cljs.core/when-let"
                                     "cljs.core/drop"
                                     "cljs.core/while"
                                     "cljs.core/import-macros"
                                     "cljs.core/string-print"
                                     "cljs.core/-"
                                     "clojure.zip/vector-zip"
                                     "cljs.core/js->clj"
                                     "cljs.core/List"
                                     "cljs.core/identical?"
                                     "cljs.core/*main-cli-fn*"
                                     "clojure.browser.dom/html->dom"
                                     "cljs.core/some"
                                     "cljs.core/doall"
                                     "cljs.core/condp"
                                     "clojure.zip/down"
                                     "cljs.core/IPending"
                                     "cljs.core/count"
                                     "cljs.core/bit-test"
                                     "cljs.core/loop"
                                     "cljs.core/subvec"
                                     "cljs.core/bit-clear"
                                     "cljs.core/gensym"
                                     "special/recur"
                                     "cljs.core/+"
                                     "cljs.core/comp"
                                     "cljs.reader/desugar-meta"
                                     "cljs.core/pr"
                                     "clojure.string/upper-case"
                                     "clojure.browser.event/expose"
                                     "clojure.browser.event/listen-once"
                                     "cljs.core/empty?"
                                     "cljs.core/newline"
                                     "cljs.core/replace"
                                     "cljs.core/rand"
                                     "cljs.core/add-watch"
                                     "clojure.string/capitalize"
                                     "cljs.core/replicate"
                                     "special/do"
                                     "cljs.core/sequential?"
                                     "cljs.core/underive"
                                     "cljs.core/get-method"
                                     "cljs.core/="
                                     "cljs.core/defn-"
                                     "cljs.reader/read-symbol"
                                     "cljs.reader/push-back-reader"
                                     "cljs.core/deftype"
                                     "cljs.core/Subvec"
                                     "special/ns"
                                     "cljs.core/extend-protocol"
                                     "cljs.reader/read"
                                     "cljs.core/EmptyList"
                                     "clojure.walk/postwalk"
                                     "clojure.zip/edit"
                                     "cljs.core/re-seq"
                                     "cljs.reader/read-list"
                                     "cljs.core/Atom"
                                     "cljs.core/IMap"
                                     "cljs.reader/read-vector"
                                     "clojure.set/join"
                                     "cljs.core/HashMap"
                                     "cljs.reader/int-pattern"
                                     "cljs.core/swap!"
                                     "cljs.core/dec"
                                     "clojure.browser.dom/remove-children"
                                     "cljs.core/get-validator"
                                     "cljs.core/coll?"
                                     "cljs.core/bit-or"
                                     "cljs.core/nfirst"
                                     "cljs.core/keep"
                                     "cljs.core/take"
                                     "cljs.core/cond"
                                     "cljs.core/bit-and"
                                     "cljs.core/ObjMap.fromObject"
                                     "clojure.browser.event/unique-event-id"
                                     "clojure.set/project"
                                     "special/js*"
                                     "clojure.string/trim-newline"
                                     "specialrepl/in-ns"
                                     "special/let*"
                                     "special/throw"
                                     "clojure.zip/insert-left"
                                     "cljs.core/true?"
                                     "clojure.browser.net/xpc-connection"
                                     "cljs.core/not"
                                     "cljs.core/js-obj"
                                     "cljs.core/complement"
                                     "cljs.core/spread"
                                     "cljs.core/keyword"
                                     "cljs.core/sort"
                                     "clojure.string/trim"
                                     "cljs.core/meta"
                                     "cljs.core/time"
                                     "cljs.core/boolean"
                                     "cljs.reader/read-token"
                                     "cljs.core/update-in"
                                     "cljs.core/map-indexed"
                                     "cljs.core/IStack"
                                     "cljs.core/IIndexed"
                                     "clojure.browser.repl/repl-print"
                                     "clojure.browser.net/xpc-config-fields"
                                     "cljs.core/nnext"
                                     "cljs.core/*print-meta*"
                                     "cljs.reader/read-dispatch"
                                     "cljs.core/distinct"
                                     "cljs.reader/wrapping-reader"
                                     "cljs.core/prn"
                                     "clojure.zip/leftmost"
                                     "cljs.core/>="
                                     "cljs.reader/macros"
                                     "cljs.core/doseq"
                                     "cljs.core/*"
                                     "cljs.core/into"
                                     "cljs.core/defmethod"
                                     "cljs.core/rest"
                                     "cljs.core/dotimes"
                                     "clojure.zip/lefts"
                                     "clojure.browser.dom/ensure-element"
                                     "cljs.core/defmacro"
                                     "cljs.core/remove"
                                     "cljs.core/if-not"
                                     "clojure.zip/path"
                                     "cljs.core/mapcat"
                                     "cljs.core/IWatchable"
                                     "clojure.zip/rightmost"
                                     "cljs.core/->"
                                     "cljs.core/remove-all-methods"
                                     "clojure.string/replace-first"
                                     "clojure.browser.dom/get-value"
                                     "cljs.nodejs/process"
                                     "cljs.core/not="
                                     "cljs.core/js-keys"
                                     "clojure.zip/seq-zip"
                                     "cljs.core/IVector"
                                     "cljs.core/empty"
                                     "cljs.core/re-matches"
                                     "clojure.browser.dom/DOMBuilder"
                                     "cljs.core/extend-type"
                                     "cljs.core/ISeqable"
                                     "cljs.core/assoc"
                                     "clojure.browser.repl/xpc-connection"
                                     "cljs.core/IDerefWithTimeout"
                                     "clojure.browser.repl/start-evaluator"
                                     "clojure.browser.event/unlisten"
                                     "cljs.core/fnil"
                                     "cljs.core/this-as"
                                     "cljs.core/PersistentQueueSeq"
                                     "cljs.core/counted?"
                                     "clojure.string/trimr"
                                     "cljs.core/force"
                                     "cljs.core/compare-and-set!"
                                     "cljs.core/set?"
                                     "clojure.string/escape"
                                     "cljs.core/remove-watch"
                                     "cljs.core/IMultiFn"
                                     "clojure.zip/end?"
                                     "clojure.set/superset?"
                                     "clojure.browser.net/IConnection"
                                     "cljs.core/let"
                                     "cljs.core/dorun"
                                     "cljs.core/pr-str"
                                     "cljs.core/IPrintable"
                                     "cljs.core/defprotocol"
                                     "cljs.core/assert"
                                     "cljs.core/declare"
                                     "cljs.core/fn?"
                                     "cljs.core/associative?"
                                     "cljs.core/list*"
                                     "cljs.core/reduce"
                                     "clojure.browser.event/has-listener"
                                     "cljs.core/compare"
                                     "cljs.core/contains?"
                                     "cljs.core/prefer-method"
                                     "cljs.core/array-seq"
                                     "cljs.core/PersistentQueue"
                                     "cljs.core/drop-last"
                                     "cljs.reader/read-string"
                                     "cljs.core/vector?"
                                     "cljs.core/defmulti"
                                     "cljs.core/List.EMPTY"
                                     "clojure.browser.event/dispatch-event"
                                     "clojure.string/split-lines"
                                     "cljs.core/areduce"
                                     "cljs.core/disj"
                                     "clojure.browser.net/event-types"
                                     "clojure.string/lower-case"
                                     "cljs.core/*print-fn*"
                                     "cljs.core/str"
                                     "cljs.core/ISequential"
                                     "cljs.core/set"
                                     "special/def"
                                     "cljs.core/print"
                                     "clojure.string/blank?"
                                     "clojure.browser.dom/append"
                                     "cljs.core/take-last"
                                     "clojure.set/intersection"
                                     "cljs.core/fnext"
                                     "cljs.core/apply"
                                     "clojure.walk/prewalk"
                                     "cljs.core/flatten"
                                     "cljs.core/get"
                                     "cljs.core/.."
                                     "cljs.core/Range"
                                     "cljs.core/zero?"
                                     "cljs.core/identity"
                                     "cljs.core/first"
                                     "cljs.reader/ratio-pattern"
                                     "cljs.core/>"
                                     "cljs.core/juxt"
                                     "cljs.core/max"
                                     "cljs.core/*3"
                                     "cljs.core/number?"
                                     "cljs.core/array"
                                     "cljs.core/nthnext"
                                     "cljs.core/re-pattern"
                                     "cljs.core/missing-protocol"
                                     "clojure.browser.dom/set-text"
                                     "clojure.zip/up"
                                     "cljs.core/IWithMeta"
                                     "cljs.core/bit-and-not"
                                     "clojure.string/triml"
                                     "clojure.string/split"
                                     "cljs.core/hash-map"
                                     "cljs.core/rem"
                                     "cljs.core/IRecord"
                                     "cljs.core/constantly"
                                     "clojure.browser.dom/get-element"
                                     "cljs.core/and"
                                     "clojure.browser.repl/wrap-message"
                                     "clojure.browser.event/unlisten-by-key"
                                     "cljs.core/try"
                                     "cljs.core/iterate"
                                     "cljs.core/lazy-seq"
                                     "specialrepl/load-file"
                                     "cljs.core/IndexedSeq"
                                     "cljs.core/next"
                                     "cljs.core/*print-readably*"
                                     "cljs.core/last"
                                     "cljs.core/bit-shift-left"
                                     "clojure.string/reverse"
                                     "cljs.core/min"
                                     "cljs.reader/escape-char"
                                     "cljs.reader/read-map"
                                     "cljs.core/seq"
                                     "cljs.core/not-empty"
                                     "cljs.core/println"
                                     "clojure.browser.repl/connect"
                                     "clojure.browser.dom/insert-at"
                                     "cljs.core/quot"
                                     "clojure.browser.event/get-listener"
                                     "cljs.core/filter"
                                     "clojure.zip/branch?"
                                     "special/if"
                                     "cljs.core/ObjMap"
                                     "cljs.core/zipmap"
                                     "cljs.core/hash-combine"
                                     "cljs.core/max-key"
                                     "clojure.zip/insert-child"
                                     "cljs.core/defrecord"
                                     "cljs.core/butlast"
                                     "cljs.core/hash"
                                     "cljs.core/bit-set"
                                     "cljs.core/concat"
                                     "cljs.core/conj"
                                     "clojure.set/difference"
                                     "cljs.core/when-first"
                                     "cljs.core/distinct?"
                                     "cljs.core/pos?"
                                     "cljs.core/IHash"
                                     "cljs.core/is_proto_"
                                     "cljs.core/keep-indexed"
                                     "cljs.core/bit-shift-right"
                                     "clojure.zip/insert-right"
                                     "cljs.core/make-hierarchy"
                                     "cljs.core/repeat"
                                     "cljs.core/MultiFn"
                                     "cljs.core/not-any?"
                                     "cljs.reader/read-regex"
                                     "clojure.zip/next"
                                     "cljs.core/aget"
                                     "cljs.core/if-let"
                                     "cljs.core//"
                                     "cljs.core/min-key"
                                     "clojure.zip/root"
                                     "cljs.core/drop-while"
                                     "clojure.browser.repl/evaluate-javascript"
                                     "cljs.core/set-validator!"
                                     "cljs.core/<"
                                     "cljs.core/fn"
                                     "cljs.core/split-with"
                                     "cljs.core/IReduce"
                                     "cljs.reader/symbol-pattern"
                                     "cljs.core/repeatedly"
                                     "cljs.reader/read-delimited-list"
                                     "cljs.core/undefined?"
                                     "clojure.zip/prev"
                                     "cljs.core/seq?"
                                     "cljs.core/odd?"
                                     "cljs.core/cons"
                                     "special/deftype*"
                                     "cljs.reader/read-set"
                                     "cljs.core/descendants"
                                     "special/new"
                                     "cljs.core/take-nth"
                                     "cljs.reader/throwing-reader"
                                     "cljs.core/even?"
                                     "special/fn*"
                                     "clojure.set/subset?"
                                     "cljs.core/flush"
                                     "cljs.reader/reader-error"
                                     "clojure.walk/prewalk-replace"
                                     "cljs.core/*1"
                                     "cljs.core/Set.EMPTY"
                                     "cljs.reader/read-unicode-char"
                                     "cljs.core/dissoc"
                                     "cljs.core/ffirst"
                                     "clojure.zip/replace"
                                     "cljs.core/vec"
                                     "cljs.core/or"
                                     "cljs.core/mod"
                                     "cljs.core/aset"
                                     "cljs.core/second"
                                     "clojure.set/rename"
                                     "cljs.core/delay?"
                                     "clojure.zip/left"
                                     "cljs.reader/not-implemented"
                                     "cljs.core/IAssociative"
                                     "cljs.core/ObjMap.EMPTY"
                                     "cljs.core/group-by"
                                     "cljs.core/symbol"
                                     "cljs.core/Delay"
                                     "cljs.core/methods"
                                     "cljs.core/vector"
                                     "cljs.core/rand-int"
                                     "cljs.core/PersistentQueue.EMPTY"
                                     "cljs.core/letfn"
                                     "cljs.reader/read-discard"
                                     "cljs.core/inc"
                                     "cljs.core/name"
                                     "cljs.core/cycle"
                                     "cljs.core/map"
                                     "cljs.core/amap"
                                     "clojure.zip/children"
                                     "special/set!"
                                     "cljs.core/when-not"
                                     "clojure.set/index"
                                     "clojure.browser.dom/log"
                                     "cljs.core/Vector.fromArray"
                                     "cljs.core/partition-by"
                                     "cljs.core/sort-by"
                                     "cljs.core/with-meta"
                                     "cljs.core/NeverEquiv"
                                     "cljs.core/select-keys"
                                     "special/loop*"
                                     "cljs.core/ISeq"
                                     "clojure.walk/postwalk-replace"
                                     "cljs.core/pr-with-opts"
                                     "cljs.core/->>"
                                     "cljs.core/nil?"
                                     "clojure.walk/stringify-keys"
                                     "clojure.browser.repl/order"
                                     "cljs.core/memoize"
                                     "cljs.core/pr-sequential"
                                     "clojure.zip/make-node"
                                     "specialrepl/load-namespace"
                                     "cljs.reader/float-pattern"
                                     "cljs.core/ancestors"
                                     "cljs.core/integer?"
                                     "cljs.core/HashMap.EMPTY"
                                     "cljs.core/Vector.EMPTY"
                                     "clojure.zip/xml-zip"
                                     "clojure.walk/walk"
                                     "cljs.core/bit-xor"
                                     "clojure.set/union"
                                     "cljs.reader/PushbackReader"
                                     "cljs.core/isa?"
                                     "clojure.browser.net/xhr-connection"
                                     "cljs.core/subs"
                                     "cljs.core/symbol?"
                                     "clojure.string/replace"
                                     "cljs.core/string?"
                                     "cljs.core/partition-all"
                                     "cljs.core/merge-with"
                                     "clojure.browser.dom/set-properties"
                                     "cljs.core/trampoline"
                                     "clojure.browser.repl/send-print"
                                     "cljs.core/ICounted"
                                     "cljs.core/IEquiv"
                                     "cljs.core/js-delete"
                                     "cljs.core/comment"
                                     "cljs.reader/special-symbols"
                                     "cljs.core/alength"
                                     "special/quote"
                                     "cljs.core/tree-seq"
                                     "cljs.reader/read-unmatched-delimiter"
                                     "cljs.core/every-pred"
                                     "clojure.set/rename-keys"
                                     "cljs.core/peek"
                                     "cljs.core/pr-str-with-opts"
                                     "cljs.core/map?"
                                     "cljs.reader/StringPushbackReader"
                                     "cljs.core/HashMap.fromArrays"
                                     "cljs.core/deref"
                                     "cljs.core/reductions"
                                     "cljs.core/false?"
                                     "cljs.core/bit-flip"
                                     "cljs.core/ISet"
                                     "cljs.core/LazySeq"
                                     "cljs.core/*2"
                                     "clojure.browser.event/total-listener-count"
                                     "cljs.core/alter-meta!"
                                     "clojure.browser.dom/click-element"
                                     "cljs.reader/read-meta"
                                     "special/try*"
                                     "cljs.core/range"
                                     "cljs.core/reify"
                                     "cljs.core/satisfies?"
                                     "cljs.core/nth"
                                     "cljs.core/list"
                                     "cljs.core/defn"
                                     "cljs.core/rand-nth"
                                     "cljs.core/atom"
                                     "cljs.reader/read-keyword"
                                     "cljs.core/Vector"
                                     "cljs.reader/skip-line"
                                     "cljs.core/namespace"
                                     "cljs.nodejs/require"
                                     "clojure.browser.event/EventType"
                                     "cljs.core/merge"
                                     "clojure.browser.repl/send-result"
                                     "clojure.walk/keywordize-keys"
                                     "cljs.core/derive"
                                     "clojure.zip/zipper"
                                     "clojure.zip/remove"
                                     "cljs.core/find"
                                     "cljs.core/*print-dup*"
                                     "cljs.core/partial"
                                     "cljs.core/keyword?"
                                     "clojure.browser.event/fire-listeners"
                                     "cljs.core/interleave"
                                     "cljs.core/*flush-on-newline*"
                                     "cljs.core/get-in"
                                     "clojure.browser.dom/element"
                                     "cljs.core/prim-seq"
                                     "cljs.core/<="
                                     "clojure.set/map-invert"
                                     "clojure.browser.event/listen"
                                     "cljs.core/neg?"
                                     "clojure.browser.dom/replace-node"
                                     "special/catch"
                                     "cljs.core/reverse"
                                     "cljs.core/realized?"}}
                           {:cljs-version "0.0-971",
                            :cljs-date "2012-01-27",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/type" "cljs.core/IFn"}}],
                 :symbol-names #{"cljs.core/keys"
                                 "cljs.core/reset!"
                                 "clojure.set/select"
                                 "cljs.core/delay"
                                 "cljs.core/bit-not"
                                 "cljs.core/partition"
                                 "cljs.core/parents"
                                 "cljs.core/aclone"
                                 "cljs.core/reset-meta!"
                                 "special/defrecord*"
                                 "cljs.reader/dispatch-macros"
                                 "cljs.core/ICollection"
                                 "cljs.core/every?"
                                 "clojure.zip/node"
                                 "cljs.core/IEmptyableCollection"
                                 "clojure.zip/right"
                                 "cljs.core/=="
                                 "special/."
                                 "clojure.browser.net/*timeout*"
                                 "cljs.core/remove-method"
                                 "cljs.core/frequencies"
                                 "cljs.core/pop"
                                 "cljs.core/not-every?"
                                 "cljs.core/some-fn"
                                 "clojure.browser.event/remove-all"
                                 "cljs.core/doto"
                                 "cljs.core/take-while"
                                 "cljs.reader/escape-char-map"
                                 "clojure.browser.event/all-listeners"
                                 "cljs.core/vals"
                                 "cljs.core/IDeref"
                                 "clojure.browser.dom/log-obj"
                                 "cljs.core/for"
                                 "cljs.core/instance?"
                                 "cljs.reader/read-comment"
                                 "cljs.reader/read-number"
                                 "cljs.core/ILookup"
                                 "cljs.core/when"
                                 "clojure.browser.dom/set-value"
                                 "cljs.reader/read-past"
                                 "cljs.core/to-array"
                                 "cljs.core/interpose"
                                 "clojure.browser.net/ICrossPageChannel"
                                 "special/finally"
                                 "cljs.core/Cons"
                                 "cljs.core/re-find"
                                 "cljs.core/IMeta"
                                 "cljs.core/assoc-in"
                                 "clojure.string/join"
                                 "clojure.zip/rights"
                                 "cljs.core/split-at"
                                 "clojure.zip/append-child"
                                 "cljs.core/binding"
                                 "cljs.core/Set"
                                 "cljs.reader/macro-terminating?"
                                 "cljs.core/prefers"
                                 "cljs.core/vary-meta"
                                 "cljs.core/when-let"
                                 "cljs.core/drop"
                                 "cljs.core/while"
                                 "cljs.core/import-macros"
                                 "cljs.core/string-print"
                                 "cljs.core/-"
                                 "clojure.zip/vector-zip"
                                 "cljs.core/js->clj"
                                 "cljs.core/List"
                                 "cljs.core/identical?"
                                 "cljs.core/*main-cli-fn*"
                                 "clojure.browser.dom/html->dom"
                                 "cljs.core/some"
                                 "cljs.core/doall"
                                 "cljs.core/condp"
                                 "clojure.zip/down"
                                 "cljs.core/IPending"
                                 "cljs.core/count"
                                 "cljs.core/bit-test"
                                 "cljs.core/loop"
                                 "cljs.core/subvec"
                                 "cljs.core/bit-clear"
                                 "cljs.core/gensym"
                                 "special/recur"
                                 "cljs.core/+"
                                 "cljs.core/comp"
                                 "cljs.reader/desugar-meta"
                                 "cljs.core/pr"
                                 "clojure.string/upper-case"
                                 "clojure.browser.event/expose"
                                 "clojure.browser.event/listen-once"
                                 "cljs.core/empty?"
                                 "cljs.core/newline"
                                 "cljs.core/replace"
                                 "cljs.core/rand"
                                 "cljs.core/add-watch"
                                 "clojure.string/capitalize"
                                 "cljs.core/replicate"
                                 "special/do"
                                 "cljs.core/sequential?"
                                 "cljs.core/underive"
                                 "cljs.core/get-method"
                                 "cljs.core/="
                                 "cljs.core/defn-"
                                 "cljs.reader/read-symbol"
                                 "cljs.reader/push-back-reader"
                                 "cljs.core/deftype"
                                 "cljs.core/Subvec"
                                 "special/ns"
                                 "cljs.core/extend-protocol"
                                 "cljs.reader/read"
                                 "cljs.core/EmptyList"
                                 "clojure.walk/postwalk"
                                 "clojure.zip/edit"
                                 "cljs.core/re-seq"
                                 "cljs.reader/read-list"
                                 "cljs.core/Atom"
                                 "cljs.core/IMap"
                                 "cljs.reader/read-vector"
                                 "clojure.set/join"
                                 "cljs.core/HashMap"
                                 "cljs.reader/int-pattern"
                                 "cljs.core/swap!"
                                 "cljs.core/dec"
                                 "clojure.browser.dom/remove-children"
                                 "cljs.core/get-validator"
                                 "cljs.core/coll?"
                                 "cljs.core/bit-or"
                                 "cljs.core/nfirst"
                                 "cljs.core/keep"
                                 "cljs.core/take"
                                 "cljs.core/cond"
                                 "cljs.core/bit-and"
                                 "cljs.core/ObjMap.fromObject"
                                 "clojure.browser.event/unique-event-id"
                                 "clojure.set/project"
                                 "special/js*"
                                 "clojure.string/trim-newline"
                                 "specialrepl/in-ns"
                                 "special/let*"
                                 "special/throw"
                                 "clojure.zip/insert-left"
                                 "cljs.core/true?"
                                 "clojure.browser.net/xpc-connection"
                                 "cljs.core/not"
                                 "cljs.core/js-obj"
                                 "cljs.core/complement"
                                 "cljs.core/spread"
                                 "cljs.core/keyword"
                                 "cljs.core/sort"
                                 "clojure.string/trim"
                                 "cljs.core/meta"
                                 "cljs.core/time"
                                 "cljs.core/boolean"
                                 "cljs.reader/read-token"
                                 "cljs.core/update-in"
                                 "cljs.core/map-indexed"
                                 "cljs.core/IStack"
                                 "cljs.core/IIndexed"
                                 "clojure.browser.repl/repl-print"
                                 "clojure.browser.net/xpc-config-fields"
                                 "cljs.core/nnext"
                                 "cljs.core/*print-meta*"
                                 "cljs.reader/read-dispatch"
                                 "cljs.core/distinct"
                                 "cljs.reader/wrapping-reader"
                                 "cljs.core/prn"
                                 "clojure.zip/leftmost"
                                 "cljs.core/>="
                                 "cljs.reader/macros"
                                 "cljs.core/doseq"
                                 "cljs.core/*"
                                 "cljs.core/into"
                                 "cljs.core/defmethod"
                                 "cljs.core/rest"
                                 "cljs.core/dotimes"
                                 "clojure.zip/lefts"
                                 "clojure.browser.dom/ensure-element"
                                 "cljs.core/defmacro"
                                 "cljs.core/remove"
                                 "cljs.core/if-not"
                                 "clojure.zip/path"
                                 "cljs.core/mapcat"
                                 "cljs.core/IWatchable"
                                 "clojure.zip/rightmost"
                                 "cljs.core/->"
                                 "cljs.core/remove-all-methods"
                                 "clojure.string/replace-first"
                                 "clojure.browser.dom/get-value"
                                 "cljs.nodejs/process"
                                 "cljs.core/not="
                                 "cljs.core/js-keys"
                                 "clojure.zip/seq-zip"
                                 "cljs.core/IVector"
                                 "cljs.core/empty"
                                 "cljs.core/re-matches"
                                 "clojure.browser.dom/DOMBuilder"
                                 "cljs.core/extend-type"
                                 "cljs.core/ISeqable"
                                 "cljs.core/assoc"
                                 "clojure.browser.repl/xpc-connection"
                                 "cljs.core/IDerefWithTimeout"
                                 "clojure.browser.repl/start-evaluator"
                                 "clojure.browser.event/unlisten"
                                 "cljs.core/fnil"
                                 "cljs.core/this-as"
                                 "cljs.core/PersistentQueueSeq"
                                 "cljs.core/counted?"
                                 "clojure.string/trimr"
                                 "cljs.core/force"
                                 "cljs.core/compare-and-set!"
                                 "cljs.core/set?"
                                 "clojure.string/escape"
                                 "cljs.core/remove-watch"
                                 "cljs.core/IMultiFn"
                                 "clojure.zip/end?"
                                 "clojure.set/superset?"
                                 "clojure.browser.net/IConnection"
                                 "cljs.core/let"
                                 "cljs.core/dorun"
                                 "cljs.core/pr-str"
                                 "cljs.core/IPrintable"
                                 "cljs.core/defprotocol"
                                 "cljs.core/assert"
                                 "cljs.core/declare"
                                 "cljs.core/fn?"
                                 "cljs.core/associative?"
                                 "cljs.core/list*"
                                 "cljs.core/reduce"
                                 "clojure.browser.event/has-listener"
                                 "cljs.core/compare"
                                 "cljs.core/contains?"
                                 "cljs.core/prefer-method"
                                 "cljs.core/array-seq"
                                 "cljs.core/PersistentQueue"
                                 "cljs.core/drop-last"
                                 "cljs.reader/read-string"
                                 "cljs.core/vector?"
                                 "cljs.core/defmulti"
                                 "cljs.core/List.EMPTY"
                                 "clojure.browser.event/dispatch-event"
                                 "clojure.string/split-lines"
                                 "cljs.core/areduce"
                                 "cljs.core/disj"
                                 "clojure.browser.net/event-types"
                                 "clojure.string/lower-case"
                                 "cljs.core/*print-fn*"
                                 "cljs.core/str"
                                 "cljs.core/ISequential"
                                 "cljs.core/set"
                                 "special/def"
                                 "cljs.core/print"
                                 "cljs.core/type"
                                 "clojure.string/blank?"
                                 "clojure.browser.dom/append"
                                 "cljs.core/take-last"
                                 "clojure.set/intersection"
                                 "cljs.core/fnext"
                                 "cljs.core/apply"
                                 "clojure.walk/prewalk"
                                 "cljs.core/flatten"
                                 "cljs.core/get"
                                 "cljs.core/.."
                                 "cljs.core/Range"
                                 "cljs.core/zero?"
                                 "cljs.core/identity"
                                 "cljs.core/first"
                                 "cljs.reader/ratio-pattern"
                                 "cljs.core/>"
                                 "cljs.core/juxt"
                                 "cljs.core/max"
                                 "cljs.core/*3"
                                 "cljs.core/number?"
                                 "cljs.core/array"
                                 "cljs.core/nthnext"
                                 "cljs.core/re-pattern"
                                 "cljs.core/missing-protocol"
                                 "clojure.browser.dom/set-text"
                                 "clojure.zip/up"
                                 "cljs.core/IWithMeta"
                                 "cljs.core/bit-and-not"
                                 "clojure.string/triml"
                                 "clojure.string/split"
                                 "cljs.core/hash-map"
                                 "cljs.core/rem"
                                 "cljs.core/IRecord"
                                 "cljs.core/constantly"
                                 "clojure.browser.dom/get-element"
                                 "cljs.core/and"
                                 "clojure.browser.repl/wrap-message"
                                 "clojure.browser.event/unlisten-by-key"
                                 "cljs.core/try"
                                 "cljs.core/iterate"
                                 "cljs.core/lazy-seq"
                                 "specialrepl/load-file"
                                 "cljs.core/IndexedSeq"
                                 "cljs.core/next"
                                 "cljs.core/*print-readably*"
                                 "cljs.core/last"
                                 "cljs.core/bit-shift-left"
                                 "clojure.string/reverse"
                                 "cljs.core/min"
                                 "cljs.reader/escape-char"
                                 "cljs.reader/read-map"
                                 "cljs.core/seq"
                                 "cljs.core/not-empty"
                                 "cljs.core/println"
                                 "clojure.browser.repl/connect"
                                 "clojure.browser.dom/insert-at"
                                 "cljs.core/quot"
                                 "clojure.browser.event/get-listener"
                                 "cljs.core/filter"
                                 "clojure.zip/branch?"
                                 "special/if"
                                 "cljs.core/ObjMap"
                                 "cljs.core/zipmap"
                                 "cljs.core/hash-combine"
                                 "cljs.core/max-key"
                                 "clojure.zip/insert-child"
                                 "cljs.core/defrecord"
                                 "cljs.core/butlast"
                                 "cljs.core/hash"
                                 "cljs.core/bit-set"
                                 "cljs.core/concat"
                                 "cljs.core/conj"
                                 "clojure.set/difference"
                                 "cljs.core/when-first"
                                 "cljs.core/distinct?"
                                 "cljs.core/pos?"
                                 "cljs.core/IHash"
                                 "cljs.core/is_proto_"
                                 "cljs.core/keep-indexed"
                                 "cljs.core/bit-shift-right"
                                 "clojure.zip/insert-right"
                                 "cljs.core/make-hierarchy"
                                 "cljs.core/repeat"
                                 "cljs.core/MultiFn"
                                 "cljs.core/not-any?"
                                 "cljs.reader/read-regex"
                                 "clojure.zip/next"
                                 "cljs.core/IFn"
                                 "cljs.core/aget"
                                 "cljs.core/if-let"
                                 "cljs.core//"
                                 "cljs.core/min-key"
                                 "clojure.zip/root"
                                 "cljs.core/drop-while"
                                 "clojure.browser.repl/evaluate-javascript"
                                 "cljs.core/set-validator!"
                                 "cljs.core/<"
                                 "cljs.core/fn"
                                 "cljs.core/split-with"
                                 "cljs.core/IReduce"
                                 "cljs.reader/symbol-pattern"
                                 "cljs.core/repeatedly"
                                 "cljs.reader/read-delimited-list"
                                 "cljs.core/undefined?"
                                 "clojure.zip/prev"
                                 "cljs.core/seq?"
                                 "cljs.core/odd?"
                                 "cljs.core/cons"
                                 "special/deftype*"
                                 "cljs.reader/read-set"
                                 "cljs.core/descendants"
                                 "special/new"
                                 "cljs.core/take-nth"
                                 "cljs.reader/throwing-reader"
                                 "cljs.core/even?"
                                 "special/fn*"
                                 "clojure.set/subset?"
                                 "cljs.core/flush"
                                 "cljs.reader/reader-error"
                                 "clojure.walk/prewalk-replace"
                                 "cljs.core/*1"
                                 "cljs.core/Set.EMPTY"
                                 "cljs.reader/read-unicode-char"
                                 "cljs.core/dissoc"
                                 "cljs.core/ffirst"
                                 "clojure.zip/replace"
                                 "cljs.core/vec"
                                 "cljs.core/or"
                                 "cljs.core/mod"
                                 "cljs.core/aset"
                                 "cljs.core/second"
                                 "clojure.set/rename"
                                 "cljs.core/delay?"
                                 "clojure.zip/left"
                                 "cljs.reader/not-implemented"
                                 "cljs.core/IAssociative"
                                 "cljs.core/ObjMap.EMPTY"
                                 "cljs.core/group-by"
                                 "cljs.core/symbol"
                                 "cljs.core/Delay"
                                 "cljs.core/methods"
                                 "cljs.core/vector"
                                 "cljs.core/rand-int"
                                 "cljs.core/PersistentQueue.EMPTY"
                                 "cljs.core/letfn"
                                 "cljs.reader/read-discard"
                                 "cljs.core/inc"
                                 "cljs.core/name"
                                 "cljs.core/cycle"
                                 "cljs.core/map"
                                 "cljs.core/amap"
                                 "clojure.zip/children"
                                 "special/set!"
                                 "cljs.core/when-not"
                                 "clojure.set/index"
                                 "clojure.browser.dom/log"
                                 "cljs.core/Vector.fromArray"
                                 "cljs.core/partition-by"
                                 "cljs.core/sort-by"
                                 "cljs.core/with-meta"
                                 "cljs.core/NeverEquiv"
                                 "cljs.core/select-keys"
                                 "special/loop*"
                                 "cljs.core/ISeq"
                                 "clojure.walk/postwalk-replace"
                                 "cljs.core/pr-with-opts"
                                 "cljs.core/->>"
                                 "cljs.core/nil?"
                                 "clojure.walk/stringify-keys"
                                 "clojure.browser.repl/order"
                                 "cljs.core/memoize"
                                 "cljs.core/pr-sequential"
                                 "clojure.zip/make-node"
                                 "specialrepl/load-namespace"
                                 "cljs.reader/float-pattern"
                                 "cljs.core/ancestors"
                                 "cljs.core/integer?"
                                 "cljs.core/HashMap.EMPTY"
                                 "cljs.core/Vector.EMPTY"
                                 "clojure.zip/xml-zip"
                                 "clojure.walk/walk"
                                 "cljs.core/bit-xor"
                                 "clojure.set/union"
                                 "cljs.reader/PushbackReader"
                                 "cljs.core/isa?"
                                 "clojure.browser.net/xhr-connection"
                                 "cljs.core/subs"
                                 "cljs.core/symbol?"
                                 "clojure.string/replace"
                                 "cljs.core/string?"
                                 "cljs.core/partition-all"
                                 "cljs.core/merge-with"
                                 "clojure.browser.dom/set-properties"
                                 "cljs.core/trampoline"
                                 "clojure.browser.repl/send-print"
                                 "cljs.core/ICounted"
                                 "cljs.core/IEquiv"
                                 "cljs.core/js-delete"
                                 "cljs.core/comment"
                                 "cljs.reader/special-symbols"
                                 "cljs.core/alength"
                                 "special/quote"
                                 "cljs.core/tree-seq"
                                 "cljs.reader/read-unmatched-delimiter"
                                 "cljs.core/every-pred"
                                 "clojure.set/rename-keys"
                                 "cljs.core/peek"
                                 "cljs.core/pr-str-with-opts"
                                 "cljs.core/map?"
                                 "cljs.reader/StringPushbackReader"
                                 "cljs.core/HashMap.fromArrays"
                                 "cljs.core/deref"
                                 "cljs.core/reductions"
                                 "cljs.core/false?"
                                 "cljs.core/bit-flip"
                                 "cljs.core/ISet"
                                 "cljs.core/LazySeq"
                                 "cljs.core/*2"
                                 "clojure.browser.event/total-listener-count"
                                 "cljs.core/alter-meta!"
                                 "clojure.browser.dom/click-element"
                                 "cljs.reader/read-meta"
                                 "special/try*"
                                 "cljs.core/range"
                                 "cljs.core/reify"
                                 "cljs.core/satisfies?"
                                 "cljs.core/nth"
                                 "cljs.core/list"
                                 "cljs.core/defn"
                                 "cljs.core/rand-nth"
                                 "cljs.core/atom"
                                 "cljs.reader/read-keyword"
                                 "cljs.core/Vector"
                                 "cljs.reader/skip-line"
                                 "cljs.core/namespace"
                                 "cljs.nodejs/require"
                                 "clojure.browser.event/EventType"
                                 "cljs.core/merge"
                                 "clojure.browser.repl/send-result"
                                 "clojure.walk/keywordize-keys"
                                 "cljs.core/derive"
                                 "clojure.zip/zipper"
                                 "clojure.zip/remove"
                                 "cljs.core/find"
                                 "cljs.core/*print-dup*"
                                 "cljs.core/partial"
                                 "cljs.core/keyword?"
                                 "clojure.browser.event/fire-listeners"
                                 "cljs.core/interleave"
                                 "cljs.core/*flush-on-newline*"
                                 "cljs.core/get-in"
                                 "clojure.browser.dom/element"
                                 "cljs.core/prim-seq"
                                 "cljs.core/<="
                                 "clojure.set/map-invert"
                                 "clojure.browser.event/listen"
                                 "cljs.core/neg?"
                                 "clojure.browser.dom/replace-node"
                                 "special/catch"
                                 "cljs.core/reverse"
                                 "cljs.core/realized?"}},
       :compiler {:changes [{:cljs-version "0.0-927",
                             :cljs-date "2012-01-20",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790",
                             :added #{"cljs.repl.rhino/current-repl-env"
                                      "cljs.repl/evaluate-form"
                                      "cljs.repl/load-stream"
                                      "cljs.repl.browser/read-get"
                                      "cljs.repl.browser/load-javascript"
                                      "cljs.repl.browser/add-in-order"
                                      "cljs.repl/load-namespace"
                                      "cljs.repl.rhino/loaded-libs"
                                      "cljs.repl.browser/run-in-order"
                                      "cljs.repl.browser/compile-client-js"
                                      "cljs.repl.browser/handle-get"
                                      "cljs.repl.browser/stop-server"
                                      "cljs.repl.browser/read-request"
                                      "cljs.repl/load-file"
                                      "cljs.repl.browser/browser-eval"
                                      "cljs.repl.browser/server-state"
                                      "cljs.repl.browser/send-for-eval"
                                      "cljs.repl.browser/constrain-order"
                                      "cljs.repl.rhino/rhino-eval"
                                      "cljs.repl.browser/read-headers"
                                      "cljs.repl/repl"
                                      "cljs.repl.rhino/load-javascript"
                                      "cljs.repl.browser/create-client-js-file"
                                      "cljs.repl/*cljs-verbose*"
                                      "cljs.repl.browser/loaded-libs"
                                      "cljs.repl.browser/repl-client-js"
                                      "cljs.repl.browser/parse-headers"
                                      "cljs.repl.browser/send-404"
                                      "cljs.repl.browser/repl-env"
                                      "cljs.repl.rhino/repl-env"
                                      "cljs.repl.rhino/goog-require"
                                      "cljs.repl.browser/send-repl-client-page"
                                      "cljs.repl.browser/send-and-close"
                                      "cljs.repl.rhino/bootjs"
                                      "cljs.repl/IJavaScriptEnv"
                                      "cljs.repl.browser/handle-connection"
                                      "cljs.repl.rhino/IEval"
                                      "cljs.repl.browser/start-server"
                                      "cljs.repl.browser/server-loop"
                                      "cljs.repl.browser/read-post"
                                      "cljs.repl.rhino/rhino-setup"
                                      "cljs.repl.browser/ordering"}}
                            {:cljs-version "0.0-971",
                             :cljs-date "2012-01-27",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}],
                  :symbol-names #{"cljs.repl.rhino/current-repl-env"
                                  "cljs.repl/evaluate-form"
                                  "cljs.repl/load-stream"
                                  "cljs.repl.browser/read-get"
                                  "cljs.repl.browser/load-javascript"
                                  "cljs.repl.browser/add-in-order"
                                  "cljs.repl/load-namespace"
                                  "cljs.repl.rhino/loaded-libs"
                                  "cljs.repl.browser/run-in-order"
                                  "cljs.repl.browser/compile-client-js"
                                  "cljs.repl.browser/handle-get"
                                  "cljs.repl.browser/stop-server"
                                  "cljs.repl.browser/read-request"
                                  "cljs.repl/load-file"
                                  "cljs.repl.browser/browser-eval"
                                  "cljs.repl.browser/server-state"
                                  "cljs.repl.browser/send-for-eval"
                                  "cljs.repl.browser/constrain-order"
                                  "cljs.repl.rhino/rhino-eval"
                                  "cljs.repl.browser/read-headers"
                                  "cljs.repl/repl"
                                  "cljs.repl.rhino/load-javascript"
                                  "cljs.repl.browser/create-client-js-file"
                                  "cljs.repl/*cljs-verbose*"
                                  "cljs.repl.browser/loaded-libs"
                                  "cljs.repl.browser/repl-client-js"
                                  "cljs.repl.browser/parse-headers"
                                  "cljs.repl.browser/send-404"
                                  "cljs.repl.browser/repl-env"
                                  "cljs.repl.rhino/repl-env"
                                  "cljs.repl.rhino/goog-require"
                                  "cljs.repl.browser/send-repl-client-page"
                                  "cljs.repl.browser/send-and-close"
                                  "cljs.repl.rhino/bootjs"
                                  "cljs.repl/IJavaScriptEnv"
                                  "cljs.repl.browser/handle-connection"
                                  "cljs.repl.rhino/IEval"
                                  "cljs.repl.browser/start-server"
                                  "cljs.repl.browser/server-loop"
                                  "cljs.repl.browser/read-post"
                                  "cljs.repl.rhino/rhino-setup"
                                  "cljs.repl.browser/ordering"}}}}
