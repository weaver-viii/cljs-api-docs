{:release {:cljs-version "0.0-1211",
           :cljs-tag "r1211",
           :cljs-date "2012-05-09",
           :clj-version "1.4.0",
           :clj-tag "clojure-1.4.0",
           :treader-version nil,
           :treader-tag nil,
           :gclosure-lib "20111110-r1376"},
 :clj-not-cljs #{"clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.data/EqualityPartition"
                 "clojure.core/*in*"
                 "clojure.core/unchecked-subtract-int"
                 "clojure.main/demunge"
                 "clojure.core.protocols/kv-reduce"
                 "clojure.core/release-pending-sends"
                 "clojure.lang/AReference"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shorts"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.lang/AMapEntry"
                 "clojure.lang/IHashEq"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.test/use-fixtures"
                 "clojure.java.io/file"
                 "clojure.lang/FnLoaderThunk"
                 "clojure.test/*load-tests*"
                 "clojure.core/->Vec"
                 "clojure.test/deftest-"
                 "clojure.core/unchecked-add"
                 "clojure.lang/Fn"
                 "clojure.core/doubles"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.core/unchecked-byte"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.lang/SeqIterator"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.lang/LazilyPersistentVector"
                 "clojure.core/proxy-super"
                 "clojure.core/unchecked-divide-int"
                 "clojure.core/refer"
                 "clojure.lang/Numbers"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.lang/ILookupThunk"
                 "clojure.core.protocols/CollReduce"
                 "clojure.core/future-call"
                 "clojure.pprint/print-table"
                 "clojure.core/ex-info"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.pprint/*print-base*"
                 "clojure.core/load-string"
                 "clojure.lang/LispReader"
                 "clojure.core/pmap"
                 "clojure.lang/ARef"
                 "clojure.test/file-position"
                 "clojure.lang/Repl"
                 "clojure.core.protocols/IKVReduce"
                 "clojure.lang/RestFn"
                 "clojure.core/float"
                 "clojure.lang/Compiler"
                 "clojure.lang/IProxy"
                 "clojure.test/do-report"
                 "clojure.core/send"
                 "clojure.core/unchecked-float"
                 "clojure.test/testing"
                 "clojure.lang/Named"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.lang/Symbol"
                 "clojure.pprint/pprint-indent"
                 "clojure.lang/PersistentStructMap"
                 "clojure.reflect/map->Field"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.lang/Util"
                 "clojure.core/agent-error"
                 "clojure.lang/Obj"
                 "clojure.core/ns-refers"
                 "clojure.lang/Binding"
                 "clojure.core/num"
                 "clojure.lang/IPersistentMap"
                 "clojure.lang/IRef"
                 "clojure.core/*clojure-version*"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.core/unchecked-short"
                 "clojure.java.io/make-writer"
                 "clojure.test/test-var"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/init-proxy"
                 "clojure.core/unchecked-inc-int"
                 "clojure.lang/IChunk"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.core/ints"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.core/default-data-readers"
                 "clojure.test/testing-contexts-str"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.lang/LineNumberingPushbackReader"
                 "clojure.test/join-fixtures"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.test/run-tests"
                 "clojure.core/short"
                 "clojure.core/unchecked-dec-int"
                 "clojure.core/unchecked-subtract"
                 "clojure.lang/EnumerationSeq"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.test/successful?"
                 "clojure.core/await"
                 "clojure.test/testing-vars-str"
                 "clojure.core/supers"
                 "clojure.test/is"
                 "clojure.reflect/Field"
                 "clojure.core/sorted?"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.instant/parse-timestamp"
                 "clojure.core/unchecked-negate"
                 "clojure.lang/Box"
                 "clojure.java.io/make-output-stream"
                 "clojure.lang/BigInt"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.lang/RSeq"
                 "clojure.lang/APersistentVector"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.core/require"
                 "clojure.pprint/pprint-tab"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.lang/IReference"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.reflect/->AsmReflector"
                 "clojure.lang/KeySeq"
                 "clojure.lang/ChunkBuffer"
                 "clojure.core/ref-set"
                 "clojure.core/booleans"
                 "clojure.reflect/->Method"
                 "clojure.core/->ArrayChunk"
                 "clojure.test/run-all-tests"
                 "clojure.test.tap/with-tap-output"
                 "clojure.core/*print-length*"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/*data-readers*"
                 "clojure.core/with-redefs"
                 "clojure.core/use"
                 "clojure.lang/Intrinsics"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.lang/Compile"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.lang/Reflector"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/longs"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.core/bytes"
                 "clojure.lang/Namespace"
                 "clojure.lang/ILookupSite"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.lang/Agent"
                 "clojure.reflect/->Constructor"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.core/memfn"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.lang/ChunkedCons"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core/nthrest"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.test/compose-fixtures"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/with-in-str"
                 "clojure.core/test"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.lang/ATransientSet"
                 "clojure.core/with-bindings*"
                 "clojure.test/test-ns"
                 "clojure.test/assert-predicate"
                 "clojure.instant/read-instant-timestamp"
                 "clojure.lang/ArityException"
                 "clojure.reflect/->Field"
                 "clojure.core/update-proxy"
                 "clojure.lang/APersistentMap"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/promise"
                 "clojure.instant/validated"
                 "clojure.core/*compile-files*"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.core/unchecked-double"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.reflect/resolve-class"
                 "clojure.java.io/as-file"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/shuffle"
                 "clojure.core/*e"
                 "clojure.core/defonce"
                 "clojure.core/unchecked-inc"
                 "clojure.core/create-ns"
                 "clojure.lang/IObj"
                 "clojure.core/hash-set"
                 "clojure.repl/doc"
                 "clojure.lang/APersistentSet"
                 "clojure.core/aset-int"
                 "clojure.test/test-all-vars"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.reflect/map->Method"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.lang/IBlockingDeref"
                 "clojure.core/int-array"
                 "clojure.test/with-test"
                 "clojure.core/unchecked-remainder-int"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.lang/ATransientMap"
                 "clojure.template/apply-template"
                 "clojure.core/cast"
                 "clojure.lang/XMLHandler"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.lang/ValSeq"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.lang/TransactionalHashMap"
                 "clojure.core/char"
                 "clojure.core/ensure"
                 "clojure.lang/AFunction"
                 "clojure.core/*print-level*"
                 "clojure.lang/IChunkedSeq"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.lang/IKeywordLookup"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.lang/ArrayChunk"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/bound-fn"
                 "clojure.core/special-symbol?"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/locking"
                 "clojure.lang/IType"
                 "clojure.core.protocols/coll-reduce"
                 "clojure.core/char-array"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.lang/IteratorSeq"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.test/are"
                 "clojure.lang/AFn"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/thread-bound?"
                 "clojure.lang/MapEntry"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/floats"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/ex-data"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/->VecSeq"
                 "clojure.lang/IPersistentCollection"
                 "clojure.core/resolve"
                 "clojure.core/->VecNode"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/lazy-cat"
                 "clojure.core/file-seq"
                 "clojure.core/ns-interns"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core/comparator"
                 "clojure.core/get-thread-bindings"
                 "clojure.core/var"
                 "clojure.stacktrace/e"
                 "clojure.core/unchecked-add-int"
                 "clojure.lang/MapEquivalence"
                 "clojure.lang/DynamicClassLoader"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.instant/read-instant-date"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.reflect/map->Constructor"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/unchecked-int"
                 "clojure.core/error-mode"
                 "clojure.lang/MethodImplCache"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.lang/RT"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.lang/Ref"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.lang/ProxyHandler"
                 "clojure.core/decimal?"
                 "clojure.core/pcalls"
                 "clojure.lang/KeywordLookupSite"
                 "clojure.lang/StringSeq"
                 "clojure.core/with-out-str"
                 "clojure.lang/ExceptionInfo"
                 "clojure.core/ns-unalias"
                 "clojure.core/double"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.lang/ArraySeq"
                 "clojure.test/function?"
                 "clojure.data/Diff"
                 "clojure.pprint/pprint"
                 "clojure.test/deftest"
                 "clojure.core/unchecked-negate-int"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.data/diff"
                 "clojure.main/main"
                 "clojure.core/unchecked-multiply"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/chars"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.lang/LockingTransaction"
                 "clojure.lang/SeqEnumeration"
                 "clojure.test/try-expr"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.test/report"
                 "clojure.core/unchecked-char"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.lang/ChunkedSeq"
                 "clojure.core/bound?"
                 "clojure.instant/read-instant-calendar"
                 "clojure.java.io/writer"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.lang/Var"
                 "clojure.lang/Keyword"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.core/byte"
                 "clojure.reflect/->JavaReflector"
                 "clojure.lang/Settable"
                 "clojure.core/unchecked-dec"
                 "clojure.lang/Script"
                 "clojure.core/*compiler-options*"
                 "clojure.core/sequence"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.core/unchecked-long"
                 "clojure.lang/Ratio"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core/unchecked-multiply-int"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"},
 :symbols {"cljs.core/keys" {:description "Returns a sequence of the keys in `hash-map`.",
                             :ns "cljs.core",
                             :name "keys",
                             :signature ["[hash-map]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/vals"],
                             :full-name-encode "cljs.core_keys",
                             :source {:code "(defn keys\n  [hash-map]\n  (seq (map first hash-map)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [5016 5019]},
                             :full-name "cljs.core/keys",
                             :clj-symbol "clojure.core/keys",
                             :docstring "Returns a sequence of the map's keys."},
           "cljs.core/reset!" {:description "Sets the value of atom `a` to `new-value` without regard for the current value.\n\nReturns `new-value`.",
                               :ns "cljs.core",
                               :name "reset!",
                               :signature ["[a new-value]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/swap!"
                                         "cljs.core/compare-and-set!"
                                         "cljs.core/atom"],
                               :full-name-encode "cljs.core_resetBANG",
                               :source {:code "(defn reset!\n  [a new-value]\n  (when-let [validate (.-validator a)]\n    (assert (validate new-value) \"Validator rejected reference state\"))\n  (let [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (-notify-watches a old-value new-value))\n  new-value)",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [5900 5909]},
                               :full-name "cljs.core/reset!",
                               :clj-symbol "clojure.core/reset!",
                               :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
           "cljs.core/ITransientCollection" {:ns "cljs.core",
                                             :name "ITransientCollection",
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core_ITransientCollection",
                                             :source {:code "(defprotocol ITransientCollection\n  (-conj! [tcoll val])\n  (-persistent! [tcoll]))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [246 248]},
                                             :methods [{:name "-conj!",
                                                        :signature ["[tcoll val]"],
                                                        :docstring nil}
                                                       {:name "-persistent!",
                                                        :signature ["[tcoll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/ITransientCollection",
                                             :clj-symbol "clojure.lang/ITransientCollection"},
           "cljs.core/transient" {:ns "cljs.core",
                                  :name "transient",
                                  :signature ["[coll]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_transient",
                                  :source {:code "(defn transient [coll]\n  (-as-transient coll))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1721 1722]},
                                  :full-name "cljs.core/transient",
                                  :clj-symbol "clojure.core/transient"},
           "clojure.set/select" {:description "Returns a set of the elements for which `pred` is true.",
                                 :ns "clojure.set",
                                 :name "select",
                                 :signature ["[pred xset]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/filter"],
                                 :full-name-encode "clojure.set_select",
                                 :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [61 65]},
                                 :full-name "clojure.set/select",
                                 :clj-symbol "clojure.set/select",
                                 :docstring "Returns a set of the elements for which pred is true"},
           "cljs.core/delay" {:ns "cljs.core",
                              :name "delay",
                              :signature ["[& body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core_delay",
                              :source {:code "(defmacro delay [& body]\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  `(new cljs.core.Delay (atom {:done false, :value nil}) (fn [] ~@body)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [564 569]},
                              :full-name "cljs.core/delay",
                              :clj-symbol "clojure.core/delay"},
           "cljs.core/bit-not" {:description "Bitwise complement.  Same as `~x` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-not",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_bit-not",
                                :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1174 1176]},
                                :extra-sources ({:code "(defmacro bit-not [x]\n  (list 'js* \"(~ ~{})\" x))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [190 191]}),
                                :examples [{:id "d4c5e3",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-not 2r1100)\n;;=> -13\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-not 12)\n;;=> -13\n```"}],
                                :full-name "cljs.core/bit-not",
                                :clj-symbol "clojure.core/bit-not",
                                :docstring "Bitwise complement"},
           "cljs.core/partition" {:description "Returns a lazy sequence of lists of `n` items each, at offsets `step` apart.\n\nIf `step` is not supplied, defaults to `n`, i.e. the partitions do not overlap.\n\nIf a `pad` collection is supplied, its elements will be used as necessary to\ncomplete the last partition up to `n` items.\n\nReturns a partition with less than `n` items if there are not enough padding\nelements.",
                                  :ns "cljs.core",
                                  :name "partition",
                                  :signature ["[n coll]"
                                              "[n step coll]"
                                              "[n step pad coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/partition-all"
                                            "cljs.core/split-at"
                                            "cljs.core/partition-by"],
                                  :full-name-encode "cljs.core_partition",
                                  :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (== n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (== n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2268 2288]},
                                  :full-name "cljs.core/partition",
                                  :clj-symbol "clojure.core/partition",
                                  :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition upto n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "cljs.core/parents" {:ns "cljs.core",
                                :name "parents",
                                :signature ["[tag]" "[h tag]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_parents",
                                :source {:code "(defn parents\n  ([tag] (parents @global-hierarchy tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6157 6163]},
                                :full-name "cljs.core/parents",
                                :clj-symbol "clojure.core/parents",
                                :docstring "Returns the immediate parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/aclone" {:description "Creates a clone of the given JavaScript array `arr`.  The result is a new\nJavaScript array, which is a shallow copy, not a deep copy.",
                               :ns "cljs.core",
                               :name "aclone",
                               :signature ["[arr]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/array"
                                         "cljs.core/make-array"],
                               :full-name-encode "cljs.core_aclone",
                               :source {:code "(defn aclone\n  [array-like]\n  #_(goog.array.clone array-like)\n  (js* \"Array.prototype.slice.call(~{array-like})\"))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [69 73]},
                               :examples [{:id "422c4e",
                                           :content "```clj\n(def a #js [1 2 3])\n(def b (aclone a))\n(aset b 0 4)\n\na\n;;=> #js [1 2 3]\n\nb\n;;=> #js [4 2 3]\n```"}],
                               :full-name "cljs.core/aclone",
                               :clj-symbol "clojure.core/aclone",
                               :docstring "Returns a javascript array, cloned from the passed in array"},
           "cljs.core/reset-meta!" {:ns "cljs.core",
                                    :name "reset-meta!",
                                    :signature ["[iref m]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_reset-metaBANG",
                                    :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [5967 5970]},
                                    :full-name "cljs.core/reset-meta!",
                                    :clj-symbol "clojure.core/reset-meta!",
                                    :docstring "Atomically resets the metadata for an atom"},
           "special/defrecord*" {:ns "special",
                                 :name "defrecord*",
                                 :type "special form",
                                 :source {:code "(defmethod parse 'defrecord*\n  [_ env [_ tsym fields pmasks :as form] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :defrecord* :form form :t t :fields fields :pmasks pmasks}))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/clj/cljs/compiler.clj",
                                          :lines [1175 1186]},
                                 :full-name "special/defrecord*",
                                 :full-name-encode "special_defrecordSTAR",
                                 :history [["+" "0.0-927"]]},
           "cljs.reader/dispatch-macros" {:ns "cljs.reader",
                                          :name "dispatch-macros",
                                          :type "var",
                                          :source {:code "(def dispatch-macros\n  {\"{\" read-set\n   \"<\" (throwing-reader \"Unreadable form\")\n   \"\\\"\" read-regex\n   \"!\" read-comment\n   \"_\" read-discard})",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [331 336]},
                                          :full-name "cljs.reader/dispatch-macros",
                                          :full-name-encode "cljs.reader_dispatch-macros",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/current-repl-env" {:ns "cljs.repl.rhino",
                                               :name "current-repl-env",
                                               :type "var",
                                               :source {:code "(def current-repl-env (atom nil))",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/clj/cljs/repl/rhino.clj",
                                                        :lines [18]},
                                               :full-name "cljs.repl.rhino/current-repl-env",
                                               :full-name-encode "cljs.repl.rhino_current-repl-env",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/ICollection" {:ns "cljs.core",
                                    :name "ICollection",
                                    :type "protocol",
                                    :full-name-encode "cljs.core_ICollection",
                                    :source {:code "(defprotocol ICollection\n  (-conj [coll o]))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [146 147]},
                                    :methods [{:name "-conj",
                                               :signature ["[coll o]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/ICollection",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/every?" {:description "Returns true if `(pred x)` is logical true for every `x` in `coll`, else false.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "every?",
                               :signature ["[pred coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/some"
                                         "cljs.core/not-any?"],
                               :full-name-encode "cljs.core_everyQMARK",
                               :source {:code "(defn ^boolean every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1813 1820]},
                               :full-name "cljs.core/every?",
                               :clj-symbol "clojure.core/every?",
                               :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
           "clojure.zip/node" {:ns "clojure.zip",
                               :name "node",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_node",
                               :source {:code "(defn node\n  [loc] (loc 0))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [60 62]},
                               :full-name "clojure.zip/node",
                               :clj-symbol "clojure.zip/node",
                               :docstring "Returns the node at loc"},
           "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                             :name "IEmptyableCollection",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IEmptyableCollection",
                                             :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [143 144]},
                                             :methods [{:name "-empty",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEmptyableCollection",
                                             :history [["+" "0.0-927"]]},
           "clojure.zip/right" {:ns "clojure.zip",
                                :name "right",
                                :signature ["[loc]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip_right",
                                :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [135 140]},
                                :full-name "clojure.zip/right",
                                :clj-symbol "clojure.zip/right",
                                :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
           "cljs.core/==" {:description "This is an equality check for numbers of different types that was carried over from Clojure,\nto allow compatibility when converting code to ClojureScript.\n\nSince there is only a single number type in JavaScript, 64-bit floating point, there is no\nreason to use the `==` operator in ClojureScript.\n\nBehavior on non-number arguments is undefined.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name "==",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/="
                                     "cljs.core/identical?"],
                           :full-name-encode "cljs.core_EQEQ",
                           :source {:code "(defn ^boolean ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1208 1219]},
                           :extra-sources ({:code "(defmacro ==\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [157 160]}),
                           :examples [{:id "5ac342",
                                       :content "```clj\n(== 1 1)\n;;=> true\n\n(== 1 2)\n;;=> false\n```"}],
                           :full-name "cljs.core/==",
                           :clj-symbol "clojure.core/==",
                           :docstring "Returns non-nil if nums all have the equivalent\nvalue, otherwise false. Behavior on non nums is\nundefined."},
           "cljs.core/dissoc!" {:ns "cljs.core",
                                :name "dissoc!",
                                :signature ["[tcoll key]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core_dissocBANG",
                                :source {:code "(defn dissoc! [tcoll key]\n  (-dissoc! tcoll key))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1733 1734]},
                                :full-name "cljs.core/dissoc!",
                                :clj-symbol "clojure.core/dissoc!"},
           "special/." {:description "For interop, the `.` special form allows access to member properties of the\ngiven JavaScript object `o`.\n\nIf the second operand is a symbol preceded with a hyphen as in `-p`, the\nexpression will result in the value of the property named `p`.\n\nIf the second operand is a symbol that is not preceded with a hyphen as in `m`,\nthe expression will evaluate to a call of the method named `m`.  Any additional\noperands will be passed as arguments to the method.\n\nThe __preferred, idiomatic__ way to access members of a JavaScript object is to\nuse the following sugar:\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Sugar</th>\n      <th>Expands To</th></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><pre>(.-p o)</pre></td>\n      <td><pre>(. o -p)</pre></td>\n    </tr>\n    <tr>\n      <td><pre>(.m o)</pre></td>\n      <td><pre>(. o m)</pre></td>\n    </tr>\n    <tr>\n      <td><pre>(.m o 1 2)</pre></td>\n      <td><pre>(. o m 1 2)</pre></td>\n    </tr>\n  </tbody>\n</table>",
                        :ns "special",
                        :name ".",
                        :signature ["[o -p]"
                                    "[o m]"
                                    "[o m 1 2]"
                                    "[o (m 1 2)]"],
                        :history [["+" "0.0-927"]],
                        :type "special form",
                        :related ["cljs.core/.." "cljs.core/aget"],
                        :full-name-encode "special_DOT",
                        :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+] :as form] _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)]\n     (case dot-action\n           ::access {:env env :op :dot :form form\n                     :target targetexpr\n                     :field field\n                     :children [targetexpr]\n                     :tag (-> form meta :tag)}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :form form\n                       :target targetexpr\n                       :method method\n                       :args argexprs\n                       :children (into [targetexpr] argexprs)\n                       :tag (-> form meta :tag)})))))",
                                 :repo "clojurescript",
                                 :tag "r1211",
                                 :filename "src/clj/cljs/compiler.clj",
                                 :lines [1256 1274]},
                        :examples [{:id "22ccbb",
                                    :content "We can access the JavaScript properties of a string:\n\n```js\n// JavaScript\nvar m = \"Hello World\";\nm.length;\n//=> 11\n```\n\n```clj\n;; ClojureScript\n(def m \"Hello World\")\n(.-length m)\n;;=> 11\n```\n\nWe can also call member functions on the string:\n\n```js\n// JavaScript\nm.toUpperCase();\n//=> \"HELLO WORLD\"\n\nm.replace(\"H\", \"\");\n//=> \"ello World\";\n```\n\n```clj\n;; ClojureScript\n(.toUpperCase m)\n;;=> \"HELLO WORLD\"\n\n(.replace m \"H\" \"\")\n;;=> \"ello World\"\n```"}
                                   {:id "7c5e58",
                                    :content "Create a JavaScript object `o`:\n\n```clj\n(def o #js {:foo \"bar\"})\n```\n\nYou can get the value at property `\"foo\"` with any of the following:\n\n```clj\n(. o -foo)\n;;=> \"bar\"\n\n(.-foo o)\n;;=> \"bar\"\n\n(aget o \"foo\")\n;;=> \"bar\"\n```"}],
                        :full-name "special/.",
                        :clj-symbol "clojure.core/."},
           "syntax/Math-ns" {:ns "syntax",
                             :name "Math-ns",
                             :history [["+" "0.0-927"]],
                             :type "special namespace",
                             :full-name-encode "syntax_Math-ns",
                             :source {:repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form "Math/",
                             :full-name "syntax/Math-ns",
                             :clj-doc "http://clojure.org/java_interop#toc6"},
           "clojure.browser.net/*timeout*" {:ns "clojure.browser.net",
                                            :name "*timeout*",
                                            :type "var",
                                            :source {:code "(def *timeout* 10000)",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/cljs/clojure/browser/net.cljs",
                                                     :lines [21]},
                                            :full-name "clojure.browser.net/*timeout*",
                                            :full-name-encode "clojure.browser.net_STARtimeoutSTAR",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/remove-method" {:ns "cljs.core",
                                      :name "remove-method",
                                      :signature ["[multifn dispatch-val]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_remove-method",
                                      :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6367 6370]},
                                      :full-name "cljs.core/remove-method",
                                      :clj-symbol "clojure.core/remove-method",
                                      :docstring "Removes the method of multimethod associated with dispatch-value."},
           "syntax/symbol" {:description "Signifies a symbol.  When evaluated, its result will be the value that the symbol\nis bound to.\n\nSome naming rules:\n\n- must not begin with a number\n- can contain special characters `*`, `+`, `!`, `-`, `_`, `?`\n- symbols starting or ending with a decimal are reserved for interop purposes\n\nSymbols can have an optional namespace. For example, `foo/bar` evaluates to the\nvalue of the `bar` symbol of the `foo` namespace.\n\nTo access symbols in the global JavaScript context, use the namespace `js`.\nFor example, use `js/document` to get the global `document` JavaScript object.",
                            :ns "syntax",
                            :name "symbol",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/symbol"
                                      "cljs.core/symbol?"],
                            :full-name-encode "syntax_symbol",
                            :source {:repo "clojure",
                                     :tag "clojure-1.4.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form " ",
                            :examples [{:id "cd60a5",
                                        :content "The following has two symbols, `def` and `a`:\n\n```clj\n(def a 1)\n```\n\nThe evaluation of the symbols is controlled by the evaluation of the list `(def\na 1)`.  `def` evaluates to a special form, which suppresses the evaluation of\n`a` since it is just being used as a name for the bound value `1`.\n\nWhen a symbol is by itself, it will evaluated to 1:\n\n```clj\na\n;;=> 1\n```\n\nTo signify an unevaluated symbol, precede it with a quote:\n\n```clj\n'a\n;;=> a\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#symbols",
                            :full-name "syntax/symbol",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/PersistentArrayMap.fromArrays" {:ns "cljs.core",
                                                      :name "PersistentArrayMap.fromArrays",
                                                      :signature ["[ks vs]"],
                                                      :history [["+"
                                                                 "0.0-1211"]],
                                                      :parent-type "PersistentArrayMap",
                                                      :type "function",
                                                      :full-name-encode "cljs.core_PersistentArrayMapDOTfromArrays",
                                                      :source {:code "(set! cljs.core.PersistentArrayMap/fromArrays\n      (fn [ks vs]\n        (let [len (count ks)]\n          (loop [i   0\n                 out (transient cljs.core.PersistentArrayMap/EMPTY)]\n            (if (< i len)\n              (recur (inc i) (assoc! out (aget ks i) (aget vs i)))\n              (persistent! out))))))",
                                                               :repo "clojurescript",
                                                               :tag "r1211",
                                                               :filename "src/cljs/cljs/core.cljs",
                                                               :lines [3438
                                                                       3445]},
                                                      :full-name "cljs.core/PersistentArrayMap.fromArrays"},
           "cljs.core/frequencies" {:description "Returns a map from distinct items in `coll` to the number of times they appear.\n\n`(frequencies [:a :a :b])` => `{:a 2, :b 1}`",
                                    :ns "cljs.core",
                                    :name "frequencies",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/group-by"
                                              "cljs.core/distinct"],
                                    :full-name-encode "cljs.core_frequencies",
                                    :source {:code "(defn frequencies\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [5493 5500]},
                                    :full-name "cljs.core/frequencies",
                                    :clj-symbol "clojure.core/frequencies",
                                    :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
           "cljs.core/pop" {:description "For a list, returns a new list without the first item.\n\nFor a vector, returns a new vector without the last item.",
                            :ns "cljs.core",
                            :name "pop",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/peek"
                                      "cljs.core/rest"
                                      "cljs.core/conj"],
                            :full-name-encode "cljs.core_pop",
                            :source {:code "(defn pop\n  [coll]\n  (-pop coll))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [700 705]},
                            :examples [{:id "6bd9f7",
                                        :content "With vectors:\n\n```clj\n(pop [1 2 3])\n;;=> [1 2]\n\n(pop [1 2])\n;;=> [1]\n\n(pop [1])\n;;=> []\n\n(pop [])\n;; Error: Can't pop empty vector\n```"}
                                       {:id "81221f",
                                        :content "With lists:\n\n```clj\n(pop '(1 2 3))\n;;=> (2 3)\n\n(pop '(1 2))\n;;=> (2)\n\n(pop '(1))\n;;=> ()\n\n(pop '())\n;; Error: Can't pop empty list\n```"}],
                            :full-name "cljs.core/pop",
                            :clj-symbol "clojure.core/pop",
                            :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
           "cljs.core/not-every?" {:description "Returns false if `(pred x)` is logical true for every `x` in `coll`, else true.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "not-every?",
                                   :signature ["[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/every?"
                                             "cljs.core/not-any?"
                                             "cljs.core/some"],
                                   :full-name-encode "cljs.core_not-everyQMARK",
                                   :source {:code "(defn ^boolean not-every?\n  [pred coll] (not (every? pred coll)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1822 1825]},
                                   :full-name "cljs.core/not-every?",
                                   :clj-symbol "clojure.core/not-every?",
                                   :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
           "cljs.core/some-fn" {:description "Takes a set of predicate functions and returns a function `f` that returns the\nfirst logical true value returned by one of its composing predicates against any\nof its arguments, else it returns logical false.\n\nNote that `f` is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates.",
                                :ns "cljs.core",
                                :name "some-fn",
                                :signature ["[p]"
                                            "[p1 p2]"
                                            "[p1 p2 p3]"
                                            "[p1 p2 p3 & ps]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/every-pred"
                                          "cljs.core/some"
                                          "cljs.core/or"],
                                :full-name-encode "cljs.core_some-fn",
                                :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2010 2047]},
                                :full-name "cljs.core/some-fn",
                                :clj-symbol "clojure.core/some-fn",
                                :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
           "syntax/vector" {:description "Signifies a literal vector.",
                            :ns "syntax",
                            :name "vector",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/vector"
                                      "cljs.core/vec"],
                            :full-name-encode "syntax_vector",
                            :source {:repo "clojure",
                                     :tag "clojure-1.4.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form "[]",
                            :examples [{:id "18e143",
                                        :content "```clj\n[1 2 3]\n;;=> [1 2 3]\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#vectors",
                            :full-name "syntax/vector",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.event/remove-all" {:ns "clojure.browser.event",
                                               :name "remove-all",
                                               :type "function",
                                               :signature ["[opt_obj opt_type opt_capt]"],
                                               :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/cljs/clojure/browser/event.cljs",
                                                        :lines [98]},
                                               :full-name "clojure.browser.event/remove-all",
                                               :full-name-encode "clojure.browser.event_remove-all",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/doto" {:ns "cljs.core",
                             :name "doto",
                             :signature ["[x & forms]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core_doto",
                             :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                      :repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [3397 3412]},
                             :full-name "cljs.core/doto",
                             :clj-symbol "clojure.core/doto",
                             :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
           "cljs.core/take-while" {:description "Returns a lazy sequence of successive items from `coll` while `(pred item)`\nreturns true. `pred` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                                   :ns "cljs.core",
                                   :name "take-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/drop-while"
                                             "cljs.core/split-with"],
                                   :full-name-encode "cljs.core_take-while",
                                   :source {:code "(defn take-while\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (when (pred (first s))\n       (cons (first s) (take-while pred (rest s)))))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [5355 5362]},
                                   :full-name "cljs.core/take-while",
                                   :clj-symbol "clojure.core/take-while",
                                   :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects."},
           "cljs.repl/evaluate-form" {:ns "cljs.repl",
                                      :name "evaluate-form",
                                      :signature ["[repl-env env filename form]"
                                                  "[repl-env env filename form wrap]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl_evaluate-form",
                                      :source {:code "(defn evaluate-form\n  ([repl-env env filename form]\n     (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n     (try\n       (let [ast (comp/analyze env form)\n             js (comp/emit-str ast)\n             wrap-js (comp/emit-str (binding [comp/*cljs-warn-on-undeclared* false\n                                              comp/*cljs-warn-on-redef* false\n                                              comp/*cljs-warn-on-dynamic* false\n                                              comp/*cljs-warn-on-fn-var* false\n                                              comp/*cljs-warn-fn-arity* false]\n                                   (comp/analyze env (wrap form))))]\n         (when (= (:op ast) :ns)\n           (load-dependencies repl-env (into (vals (:requires ast))\n                                             (distinct (vals (:uses ast))))))\n         (when *cljs-verbose*\n           (print js))\n         (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n           (case (:status ret)\n             ;;we eat ns errors because we know goog.provide() will throw when reloaded\n             ;;TODO - file bug with google, this is bs error\n             ;;this is what you get when you try to 'teach new developers'\n             ;;via errors (goog/base.js 104)\n             :error (display-error ret form)\n             :exception (display-error ret form\n                          #(prn \"Error evaluating:\" form :as js))\n             :success (:value ret))))\n       (catch Throwable ex\n         (.printStackTrace ex)\n         (println (str ex))))))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [56 89]},
                                      :full-name "cljs.repl/evaluate-form",
                                      :docstring "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader."},
           "cljs.reader/escape-char-map" {:ns "cljs.reader",
                                          :name "escape-char-map",
                                          :type "var",
                                          :source {:code "(def escape-char-map {\\t \"\\t\"\n                      \\r \"\\r\"\n                      \\n \"\\n\"\n                      \\\\ \\\\\n                      \\\" \\\"\n                      \\b \"\\b\"\n                      \\f \"\\f\"})",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [137 143]},
                                          :full-name "cljs.reader/escape-char-map",
                                          :full-name-encode "cljs.reader_escape-char-map",
                                          :history [["+" "0.0-927"]]},
           "clojure.browser.event/all-listeners" {:ns "clojure.browser.event",
                                                  :name "all-listeners",
                                                  :type "function",
                                                  :signature ["[obj type capture]"],
                                                  :source {:code "(defn all-listeners [obj type capture])",
                                                           :repo "clojurescript",
                                                           :tag "r1211",
                                                           :filename "src/cljs/clojure/browser/event.cljs",
                                                           :lines [90]},
                                                  :full-name "clojure.browser.event/all-listeners",
                                                  :full-name-encode "clojure.browser.event_all-listeners",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/ITransientSet" {:ns "cljs.core",
                                      :name "ITransientSet",
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core_ITransientSet",
                                      :source {:code "(defprotocol ITransientSet\n  (-disjoin! [tcoll v]))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [260 261]},
                                      :methods [{:name "-disjoin!",
                                                 :signature ["[tcoll v]"],
                                                 :docstring nil}],
                                      :full-name "cljs.core/ITransientSet",
                                      :clj-symbol "clojure.lang/ITransientSet"},
           "cljs.core/vals" {:description "Returns a sequence of the values in `hash-map`.",
                             :ns "cljs.core",
                             :name "vals",
                             :signature ["[hash-map]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/keys"],
                             :full-name-encode "cljs.core_vals",
                             :source {:code "(defn vals\n  [hash-map]\n  (seq (map second hash-map)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [5026 5029]},
                             :full-name "cljs.core/vals",
                             :clj-symbol "clojure.core/vals",
                             :docstring "Returns a sequence of the map's values."},
           "cljs.core/IDeref" {:ns "cljs.core",
                               :name "IDeref",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core_IDeref",
                               :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [187 188]},
                               :methods [{:name "-deref",
                                          :signature ["[o]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IDeref",
                               :clj-symbol "clojure.lang/IDeref"},
           "cljs.core/array-map" {:description "Returns a new array map (a map implemented with arrays) with the supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                  :ns "cljs.core",
                                  :name "array-map",
                                  :signature ["[& keyvals]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :related ["cljs.core/assoc"
                                            "cljs.core/hash-map"
                                            "cljs.core/sorted-map"],
                                  :full-name-encode "cljs.core_array-map",
                                  :source {:code "(defn array-map\n  [& keyvals]\n  (PersistentArrayMap. nil (quot (count keyvals) 2) (apply array keyvals) nil))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [4991 4995]},
                                  :examples [{:id "198026",
                                              :content "```clj\n(array-map :a 10)\n;;=> {:a 10}\n\n(array-map :a 10 :b 20)\n;;=> {:a 10 :b 20}\n```"}],
                                  :full-name "cljs.core/array-map",
                                  :clj-symbol "clojure.core/array-map",
                                  :docstring "keyval => key val\nReturns a new array map with supplied mappings."},
           "clojure.browser.dom/log-obj" {:ns "clojure.browser.dom",
                                          :name "log-obj",
                                          :type "function",
                                          :signature ["[obj]"],
                                          :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [23 24]},
                                          :full-name "clojure.browser.dom/log-obj",
                                          :full-name-encode "clojure.browser.dom_log-obj",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/for" {:description "List comprehension.\n\nTakes a vector of one or more binding-form/collection-expr pairs, each followed\nby zero or more modifiers, and yields a lazy sequence of evaluations of expr.\n\nCollections are iterated in a nested fashion, rightmost fastest, and nested\ncoll-exprs can refer to bindings created in prior binding-forms. Supported\nmodifiers are: `:let [binding-form expr ...]`, `:while test`, `:when test`.",
                            :ns "cljs.core",
                            :name "for",
                            :signature ["[seq-exprs body-expr]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/doseq"
                                      "cljs.core/doall"
                                      "special/recur"],
                            :full-name-encode "cljs.core_for",
                            :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (apply core/str msg)))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      `(fn ~giter [~gxs]\n                         (lazy-seq\n                           (loop [~gxs ~gxs]\n                             (when-first [~bind ~gxs]\n                               ~(do-mod mod-pairs)))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [700 747]},
                            :extra-sources ({:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce1 (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                             (loop [~gxs ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (chunk-buffer size#)]\n                                       (if (loop [~gi (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [~bind (.nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))",
                                             :repo "clojure",
                                             :tag "clojure-1.4.0",
                                             :filename "src/clj/clojure/core.clj",
                                             :lines [4078 4163]}),
                            :full-name "cljs.core/for",
                            :clj-symbol "clojure.core/for",
                            :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
           "cljs.repl/load-stream" {:ns "cljs.repl",
                                    :name "load-stream",
                                    :type "function",
                                    :signature ["[repl-env filename stream]"],
                                    :source {:code "(defn load-stream [repl-env filename stream]\n  (with-open [r (io/reader stream)]\n    (let [env {:ns (@comp/namespaces comp/*cljs-ns*) :context :statement :locals {}}\n          pbr (clojure.lang.LineNumberingPushbackReader. r)\n          eof (Object.)]\n      (loop [r (read pbr false eof false)]\n        (let [env (assoc env :ns (@comp/namespaces comp/*cljs-ns*))]\n          (when-not (identical? eof r)\n            (evaluate-form repl-env env filename r)\n            (recur (read pbr false eof false))))))))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [91 100]},
                                    :full-name "cljs.repl/load-stream",
                                    :full-name-encode "cljs.repl_load-stream",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/instance?" {:description "Returns true if `o` is an instance of type `t`, false otherwise.",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "instance?",
                                  :signature ["[t o]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/type"],
                                  :full-name-encode "cljs.core_instanceQMARK",
                                  :source {:code "(defn ^boolean instance? [t o]\n  (js* \"(~{o} != null && (~{o} instanceof ~{t} || ~{o}.constructor === ~{t} || ~{t} === Object))\"))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [818 819]},
                                  :full-name "cljs.core/instance?",
                                  :clj-symbol "clojure.core/instance?"},
           "cljs.core/rseq" {:description "Returns a sequence of the items in `coll` in reverse order in constant time.\n\nReturns nil if `coll` is empty.\n\n`coll` must be a vector or a sorted-map.",
                             :ns "cljs.core",
                             :name "rseq",
                             :signature ["[coll]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/reverse"],
                             :full-name-encode "cljs.core_rseq",
                             :source {:code "(defn rseq [coll]\n  (-rseq coll))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1439 1440]},
                             :full-name "cljs.core/rseq",
                             :clj-symbol "clojure.core/rseq"},
           "cljs.core/PersistentVector.EMPTY_NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY_NODE",
                                                    :type "var",
                                                    :parent-type "PersistentVector",
                                                    :source {:code "(set! cljs.core.PersistentVector/EMPTY_NODE (pv-fresh-node nil))",
                                                             :repo "clojurescript",
                                                             :tag "r1211",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [2662]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY_NODE",
                                                    :full-name-encode "cljs.core_PersistentVectorDOTEMPTY_NODE",
                                                    :history [["+"
                                                               "0.0-1006"]]},
           "cljs.reader/read-comment" {:ns "cljs.reader",
                                       :name "read-comment",
                                       :type "var",
                                       :source {:code "(def read-comment skip-line)",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [207]},
                                       :full-name "cljs.reader/read-comment",
                                       :full-name-encode "cljs.reader_read-comment",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/ITransientMap" {:ns "cljs.core",
                                      :name "ITransientMap",
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core_ITransientMap",
                                      :source {:code "(defprotocol ITransientMap\n  (-dissoc! [tcoll key]))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [253 254]},
                                      :methods [{:name "-dissoc!",
                                                 :signature ["[tcoll key]"],
                                                 :docstring nil}],
                                      :full-name "cljs.core/ITransientMap",
                                      :clj-symbol "clojure.lang/ITransientMap"},
           "cljs.reader/read-number" {:ns "cljs.reader",
                                      :name "read-number",
                                      :type "function",
                                      :signature ["[reader initch]"],
                                      :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (contains? macros ch))\n      (do\n        (unread reader ch)\n        (let [s (. buffer (toString))]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [220 230]},
                                      :full-name "cljs.reader/read-number",
                                      :full-name-encode "cljs.reader_read-number",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/ILookup" {:ns "cljs.core",
                                :name "ILookup",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_ILookup",
                                :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [161 162]},
                                :methods [{:name "-lookup",
                                           :signature ["[o k]"
                                                       "[o k not-found]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ILookup",
                                :clj-symbol "clojure.lang/ILookup"},
           "cljs.core/when" {:description "Evaluates `test`. If logical true, evaluates `body` in an implicit `do`.\n\n`when` is often used instead of `if` for conditions that do not have an \"else\".",
                             :ns "cljs.core",
                             :name "when",
                             :signature ["[test & body]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/when-not"
                                       "cljs.core/when-let"
                                       "special/if"],
                             :full-name-encode "cljs.core_when",
                             :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                      :repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [455 459]},
                             :full-name "cljs.core/when",
                             :clj-symbol "clojure.core/when",
                             :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
           "cljs.core/ArrayNodeSeq" {:ns "cljs.core",
                                     :name "ArrayNodeSeq",
                                     :type "type",
                                     :signature ["[meta nodes i s __hash]"],
                                     :source {:code "(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (ArrayNodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll] (create-array-node-seq nil nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash)))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [4076 4111]},
                                     :full-name "cljs.core/ArrayNodeSeq",
                                     :full-name-encode "cljs.core_ArrayNodeSeq",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/list?" {:description "Returns true if `x` is a list, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "list?",
                              :signature ["[x]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :related ["cljs.core/seq?"
                                        "cljs.core/sequential?"
                                        "cljs.core/coll?"],
                              :full-name-encode "cljs.core_listQMARK",
                              :source {:code "(defn ^boolean list? [x]\n  (satisfies? IList x))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1492 1493]},
                              :full-name "cljs.core/list?",
                              :clj-symbol "clojure.core/list?"},
           "cljs.core/val" {:description "Returns the value in the map entry.",
                            :ns "cljs.core",
                            :name "val",
                            :signature ["[map-entry]"],
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :related ["cljs.core/vals"],
                            :full-name-encode "cljs.core_val",
                            :source {:code "(defn val\n  [map-entry]\n  (-val map-entry))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [5031 5034]},
                            :full-name "cljs.core/val",
                            :clj-symbol "clojure.core/val",
                            :docstring "Returns the value in the map entry."},
           "clojure.browser.dom/set-value" {:ns "clojure.browser.dom",
                                            :name "set-value",
                                            :signature ["[e v]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom_set-value",
                                            :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [142 145]},
                                            :full-name "clojure.browser.dom/set-value",
                                            :docstring "Set the value property for an element."},
           "cljs.repl.browser/read-get" {:ns "cljs.repl.browser",
                                         :name "read-get",
                                         :type "function",
                                         :signature ["[line rdr]"],
                                         :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [153 158]},
                                         :full-name "cljs.repl.browser/read-get",
                                         :full-name-encode "cljs.repl.browser_read-get",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/BitmapIndexedNode" {:ns "cljs.core",
                                          :name "BitmapIndexedNode",
                                          :signature ["[edit bitmap arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_BitmapIndexedNode",
                                          :source {:code "(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc cljs.core.BitmapIndexedNode/EMPTY (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if (coercive-not= nil (aget arr j))\n                                (.inode-assoc cljs.core.BitmapIndexedNode/EMPTY\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset added-leaf? 0 true)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (coercive-= nil key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (= key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (aset added-leaf? 0 true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (coercive-= nil key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (coercive-not= nil n) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (== bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (= key key-or-nil)\n                (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))\n                :else inode)))))\n\n  (inode-find [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        nil\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (coercive-= nil key-or-nil) (.inode-find val-or-node (+ shift 5) hash key)\n                (= key key-or-nil)          [key-or-nil val-or-node]\n                :else nil)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (coercive-= nil key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (= key key-or-nil)          [key-or-nil val-or-node]\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (== bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (.-length earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (< (* 2 n) (.-length arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (aset added-leaf? 0 true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! cljs.core.BitmapIndexedNode/EMPTY edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if (coercive-not= nil (aget arr j))\n                                (.inode-assoc! cljs.core.BitmapIndexedNode/EMPTY\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset added-leaf? 0 true)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (coercive-= nil key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (= key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (aset added-leaf? 0 true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (coercive-= nil key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (coercive-not= nil n) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (== bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (= key key-or-nil)\n                (do (aset removed-leaf? 0 true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [3583 3777]},
                                          :full-name "cljs.core/BitmapIndexedNode",
                                          :clj-symbol "clojure.lang/BitmapIndexedNode"},
           "cljs.reader/read-past" {:ns "cljs.reader",
                                    :name "read-past",
                                    :signature ["[pred rdr]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader_read-past",
                                    :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [159 166]},
                                    :full-name "cljs.reader/read-past",
                                    :docstring "Read until first character that doesn't match pred, returning\nchar."},
           "cljs.repl.browser/load-javascript" {:ns "cljs.repl.browser",
                                                :name "load-javascript",
                                                :type "function",
                                                :signature ["[repl-env ns url]"],
                                                :source {:code "(defn load-javascript [repl-env ns url]\n  (let [missing (remove #(contains? @loaded-libs %) ns)]\n    (when (seq missing)\n      (let [ret (browser-eval (object-query-str ns))]\n        (when-not (and (= (:status ret) :success)\n                       (= (:value ret) \"true\"))\n          (browser-eval (slurp url))))\n      (swap! loaded-libs (partial apply conj) missing))))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [300
                                                                 307]},
                                                :full-name "cljs.repl.browser/load-javascript",
                                                :full-name-encode "cljs.repl.browser_load-javascript",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/to-array" {:ns "cljs.core",
                                 :name "to-array",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_to-array",
                                 :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1588 1596]},
                                 :full-name "cljs.core/to-array",
                                 :clj-symbol "clojure.core/to-array",
                                 :docstring "Naive impl of to-array as a start."},
           "cljs.core/interpose" {:description "Returns a lazy seq of the elements of `coll` separated by `sep`.",
                                  :ns "cljs.core",
                                  :name "interpose",
                                  :signature ["[sep coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/interleave"
                                            "clojure.string/join"],
                                  :full-name-encode "cljs.core_interpose",
                                  :source {:code "(defn interpose\n  [sep coll] (drop 1 (interleave (repeat sep) coll)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2169 2171]},
                                  :full-name "cljs.core/interpose",
                                  :clj-symbol "clojure.core/interpose",
                                  :docstring "Returns a lazy seq of the elements of coll separated by sep"},
           "cljs.core/IMapEntry" {:ns "cljs.core",
                                  :name "IMapEntry",
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IMapEntry",
                                  :source {:code "(defprotocol IMapEntry\n  (-key [coll])\n  (-val [coll]))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [173 175]},
                                  :methods [{:name "-key",
                                             :signature ["[coll]"],
                                             :docstring nil}
                                            {:name "-val",
                                             :signature ["[coll]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IMapEntry",
                                  :clj-symbol "clojure.lang/IMapEntry"},
           "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                    :name "ICrossPageChannel",
                                                    :type "protocol",
                                                    :full-name-encode "clojure.browser.net_ICrossPageChannel",
                                                    :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                             :repo "clojurescript",
                                                             :tag "r1211",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [88
                                                                     89]},
                                                    :methods [{:name "register-service",
                                                               :signature ["[this service-name fn]"
                                                                           "[this service-name fn encode-json?]"],
                                                               :docstring nil}],
                                                    :full-name "clojure.browser.net/ICrossPageChannel",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "special/finally" {:description "`finally` should be the last form inside of a `try` expression. It is optional.\n\n`finally` clauses are always evaluated for their side effects whether there was\nan error or not, but they are never the return value of a `try` expression.",
                              :ns "special",
                              :name "finally",
                              :signature ["[expr*]"],
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :related ["special/try"
                                        "special/catch"
                                        "special/throw"],
                              :full-name-encode "special_finally",
                              :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [648 676]},
                              :full-name "special/finally",
                              :clj-symbol "clojure.core/finally",
                              :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/Cons" {:ns "cljs.core",
                             :name "Cons",
                             :signature ["[meta first rest __hash]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_Cons",
                             :source {:code "(deftype Cons [meta first rest ^:mutable __hash]\n  IList\n  \n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll __hash))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1450 1482]},
                             :full-name "cljs.core/Cons",
                             :clj-symbol "clojure.lang/Cons"},
           "cljs.core/re-find" {:description "Returns the first regex match, if any, of `s` to `re`, using `re.exec(s)`.\n\nReturns a vector, containing first the matching substring, then any capturing\ngroups if the regular expression contains capturing groups.",
                                :ns "cljs.core",
                                :name "re-find",
                                :signature ["[re s]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_re-find",
                                :source {:code "(defn re-find\n  [re s]\n  (let [matches (.exec re s)]\n    (when-not (nil? matches)\n      (if (== (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5590 5600]},
                                :full-name "cljs.core/re-find",
                                :clj-symbol "clojure.core/re-find",
                                :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
           "cljs.core/IMeta" {:ns "cljs.core",
                              :name "IMeta",
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core_IMeta",
                              :source {:code "(defprotocol IMeta\n  (-meta [o]))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [193 194]},
                              :methods [{:name "-meta",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IMeta",
                              :clj-symbol "clojure.lang/IMeta"},
           "cljs.core/assoc-in" {:description "Associates a value in a nested associative structure, where `ks` is a sequence\nof keys and `v` is the new value. Returns a new nested structure.\n\nIf any levels do not exist, hash-maps will be created.",
                                 :ns "cljs.core",
                                 :name "assoc-in",
                                 :signature ["[m [k & ks] v]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/assoc"
                                           "cljs.core/update-in"
                                           "cljs.core/get-in"],
                                 :full-name-encode "cljs.core_assoc-in",
                                 :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2309 2316]},
                                 :examples [{:id "e76f20",
                                             :content "```clj\n(def users [{:name \"James\" :age 26}\n            {:name \"John\" :age 43}])\n```\n\nUpdate the age of the second (index 1) user:\n\n```clj\n(assoc-in users [1 :age] 44)\n;;=> [{:name \"James\", :age 26}\n;;    {:name \"John\", :age 44}]\n```\n\nInsert the password of the second (index 1) user:\n\n```clj\n(assoc-in users [1 :password] \"nhoJ\")\n;;=> [{:name \"James\", :age 26}\n;;    {:password \"nhoJ\", :name \"John\", :age 43}]\n```"}],
                                 :full-name "cljs.core/assoc-in",
                                 :clj-symbol "clojure.core/assoc-in",
                                 :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
           "clojure.string/join" {:description "Returns a string of all elements in `coll`, as returned by `(seq coll)`,\nseparated by an optional separator.",
                                  :ns "clojure.string",
                                  :name "join",
                                  :signature ["[coll]"
                                              "[separator coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string_join",
                                  :source {:code "(defn join\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (apply str (interpose separator coll))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [45 51]},
                                  :full-name "clojure.string/join",
                                  :clj-symbol "clojure.string/join",
                                  :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
           "cljs.core/*unchecked-if*" {:ns "cljs.core",
                                       :name "*unchecked-if*",
                                       :type "var",
                                       :source {:code "(def *unchecked-if* false)",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [15]},
                                       :full-name "cljs.core/*unchecked-if*",
                                       :full-name-encode "cljs.core_STARunchecked-ifSTAR",
                                       :history [["+" "0.0-1211"]]},
           "cljs.core/seqable?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "seqable?",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_seqableQMARK",
                                 :source {:code "(defn ^boolean seqable?\n  [s]\n  (satisfies? ISeqable s))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [828 831]},
                                 :full-name "cljs.core/seqable?",
                                 :docstring "Return true if s satisfies ISeqable"},
           "clojure.zip/rights" {:ns "clojure.zip",
                                 :name "rights",
                                 :signature ["[loc]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_rights",
                                 :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [92 95]},
                                 :full-name "clojure.zip/rights",
                                 :clj-symbol "clojure.zip/rights",
                                 :docstring "Returns a seq of the right siblings of this loc"},
           "cljs.core/split-at" {:description "Returns a vector of `[(take n coll) (drop n coll)]`.",
                                 :ns "cljs.core",
                                 :name "split-at",
                                 :signature ["[n coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/split-with"
                                           "clojure.string/split"],
                                 :full-name-encode "cljs.core_split-at",
                                 :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2129 2132]},
                                 :full-name "cljs.core/split-at",
                                 :clj-symbol "clojure.core/split-at",
                                 :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
           "clojure.zip/append-child" {:ns "clojure.zip",
                                       :name "append-child",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_append-child",
                                       :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [200 204]},
                                       :full-name "clojure.zip/append-child",
                                       :clj-symbol "clojure.zip/append-child",
                                       :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
           "cljs.core/binding" {:description "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit `do`, then\nre-establishes the bindings that existed before.\n\nThe new bindings are made in parallel (unlike `let`); all init-exprs are\nevaluated before the vars are bound to their new values.",
                                :ns "cljs.core",
                                :name "binding",
                                :signature ["[bindings & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/let"],
                                :full-name-encode "cljs.core_binding",
                                :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map vector names vals)\n        resets (reverse (map vector names tempnames))]\n    (cljs.compiler/confirm-bindings &env names)\n    `(let [~@(interleave tempnames names)]\n       (try\n        ~@(map\n           (fn [[k v]] (list 'set! k v))\n           binds)\n        ~@body\n        (finally\n         ~@(map\n            (fn [[k v]] (list 'set! k v))\n            resets))))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [571 595]},
                                :examples [{:id "7dd17f",
                                            :content "```clj\n(def ^:dynamic *foo* 1)\n\n(defn do-something []\n  (println *foo*))\n\n(binding [*foo* 2]\n  (do-something))\n;;=> prints 2\n\n*foo*\n;;=> 1\n```"}],
                                :full-name "cljs.core/binding",
                                :clj-symbol "clojure.core/binding",
                                :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
           "cljs.core/Set" {:ns "cljs.core",
                            :name "Set",
                            :signature ["[meta hash-map]"],
                            :history [["+" "0.0-927"]
                                      ["-" "0.0-1211"]],
                            :type "type",
                            :full-name-encode "cljs.core_Set",
                            :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2659 2706]},
                            :full-name "cljs.core/Set",
                            :removed {:in "0.0-1211",
                                      :last-seen "0.0-1011"}},
           "cljs.core/sorted-map" {:description "Returns a new sorted map with supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                   :ns "cljs.core",
                                   :name "sorted-map",
                                   :signature ["[& keyvals]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/sorted-map-by"
                                             "cljs.core/subseq"
                                             "cljs.core/rsubseq"
                                             "cljs.core/sorted-set"
                                             "cljs.core/array-map"
                                             "cljs.core/hash-map"],
                                   :full-name-encode "cljs.core_sorted-map",
                                   :source {:code "(defn sorted-map\n  ([& keyvals]\n     (loop [in (seq keyvals) out cljs.core.PersistentTreeMap/EMPTY]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [4997 5004]},
                                   :full-name "cljs.core/sorted-map",
                                   :clj-symbol "clojure.core/sorted-map",
                                   :docstring "keyval => key val\nReturns a new sorted map with supplied mappings."},
           "cljs.reader/macro-terminating?" {:ns "cljs.reader",
                                             :name "macro-terminating?",
                                             :type "function",
                                             :signature ["[ch]"],
                                             :source {:code "(defn macro-terminating? [ch]\n  (and (not= ch \"#\") (not= ch \\') (not= ch \":\") (contains? macros ch)))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/cljs/cljs/reader.cljs",
                                                      :lines [73 74]},
                                             :full-name "cljs.reader/macro-terminating?",
                                             :full-name-encode "cljs.reader_macro-terminatingQMARK",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/prefers" {:ns "cljs.core",
                                :name "prefers",
                                :signature ["[multifn]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_prefers",
                                :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6387 6389]},
                                :full-name "cljs.core/prefers",
                                :clj-symbol "clojure.core/prefers",
                                :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
           "cljs.core/vary-meta" {:description "Returns an object of the same type and value as `obj`, with\n`(apply f (meta obj) args)` as its metadata.",
                                  :ns "cljs.core",
                                  :name "vary-meta",
                                  :signature ["[obj f & args]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/alter-meta!"
                                            "cljs.core/with-meta"],
                                  :full-name-encode "cljs.core_vary-meta",
                                  :source {:code "(defn vary-meta\n [obj f & args]\n (with-meta obj (apply f (meta obj) args)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1796 1800]},
                                  :examples [{:id "8cca62",
                                              :content "```clj\n(def a ^:foo [1 2 3])\n(def b (vary-meta a assoc :bar true))\n\n(= a b)\n;;=> true\n\n(meta a)\n;;=> {:foo true}\n\n(meta b)\n;;=> {:foo true, :bar true}\n```"}],
                                  :full-name "cljs.core/vary-meta",
                                  :clj-symbol "clojure.core/vary-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
           "cljs.core/when-let" {:description "When `test` is logical true, evaluates `body` with the value of `test` bound to\n`x`.",
                                 :ns "cljs.core",
                                 :name "when-let",
                                 :signature ["[[x test] & body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/if-let"
                                           "cljs.core/when"
                                           "cljs.core/when-not"
                                           "special/if"
                                           "cljs.core/when-first"],
                                 :full-name-encode "cljs.core_when-let",
                                 :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                          :repo "clojure",
                                          :tag "clojure-1.4.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [1687 1700]},
                                 :full-name "cljs.core/when-let",
                                 :clj-symbol "clojure.core/when-let",
                                 :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
           "cljs.core/ASeq" {:ns "cljs.core",
                             :name "ASeq",
                             :type "protocol",
                             :full-name-encode "cljs.core_ASeq",
                             :source {:code "(defprotocol ASeq)",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [155]},
                             :full-name "cljs.core/ASeq",
                             :clj-symbol "clojure.lang/ASeq",
                             :history [["+" "0.0-1211"]]},
           "cljs.core/drop" {:description "Returns a lazy sequence of all but the first `n` items in `coll`.\n\nReturns a stateful transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "drop",
                             :signature ["[n]" "[n coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/take"
                                       "cljs.core/drop-last"
                                       "cljs.core/drop-while"
                                       "cljs.core/nthnext"
                                       "cljs.core/nthrest"],
                             :full-name-encode "cljs.core_drop",
                             :source {:code "(defn drop\n  [n coll]\n  (let [step (fn [n coll]\n               (let [s (seq coll)]\n                 (if (and (pos? n) s)\n                   (recur (dec n) (rest s))\n                   s)))]\n    (lazy-seq (step n coll))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2088 2096]},
                             :full-name "cljs.core/drop",
                             :clj-symbol "clojure.core/drop",
                             :docstring "Returns a lazy sequence of all but the first n items in coll."},
           "cljs.core/reduceable?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "reduceable?",
                                    :signature ["[x]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_reduceableQMARK",
                                    :source {:code "(defn ^boolean reduceable?\n  [x] (satisfies? IReduce x))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [757 759]},
                                    :full-name "cljs.core/reduceable?",
                                    :docstring "Returns true if coll satisfies IReduce"},
           "cljs.core/while" {:description "Repeatedly executes `body` while `test` expression is true. Presumes some\nside-effect will cause `test` to become false or nil.\n\nReturns nil.",
                              :ns "cljs.core",
                              :name "while",
                              :signature ["[test & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/loop"],
                              :full-name-encode "cljs.core_while",
                              :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                       :repo "clojure",
                                       :tag "clojure-1.4.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5598 5606]},
                              :full-name "cljs.core/while",
                              :clj-symbol "clojure.core/while",
                              :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
           "cljs.core/import-macros" {:ns "cljs.core",
                                      :name "import-macros",
                                      :type "macro",
                                      :signature ["[ns [& vars]]"],
                                      :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(def ~sym (deref ~var))) syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [27 34]},
                                      :full-name "cljs.core/import-macros",
                                      :full-name-encode "cljs.core_import-macros",
                                      :history [["+" "0.0-927"]]},
           "cljs.repl.browser/add-in-order" {:ns "cljs.repl.browser",
                                             :name "add-in-order",
                                             :type "function",
                                             :signature ["[{:keys [expecting fns]} order f]"],
                                             :source {:code "(defn add-in-order [{:keys [expecting fns]} order f]\n  {:expecting (or expecting order) :fns (assoc fns order f)})",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [220 221]},
                                             :full-name "cljs.repl.browser/add-in-order",
                                             :full-name-encode "cljs.repl.browser_add-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/string-print" {:ns "cljs.core",
                                     :name "string-print",
                                     :type "function",
                                     :signature ["[x]"],
                                     :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [5625 5627]},
                                     :full-name "cljs.core/string-print",
                                     :full-name-encode "cljs.core_string-print",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/-" {:description "If no `y`s are supplied, returns the negation of `x`, else subtracts the `y`s\nfrom `x` and returns the result.",
                          :ns "cljs.core",
                          :name "-",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/+"],
                          :full-name-encode "cljs.core_-",
                          :source {:code "(defn -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1020 1025]},
                          :extra-sources ({:code "(defmacro -\n  ([x] (list 'js* \"(- ~{})\" x))\n  ([x y] (list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [121 124]}),
                          :examples [{:id "0a974e",
                                      :content "```clj\n(- 1)\n;;=> -1\n\n(- 6 3)\n;;=> 3\n\n(- 10 3 2)\n;;=> 5\n```"}],
                          :full-name "cljs.core/-",
                          :clj-symbol "clojure.core/-",
                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/vector-seq" {:ns "cljs.core",
                                   :name "vector-seq",
                                   :type "function",
                                   :signature ["[v offset]"],
                                   :source {:code "(defn vector-seq [v offset]\n  (let [c (-count v)]\n    (when (pos? c)\n      (reify\n        IPrintable\n        (-pr-seq [vseq opts] (pr-sequential pr-seq \"(\" \" \" \")\" opts vseq))\n        ISequential\n        IEquiv\n        (-equiv [vseq other] (equiv-sequential vseq other))\n        ASeq\n        ISeq\n        (-first [_] (-nth v offset))\n        (-rest [_]\n          (let [offset (inc offset)]\n            (if (< offset c)\n              (vector-seq v offset)\n              ())))\n        ISeqable\n        (-seq [vseq] vseq)))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2510 2528]},
                                   :full-name "cljs.core/vector-seq",
                                   :full-name-encode "cljs.core_vector-seq",
                                   :history [["+" "0.0-1211"]]},
           "clojure.zip/vector-zip" {:ns "clojure.zip",
                                     :name "vector-zip",
                                     :signature ["[root]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.zip_vector-zip",
                                     :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/clojure/zip.cljs",
                                              :lines [42 48]},
                                     :full-name "clojure.zip/vector-zip",
                                     :clj-symbol "clojure.zip/vector-zip",
                                     :docstring "Returns a zipper for nested vectors, given a root vector"},
           "cljs.core/conj!" {:ns "cljs.core",
                              :name "conj!",
                              :signature ["[tcoll val]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core_conjBANG",
                              :source {:code "(defn conj! [tcoll val]\n  (-conj! tcoll val))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1727 1728]},
                              :full-name "cljs.core/conj!",
                              :clj-symbol "clojure.core/conj!"},
           "cljs.core/js->clj" {:description "Recursively transforms JavaScript arrays into ClojureScript vectors, and\nJavaScript objects into ClojureScript maps.\n\nWith option `{:keywordize-keys true}` will convert object fields from strings to\nkeywords.\n\nNote that `js->clj` is not optimized for speed and the [transit.cljs] library is\nrecommended for parsing large amounts of JSON data.\n\n[transit.cljs]:http://swannodette.github.io/2014/07/26/transit--clojurescript/",
                                :ns "cljs.core",
                                :name "js->clj",
                                :signature ["[x]" "[x & opts]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/clj->js"],
                                :full-name-encode "cljs.core_js-GTclj",
                                :source {:code "(defn js->clj\n  [x & options]\n  (let [{:keys [keywordize-keys]} options\n        keyfn (if keywordize-keys keyword str)\n        f (fn thisfn [x]\n            (cond\n             (seq? x) (doall (map thisfn x))\n             (coll? x) (into (empty x) (map thisfn x))\n             (goog.isArray x) (vec (map thisfn x))\n             (identical? (type x) js/Object) (into {} (for [k (js-keys x)]\n                                                        [(keyfn k)\n                                                         (thisfn (aget x k))]))\n             :else x))]\n    (f x)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6052 6069]},
                                :examples [{:id "61d263",
                                            :content "Parse a JSON string:\n\n```clj\n(def json \"{\\\"foo\\\": 1, \\\"bar\\\": 2, \\\"baz\\\": [1,2,3]}\")\n(def a (.parse js/JSON json))\n;;=> #js {:foo 1, :bar 2, :baz #js [1 2 3]}\n```\n\nConvert JSON data `a` to ClojureScript data:\n\n```clj\n(js->clj a)\n;;=> {\"foo\" 1, \"bar\" 2, \"baz\" [1 2 3]}\n\n(js->clj a :keywordize-keys true)\n;;=> {:foo 1, :bar 2, :baz [1 2 3]}\n```"}],
                                :full-name "cljs.core/js->clj",
                                :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords."},
           "cljs.core/List" {:ns "cljs.core",
                             :name "List",
                             :signature ["[meta first rest count __hash]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_List",
                             :source {:code "(deftype List [meta first rest count ^:mutable __hash]\n  IList\n  \n  Object\n  (toString [this]\n    (pr-str this))\n  \n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] rest)\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1353 1392]},
                             :full-name "cljs.core/List",
                             :clj-symbol "clojure.lang/PersistentList"},
           "cljs.core/identical?" {:description "Returns true if `x` and `y` are the same object, false otherwise.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "identical?",
                                   :signature ["[x y]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/="
                                             "cljs.core/=="],
                                   :full-name-encode "cljs.core_identicalQMARK",
                                   :source {:code "(defn ^boolean identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [264 267]},
                                   :extra-sources ({:code "(defmacro identical? [a b]\n  (bool-expr (list 'js* \"(~{} === ~{})\" a b)))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [102 103]}),
                                   :full-name "cljs.core/identical?",
                                   :clj-symbol "clojure.core/identical?",
                                   :docstring "Tests if 2 arguments are the same object"},
           "cljs.core/*main-cli-fn*" {:ns "cljs.core",
                                      :name "*main-cli-fn*",
                                      :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                      :type "var",
                                      :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [56 60]},
                                      :full-name "cljs.core/*main-cli-fn*",
                                      :full-name-encode "cljs.core_STARmain-cli-fnSTAR",
                                      :history [["+" "0.0-927"]]},
           "clojure.browser.dom/html->dom" {:ns "clojure.browser.dom",
                                            :name "html->dom",
                                            :type "function",
                                            :signature ["[s]"],
                                            :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [101 102]},
                                            :full-name "clojure.browser.dom/html->dom",
                                            :full-name-encode "clojure.browser.dom_html-GTdom",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/some" {:description "Returns the first logical true value of `(pred x)` for any `x` in `coll`, else\nnil.\n\nA common idiom is to use a set as pred, for example this will return `:fred` if\n`:fred` is in the sequence, otherwise nil: `(some #{:fred} coll)`",
                             :ns "cljs.core",
                             :name "some",
                             :signature ["[pred coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/every?"
                                       "cljs.core/not-any?"
                                       "cljs.core/keep"
                                       "cljs.core/keep-indexed"
                                       "cljs.core/some-fn"],
                             :full-name-encode "cljs.core_some",
                             :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1827 1834]},
                             :full-name "cljs.core/some",
                             :clj-symbol "clojure.core/some",
                             :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
           "cljs.core/doall" {:description "Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.\n\n`doall` walks through the successive `next`s of the sequence, returning the head\nand causing the entire sequence to reside in memory at one time.",
                              :ns "cljs.core",
                              :name "doall",
                              :signature ["[coll]" "[n coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/dorun"
                                        "cljs.core/doseq"],
                              :full-name-encode "cljs.core_doall",
                              :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5565 5577]},
                              :full-name "cljs.core/doall",
                              :clj-symbol "clojure.core/doall",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
           "cljs.core/condp" {:description "Takes a binary predicate, an expression, and a set of clauses. There are two\nkinds of clauses:\n\nBinary clause: `test-expr` `result-expr`\n\nTernary clause: `test-expr` `:>>` `result-fn`<br />\n(Note: `:>>` is an ordinary keyword)\n\nFor each clause, `(pred test-expr expr)` is evaluated. If it returns logical\ntrue, the clause is a match.\n\nIf a binary clause matches, its `result-expr` is returned.\n\nIf a ternary clause matches, its `result-fn` is called with the result of the\npredicate and returned by `condp`. `result-fn` should take one argument.\n\nA single default expression can follow the clauses, and its value will be\nreturned if no clause matches.\n\nIf no default expression is provided and no clause matches, an Error is thrown.",
                              :ns "cljs.core",
                              :name "condp",
                              :signature ["[pred expr & clauses]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/cond" "special/if"],
                              :full-name-encode "cljs.core_condp",
                              :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (cond\n                  (= 0 n) `(throw (js/Error. (core/str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [597 637]},
                              :full-name "cljs.core/condp",
                              :clj-symbol "clojure.core/condp",
                              :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
           "clojure.zip/down" {:ns "clojure.zip",
                               :name "down",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_down",
                               :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [98 109]},
                               :full-name "clojure.zip/down",
                               :clj-symbol "clojure.zip/down",
                               :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
           "cljs.core/IPending" {:ns "cljs.core",
                                 :name "IPending",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IPending",
                                 :source {:code "(defprotocol IPending\n  (-realized? [d]))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [235 236]},
                                 :methods [{:name "-realized?",
                                            :signature ["[d]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IPending",
                                 :clj-symbol "clojure.lang/IPending"},
           "cljs.core/count" {:description "Returns the number of items in `x`.\n\n`count` works on arrays, lists, maps, sets, strings, and vectors.\n\n`(count nil)` returns 0.",
                              :ns "cljs.core",
                              :name "count",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_count",
                              :source {:code "(defn count\n  [coll]\n  (if (counted? coll)\n    (-count coll)\n    (accumulating-seq-count coll 0)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [608 614]},
                              :examples [{:id "96e470",
                                          :content "```clj\n(count [1 2 3])\n;;=> 3\n\n(count [])\n;;=> 0\n\n(count nil)\n;;=> 0\n\n(count #{:a :b})\n;;=> 2\n\n(count {:key \"value\" :key2 \"value2\"})\n;;=> 2\n```"}],
                              :full-name "cljs.core/count",
                              :clj-symbol "clojure.core/count",
                              :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
           "cljs.core/bit-test" {:description "Test bit at index `n`. Returns `true` if 1, and `false` if 0. Same as `(x & (1 << y)) != 0` in JavaScript.",
                                 :ns "cljs.core",
                                 :name "bit-test",
                                 :signature ["[x n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_bit-test",
                                 :source {:code "(defn bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1183 1186]},
                                 :extra-sources ({:code "(defmacro bit-test [x n]\n  (list 'js* \"((~{} & (1 << ~{})) != 0)\" x n))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [220 221]}),
                                 :examples [{:id "f64664",
                                             :content "Bits can be entered using radix notation:\n\n```clj\n(bit-test 2r0100 2)\n;;=> true\n\n(bit-test 2r0100 1)\n;;=> false\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-test 4 2)\n;;=> true\n\n(bit-test 4 1)\n;;=> false\n```"}],
                                 :full-name "cljs.core/bit-test",
                                 :clj-symbol "clojure.core/bit-test",
                                 :docstring "Test bit at index n"},
           "cljs.core/loop" {:description "Evaluates the `body-exprs` in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs, just like a `let` form.\nActs as a `recur` target, which will allow tail-call optimization.",
                             :ns "cljs.core",
                             :name "loop",
                             :signature ["[[& bindings] & body-exprs]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["special/recur"],
                             :full-name-encode "cljs.core_loop",
                             :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)\n              bfs (reduce1 (fn [ret [b v g]]\n                            (if (symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                      :repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [4029 4052]},
                             :extra-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n loop (fn* loop [&form &env & decl] (cons 'loop* decl)))",
                                              :repo "clojure",
                                              :tag "clojure-1.4.0",
                                              :filename "src/clj/clojure/core.clj",
                                              :lines [37 40]}),
                             :examples [{:id "60291e",
                                         :content "```clj\n(loop [x 0]\n  (when (< x 10)\n    (println x)\n    (recur (+ x 2))))\n;; Prints:\n;; 0\n;; 2\n;; 4\n;; 6\n;; 8\n;;\n;;=> nil\n```"}],
                             :full-name "cljs.core/loop",
                             :clj-symbol "clojure.core/loop",
                             :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
           "cljs.core/subvec" {:description "Returns a persistent vector of the items in `v` from `start` inclusive to `end`\nexclusive.\n\nIf `end` is not supplied, defaults to `(count v)`.\n\nThis operation is O(1) and very fast, as the resulting vector shares structure\nwith the original and no trimming is done.",
                               :ns "cljs.core",
                               :name "subvec",
                               :signature ["[v start]"
                                           "[v start end]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/vector"
                                         "cljs.core/vector?"],
                               :full-name-encode "cljs.core_subvec",
                               :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (Subvec. nil v start end nil)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2753 2762]},
                               :full-name "cljs.core/subvec",
                               :clj-symbol "clojure.core/subvec",
                               :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
           "cljs.core/bit-clear" {:description "Clear bit at index `n`.  Same as `x & ~(1 << y)` in JavaScript.",
                                  :ns "cljs.core",
                                  :name "bit-clear",
                                  :signature ["[x n]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/bit-set"
                                            "cljs.core/bit-flip"],
                                  :full-name-encode "cljs.core_bit-clear",
                                  :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1164 1167]},
                                  :extra-sources ({:code "(defmacro bit-clear [x n]\n  (list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [214 215]}),
                                  :examples [{:id "0f6748",
                                              :content "Bits can be entered using radix notation:\n\n```clj\n(bit-clear 2r1111 2)\n;;=> 11\n;; 11 = 2r1011\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-clear 15 2)\n;;=> 11\n```"}],
                                  :full-name "cljs.core/bit-clear",
                                  :clj-symbol "clojure.core/bit-clear",
                                  :docstring "Clear bit at index n"},
           "cljs.core/gensym" {:ns "cljs.core",
                               :name "gensym",
                               :signature ["[]" "[prefix-string]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_gensym",
                               :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6007 6015]},
                               :full-name "cljs.core/gensym",
                               :clj-symbol "clojure.core/gensym",
                               :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
           "special/recur" {:ns "special",
                            :name "recur",
                            :type "special form",
                            :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs :as form] _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (assert frame \"Can't recur here\")\n    (assert (= (count exprs) (count (:names frame))) \"recur argument count mismatch\")\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children exprs)))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [1038 1049]},
                            :full-name "special/recur",
                            :full-name-encode "special_recur",
                            :clj-symbol "clojure.core/recur",
                            :history [["+" "0.0-927"]]},
           "cljs.core/+" {:description "Returns the sum of nums.\n\n`(+)` returns 0.",
                          :ns "cljs.core",
                          :name "+",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/*" "cljs.core/-"],
                          :full-name-encode "cljs.core_PLUS",
                          :source {:code "(defn +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more] (reduce + (cljs.core/+ x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1013 1018]},
                          :extra-sources ({:code "(defmacro +\n  ([] 0)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [115 119]}),
                          :examples [{:id "650668",
                                      :content "```clj\n(+)\n;;=> 0\n\n(+ 1)\n;;=> 1\n\n(+ -10)\n;;=> -10\n\n(+ 1 2)\n;;=> 3\n\n(+ 1 2 3)\n;;=> 6\n```"}],
                          :full-name "cljs.core/+",
                          :clj-symbol "clojure.core/+",
                          :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/comp" {:description "Takes a set of functions and returns a function that is the composition\nof those functions.\n\nThe returned function takes a variable number of arguments, applies the\nrightmost of `fns` to the arguments, whose result is subsequently applied to\nthe next left function, and so on.\n\n`((comp a b c) x y)` = `(a (b (c x y)))`",
                             :ns "cljs.core",
                             :name "comp",
                             :signature ["[& fns]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/partial"
                                       "cljs.core/juxt"],
                             :full-name-encode "cljs.core_comp",
                             :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1867 1894]},
                             :examples [{:id "5d3250",
                                         :content "```clj\n(def f (comp str inc +))\n(f 1 2 3)\n;;=> \"7\"\n```"}],
                             :full-name "cljs.core/comp",
                             :clj-symbol "clojure.core/comp",
                             :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
           "cljs.reader/desugar-meta" {:ns "cljs.reader",
                                       :name "desugar-meta",
                                       :type "function",
                                       :signature ["[f]"],
                                       :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [269 275]},
                                       :full-name "cljs.reader/desugar-meta",
                                       :full-name-encode "cljs.reader_desugar-meta",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl/load-namespace" {:ns "cljs.repl",
                                       :name "load-namespace",
                                       :signature ["[repl-env sym]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl_load-namespace",
                                       :source {:code "(defn load-namespace\n  [repl-env sym]\n  (let [sym (if (and (seq? sym)\n                     (= (first sym) 'quote))\n              (second sym)\n              sym)\n        opts {:output-dir (get repl-env :working-dir \".repl\")}\n        deps (->> (cljsc/add-dependencies opts {:requires [(name sym)] :type :seed})\n                  (remove (comp #{[\"goog\"]} :provides))\n                  (remove (comp #{:seed} :type))\n                  (map #(select-keys % [:provides :url])))]\n    (doseq [{:keys [url provides]} deps]\n      (-load repl-env provides url))))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [24 39]},
                                       :full-name "cljs.repl/load-namespace",
                                       :docstring "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once and\nonly once."},
           "cljs.core/pr" {:ns "cljs.core",
                           :name "pr",
                           :signature ["[& objs]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :full-name-encode "cljs.core_pr",
                           :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [5711 5717]},
                           :full-name "cljs.core/pr",
                           :clj-symbol "clojure.core/pr",
                           :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
           "clojure.string/upper-case" {:description "Converts string to all upper-case.",
                                        :ns "clojure.string",
                                        :name "upper-case",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_upper-case",
                                        :source {:code "(defn upper-case\n  [s]\n  (. s (toUpperCase)))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [53 56]},
                                        :full-name "clojure.string/upper-case",
                                        :clj-symbol "clojure.string/upper-case",
                                        :docstring "Converts string to all upper-case."},
           "syntax/string" {:description "Signifies a string.  ClojureScript strings are the same as JavaScript strings.\n\nStrings may span multiple lines.\n\nStandard escape characters such as `\\\"` are supported, as well as unicode\nescape characters:\n\n| unicode characters  | constraints                                   |\n|---------------------|-----------------------------------------------|\n| `\\uXXXX`            | XXXX must have 4 digits outside 0xD7FF-0xE000 |\n| `\\oXXX`             | XXX is octal between 0 and 0377               |",
                            :ns "syntax",
                            :name "string",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/str"],
                            :full-name-encode "syntax_string",
                            :source {:repo "clojure",
                                     :tag "clojure-1.4.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form "\"\"",
                            :examples [{:id "eb97ac",
                                        :content "```clj\n\"foo\"\n;;=> \"foo\"\n\n\"hello\n     world\"\n;;=> \"hello\\n     world\"\n```\n\nCharacters can be escaped:\n\n```clj\n(println \"foo\\nbar\")\n;; prints:\n;;   foo\n;;   bar\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#strings",
                            :full-name "syntax/string",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.event/expose" {:ns "clojure.browser.event",
                                           :name "expose",
                                           :type "function",
                                           :signature ["[e]"],
                                           :source {:code "(defn expose [e]\n  (goog.events/expose e))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [79 80]},
                                           :full-name "clojure.browser.event/expose",
                                           :full-name-encode "clojure.browser.event_expose",
                                           :history [["+" "0.0-927"]]},
           "clojure.browser.event/listen-once" {:ns "clojure.browser.event",
                                                :name "listen-once",
                                                :type "function",
                                                :signature ["[src type fn]"
                                                            "[src type fn capture?]"],
                                                :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (goog.events/listenOnce src\n                             (get (event-types src) type type)\n                             fn\n                             capture?)))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/cljs/clojure/browser/event.cljs",
                                                         :lines [53
                                                                 60]},
                                                :full-name "clojure.browser.event/listen-once",
                                                :full-name-encode "clojure.browser.event_listen-once",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/empty?" {:description "Returns true if `coll` has no items - same as `(not (seq coll))`.\n\nPlease use the idiom `(seq x)` rather than `(not (empty? x))`.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "empty?",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/seq"],
                               :full-name-encode "cljs.core_emptyQMARK",
                               :source {:code "(defn ^boolean empty?\n  [coll] (not (seq coll)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [722 725]},
                               :full-name "cljs.core/empty?",
                               :clj-symbol "clojure.core/empty?",
                               :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
           "cljs.core/newline" {:ns "cljs.core",
                                :name "newline",
                                :signature ["[opts]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_newline",
                                :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5685 5688]},
                                :full-name "cljs.core/newline",
                                :clj-symbol "clojure.core/newline"},
           "cljs.core/PersistentHashMap" {:ns "cljs.core",
                                          :name "PersistentHashMap",
                                          :signature ["[meta cnt root has-nil? nil-val __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_PersistentHashMap",
                                          :source {:code "(deftype PersistentHashMap [meta cnt root has-nil? nil-val ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj coll entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta cljs.core.PersistentHashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if (coercive-not= nil root) (.inode-seq root))]\n        (if has-nil?\n          (cons [nil nil-val] s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (nth (.inode-find root 0 (hash k) k (array nil not-found)) 1)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (array false)\n            new-root    (-> (if (nil? root)\n                              cljs.core.BitmapIndexedNode/EMPTY\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if (aget added-leaf? 0) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-find root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (coercive-not= nil root) (.kv-reduce root f init)\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [4129 4227]},
                                          :full-name "cljs.core/PersistentHashMap",
                                          :clj-symbol "clojure.lang/PersistentHashMap"},
           "cljs.core/replace" {:description "Given a map of replacement pairs `smap` and a vector/collection `coll`, returns\na vector/seq with any elements `=` to a key in `smap` replaced with the\ncorresponding val in `smap`.\n\nReturns a transducer when `coll` is not provided.",
                                :ns "cljs.core",
                                :name "replace",
                                :signature ["[smap]" "[smap coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/map"
                                          "clojure.walk/prewalk-replace"
                                          "clojure.walk/postwalk-replace"],
                                :full-name-encode "cljs.core_replace",
                                :source {:code "(defn replace\n  [smap coll]\n  (if (vector? coll)\n    (let [n (count coll)]\n      (reduce (fn [v i]\n                (if-let [e (find smap (nth v i))]\n                  (assoc v i (second e))\n                  v))\n              coll (take n (iterate inc 0))))\n    (map #(if-let [e (find smap %)] (second e) %) coll)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5264 5276]},
                                :full-name "cljs.core/replace",
                                :clj-symbol "clojure.core/replace",
                                :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap"},
           "cljs.core/rand" {:description "Returns a random floating point number between 0 inclusive and `n` exclusive.\n\n`n` defaults to 1.",
                             :ns "cljs.core",
                             :name "rand",
                             :signature ["[]" "[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rand-int"
                                       "cljs.core/rand-nth"],
                             :full-name-encode "cljs.core_rand",
                             :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (js* \"Math.random() * ~{n}\")))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [6101 6105]},
                             :extra-sources ({:code "(defn rand\n  ([]  (Math/random))\n  ([n] (* n (rand))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1139 1142]}),
                             :full-name "cljs.core/rand",
                             :clj-symbol "clojure.core/rand",
                             :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
           "cljs.core/add-watch" {:description "Adds a watch function `f` to atom `a` that will execute when the value of `a`\nchanges.\n\nThe watch function takes 4 arguments: a key, the atom, its old state, and its\nnew state.\n\n`key` should be a keyword and can be used with `remove-watch` to remove the\nwatch function.",
                                  :ns "cljs.core",
                                  :name "add-watch",
                                  :signature ["[a key f]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/remove-watch"],
                                  :full-name-encode "cljs.core_add-watch",
                                  :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [5972 5994]},
                                  :examples [{:id "2f2fe0",
                                              :content "```clj\n(def a (atom {}))\n\n(add-watch a :logger\n  (fn [_key _atom old-state new-state]\n    (println \"old:\" old-state)\n    (println \"new:\" new-state)))\n\n(swap! a assoc :foo \"bar\")\n;;=> will print the following:\n;; old: {}\n;; new: {:foo \"bar\"}\n```"}],
                                  :full-name "cljs.core/add-watch",
                                  :clj-symbol "clojure.core/add-watch",
                                  :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
           "cljs.repl.rhino/loaded-libs" {:ns "cljs.repl.rhino",
                                          :name "loaded-libs",
                                          :type "var",
                                          :source {:code "(def loaded-libs (atom #{}))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [19]},
                                          :full-name "cljs.repl.rhino/loaded-libs",
                                          :full-name-encode "cljs.repl.rhino_loaded-libs",
                                          :history [["+" "0.0-927"]]},
           "clojure.string/capitalize" {:description "Converts first character of the string to upper-case, all other characters to\nlower-case.",
                                        :ns "clojure.string",
                                        :name "capitalize",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_capitalize",
                                        :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [63 70]},
                                        :full-name "clojure.string/capitalize",
                                        :clj-symbol "clojure.string/capitalize",
                                        :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
           "cljs.core/replicate" {:ns "cljs.core",
                                  :name "replicate",
                                  :signature ["[n x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_replicate",
                                  :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2139 2141]},
                                  :full-name "cljs.core/replicate",
                                  :clj-symbol "clojure.core/replicate",
                                  :docstring "Returns a lazy seq of n xs."},
           "special/do" {:ns "special",
                         :name "do",
                         :type "special form",
                         :source {:code "(defmethod parse 'do\n  [op env [_ & exprs :as form] _]\n  (let [block (analyze-block env exprs)]\n    (merge {:env env :op :do :form form :children (block-children block)} block)))",
                                  :repo "clojurescript",
                                  :tag "r1211",
                                  :filename "src/clj/cljs/compiler.clj",
                                  :lines [991 994]},
                         :full-name "special/do",
                         :full-name-encode "special_do",
                         :clj-symbol "clojure.core/do",
                         :history [["+" "0.0-927"]]},
           "cljs.core/sequential?" {:description "Returns true if `coll` implements the `ISequential` protocol, false otherwise.\n\nLists and vectors are sequential.",
                                    :return-type boolean,
                                    :ns "cljs.core",
                                    :name "sequential?",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/seq?"
                                              "cljs.core/coll?"],
                                    :full-name-encode "cljs.core_sequentialQMARK",
                                    :source {:code "(defn ^boolean sequential?\n  [x] (satisfies? ISequential x))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [745 747]},
                                    :full-name "cljs.core/sequential?",
                                    :clj-symbol "clojure.core/sequential?",
                                    :docstring "Returns true if coll satisfies ISequential"},
           "cljs.core/underive" {:ns "cljs.core",
                                 :name "underive",
                                 :signature ["[tag parent]"
                                             "[h tag parent]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_underive",
                                 :source {:code "(defn underive\n  ([tag parent]\n     ;; (alter-var-root #'global-hierarchy underive tag parent)\n     (swap! global-hierarchy underive tag parent) nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [6216 6235]},
                                 :full-name "cljs.core/underive",
                                 :clj-symbol "clojure.core/underive",
                                 :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "cljs.core/get-method" {:ns "cljs.core",
                                   :name "get-method",
                                   :signature ["[multifn dispatch-val]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_get-method",
                                   :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6382 6385]},
                                   :full-name "cljs.core/get-method",
                                   :clj-symbol "clojure.core/get-method",
                                   :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
           "cljs.core/=" {:description "Returns true if the value of `x` equals the value of `y`, false otherwise.\n\n`=` is a value comparison, not an identity comparison.\n\nAll collections can be tested for value, regardless of \"depth\".",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name "=",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/=="
                                    "cljs.core/not="
                                    "cljs.core/identical?"],
                          :full-name-encode "cljs.core_EQ",
                          :source {:code "(defn ^boolean =\n  ([x] true)\n  ([x y] (or (identical? x y) (-equiv x y)))\n  ([x y & more]\n     (if (= x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (= y (first more)))\n       false)))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [271 283]},
                          :examples [{:id "edffb6",
                                      :content "```clj\n(= 1)\n;;=> true\n\n(= 1 1)\n;;=> true\n\n(= 1 2)\n;;=> false\n\n(= 1 1 1)\n;;=> true\n\n(= 1 1 2)\n;;=> false\n```"}
                                     {:id "a2d064",
                                      :content "Sequences are considered equal in value if they have the same elements:\n\n```clj\n(= '(1 2) [1 2])\n;;=> true\n```\n\nBut you cannot compare JavaScript arrays until you convert them to sequences:\n\n```clj\n(def a #js [1 2])\n(def b #js [1 2])\n(= a b)\n;;=> false\n\n(= (seq a) (seq b))\n;;=> true\n```"}
                                     {:id "6c8424",
                                      :content "It is natural to compare deeply nested collections since value equality checks\nare cheap in ClojureScript:\n\n```clj\n(def a {:foo {:bar \"baz\"}})\n(def b {:foo {:bar \"baz\"}})\n(= a b)\n;;=> true\n\n(= [a b] [a b])\n;=> true\n```\n\nJavaScript objects cannot be compared in this way until they are converted to\nClojureScript collections:\n\n```clj\n(def a #js {:foo #js {:bar \"baz\"}})\n(def b #js {:foo #js {:bar \"baz\"}})\n(= a b)\n;;=> false\n\n(= (js->clj a)\n   (js->clj b))\n;;=> true\n```"}],
                          :full-name "cljs.core/=",
                          :clj-symbol "clojure.core/=",
                          :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
           "syntax/comment" {:description "\"Comments out\" everything after `;` on the current line.",
                             :ns "syntax",
                             :name "comment",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/ignore"
                                       "cljs.core/comment"],
                             :full-name-encode "syntax_comment",
                             :source {:repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form ";",
                             :examples [{:id "ab62d2",
                                         :content "Add comments to code:\n\n```clj\n(def a 1) ; this is a comment\n```\n\nIt is common to use `;;` for comments that have their own line:\n\n```clj\n;; this is comment is on its own line\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#comments",
                             :full-name "syntax/comment",
                             :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/defn-" {:description "Same as `defn`, but adds `{:private true}` metadata to the definition.\n\nNote: `:private` metadata is not currently enforced by the ClojureScript\ncompiler.",
                              :ns "cljs.core",
                              :name "defn-",
                              :signature ["[name & decls]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/defn"],
                              :full-name-encode "cljs.core_defn-",
                              :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                       :repo "clojure",
                                       :tag "clojure-1.4.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [4355 4359]},
                              :full-name "cljs.core/defn-",
                              :clj-symbol "clojure.core/defn-",
                              :docstring "same as defn, yielding non-public def"},
           "cljs.reader/read-symbol" {:ns "cljs.reader",
                                      :name "read-symbol",
                                      :type "function",
                                      :signature ["[reader initch]"],
                                      :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (gstring/contains token \"/\")\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\")) (.-length token)))\n      (get special-symbols token (symbol token)))))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [248 254]},
                                      :full-name "cljs.reader/read-symbol",
                                      :full-name-encode "cljs.reader_read-symbol",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/push-back-reader" {:ns "cljs.reader",
                                           :name "push-back-reader",
                                           :type "function",
                                           :signature ["[s]"],
                                           :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (atom 0) (atom nil)))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/cljs/reader.cljs",
                                                    :lines [30 32]},
                                           :full-name "cljs.reader/push-back-reader",
                                           :full-name-encode "cljs.reader_push-back-reader",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/deftype" {:ns "cljs.core",
                                :name "deftype",
                                :signature ["[t fields & impls]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_deftype",
                                :source {:code "(defmacro deftype [t fields & impls]\n  (let [adorn-params (fn [sig]\n                       (cons (vary-meta (second sig) assoc :cljs.compiler/fields fields)\n                             (nnext sig)))\n        ;;reshape for extend-type\n        dt->et (fn [specs]\n                 (loop [ret [] s specs]\n                   (if (seq s)\n                     (recur (-> ret\n                                (conj (first s))\n                                (into\n                                 (reduce (fn [v [f sigs]]\n                                           (conj v (cons f (map adorn-params sigs))))\n                                         []\n                                         (group-by first (take-while seq? (next s))))))\n                            (drop-while seq? (next s)))\n                     ret)))\n        r (:name (cljs.compiler/resolve-var (dissoc &env :locals) t))\n        pmasks (prepare-protocol-masks &env t impls)]\n    (if (seq impls)\n      `(do\n         (deftype* ~t ~fields ~pmasks)\n         (set! (.-cljs$lang$type ~t) true)\n         (set! (.-cljs$lang$ctorPrSeq ~t) (fn [this#] (list ~(core/str r))))\n         (extend-type ~t ~@(dt->et impls))\n         ~t)\n      `(do\n         (deftype* ~t ~fields ~pmasks)\n         (set! (.-cljs$lang$type ~t) true)\n         (set! (.-cljs$lang$ctorPrSeq ~t) (fn [this#] (list ~(core/str r))))\n         ~t))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [369 399]},
                                :full-name "cljs.core/deftype",
                                :clj-symbol "clojure.core/deftype"},
           "cljs.core/Subvec" {:ns "cljs.core",
                               :name "Subvec",
                               :type "type",
                               :signature ["[meta v start end __hash]"],
                               :source {:code "(deftype Subvec [meta v start end ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Subvec. meta v start end __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (== start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (Subvec. meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (Subvec. meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (== i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (-nth v (+ start n)))\n  (-nth [coll n not-found]\n    (-nth v (+ start n) not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (let [v-pos (+ start key)]\n      (Subvec. meta (-assoc v v-pos val)\n               start (max end (inc v-pos))\n               nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2676 2751]},
                               :full-name "cljs.core/Subvec",
                               :full-name-encode "cljs.core_Subvec",
                               :history [["+" "0.0-927"]]},
           "cljs.repl.browser/run-in-order" {:ns "cljs.repl.browser",
                                             :name "run-in-order",
                                             :type "function",
                                             :signature ["[{:keys [expecting fns]}]"],
                                             :source {:code "(defn run-in-order [{:keys [expecting fns]}]\n  (loop [order expecting\n         fns fns]\n    (if-let [f (get fns order)]\n      (do (f)\n          (recur (inc order) (dissoc fns order)))\n      {:expecting order :fns fns})))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [223 229]},
                                             :full-name "cljs.repl.browser/run-in-order",
                                             :full-name-encode "cljs.repl.browser_run-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.browser/compile-client-js" {:ns "cljs.repl.browser",
                                                  :name "compile-client-js",
                                                  :type "function",
                                                  :signature ["[opts]"],
                                                  :source {:code "(defn compile-client-js [opts]\n  (cljsc/build '[(ns clojure.browser.repl.client\n                   (:require [goog.events :as event]\n                             [clojure.browser.repl :as repl]))\n                 (defn start [url]\n                   (event/listen js/window\n                                 \"load\"\n                                 (fn []\n                                   (repl/start-evaluator url))))]\n               {:optimizations (:optimizations opts)\n                :output-dir (:working-dir opts)}))",
                                                           :repo "clojurescript",
                                                           :tag "r1211",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [319
                                                                   329]},
                                                  :full-name "cljs.repl.browser/compile-client-js",
                                                  :full-name-encode "cljs.repl.browser_compile-client-js",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "special/ns" {:description "Sets the namespace of the file.\n\n`ns` must be the first form in a `.cljs` file and there can only be one `ns`\ndeclaration per file. Namespaces must match the file name of their respective\n`.cljs` files, with the exception that dashes in namespaces become underscores\nin filenames. Thus, `(ns foo.bar-biz.baz)` should be the first form in file\n`foo/bar_biz/baz.cljs`.\n\n`references` can be zero or more forms used to import other namespaces, symbols,\nand libraries into the current namespace.",
                         :ns "special",
                         :name "ns",
                         :signature ["[name & references]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :full-name-encode "special_ns",
                         :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args :as form] _]\n  (let [docstring (if (string? (first args)) (first args) nil)\n        args      (if docstring (next args) args)\n        excludes\n        (reduce (fn [s [k exclude xs]]\n                  (if (= k :refer-clojure)\n                    (do\n                      (assert (= exclude :exclude) \"Only [:refer-clojure :exclude [names]] form supported\")\n                      (into s xs))\n                    s))\n                #{} args)\n        deps (atom #{})\n        {uses :use requires :require uses-macros :use-macros requires-macros :require-macros :as params}\n        (reduce (fn [m [k & libs]]\n                  (assert (#{:use :use-macros :require :require-macros} k)\n                          \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")\n                  (assoc m k (into {}\n                                   (mapcat (fn [[lib kw expr]]\n                                             (swap! deps conj lib)\n                                             (case k\n                                               (:require :require-macros)\n                                               (do (assert (and expr (= :as kw))\n                                                           \"Only (:require [lib.ns :as alias]*) form of :require / :require-macros is supported\")\n                                                   [[expr lib]])\n                                               (:use :use-macros)\n                                               (do (assert (and expr (= :only kw))\n                                                           \"Only (:use [lib.ns :only [names]]*) form of :use / :use-macros is supported\")\n                                                   (map vector expr (repeat lib)))))\n                                           libs))))\n                {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (when (seq @deps)\n      (analyze-deps @deps))\n    (set! *cljs-ns* name)\n    (require 'cljs.core)\n    (doseq [nsym (concat (vals requires-macros) (vals uses-macros))]\n      (clojure.core/require nsym))\n    (swap! namespaces #(-> %\n                           (assoc-in [name :name] name)\n                           (assoc-in [name :excludes] excludes)\n                           (assoc-in [name :uses] uses)\n                           (assoc-in [name :requires] requires)\n                           (assoc-in [name :uses-macros] uses-macros)\n                           (assoc-in [name :requires-macros]\n                                     (into {} (map (fn [[alias nsym]]\n                                                     [alias (find-ns nsym)])\n                                                   requires-macros)))))\n    {:env env :op :ns :form form :name name :uses uses :requires requires\n     :uses-macros uses-macros :requires-macros requires-macros :excludes excludes}))",
                                  :repo "clojurescript",
                                  :tag "r1211",
                                  :filename "src/clj/cljs/compiler.clj",
                                  :lines [1112 1160]},
                         :full-name "special/ns",
                         :clj-symbol "clojure.core/ns"},
           "cljs.core/IReversible" {:ns "cljs.core",
                                    :name "IReversible",
                                    :history [["+" "0.0-1211"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core_IReversible",
                                    :source {:code "(defprotocol IReversible\n  (-rseq [coll]))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [223 224]},
                                    :methods [{:name "-rseq",
                                               :signature ["[coll]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IReversible",
                                    :clj-symbol "clojure.lang/Reversible"},
           "cljs.core/extend-protocol" {:ns "cljs.core",
                                        :name "extend-protocol",
                                        :signature ["[p & specs]"],
                                        :history [["+" "0.0-927"]],
                                        :type "macro",
                                        :full-name-encode "cljs.core_extend-protocol",
                                        :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                 :repo "clojure",
                                                 :tag "clojure-1.4.0",
                                                 :filename "src/clj/clojure/core_deftype.clj",
                                                 :lines [786 824]},
                                        :full-name "cljs.core/extend-protocol",
                                        :clj-symbol "clojure.core/extend-protocol",
                                        :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
           "cljs.reader/read" {:ns "cljs.reader",
                               :name "read",
                               :signature ["[reader eof-is-error sentinel is-recursive]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.reader_read",
                               :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [res\n                 (cond\n                  (macros ch) ((macros ch) reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (= res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/reader.cljs",
                                        :lines [338 354]},
                               :full-name "cljs.reader/read",
                               :clj-symbol "clojure.core/read",
                               :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
           "cljs.core/EmptyList" {:ns "cljs.core",
                                  :name "EmptyList",
                                  :signature ["[meta]"],
                                  :history [["+" "0.0-927"]],
                                  :type "type",
                                  :full-name-encode "cljs.core_EmptyList",
                                  :source {:code "(deftype EmptyList [meta]\n  IList\n  \n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] #_(throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] 0)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1394 1432]},
                                  :full-name "cljs.core/EmptyList",
                                  :clj-symbol "clojure.lang/EmptyList"},
           "clojure.walk/postwalk" {:ns "clojure.walk",
                                    :name "postwalk",
                                    :signature ["[f form]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.walk_postwalk",
                                    :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/clojure/walk.cljs",
                                             :lines [50 56]},
                                    :full-name "clojure.walk/postwalk",
                                    :clj-symbol "clojure.walk/postwalk",
                                    :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "clojure.zip/edit" {:ns "clojure.zip",
                               :name "edit",
                               :signature ["[loc f & args]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_edit",
                               :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [189 192]},
                               :full-name "clojure.zip/edit",
                               :clj-symbol "clojure.zip/edit",
                               :docstring "Replaces the node at this loc with the value of (f node args)"},
           "cljs.core/re-seq" {:description "Returns a lazy sequence of successive matches of regex `re` in string `s`.",
                               :ns "cljs.core",
                               :name "re-seq",
                               :signature ["[re s]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/re-find"
                                         "cljs.core/re-pattern"
                                         "cljs.core/re-matches"
                                         "cljs.core/subs"
                                         "clojure.string/split"],
                               :full-name-encode "cljs.core_re-seq",
                               :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (re-seq re post-match))))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [5602 5609]},
                               :full-name "cljs.core/re-seq",
                               :clj-symbol "clojure.core/re-seq",
                               :docstring "Returns a lazy sequence of successive matches of re in s."},
           "cljs.reader/read-list" {:ns "cljs.reader",
                                    :name "read-list",
                                    :type "function",
                                    :signature ["[rdr _]"],
                                    :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [203 205]},
                                    :full-name "cljs.reader/read-list",
                                    :full-name-encode "cljs.reader_read-list",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/IKVReduce" {:ns "cljs.core",
                                  :name "IKVReduce",
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IKVReduce",
                                  :source {:code "(defprotocol IKVReduce\n  (-kv-reduce [coll f init]))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [202 203]},
                                  :methods [{:name "-kv-reduce",
                                             :signature ["[coll f init]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IKVReduce",
                                  :history [["+" "0.0-1211"]]},
           "cljs.core/Atom" {:ns "cljs.core",
                             :name "Atom",
                             :signature ["[state meta validator watches]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_Atom",
                             :source {:code "(deftype Atom [state meta validator watches]\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IPrintable\n  (-pr-seq [a opts]\n    (concat  [\"#<Atom: \"] (-pr-seq state opts) \">\"))\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f)))\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [5857 5881]},
                             :full-name "cljs.core/Atom",
                             :clj-symbol "clojure.lang/Atom"},
           "cljs.core/IMap" {:ns "cljs.core",
                             :name "IMap",
                             :type "protocol",
                             :full-name-encode "cljs.core_IMap",
                             :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (-dissoc [coll k]))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [169 171]},
                             :methods [{:name "-dissoc",
                                        :signature ["[coll k]"],
                                        :docstring nil}],
                             :full-name "cljs.core/IMap",
                             :history [["+" "0.0-927"]]},
           "cljs.reader/read-vector" {:ns "cljs.reader",
                                      :name "read-vector",
                                      :type "function",
                                      :signature ["[rdr _]"],
                                      :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [209 211]},
                                      :full-name "cljs.reader/read-vector",
                                      :full-name-encode "cljs.reader_read-vector",
                                      :history [["+" "0.0-927"]]},
           "clojure.set/join" {:ns "clojure.set",
                               :name "join",
                               :signature ["[xrel yrel]"
                                           "[xrel yrel km]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.set_join",
                               :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/set.cljs",
                                        :lines [102 130]},
                               :full-name "clojure.set/join",
                               :clj-symbol "clojure.set/join",
                               :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
           "cljs.core/HashMap" {:ns "cljs.core",
                                :name "HashMap",
                                :type "type",
                                :signature ["[meta count hashobj __hash]"],
                                :source {:code "(deftype HashMap [meta count hashobj ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n  \n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj nil))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj nil))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj nil)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (.-length bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj nil)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3199 3290]},
                                :full-name "cljs.core/HashMap",
                                :full-name-encode "cljs.core_HashMap",
                                :history [["+" "0.0-927"]]},
           "cljs.repl.browser/handle-get" {:ns "cljs.repl.browser",
                                           :name "handle-get",
                                           :type "function",
                                           :signature ["[opts conn request]"],
                                           :source {:code "(defn handle-get [opts conn request]\n  (let [path (:path request)]\n    (cond\n     (.startsWith path \"/repl\") (send-repl-client-page opts conn request)\n     (:serve-static opts) (send-static opts conn request)\n     :else (send-404 conn (:path request)))))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/clj/cljs/repl/browser.clj",
                                                    :lines [198 203]},
                                           :full-name "cljs.repl.browser/handle-get",
                                           :full-name-encode "cljs.repl.browser_handle-get",
                                           :history [["+" "0.0-927"]]},
           "cljs.reader/int-pattern" {:ns "cljs.reader",
                                      :name "int-pattern",
                                      :type "var",
                                      :source {:code "(def int-pattern (re-pattern \"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?\"))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [95]},
                                      :full-name "cljs.reader/int-pattern",
                                      :full-name-encode "cljs.reader_int-pattern",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/swap!" {:description "Atomically swaps the value of atom to be: `(apply f current-value-of-atom\nargs)`\n\nNote that `f` may be called multiple times, and thus should be free of side\neffects.\n\nReturns the value that was swapped in.",
                              :ns "cljs.core",
                              :name "swap!",
                              :signature ["[a f]"
                                          "[a f x]"
                                          "[a f x y]"
                                          "[a f x y & more]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/atom"
                                        "cljs.core/reset!"],
                              :full-name-encode "cljs.core_swapBANG",
                              :source {:code "(defn swap!\n  ([a f]\n     (reset! a (f (.-state a))))\n  ([a f x]\n     (reset! a (f (.-state a) x)))\n  ([a f x y]\n     (reset! a (f (.-state a) x y)))\n  ([a f x y z]\n     (reset! a (f (.-state a) x y z)))\n  ([a f x y z & more]\n     (reset! a (apply f (.-state a) x y z more))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5911 5925]},
                              :full-name "cljs.core/swap!",
                              :clj-symbol "clojure.core/swap!",
                              :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
           "cljs.core/dec" {:description "Returns a number one less than `x`.",
                            :ns "cljs.core",
                            :name "dec",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/inc"],
                            :full-name-encode "cljs.core_dec",
                            :source {:code "(defn dec\n  [x] (- x 1))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1089 1091]},
                            :extra-sources ({:code "(defmacro dec [x]\n  `(- ~x 1))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [162 163]}),
                            :full-name "cljs.core/dec",
                            :clj-symbol "clojure.core/dec",
                            :docstring "Returns a number one less than num."},
           "clojure.browser.dom/remove-children" {:ns "clojure.browser.dom",
                                                  :name "remove-children",
                                                  :signature ["[id]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.dom_remove-children",
                                                  :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                           :repo "clojurescript",
                                                           :tag "r1211",
                                                           :filename "src/cljs/clojure/browser/dom.cljs",
                                                           :lines [92
                                                                   96]},
                                                  :full-name "clojure.browser.dom/remove-children",
                                                  :docstring "Remove all children from the element with the passed id."},
           "cljs.core/BlackNode" {:ns "cljs.core",
                                  :name "BlackNode",
                                  :type "type",
                                  :signature ["[key val left right __hash]"],
                                  :source {:code "(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  (toString [this]\n    (pr-str this))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [4499 4605]},
                                  :full-name "cljs.core/BlackNode",
                                  :full-name-encode "cljs.core_BlackNode",
                                  :history [["+" "0.0-1211"]]},
           "cljs.core/get-validator" {:description "Returns the validator function for atom `a`.",
                                      :ns "cljs.core",
                                      :name "get-validator",
                                      :signature ["[a]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :related ["cljs.core/atom"
                                                "cljs.core/set-validator!"],
                                      :full-name-encode "cljs.core_get-validator",
                                      :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [5953 5956]},
                                      :full-name "cljs.core/get-validator",
                                      :clj-symbol "clojure.core/get-validator",
                                      :docstring "Gets the validator-fn for a var/ref/agent/atom."},
           "cljs.core/coll?" {:description "Returns true if `x` is a collection, false otherwise.\n\nLists, maps, sets, and vectors are collections.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "coll?",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/seq?"
                                        "cljs.core/list?"
                                        "cljs.core/sequential?"],
                              :full-name-encode "cljs.core_collQMARK",
                              :source {:code "(defn ^boolean coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [727 732]},
                              :examples [{:id "d30884",
                                          :content "```clj\n(coll? [1 2 3])\n;;=> true\n\n(coll? '(1 2 3))\n;;=> true\n\n(coll? #{1 2 3})\n;;=> true\n\n(coll? {:foo 1 :bar 2})\n;;=> true\n```\n\nNot collections:\n\n```clj\n(coll? \"foo\")\n;;=> false\n\n(coll? 123)\n;;=> false\n\n(coll? nil)\n;;=> false\n```"}],
                              :full-name "cljs.core/coll?",
                              :clj-symbol "clojure.core/coll?",
                              :docstring "Returns true if x satisfies ICollection"},
           "cljs.core/bit-or" {:description "Bitwise \"or\". Same as `x | y` in JavaScript.",
                               :ns "cljs.core",
                               :name "bit-or",
                               :signature ["[x y]" "[x y & more]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/bit-and"
                                         "cljs.core/bit-xor"],
                               :full-name-encode "cljs.core_bit-or",
                               :source {:code "(defn bit-or\n  [x y] (cljs.core/bit-or x y))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1156 1158]},
                               :extra-sources ({:code "(defmacro bit-or\n  ([x y] (list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [202 204]}),
                               :examples [{:id "ecea10",
                                           :content "Bits can be entered using radix notation:\n\n```clj\n(bit-or 2r1100 2r1010)\n;;=> 14\n;; 14 = 2r1110\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-or 12 10)\n;;=> 14\n```"}],
                               :full-name "cljs.core/bit-or",
                               :clj-symbol "clojure.core/bit-or",
                               :docstring "Bitwise or"},
           "cljs.core/nfirst" {:description "Same as `(next (first coll))`.",
                               :ns "cljs.core",
                               :name "nfirst",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/next"],
                               :full-name-encode "cljs.core_nfirst",
                               :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [555 558]},
                               :examples [{:id "60b8a4",
                                           :content "```clj\n(nfirst [[1 2 3] [4 5]])\n;;=> (2 3)\n\n(nfirst [[1 2] [3 4]])\n;;=> (2)\n\n(nfirst [[1] [2 3]])\n;;=> nil\n\n(nfirst [[] [1 2]])\n;;=> nil\n```"}],
                               :full-name "cljs.core/nfirst",
                               :clj-symbol "clojure.core/nfirst",
                               :docstring "Same as (next (first x))"},
           "cljs.core/keep" {:description "Returns a lazy sequence of the non-nil results of `(f item)`. Note, this means\nfalse return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "keep",
                             :signature ["[f]" "[f coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/keep-indexed"
                                       "cljs.core/map"
                                       "cljs.core/filter"],
                             :full-name-encode "cljs.core_keep",
                             :source {:code "(defn keep\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [x (f (first s))]\n        (if (nil? x)\n          (keep f (rest s))\n          (cons x (keep f (rest s)))))))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1945 1955]},
                             :full-name "cljs.core/keep",
                             :clj-symbol "clojure.core/keep",
                             :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
           "cljs.core/take" {:description "Returns a lazy sequence of the first `n` items in `coll`. Returns all the items\nif there are fewer than `n`.\n\nReturns a stateful transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "take",
                             :signature ["[n]" "[n coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/drop"
                                       "cljs.core/take-while"
                                       "cljs.core/take-last"
                                       "cljs.core/take-nth"],
                             :full-name-encode "cljs.core_take",
                             :source {:code "(defn take\n  [n coll]\n  (lazy-seq\n   (when (pos? n)\n     (when-let [s (seq coll)]\n      (cons (first s) (take (dec n) (rest s)))))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2079 2086]},
                             :full-name "cljs.core/take",
                             :clj-symbol "clojure.core/take",
                             :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n."},
           "cljs.core/PersistentHashSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentHashSet",
                                                :type "var",
                                                :full-name-encode "cljs.core_PersistentHashSetDOTEMPTY",
                                                :source {:code "(set! cljs.core.PersistentHashSet/EMPTY (PersistentHashSet. nil (hash-map) 0))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [5134]},
                                                :full-name "cljs.core/PersistentHashSet.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentHashSet.EMPTY"},
           "cljs.core/cond" {:description "`clauses` must be an even number of forms, ie: `(cond t1 e1, t2 e2, t3 e3)`.\nEach test `t` is evaluated one at a time. If a test returns logical true, `cond`\nevaluates and returns the corresponding expression `e` and does not evaluate any\nof the other tests or expressions.\n\nIt is idiomatic to provide a default case as the last test pair using the\nkeyword `:else` (a keyword always evaluates to logical true).\n\n`(cond)` returns nil.",
                             :ns "cljs.core",
                             :name "cond",
                             :signature ["[& clauses]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/condp"
                                       "cljs.core/case"
                                       "special/if"],
                             :full-name-encode "cljs.core_cond",
                             :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                      :repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [535 548]},
                             :full-name "cljs.core/cond",
                             :clj-symbol "clojure.core/cond",
                             :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
           "cljs.core/bit-and" {:description "Bitwise \"and\".  Same as `x & y` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-and",
                                :signature ["[x y]" "[x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-or"],
                                :full-name-encode "cljs.core_bit-and",
                                :source {:code "(defn bit-and\n  [x y] (cljs.core/bit-and x y))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1152 1154]},
                                :extra-sources ({:code "(defmacro bit-and\n  ([x y] (list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [193 195]}),
                                :examples [{:id "3c0470",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-and 2r1100 2r1010)\n;;=> 8\n;; 8 = 2r1000\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-and 12 10)\n;;=> 8\n```"}],
                                :full-name "cljs.core/bit-and",
                                :clj-symbol "clojure.core/bit-and",
                                :docstring "Bitwise and"},
           "cljs.core/ObjMap.fromObject" {:ns "cljs.core",
                                          :name "ObjMap.fromObject",
                                          :signature ["[ks obj]"],
                                          :history [["+" "0.0-927"]],
                                          :parent-type "ObjMap",
                                          :type "function",
                                          :full-name-encode "cljs.core_ObjMapDOTfromObject",
                                          :source {:code "(set! cljs.core.ObjMap/fromObject (fn [ks obj] (ObjMap. nil ks obj 0 nil)))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [3188]},
                                          :full-name "cljs.core/ObjMap.fromObject"},
           "cljs.core/PersistentArrayMap" {:ns "cljs.core",
                                           :name "PersistentArrayMap",
                                           :signature ["[meta cnt arr __hash]"],
                                           :history [["+" "0.0-1211"]],
                                           :type "type",
                                           :full-name-encode "cljs.core_PersistentArrayMap",
                                           :source {:code "(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentArrayMap. meta cnt arr __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj coll entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta cljs.core.PersistentArrayMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [len (.-length arr)\n            array-map-seq\n            (fn array-map-seq [i]\n              (lazy-seq\n               (when (< i len)\n                 (cons [(aget arr i) (aget arr (inc i))]\n                       (array-map-seq (+ i 2))))))]\n        (array-map-seq 0))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (== idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (== idx -1)\n        (if (< cnt cljs.core.PersistentArrayMap/HASHMAP_THRESHOLD)\n          (PersistentArrayMap. meta\n                               (inc cnt)\n                               (doto (aclone arr)\n                                 (.push k)\n                                 (.push v))\n                               nil)\n          (persistent!\n           (assoc!\n            (transient (into cljs.core.PersistentHashMap/EMPTY coll))\n            k v)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (PersistentArrayMap. meta\n                             cnt\n                             (doto (aclone arr)\n                               (aset (inc idx) v))\n                             nil))))\n\n  (-contains-key? [coll k]\n    (coercive-not= (array-map-index-of coll k) -1))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (>= idx 0)\n        (let [len     (.-length arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (>= s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (= k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (.-length arr)]\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (.-length arr) (aclone arr))))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3314 3432]},
                                           :full-name "cljs.core/PersistentArrayMap",
                                           :clj-symbol "clojure.lang/PersistentArrayMap"},
           "clojure.browser.event/unique-event-id" {:ns "clojure.browser.event",
                                                    :name "unique-event-id",
                                                    :type "function",
                                                    :signature ["[event-type]"],
                                                    :source {:code "(defn unique-event-id [event-type])",
                                                             :repo "clojurescript",
                                                             :tag "r1211",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [92]},
                                                    :full-name "clojure.browser.event/unique-event-id",
                                                    :full-name-encode "clojure.browser.event_unique-event-id",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/ObjMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                 :name "ObjMap.HASHMAP_THRESHOLD",
                                                 :type "var",
                                                 :parent-type "ObjMap",
                                                 :source {:code "(set! cljs.core.ObjMap/HASHMAP_THRESHOLD 32)",
                                                          :repo "clojurescript",
                                                          :tag "r1211",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [3186]},
                                                 :full-name "cljs.core/ObjMap.HASHMAP_THRESHOLD",
                                                 :full-name-encode "cljs.core_ObjMapDOTHASHMAP_THRESHOLD",
                                                 :history [["+"
                                                            "0.0-1211"]]},
           "clojure.set/project" {:ns "clojure.set",
                                  :name "project",
                                  :signature ["[xrel ks]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set_project",
                                  :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [67 70]},
                                  :full-name "clojure.set/project",
                                  :clj-symbol "clojure.set/project",
                                  :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
           "cljs.core/int" {:description "Coerces `x` to an integer by stripping decimal places.",
                            :ns "cljs.core",
                            :name "int",
                            :signature ["[x]"],
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :related ["cljs.core/char"
                                      "cljs.core/integer?"],
                            :full-name-encode "cljs.core_int",
                            :source {:code "(defn int\n  [x]\n  (fix x))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1112 1115]},
                            :full-name "cljs.core/int",
                            :clj-symbol "clojure.core/int",
                            :docstring "Coerce to int by stripping decimal places."},
           "special/js*" {:ns "special",
                          :name "js*",
                          :type "special form",
                          :source {:code "(defmethod parse 'js*\n  [op env [_ jsform & args :as form] _]\n  (assert (string? jsform))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (cons (subs s 0 idx) (seg (subs s (inc end))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       {:env env :op :js :segs (seg jsform) :args argexprs\n        :tag (-> form meta :tag) :form form :children argexprs}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (cons (subs s 0 idx) (cons inner (interp (subs s (inc end)))))))))]\n      {:env env :op :js :form form :code (apply str (interp jsform))\n       :tag (-> form meta :tag)})))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [1276 1299]},
                          :full-name "special/js*",
                          :full-name-encode "special_jsSTAR",
                          :history [["+" "0.0-927"]]},
           "syntax/quote" {:description "Prevent the evaluation of the following form.\n\n`'foo` = `(quote foo)`",
                           :ns "syntax",
                           :name "quote",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["special/quote"],
                           :full-name-encode "syntax_quote",
                           :source {:repo "clojure",
                                    :tag "clojure-1.4.0",
                                    :filename "src/jvm/clojure/lang/LispReader.java",
                                    :lines [nil]},
                           :syntax-form "'",
                           :examples [{:id "0d2c26",
                                       :content "```clj\n'foo\n;;=> foo\n\n'(a b c)\n;;=> (a b c)\n\n'[a b c]\n;;=> [a b c]\n\n'(a b (c d))\n;;=> (a b (c d))\n```"}],
                           :full-name "syntax/quote",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.string/trim-newline" {:description "Removes all trailing newline `\\n` or return `\\r` characters from string.\n\nSimilar to Perl's chomp.",
                                          :ns "clojure.string",
                                          :name "trim-newline",
                                          :signature ["[s]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.string_trim-newline",
                                          :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/clojure/string.cljs",
                                                   :lines [121 131]},
                                          :full-name "clojure.string/trim-newline",
                                          :clj-symbol "clojure.string/trim-newline",
                                          :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
           "specialrepl/in-ns" {:description "Only usable from a REPL.\n\nChanges to the namespace `name`, creating it if needed.\n\nSets `*cljs-ns*` to the namespace `name`.",
                                :ns "specialrepl",
                                :name "in-ns",
                                :signature ["[name]"],
                                :history [["+" "0.0-927"]],
                                :type "special form (repl)",
                                :full-name-encode "specialrepl_in-ns",
                                :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (@comp/namespaces ns-name)\n                  (swap! comp/namespaces assoc ns-name {:name ns-name}))\n                (set! comp/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/clj/cljs/repl.clj",
                                         :lines [138 147]},
                                :examples [{:id "e81eb3",
                                            :content "```clj\n(in-ns 'foo.core)\n```"}],
                                :full-name "specialrepl/in-ns",
                                :clj-symbol "clojure.core/in-ns"},
           "special/let*" {:ns "special",
                           :name "let*",
                           :type "special form",
                           :source {:code "(defmethod parse 'let*\n  [op encl-env form _]\n  (analyze-let encl-env form false))",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [1030 1032]},
                           :full-name "special/let*",
                           :full-name-encode "special_letSTAR",
                           :history [["+" "0.0-927"]]},
           "cljs.repl.browser/stop-server" {:ns "cljs.repl.browser",
                                            :name "stop-server",
                                            :type "function",
                                            :signature ["[]"],
                                            :source {:code "(defn stop-server\n  []\n  (.close (:socket @server-state)))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [271 273]},
                                            :full-name "cljs.repl.browser/stop-server",
                                            :full-name-encode "cljs.repl.browser_stop-server",
                                            :history [["+" "0.0-927"]]},
           "special/throw" {:description "`expr` is evaluated and thrown, hopefully to be caught by a `try` expression.\n\n`(throw (js/Error. \"Oops!\"))`",
                            :ns "special",
                            :name "throw",
                            :signature ["[expr]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :related ["special/try"
                                      "special/catch"
                                      "special/finally"],
                            :full-name-encode "special_throw",
                            :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [837 842]},
                            :full-name "special/throw",
                            :clj-symbol "clojure.core/throw"},
           "clojure.zip/insert-left" {:ns "clojure.zip",
                                      :name "insert-left",
                                      :signature ["[loc item]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.zip_insert-left",
                                      :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/clojure/zip.cljs",
                                               :lines [165 172]},
                                      :full-name "clojure.zip/insert-left",
                                      :clj-symbol "clojure.zip/insert-left",
                                      :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
           "cljs.core/true?" {:description "Returns true if `x` is the value true, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "true?",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/false?"],
                              :full-name-encode "cljs.core_trueQMARK",
                              :source {:code "(defn ^boolean true?\n  [x] (cljs.core/true? x))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [811 813]},
                              :extra-sources ({:code "(defmacro true? [x]\n  (bool-expr (list 'js* \"~{} === true\" x)))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [93 94]}),
                              :full-name "cljs.core/true?",
                              :clj-symbol "clojure.core/true?",
                              :docstring "Returns true if x is the value true, false otherwise."},
           "clojure.browser.net/xpc-connection" {:ns "clojure.browser.net",
                                                 :name "xpc-connection",
                                                 :signature ["[]"
                                                             "[config]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net_xpc-connection",
                                                 :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (goog.Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (goog.net.xpc.CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (goog.net.xpc.CrossPageChannel.\n      (reduce (fn [sum [k v]]\n                (if-let [field (get xpc-config-fields k)]\n                  (doto sum (aset field v))\n                  sum))\n              (js-obj)\n              config))))",
                                                          :repo "clojurescript",
                                                          :tag "r1211",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [118
                                                                  140]},
                                                 :full-name "clojure.browser.net/xpc-connection",
                                                 :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API."},
           "cljs.core/not" {:description "Returns true if `x` is logical false, false otherwise.",
                            :return-type boolean,
                            :ns "cljs.core",
                            :name "not",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/complement"
                                      "cljs.core/false?"],
                            :full-name-encode "cljs.core_not",
                            :source {:code "(defn ^boolean not\n  [x] (if x false true))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [581 583]},
                            :full-name "cljs.core/not",
                            :clj-symbol "clojure.core/not",
                            :docstring "Returns true if x is logical false, false otherwise."},
           "cljs.core/js-obj" {:description "Returns a new JavaScript object using the supplied mappings.\n\n`keyvals` must be an even number of forms.",
                               :ns "cljs.core",
                               :name "js-obj",
                               :signature ["[& keyvals]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/array"],
                               :full-name-encode "cljs.core_js-obj",
                               :source {:code "(defn js-obj\n  ([]\n     (js* \"{}\"))\n  ([& keyvals]\n     (apply gobject/create keyvals)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [773 777]},
                               :extra-sources ({:code "(defmacro js-obj [& rest]\n  (let [kvs-str (->> (repeat \"~{}:~{}\")\n                     (take (quot (count rest) 2))\n                     (interpose \",\")\n                     (apply core/str))]\n    (concat\n     (list 'js* (core/str \"{\" kvs-str \"}\"))\n     rest)))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [795 802]}),
                               :examples [{:id "657cd7",
                                           :content "```clj\n(js-obj \"foo\" 1 \"bar\" 2)\n;;=> #js {:foo 1, :bar 2}\n```"}],
                               :full-name "cljs.core/js-obj"},
           "cljs.core/complement" {:description "Takes a function `f` and returns a function that takes the same arguments as\n`f`, has the same effects, if any, and returns the opposite truth value.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "complement",
                                   :signature ["[f]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/not"],
                                   :full-name-encode "cljs.core_complement",
                                   :source {:code "(defn ^boolean complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1853 1861]},
                                   :full-name "cljs.core/complement",
                                   :clj-symbol "clojure.core/complement",
                                   :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
           "cljs.core/spread" {:ns "cljs.core",
                               :name "spread",
                               :type "function",
                               :signature ["[arglist]"],
                               :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1680 1686]},
                               :full-name "cljs.core/spread",
                               :full-name-encode "cljs.core_spread",
                               :history [["+" "0.0-927"]]},
           "cljs.core/keyword" {:ns "cljs.core",
                                :name "keyword",
                                :signature ["[name]" "[ns name]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_keyword",
                                :source {:code "(defn keyword\n  ([name] (cond (keyword? name) name\n                (symbol? name) (str* \"\\uFDD0\" \"'\" (subs name 2))\n                :else (str* \"\\uFDD0\" \"'\" name)))\n  ([ns name] (keyword (str* ns \"/\" name))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1287 1293]},
                                :full-name "cljs.core/keyword",
                                :clj-symbol "clojure.core/keyword",
                                :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
           "syntax/keyword-qualify" {:ns "syntax",
                                     :name "keyword-qualify",
                                     :history [["+" "0.0-927"]],
                                     :type "syntax",
                                     :full-name-encode "syntax_keyword-qualify",
                                     :source {:repo "clojure",
                                              :tag "clojure-1.4.0",
                                              :filename "src/jvm/clojure/lang/LispReader.java",
                                              :lines [nil]},
                                     :syntax-form "::",
                                     :full-name "syntax/keyword-qualify",
                                     :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/sort" {:description "Returns a sorted sequence of the items in `coll`.\n\n`comp` can be a boolean-valued comparison funcion, or a -/0/+ valued comparator.\n\n`comp` defaults to `compare`.",
                             :ns "cljs.core",
                             :name "sort",
                             :signature ["[coll]" "[comp coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/sort-by"],
                             :full-name-encode "cljs.core_sort",
                             :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [928 940]},
                             :full-name "cljs.core/sort",
                             :clj-symbol "clojure.core/sort",
                             :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "clojure.string/trim" {:description "Removes whitespace from both ends of string.",
                                  :ns "clojure.string",
                                  :name "trim",
                                  :signature ["[s]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string_trim",
                                  :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [106 109]},
                                  :full-name "clojure.string/trim",
                                  :clj-symbol "clojure.string/trim",
                                  :docstring "Removes whitespace from both ends of string."},
           "cljs.core/meta" {:ns "cljs.core",
                             :name "meta",
                             :signature ["[o]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_meta",
                             :source {:code "(defn meta\n  [o]\n  (when (satisfies? IMeta o)\n    (-meta o)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [688 692]},
                             :full-name "cljs.core/meta",
                             :clj-symbol "clojure.core/meta",
                             :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
           "cljs.core/time" {:ns "cljs.core",
                             :name "time",
                             :signature ["[expr]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core_time",
                             :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.) ())\n         ret# ~expr]\n     (prn (core/str \"Elapsed time: \" (- (.getTime (js/Date.) ()) start#) \" msecs\"))\n     ret#))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [908 914]},
                             :full-name "cljs.core/time",
                             :clj-symbol "clojure.core/time",
                             :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
           "cljs.core/boolean" {:description "Return `false` if `x` is false or nil.  Otherwise return `true`.  This is the\ntruthiness condition used by `if` expressions.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "boolean",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["special/if"],
                                :full-name-encode "cljs.core_boolean",
                                :source {:code "(defn ^boolean boolean [x]\n  (if x true false))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [833 834]},
                                :examples [{:id "9edf3a",
                                            :content "```clj\n(boolean 1)\n;;=> true\n\n(boolean 0)\n;;=> true\n\n(boolean nil)\n;;=> false\n```"}],
                                :full-name "cljs.core/boolean",
                                :clj-symbol "clojure.core/boolean"},
           "cljs.reader/read-token" {:ns "cljs.reader",
                                     :name "read-token",
                                     :type "function",
                                     :signature ["[rdr initch]"],
                                     :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (gstring/StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (. sb (toString)))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [76 84]},
                                     :full-name "cljs.reader/read-token",
                                     :full-name-encode "cljs.reader_read-token",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/update-in" {:description "\"Updates\" a value in a nested associative structure, where `ks` is a sequence of\nkeys and `f` is a function that will take the old value and any supplied\narguments and return the new value. Returns a new nested structure.\n\nIf any levels do not exist, hash-maps will be created.",
                                  :ns "cljs.core",
                                  :name "update-in",
                                  :signature ["[m [k & ks] f]"
                                              "[m [k & ks] f a]"
                                              "[m [k & ks] f a b]"
                                              "[m [k & ks] f a b c]"
                                              "[m [k & ks] f a b c & args]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/assoc-in"
                                            "cljs.core/get-in"],
                                  :full-name-encode "cljs.core_update-in",
                                  :source {:code "(defn update-in\n  ([m [k & ks] f & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f args))\n     (assoc m k (apply f (get m k) args)))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2318 2327]},
                                  :full-name "cljs.core/update-in",
                                  :clj-symbol "clojure.core/update-in",
                                  :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
           "cljs.core/map-indexed" {:description "Returns a lazy sequence consisting of the result of applying `f` to 0 and the\nfirst item of `coll`, followed by applying `f` to 1 and the second item in\n`coll`, etc, until `coll` is exhausted.\n\nFunction `f` should accept 2 arguments, index and item.",
                                    :ns "cljs.core",
                                    :name "map-indexed",
                                    :signature ["[f coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/map"
                                              "cljs.core/keep-indexed"],
                                    :full-name-encode "cljs.core_map-indexed",
                                    :source {:code "(defn map-indexed\n  [f coll]\n  (let [mapi (fn mpi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (cons (f idx (first s))\n                        (mpi (inc idx) (rest s))))))]\n    (mapi 0 coll)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1932 1943]},
                                    :full-name "cljs.core/map-indexed",
                                    :clj-symbol "clojure.core/map-indexed",
                                    :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
           "cljs.core/IStack" {:ns "cljs.core",
                               :name "IStack",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core_IStack",
                               :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (-pop [coll]))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [180 182]},
                               :methods [{:name "-peek",
                                          :signature ["[coll]"],
                                          :docstring nil}
                                         {:name "-pop",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IStack",
                               :clj-symbol "clojure.lang/IPersistentStack"},
           "cljs.core/ISorted" {:ns "cljs.core",
                                :name "ISorted",
                                :history [["+" "0.0-1211"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_ISorted",
                                :source {:code "(defprotocol ISorted\n  (-sorted-seq [coll ascending?])\n  (-sorted-seq-from [coll k ascending?])\n  (-entry-key [coll entry])\n  (-comparator [coll]))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [226 230]},
                                :methods [{:name "-sorted-seq",
                                           :signature ["[coll ascending?]"],
                                           :docstring nil}
                                          {:name "-sorted-seq-from",
                                           :signature ["[coll k ascending?]"],
                                           :docstring nil}
                                          {:name "-entry-key",
                                           :signature ["[coll entry]"],
                                           :docstring nil}
                                          {:name "-comparator",
                                           :signature ["[coll]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ISorted",
                                :clj-symbol "clojure.lang/Sorted"},
           "cljs.core/IIndexed" {:ns "cljs.core",
                                 :name "IIndexed",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IIndexed",
                                 :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [152 153]},
                                 :methods [{:name "-nth",
                                            :signature ["[coll n]"
                                                        "[coll n not-found]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IIndexed",
                                 :clj-symbol "clojure.lang/Indexed"},
           "clojure.browser.repl/repl-print" {:ns "clojure.browser.repl",
                                              :name "repl-print",
                                              :type "function",
                                              :signature ["[data]"],
                                              :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [23 25]},
                                              :full-name "clojure.browser.repl/repl-print",
                                              :full-name-encode "clojure.browser.repl_repl-print",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.browser.net/xpc-config-fields" {:ns "clojure.browser.net",
                                                    :name "xpc-config-fields",
                                                    :type "var",
                                                    :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (js->clj goog.net.xpc.CfgFields))))",
                                                             :repo "clojurescript",
                                                             :tag "r1211",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [75
                                                                     81]},
                                                    :full-name "clojure.browser.net/xpc-config-fields",
                                                    :full-name-encode "clojure.browser.net_xpc-config-fields",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/nnext" {:description "Same as `(next (next coll))`.",
                              :ns "cljs.core",
                              :name "nnext",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/next"],
                              :full-name-encode "cljs.core_nnext",
                              :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [565 568]},
                              :full-name "cljs.core/nnext",
                              :clj-symbol "clojure.core/nnext",
                              :docstring "Same as (next (next x))"},
           "cljs.core/*print-meta*" {:ns "cljs.core",
                                     :name "*print-meta*",
                                     :type "var",
                                     :source {:code "(def *print-meta* false)",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [5692]},
                                     :full-name "cljs.core/*print-meta*",
                                     :full-name-encode "cljs.core_STARprint-metaSTAR",
                                     :clj-symbol "clojure.core/*print-meta*",
                                     :history [["+" "0.0-927"]]},
           "cljs.reader/read-dispatch" {:ns "cljs.reader",
                                        :name "read-dispatch",
                                        :type "function",
                                        :signature ["[rdr _]"],
                                        :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (get dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (reader-error rdr \"No dispatch macro for \" ch))))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [191 197]},
                                        :full-name "cljs.reader/read-dispatch",
                                        :full-name-encode "cljs.reader_read-dispatch",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/distinct" {:description "Returns a lazy sequence of the elements of `coll` with duplicates removed.",
                                 :ns "cljs.core",
                                 :name "distinct",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/distinct?"],
                                 :full-name-encode "cljs.core_distinct",
                                 :source {:code "(defn distinct\n  [coll]\n  (let [step (fn step [xs seen]\n               (lazy-seq\n                ((fn [[f :as xs] seen]\n                   (when-let [s (seq xs)]\n                     (if (contains? seen f)\n                       (recur (rest s) seen)\n                       (cons f (step (rest s) (conj seen f))))))\n                 xs seen)))]\n    (step coll #{})))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [5278 5289]},
                                 :full-name "cljs.core/distinct",
                                 :clj-symbol "clojure.core/distinct",
                                 :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
           "cljs.reader/wrapping-reader" {:ns "cljs.reader",
                                          :name "wrapping-reader",
                                          :type "function",
                                          :signature ["[sym]"],
                                          :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [277 280]},
                                          :full-name "cljs.reader/wrapping-reader",
                                          :full-name-encode "cljs.reader_wrapping-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/double-array" {:ns "cljs.core",
                                     :name "double-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :history [["+" "0.0-1211"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_double-array",
                                     :source {:code "(defn double-array\n  ([size-or-seq]\n     (cond\n      (number? size-or-seq) (double-array size-or-seq nil)\n      (seq? size-or-seq) (into-array size-or-seq)\n      :else (throw (js/Error. \"double-array called with something other than size or ISeq\"))))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1630 1649]},
                                     :full-name "cljs.core/double-array",
                                     :clj-symbol "clojure.core/double-array"},
           "cljs.core/prn" {:ns "cljs.core",
                            :name "prn",
                            :signature ["[& objs]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core_prn",
                            :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (newline (pr-opts)))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [5742 5746]},
                            :full-name "cljs.core/prn",
                            :clj-symbol "clojure.core/prn",
                            :docstring "Same as pr followed by (newline)."},
           "clojure.zip/leftmost" {:ns "clojure.zip",
                                   :name "leftmost",
                                   :signature ["[loc]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip_leftmost",
                                   :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [157 163]},
                                   :full-name "clojure.zip/leftmost",
                                   :clj-symbol "clojure.zip/leftmost",
                                   :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
           "cljs.core/>=" {:description "Returns true if each successive number argument is less than or equal to the\nprevious one, false otherwise.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name ">=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/>"],
                           :full-name-encode "cljs.core_GTEQ",
                           :source {:code "(defn ^boolean >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1077 1087]},
                           :extra-sources ({:code "(defmacro >=\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [152 155]}),
                           :examples [{:id "de73d7",
                                       :content "```clj\n(>= 2 1)\n;;=> true\n\n(>= 2 2)\n;;=> true\n\n(>= 1 2)\n;;=> false\n\n(>= 6 5 4 3 2)\n;;=> true\n```"}],
                           :full-name "cljs.core/>=",
                           :clj-symbol "clojure.core/>=",
                           :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
           "cljs.repl.browser/read-request" {:ns "cljs.repl.browser",
                                             :name "read-request",
                                             :type "function",
                                             :signature ["[rdr]"],
                                             :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [160 164]},
                                             :full-name "cljs.repl.browser/read-request",
                                             :full-name-encode "cljs.repl.browser_read-request",
                                             :history [["+" "0.0-927"]]},
           "cljs.reader/macros" {:ns "cljs.reader",
                                 :name "macros",
                                 :type "var",
                                 :source {:code "(def macros\n     { \\\" read-string\n       \\: read-keyword\n       \\; not-implemented ;; never hit this\n       \\' (wrapping-reader 'quote)\n       \\@ (wrapping-reader 'deref)\n       \\^ read-meta\n       \\` not-implemented\n       \\~ not-implemented\n       \\( read-list\n       \\) read-unmatched-delimiter\n       \\[ read-vector\n       \\] read-unmatched-delimiter\n       \\{ read-map\n       \\} read-unmatched-delimiter\n       \\\\ read-char\n       \\% not-implemented\n       \\# read-dispatch\n       })",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/reader.cljs",
                                          :lines [310 328]},
                                 :full-name "cljs.reader/macros",
                                 :full-name-encode "cljs.reader_macros",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/doseq" {:description "Repeatedly executes `body` (presumably for side-effects) with bindings and\nfiltering as provided by `for`. Does not retain the head of the sequence.\n\nReturns nil.",
                              :ns "cljs.core",
                              :name "doseq",
                              :signature ["[seq-exprs & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/doall"
                                        "cljs.core/dorun"
                                        "cljs.core/for"
                                        "cljs.core/dotimes"],
                              :full-name-encode "cljs.core_doseq",
                              :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n                       \n                       seqsym (when-not (keyword? k) (gensym))\n                       recform (if (keyword? k) recform `(recur (first ~seqsym) ~seqsym))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     :else [true `(let [~seqsym (seq ~v)]\n                                    (when ~seqsym\n                                      (loop [~k (first ~seqsym) ~seqsym ~seqsym]\n                                       ~subform\n                                       (when-let [~seqsym (next ~seqsym)]\n                                        ~@(when needrec [recform])))))]))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [749 784]},
                              :full-name "cljs.core/doseq",
                              :clj-symbol "clojure.core/doseq",
                              :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
           "cljs.core/*" {:description "Returns the product of nums.\n\n`(*)` returns 1.",
                          :ns "cljs.core",
                          :name "*",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/+" "cljs.core//"],
                          :full-name-encode "cljs.core_STAR",
                          :source {:code "(defn *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1027 1032]},
                          :extra-sources ({:code "(defmacro *\n  ([] 1)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [126 130]}),
                          :examples [{:id "bc4a1f",
                                      :content "```clj\n;; there is an implicit 1\n(*)\n;;=> 1\n\n;; the implicit 1 comes into play\n(* 6)\n;;=> 6\n\n(* 2 3)\n;;=> 6\n\n(* 2 3 4)\n;;=> 24\n```"}],
                          :full-name "cljs.core/*",
                          :clj-symbol "clojure.core/*",
                          :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/into" {:description "Returns a new collection consisting of `to` with all of the items of `from`\n\"added\" using `conj`.\n\nA transducer may be supplied as `xform`.",
                             :ns "cljs.core",
                             :name "into",
                             :signature ["[to from]"
                                         "[to xform from]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/conj"],
                             :full-name-encode "cljs.core_into",
                             :source {:code "(defn into\n  [to from]\n  (if (satisfies? IEditableCollection to)\n    (persistent! (reduce -conj! (transient to) from))\n    (reduce -conj to from)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2235 2241]},
                             :full-name "cljs.core/into",
                             :clj-symbol "clojure.core/into",
                             :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined."},
           "cljs.core/defmethod" {:ns "cljs.core",
                                  :name "defmethod",
                                  :signature ["[multifn dispatch-val & fn-tail]"],
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core_defmethod",
                                  :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core.MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [903 906]},
                                  :full-name "cljs.core/defmethod",
                                  :clj-symbol "clojure.core/defmethod",
                                  :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
           "cljs.core/rest" {:description "Returns a possibly empty sequence of the items after the first item.\n\nCalls `seq` on its argument.",
                             :ns "cljs.core",
                             :name "rest",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/next"
                                       "cljs.core/first"
                                       "cljs.core/drop"
                                       "cljs.core/pop"],
                             :full-name-encode "cljs.core_rest",
                             :source {:code "(defn rest\n  [coll]\n  (if (coercive-not= coll nil)\n    (if (satisfies? ISeq coll)\n      (-rest coll)\n      (let [s (seq coll)]\n        (if (coercive-not= s nil)\n          (-rest s)\n          ())))\n    ()))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [519 530]},
                             :examples [{:id "0869af",
                                         :content "```clj\n(rest [1 2 3])\n;;=> (2 3)\n\n(rest [1 2])\n;;=> (2)\n\n(rest [1])\n;;=> ()\n\n(rest [])\n;;=> ()\n```"}],
                             :full-name "cljs.core/rest",
                             :clj-symbol "clojure.core/rest",
                             :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
           "cljs.core/dotimes" {:description "Repeatedly executes `body` (presumably for side-effects) with `name` bound to\nintegers from 0 through `n`-1.",
                                :ns "cljs.core",
                                :name "dotimes",
                                :signature ["[[name n] & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/repeat"
                                          "cljs.core/for"
                                          "cljs.core/doseq"],
                                :full-name-encode "cljs.core_dotimes",
                                :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [833 845]},
                                :full-name "cljs.core/dotimes",
                                :clj-symbol "clojure.core/dotimes",
                                :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
           "clojure.zip/lefts" {:ns "clojure.zip",
                                :name "lefts",
                                :signature ["[loc]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip_lefts",
                                :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [87 90]},
                                :full-name "clojure.zip/lefts",
                                :clj-symbol "clojure.zip/lefts",
                                :docstring "Returns a seq of the left siblings of this loc"},
           "clojure.browser.dom/ensure-element" {:ns "clojure.browser.dom",
                                                 :name "ensure-element",
                                                 :signature ["[e]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom_ensure-element",
                                                 :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                          :repo "clojurescript",
                                                          :tag "r1211",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [107
                                                                  112]},
                                                 :full-name "clojure.browser.dom/ensure-element",
                                                 :docstring "Coerce the argument to a dom element if possible."},
           "cljs.core/defmacro" {:ns "cljs.core",
                                 :name "defmacro",
                                 :signature ["[name doc-string? attr-map? [params*] body]"
                                             "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core_defmacro",
                                 :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                          :repo "clojure",
                                          :tag "clojure-1.4.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [406 450]},
                                 :full-name "cljs.core/defmacro",
                                 :clj-symbol "clojure.core/defmacro",
                                 :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
           "cljs.core/remove" {:description "Returns a lazy sequence of the items in `coll` for which `(pred item)` returns\nfalse.\n\n`pred` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                               :ns "cljs.core",
                               :name "remove",
                               :signature ["[pred]" "[pred coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/filter"],
                               :full-name-encode "cljs.core_remove",
                               :source {:code "(defn remove\n  [pred coll]\n  (filter (complement pred) coll))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2206 2210]},
                               :full-name "cljs.core/remove",
                               :clj-symbol "clojure.core/remove",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects."},
           "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :type "var",
                                                             :parent-type "PersistentArrayMap",
                                                             :source {:code "(set! cljs.core.PersistentArrayMap/HASHMAP_THRESHOLD 16)",
                                                                      :repo "clojurescript",
                                                                      :tag "r1211",
                                                                      :filename "src/cljs/cljs/core.cljs",
                                                                      :lines [3436]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :full-name-encode "cljs.core_PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-1211"]]},
           "cljs.core/if-not" {:description "If `test` is false or nil, evaluates and returns `then`. Otherwise, evaluates\nand returns `else`. `else` defaults to nil if not provided.",
                               :ns "cljs.core",
                               :name "if-not",
                               :signature ["[test then]"
                                           "[test then else]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :related ["special/if"
                                         "cljs.core/when-not"],
                               :full-name-encode "cljs.core_if-not",
                               :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                        :repo "clojure",
                                        :tag "clojure-1.4.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [703 709]},
                               :full-name "cljs.core/if-not",
                               :clj-symbol "clojure.core/if-not",
                               :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
           "clojure.zip/path" {:ns "clojure.zip",
                               :name "path",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_path",
                               :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [82 85]},
                               :full-name "clojure.zip/path",
                               :clj-symbol "clojure.zip/path",
                               :docstring "Returns a seq of nodes leading to this loc"},
           "cljs.core/mapcat" {:description "Returns the result of applying `concat` to the result of applying `map` to `f`\nand `colls`.\n\nFunction `f` should return a collection.\n\nReturns a transducer when no collections are provided.",
                               :ns "cljs.core",
                               :name "mapcat",
                               :signature ["[f]" "[f & colls]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/map"
                                         "cljs.core/concat"],
                               :full-name-encode "cljs.core_mapcat",
                               :source {:code "(defn mapcat\n  ([f coll]\n    (flatten1 (map f coll)))\n  ([f coll & colls]\n    (flatten1 (apply map f coll colls))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2187 2193]},
                               :full-name "cljs.core/mapcat",
                               :clj-symbol "clojure.core/mapcat",
                               :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection."},
           "cljs.core/IWatchable" {:ns "cljs.core",
                                   :name "IWatchable",
                                   :type "protocol",
                                   :full-name-encode "cljs.core_IWatchable",
                                   :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [238 241]},
                                   :methods [{:name "-notify-watches",
                                              :signature ["[this oldval newval]"],
                                              :docstring nil}
                                             {:name "-add-watch",
                                              :signature ["[this key f]"],
                                              :docstring nil}
                                             {:name "-remove-watch",
                                              :signature ["[this key]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IWatchable",
                                   :history [["+" "0.0-927"]]},
           "clojure.zip/rightmost" {:ns "clojure.zip",
                                    :name "rightmost",
                                    :signature ["[loc]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip_rightmost",
                                    :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [142 148]},
                                    :full-name "clojure.zip/rightmost",
                                    :clj-symbol "clojure.zip/rightmost",
                                    :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
           "cljs.core/PersistentArrayMap.EMPTY" {:ns "cljs.core",
                                                 :name "PersistentArrayMap.EMPTY",
                                                 :history [["+"
                                                            "0.0-1211"]],
                                                 :parent-type "PersistentArrayMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core_PersistentArrayMapDOTEMPTY",
                                                 :source {:code "(set! cljs.core.PersistentArrayMap/EMPTY (PersistentArrayMap. nil 0 (array) nil))",
                                                          :repo "clojurescript",
                                                          :tag "r1211",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [3434]},
                                                 :full-name "cljs.core/PersistentArrayMap.EMPTY",
                                                 :clj-symbol "clojure.lang/PersistentArrayMap.EMPTY"},
           "cljs.repl/load-file" {:ns "cljs.repl",
                                  :name "load-file",
                                  :type "function",
                                  :signature ["[repl-env f]"],
                                  :source {:code "(defn load-file\n  [repl-env f]\n  (binding [comp/*cljs-ns* 'cljs.user]\n    (let [res (if (= \\/ (first f)) f (io/resource f))]\n      (assert res (str \"Can't find \" f \" in classpath\"))\n      (load-stream repl-env f res))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [102 107]},
                                  :full-name "cljs.repl/load-file",
                                  :full-name-encode "cljs.repl_load-file",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/->" {:description "The thread-first macro \"threads\" an expression through several forms as the\nsecond item in a list.\n\nInserts `x` as the second item in the first form, making a list of it if it is\nnot a list already. If there are more forms, inserts the first form as the\nsecond item in second form, etc.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(-> x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x (d (a x b c)) y z)</pre></td></tr></tbody></table>",
                           :ns "cljs.core",
                           :name "->",
                           :signature ["[x & forms]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/->>"],
                           :full-name-encode "cljs.core_-GT",
                           :source {:code "(defmacro ->\n  ([x] x)\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n              (list form x)))\n  ([x form & more] `(-> (-> ~x ~form) ~@more)))",
                                    :repo "clojure",
                                    :tag "clojure-1.4.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1529 1539]},
                           :examples [{:id "19b460",
                                       :content "The first is arguably a bit more cumbersome to read than the second:\n\n```clj\n(first (.split (.replace (.toUpperCase \"a b c d\") \"A\" \"X\") \" \"))\n;;=> \"X\"\n\n(-> \"a b c d\"\n    .toUpperCase\n    (.replace \"A\" \"X\")\n    (.split \" \")\n    first)\n;;=> \"X\"\n```"}
                                      {:id "78ad8f",
                                       :content "It can also be useful for pulling values out of deeply-nested\ndata structures:\n\n```clj\n(def person\n  {:name \"Mark Volkmann\"\n   :address {:street \"644 Glen Summit\"\n             :city \"St. Charles\"\n             :state \"Missouri\"\n             :zip 63304}\n   :employer {:name \"Object Computing, Inc.\"\n              :address {:street \"12140 Woodcrest Dr.\"\n                        :city \"Creve Coeur\"\n                        :state \"Missouri\"\n                        :zip 63141}}})\n\n(-> person :employer :address :city)\n;;=> \"Creve Coeur\"\n```\n\nSame as above, but with more nesting:\n\n```clj\n(:city (:address (:employer person)))\n;;=> \"Creve Coeur\"\n```"}
                                      {:id "5fe621",
                                       :content "It can also help with arithmetic:\n\n```clj\n(def c 5)\n(-> c (+ 3) (/ 2) (- 1))\n;;=> 3\n```\n\nSame as above, but with more nesting:\n\n```clj\n(- (/ (+ c 3) 2) 1)\n;;=> 3\n```"}],
                           :full-name "cljs.core/->",
                           :clj-symbol "clojure.core/->",
                           :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
           "cljs.core/remove-all-methods" {:ns "cljs.core",
                                           :name "remove-all-methods",
                                           :signature ["[multifn]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_remove-all-methods",
                                           :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [6362 6365]},
                                           :full-name "cljs.core/remove-all-methods",
                                           :clj-symbol "clojure.core/remove-all-methods",
                                           :docstring "Removes all of the methods of multimethod."},
           "clojure.string/replace-first" {:description "Replaces the first instance of `match` with `replacement` in `s`.\n\nThe options for match / replacement are:\n\n| match  | replacement |\n|--------|-------------|\n| string | string      |\n| regex  | string      |\n| regex  | function    |",
                                           :ns "clojure.string",
                                           :name "replace-first",
                                           :signature ["[s match replacement]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.string_replace-first",
                                           :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/clojure/string.cljs",
                                                    :lines [36 43]},
                                           :full-name "clojure.string/replace-first",
                                           :clj-symbol "clojure.string/replace-first",
                                           :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/reduced?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "reduced?",
                                 :signature ["[r]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_reducedQMARK",
                                 :source {:code "(defn ^boolean reduced?\n  [r]\n  (instance? Reduced r))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1000 1003]},
                                 :full-name "cljs.core/reduced?",
                                 :docstring "Returns true if x is the result of a call to reduced"},
           "clojure.browser.dom/get-value" {:ns "clojure.browser.dom",
                                            :name "get-value",
                                            :signature ["[e]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom_get-value",
                                            :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [131 134]},
                                            :full-name "clojure.browser.dom/get-value",
                                            :docstring "Get the value of an element."},
           "cljs.nodejs/process" {:ns "cljs.nodejs",
                                  :name "process",
                                  :type "var",
                                  :source {:code "(def process (js* \"process\"))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [8]},
                                  :full-name "cljs.nodejs/process",
                                  :full-name-encode "cljs.nodejs_process",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/not=" {:description "Returns the opposite of `=`.\n\nSame as `(not (= x y))`",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "not=",
                             :signature ["[x]" "[x y]" "[x y & more]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/=" "cljs.core/not"],
                             :full-name-encode "cljs.core_notEQ",
                             :source {:code "(defn ^boolean not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1802 1807]},
                             :full-name "cljs.core/not=",
                             :clj-symbol "clojure.core/not=",
                             :docstring "Same as (not (= obj1 obj2))"},
           "cljs.core/PersistentTreeMapSeq" {:ns "cljs.core",
                                             :name "PersistentTreeMapSeq",
                                             :type "type",
                                             :signature ["[meta stack ascending? cnt __hash]"],
                                             :source {:code "(deftype PersistentTreeMapSeq [meta stack ascending? cnt ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n\n  (-rest [this]\n    (let [t (peek stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (pop stack)\n                                        ascending?)]\n      (if (coercive-not= next-stack nil)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil))))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta]\n    (PersistentTreeMapSeq. meta stack ascending? cnt __hash)))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [4351
                                                              4391]},
                                             :full-name "cljs.core/PersistentTreeMapSeq",
                                             :full-name-encode "cljs.core_PersistentTreeMapSeq",
                                             :history [["+"
                                                        "0.0-1211"]]},
           "cljs.core/js-keys" {:description "Returns the keys for the JavaScript object `obj`.",
                                :ns "cljs.core",
                                :name "js-keys",
                                :signature ["[obj]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/keys"],
                                :full-name-encode "cljs.core_js-keys",
                                :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [779 782]},
                                :examples [{:id "5dd933",
                                            :content "```clj\n(js-keys #js {:foo 1 :bar 2})\n;;=> #js [\"foo\" \"bar\"]\n```"}],
                                :full-name "cljs.core/js-keys"},
           "cljs.repl.browser/browser-eval" {:ns "cljs.repl.browser",
                                             :name "browser-eval",
                                             :signature ["[form]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser_browser-eval",
                                             :source {:code "(defn browser-eval\n  [form]\n  (let [return-value (promise)]\n    (send-for-eval form\n                   (fn [val] (deliver return-value val)))\n    (let [ret @return-value]\n      (try (read-string ret)\n           (catch Exception e\n             {:status :error\n              :value (str \"Could not read return value: \" ret)})))))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [275 290]},
                                             :full-name "cljs.repl.browser/browser-eval",
                                             :docstring "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured."},
           "clojure.zip/seq-zip" {:ns "clojure.zip",
                                  :name "seq-zip",
                                  :signature ["[root]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_seq-zip",
                                  :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [34 40]},
                                  :full-name "clojure.zip/seq-zip",
                                  :clj-symbol "clojure.zip/seq-zip",
                                  :docstring "Returns a zipper for nested sequences, given a root sequence"},
           "cljs.repl.browser/server-state" {:ns "cljs.repl.browser",
                                             :name "server-state",
                                             :type "var",
                                             :source {:code "(defonce server-state (atom {:socket nil\n                             :connection nil\n                             :promised-conn nil\n                             :return-value-fn nil\n                             :client-js nil}))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [24 28]},
                                             :full-name "cljs.repl.browser/server-state",
                                             :full-name-encode "cljs.repl.browser_server-state",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/IVector" {:ns "cljs.core",
                                :name "IVector",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IVector",
                                :source {:code "(defprotocol IVector\n  (-assoc-n [coll n val]))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [184 185]},
                                :methods [{:name "-assoc-n",
                                           :signature ["[coll n val]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IVector",
                                :clj-symbol "clojure.lang/IPersistentVector"},
           "cljs.core/persistent!" {:ns "cljs.core",
                                    :name "persistent!",
                                    :signature ["[tcoll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_persistentBANG",
                                    :source {:code "(defn persistent! [tcoll]\n  (-persistent! tcoll))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1724 1725]},
                                    :full-name "cljs.core/persistent!",
                                    :clj-symbol "clojure.core/persistent!"},
           "cljs.core/empty" {:description "Returns an empty collection of the same category as `coll`.\n\nReturns nil if `coll` is nil.",
                              :ns "cljs.core",
                              :name "empty",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/not-empty"],
                              :full-name-encode "cljs.core_empty",
                              :source {:code "(defn empty\n  [coll]\n  (-empty coll))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [596 599]},
                              :full-name "cljs.core/empty",
                              :clj-symbol "clojure.core/empty",
                              :docstring "Returns an empty collection of the same category as coll, or nil"},
           "cljs.core/re-matches" {:description "Returns the result of `(re-find re s)` if `re` fully matches `s`.",
                                   :ns "cljs.core",
                                   :name "re-matches",
                                   :signature ["[re s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_re-matches",
                                   :source {:code "(defn re-matches\n  [re s]\n  (let [matches (.exec re s)]\n    (when (= (first matches) s)\n      (if (== (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [5581 5588]},
                                   :full-name "cljs.core/re-matches",
                                   :clj-symbol "clojure.core/re-matches",
                                   :docstring "Returns the result of (re-find re s) if re fully matches s."},
           "syntax/meta" {:description "Attaches metadata to the following form.\n\nMetadata is a map.  It can be attached to a collection or symbol.\n\nIf the provided metadata is a keyword, the resulting metadata will be a map\ncontaining that keyword with an associated value `true`.\n\nIf the provided metadata is a string or symbol, the resulting metadata will be\na map associating `:tag` with the value of the string or evaluated symbol.",
                          :ns "syntax",
                          :name "meta",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :related ["cljs.core/meta"
                                    "cljs.core/with-meta"
                                    "cljs.core/vary-meta"
                                    "cljs.core/alter-meta!"],
                          :full-name-encode "syntax_meta",
                          :source {:repo "clojure",
                                   :tag "clojure-1.4.0",
                                   :filename "src/jvm/clojure/lang/LispReader.java",
                                   :lines [nil]},
                          :syntax-form "^",
                          :examples [{:id "5b8fec",
                                      :content "Attach metadata to a collection:\n\n```clj\n^:foo [1 2 3]\n;;=> [1 2 3]\n```\n\nView the resulting metadata:\n\n```clj\n(meta ^:foo [1 2 3])\n;;=> {:foo true}\n\n(meta ^{:foo \"bar\"} [1 2 3])\n;;=> {:foo \"bar\"}\n\n(meta ^\"foo\" [1 2 3])\n;;=> {:tag \"foo\"}\n\n(def foo 1)\n(meta ^foo [1 2 3])\n;;=> {:tag 1}\n```\n\nChain metadata:\n\n```clj\n(meta ^:foo ^\"foo\" [1 2 3])\n;;=> {:foo true, :tag \"foo\"}\n```"}],
                          :full-name "syntax/meta",
                          :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                             :name "DOMBuilder",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.dom_DOMBuilder",
                                             :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/cljs/clojure/browser/dom.cljs",
                                                      :lines [17 18]},
                                             :methods [{:name "-element",
                                                        :signature ["[this]"
                                                                    "[this attrs-or-children]"
                                                                    "[this attrs children]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.dom/DOMBuilder",
                                             :history [["+" "0.0-927"]]},
           "syntax/regex" {:description "Signifies a regular expression. Represented as JavaScript regular expressions.\n\nAn inline modifier can be included at the beginning of the regex:\n\n|  modifier          | ClojureScript | JavaScript |\n|--------------------|---------------|------------|\n|  global match      | N/A           | `/foo/g`   |\n|  case-insensitive  | `#\"(?i)foo\"`  | `/foo/i`   |\n|  multi-line        | `#\"(?m)f.*o\"` | `/f.*o/m`  |\n\nGlobal matches (i.e. multiple matches per line) can be achieved using `re-seq`.",
                           :ns "syntax",
                           :name "regex",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["cljs.core/re-pattern"
                                     "cljs.core/re-find"
                                     "cljs.core/re-seq"
                                     "cljs.core/re-matches"],
                           :full-name-encode "syntax_regex",
                           :source {:repo "clojure",
                                    :tag "clojure-1.4.0",
                                    :filename "src/jvm/clojure/lang/LispReader.java",
                                    :lines [nil]},
                           :syntax-form "#\"\"",
                           :examples [{:id "dacf80",
                                       :content "```clj\n#\"foo\"\n;;=> #\"foo\"\n\n(re-seq #\"foo\" \"FOO BAR foo bar\")\n;;=> (\"foo\")\n```\n\nCase-insensitive matching:\n\n```clj\n#\"(?i)foo\"\n;;=> #\"foo\"\n\n(re-seq #\"(?i)foo\" \"FOO BAR foo bar\")\n;;=> (\"FOO\" \"foo\")\n```"}],
                           :full-name "syntax/regex",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/extend-type" {:ns "cljs.core",
                                    :name "extend-type",
                                    :signature ["[tsym & impls]"],
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_extend-type",
                                    :source {:code "(defmacro extend-type [tsym & impls]\n  (let [resolve #(let [ret (:name (cljs.compiler/resolve-var (dissoc &env :locals) %))]\n                   (assert ret (core/str \"Can't resolve: \" %))\n                   ret)\n        impl-map (loop [ret {} s impls]\n                   (if (seq s)\n                     (recur (assoc ret (first s) (take-while seq? (next s)))\n                            (drop-while seq? (next s)))\n                     ret))]\n    (if (base-type tsym)\n      (let [t (base-type tsym)\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n                                 pfn-prefix (subs (core/str psym) 0 (clojure.core/inc (.lastIndexOf (core/str psym) \".\")))]\n                             (cons `(aset ~psym ~t true)\n                                   (map (fn [[f & meths]]\n                                          `(aset ~(symbol (core/str pfn-prefix f)) ~t (fn ~@meths)))\n                                        sigs))))]\n        `(do ~@(mapcat assign-impls impl-map)))\n      (let [t (resolve tsym)\n            prototype-prefix (core/str t \".prototype.\")\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n                                 pprefix (protocol-prefix psym)]\n                             (if (= p 'Object)\n                               (let [adapt-params (fn [[sig & body]]\n                                                    (let [[tname & args] sig]\n                                                      (list (with-meta (vec args) (meta sig))\n                                                            (list* 'this-as tname body))))]\n                                 (map (fn [[f & meths]]\n                                        `(set! ~(symbol (core/str prototype-prefix f)) (fn ~@(map adapt-params meths))))\n                                      sigs))\n                               (cons `(set! ~(symbol (core/str prototype-prefix pprefix)) true)\n                                     (mapcat (fn [[f & meths]]\n                                               (if (= psym 'cljs.core.IFn)\n                                                 (let [adapt-params (fn [[[targ & args :as sig] & body]]\n                                                                      (let [tsym (gensym \"tsym\")]\n                                                                        `(~(with-meta (vec (cons tsym args)) (meta sig))\n                                                                          (this-as ~tsym\n                                                                                   (let [~targ ~tsym]\n                                                                                     ~@body)))))\n                                                       meths (map adapt-params meths)\n                                                       tsym (gensym \"tsym\")\n                                                       argsym (gensym \"args\")]\n                                                    [`(set! ~(symbol (core/str prototype-prefix 'call)) (fn ~@meths))\n                                                     `(set! ~(symbol (core/str prototype-prefix 'apply))\n                                                            (fn ~(with-meta [tsym argsym] (meta (first meths)))\n                                                              (.apply (.-call ~tsym) ~tsym\n                                                                      (.concat (array ~tsym) (aclone ~argsym)))))])\n                                                 (let [pf (core/str prototype-prefix pprefix f)]\n                                                   (if (vector? (first meths))\n                                                     [`(set! ~(symbol (core/str pf \"$arity$\" (count (first meths)))) (fn ~@meths))]\n                                                     (map (fn [[sig & body :as meth]]\n                                                            `(set! ~(symbol (core/str pf \"$arity$\" (count sig)))\n                                                                   (fn ~meth)))\n                                                          meths)))))\n                                             sigs)))))]\n        `(do ~@(mapcat assign-impls impl-map))))))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [288 345]},
                                    :full-name "cljs.core/extend-type",
                                    :clj-symbol "clojure.core/extend-type"},
           "cljs.core/ISeqable" {:ns "cljs.core",
                                 :name "ISeqable",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_ISeqable",
                                 :source {:code "(defprotocol ISeqable\n  (-seq [o]))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [211 212]},
                                 :methods [{:name "-seq",
                                            :signature ["[o]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/ISeqable",
                                 :clj-symbol "clojure.lang/Seqable"},
           "cljs.core/assoc" {:description "assoc(iate)\n\nWhen applied to a map, returns a new map that contains the mapping of key(s) to\nval(s).\n\nHas no effect on the map type (hashed/sorted).\n\nWhen applied to a vector, returns a new vector that contains value `v` at index\n`k`.",
                              :ns "cljs.core",
                              :name "assoc",
                              :signature ["[coll k v]"
                                          "[coll k v & kvs]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/assoc-in"
                                        "cljs.core/dissoc"
                                        "cljs.core/merge"],
                              :full-name-encode "cljs.core_assoc",
                              :source {:code "(defn assoc\n  ([coll k v]\n     (-assoc coll k v))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [657 668]},
                              :examples [{:id "2fa7e0",
                                          :content "```clj\n(def my-map {:foo 1})\n\n(assoc my-map :foo 2)\n;;=> {:foo 2}\n\n(assoc my-map :bar 2)\n;;=> {:foo 1 :bar 2}\n\n(assoc my-map :a 3 :b 4 :c 5 :d 6)\n;;=> {:foo 1 :a 3 :b 4 :c 5 :d 6}\n\n;; you must pass a value for every key\n(assoc my-map :foo)\n;;=> WARNING: Wrong number of args (2) passed to cljs.core/assoc\n```"}
                                         {:id "c06eac",
                                          :content "```clj\n(def my-vec [1 2 3])\n\n(assoc my-vec 0 \"foo\")\n;;=> [\"foo\" 2 3]\n\n(assoc my-vec 3 \"foo\")\n;;=> Error: Index 3 out of bounds  [0,0]\n```"}],
                              :full-name "cljs.core/assoc",
                              :clj-symbol "clojure.core/assoc",
                              :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
           "clojure.browser.repl/xpc-connection" {:ns "clojure.browser.repl",
                                                  :name "xpc-connection",
                                                  :type "var",
                                                  :source {:code "(def xpc-connection (atom nil))",
                                                           :repo "clojurescript",
                                                           :tag "r1211",
                                                           :filename "src/cljs/clojure/browser/repl.cljs",
                                                           :lines [21]},
                                                  :full-name "clojure.browser.repl/xpc-connection",
                                                  :full-name-encode "clojure.browser.repl_xpc-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                          :name "IDerefWithTimeout",
                                          :type "protocol",
                                          :full-name-encode "cljs.core_IDerefWithTimeout",
                                          :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [190 191]},
                                          :methods [{:name "-deref-with-timeout",
                                                     :signature ["[o msec timeout-val]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IDerefWithTimeout",
                                          :history [["+" "0.0-927"]]},
           "syntax/eval" {:ns "syntax",
                          :name "eval",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :full-name-encode "syntax_eval",
                          :source {:repo "clojure",
                                   :tag "clojure-1.4.0",
                                   :filename "src/jvm/clojure/lang/LispReader.java",
                                   :lines [nil]},
                          :syntax-form "#=",
                          :full-name "syntax/eval",
                          :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L113"},
           "clojure.browser.repl/start-evaluator" {:ns "clojure.browser.repl",
                                                   :name "start-evaluator",
                                                   :signature ["[url]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.repl_start-evaluator",
                                                   :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText e/currentTarget\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                            :repo "clojurescript",
                                                            :tag "r1211",
                                                            :filename "src/cljs/clojure/browser/repl.cljs",
                                                            :lines [60
                                                                    88]},
                                                   :full-name "clojure.browser.repl/start-evaluator",
                                                   :docstring "Start the REPL server connection."},
           "cljs.repl.browser/send-for-eval" {:ns "cljs.repl.browser",
                                              :name "send-for-eval",
                                              :signature ["[form return-value-fn]"
                                                          "[conn form return-value-fn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser_send-for-eval",
                                              :source {:code "(defn send-for-eval\n  ([form return-value-fn]\n     (send-for-eval @(connection) form return-value-fn))\n  ([conn form return-value-fn]\n     (do (set-return-value-fn return-value-fn)\n         (send-and-close conn 200 form \"text/javascript\"))))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [99 107]},
                                              :full-name "cljs.repl.browser/send-for-eval",
                                              :docstring "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received."},
           "clojure.browser.event/unlisten" {:ns "clojure.browser.event",
                                             :name "unlisten",
                                             :type "function",
                                             :signature ["[src type fn]"
                                                         "[src type fn capture?]"],
                                             :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (goog.events/unlisten src\n                           (get (event-types src) type type)\n                           fn\n                           capture?)))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/cljs/clojure/browser/event.cljs",
                                                      :lines [62 69]},
                                             :full-name "clojure.browser.event/unlisten",
                                             :full-name-encode "clojure.browser.event_unlisten",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashMap.fromArrays" {:ns "cljs.core",
                                                     :name "PersistentHashMap.fromArrays",
                                                     :signature ["[ks vs]"],
                                                     :history [["+"
                                                                "0.0-1211"]],
                                                     :parent-type "PersistentHashMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core_PersistentHashMapDOTfromArrays",
                                                     :source {:code "(set! cljs.core.PersistentHashMap/fromArrays\n      (fn [ks vs]\n        (let [len (.-length ks)]\n          (loop [i 0 out (transient cljs.core.PersistentHashMap/EMPTY)]\n            (if (< i len)\n              (recur (inc i) (assoc! out (aget ks i) (aget vs i)))\n              (persistent! out))))))",
                                                              :repo "clojurescript",
                                                              :tag "r1211",
                                                              :filename "src/cljs/cljs/core.cljs",
                                                              :lines [4231
                                                                      4237]},
                                                     :full-name "cljs.core/PersistentHashMap.fromArrays"},
           "cljs.repl.browser/constrain-order" {:ns "cljs.repl.browser",
                                                :name "constrain-order",
                                                :signature ["[order f]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser_constrain-order",
                                                :source {:code "(defn constrain-order\n  [order f]\n  (send-off ordering add-in-order order f)\n  (send-off ordering run-in-order))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [231
                                                                 236]},
                                                :full-name "cljs.repl.browser/constrain-order",
                                                :docstring "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order."},
           "cljs.repl/default-special-fns" {:ns "cljs.repl",
                                            :name "default-special-fns",
                                            :type "var",
                                            :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (@comp/namespaces ns-name)\n                  (swap! comp/namespaces assoc ns-name {:name ns-name}))\n                (set! comp/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [138 147]},
                                            :full-name "cljs.repl/default-special-fns",
                                            :full-name-encode "cljs.repl_default-special-fns",
                                            :history [["+" "0.0-993"]]},
           "cljs.core/sorted-set" {:description "Returns a new sorted set with supplied `keys`.",
                                   :ns "cljs.core",
                                   :name "sorted-set",
                                   :signature ["[& keys]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/sorted-set-by"
                                             "cljs.core/subseq"
                                             "cljs.core/rsubseq"
                                             "cljs.core/sorted-map"],
                                   :full-name-encode "cljs.core_sorted-set",
                                   :source {:code "(defn sorted-set\n  ([& keys]\n   (reduce -conj cljs.core.PersistentTreeSet/EMPTY keys)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [5252 5255]},
                                   :full-name "cljs.core/sorted-set",
                                   :clj-symbol "clojure.core/sorted-set",
                                   :docstring "Returns a new sorted set with supplied keys."},
           "cljs.core/fnil" {:description "Takes a function `f`, and returns a function that calls `f`, replacing a nil\nfirst argument to `f` with the supplied value `x`. Higher arity versions can\nreplace arguments in the second and third positions (`y`, `z`).\n\nNote that the function `f` can take any number of arguments, not just the one(s)\nbeing nil-patched.",
                             :ns "cljs.core",
                             :name "fnil",
                             :signature ["[f x]"
                                         "[f x y]"
                                         "[f x y z]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_fnil",
                             :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1909 1930]},
                             :full-name "cljs.core/fnil",
                             :clj-symbol "clojure.core/fnil",
                             :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
           "cljs.core/this-as" {:ns "cljs.core",
                                :name "this-as",
                                :signature ["[name & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_this-as",
                                :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (~'js* \"this\")]\n     ~@body))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [282 286]},
                                :full-name "cljs.core/this-as",
                                :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."},
           "cljs.repl.rhino/rhino-eval" {:ns "cljs.repl.rhino",
                                         :name "rhino-eval",
                                         :type "function",
                                         :signature ["[repl-env filename line js]"],
                                         :source {:code "(defn rhino-eval\n  [repl-env filename line js]\n  (try\n    (let [linenum (or line Integer/MIN_VALUE)]\n      {:status :success\n       :value (eval-result (-eval js repl-env filename linenum))})\n    (catch Throwable ex\n      {:status :exception\n       :value (.toString ex)\n       :stacktrace (stacktrace ex)})))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [57 66]},
                                         :full-name "cljs.repl.rhino/rhino-eval",
                                         :full-name-encode "cljs.repl.rhino_rhino-eval",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueueSeq" {:ns "cljs.core",
                                           :name "PersistentQueueSeq",
                                           :type "type",
                                           :signature ["[meta front rear __hash]"],
                                           :source {:code "(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n  \n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (-first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2949 2983]},
                                           :full-name "cljs.core/PersistentQueueSeq",
                                           :full-name-encode "cljs.core_PersistentQueueSeq",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/counted?" {:description "Returns true if `x` executes `count` in constant time, false otherwise.\n\nLists, maps, sets, strings, and vectors can be counted in constant time.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "counted?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_countedQMARK",
                                 :source {:code "(defn ^boolean counted?\n  [x] (satisfies? ICounted x))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [749 751]},
                                 :full-name "cljs.core/counted?",
                                 :clj-symbol "clojure.core/counted?",
                                 :docstring "Returns true if coll implements count in constant time"},
           "cljs.repl.browser/read-headers" {:ns "cljs.repl.browser",
                                             :name "read-headers",
                                             :type "function",
                                             :signature ["[rdr]"],
                                             :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [135 140]},
                                             :full-name "cljs.repl.browser/read-headers",
                                             :full-name-encode "cljs.repl.browser_read-headers",
                                             :history [["+" "0.0-927"]]},
           "clojure.string/trimr" {:description "Removes whitespace from the right side of string.",
                                   :ns "clojure.string",
                                   :name "trimr",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string_trimr",
                                   :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [116 119]},
                                   :full-name "clojure.string/trimr",
                                   :clj-symbol "clojure.string/trimr",
                                   :docstring "Removes whitespace from the right side of string."},
           "cljs.core/force" {:ns "cljs.core",
                              :name "force",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_force",
                              :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6040 6045]},
                              :full-name "cljs.core/force",
                              :clj-symbol "clojure.core/force",
                              :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
           "cljs.core/compare-and-set!" {:description "Atomically sets the value of atom `a` to `newval` if and only if the current\nvalue of the atom is identical to `oldval`.\n\nReturns true if set happened, false otherwise.",
                                         :ns "cljs.core",
                                         :name "compare-and-set!",
                                         :signature ["[a oldval newval]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :related ["cljs.core/atom"
                                                   "cljs.core/reset!"
                                                   "cljs.core/swap!"],
                                         :full-name-encode "cljs.core_compare-and-setBANG",
                                         :source {:code "(defn compare-and-set!\n  [a oldval newval]\n  (if (= a.state oldval)\n    (do (reset! a newval) true)\n    false))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [5927 5934]},
                                         :full-name "cljs.core/compare-and-set!",
                                         :clj-symbol "clojure.core/compare-and-set!",
                                         :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is identical to oldval. Returns true if\nset happened, else false."},
           "cljs.core/set?" {:description "Returns true if `x` is a set, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "set?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/set"],
                             :full-name-encode "cljs.core_setQMARK",
                             :source {:code "(defn ^boolean set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [734 739]},
                             :full-name "cljs.core/set?",
                             :clj-symbol "clojure.core/set?",
                             :docstring "Returns true if x satisfies ISet"},
           "syntax/unquote-splicing" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nIntended for use inside a syntax-quote.\n\nForces evaluation of the following form and expands its children into the\nparent form.",
                                      :ns "syntax",
                                      :name "unquote-splicing",
                                      :history [["+" "0.0-927"]],
                                      :type "syntax",
                                      :related ["syntax/syntax-quote"
                                                "syntax/unquote"],
                                      :full-name-encode "syntax_unquote-splicing",
                                      :source {:repo "clojure",
                                               :tag "clojure-1.4.0",
                                               :filename "src/jvm/clojure/lang/LispReader.java",
                                               :lines [nil]},
                                      :syntax-form "~@",
                                      :examples [{:id "e6f73d",
                                                  :content "```clj\n(def foo '[a b c])\n`(~@foo)\n;;=> (a b c)\n```"}],
                                      :full-name "syntax/unquote-splicing",
                                      :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.string/escape" {:description "Return a new string, using `cmap` to escape each character `ch` from `s` as follows:\n\nIf `(cmap ch)` is nil, append ch to the new string.\n\nIf `(cmap ch)` is non-nil, append `(str (cmap ch))` instead.",
                                    :ns "clojure.string",
                                    :name "escape",
                                    :signature ["[s cmap]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string_escape",
                                    :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (gstring/StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [144 160]},
                                    :full-name "clojure.string/escape",
                                    :clj-symbol "clojure.string/escape",
                                    :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
           "cljs.core/remove-watch" {:description "Removes a watch function identified by `key` from atom `a`.  The function must\nhave originally been set by `add-watch`.",
                                     :ns "cljs.core",
                                     :name "remove-watch",
                                     :signature ["[a key]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/add-watch"],
                                     :full-name-encode "cljs.core_remove-watch",
                                     :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [5996 6001]},
                                     :examples [{:id "70044a",
                                                 :content "```clj\n(def a (atom {}))\n\n(add-watch a :logger\n  (fn [_key _atom old-state new-state]\n    (println \"old:\" old-state)\n    (println \"new:\" new-state)))\n\n(swap! a assoc :foo \"bar\")\n;;=> will print the following:\n;; old: {}\n;; new: {:foo \"bar\"}\n\n(remove-watch a :logger)\n\n(swap! a assoc :foo 3)\n;;=> nothing will be printed...\n```"}],
                                     :full-name "cljs.core/remove-watch",
                                     :clj-symbol "clojure.core/remove-watch",
                                     :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
           "cljs.core/IMultiFn" {:ns "cljs.core",
                                 :name "IMultiFn",
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IMultiFn",
                                 :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-dispatch [mf args]))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [6289 6297]},
                                 :methods [{:name "-reset",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-add-method",
                                            :signature ["[mf dispatch-val method]"],
                                            :docstring nil}
                                           {:name "-remove-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-prefer-method",
                                            :signature ["[mf dispatch-val dispatch-val-y]"],
                                            :docstring nil}
                                           {:name "-get-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-methods",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-prefers",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-dispatch",
                                            :signature ["[mf args]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IMultiFn",
                                 :history [["+" "0.0-927"]]},
           "clojure.zip/end?" {:ns "clojure.zip",
                               :name "end?",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_endQMARK",
                               :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [232 235]},
                               :full-name "clojure.zip/end?",
                               :clj-symbol "clojure.zip/end?",
                               :docstring "Returns true if loc represents the end of a depth-first walk"},
           "clojure.set/superset?" {:description "Returns true if `a` is a superset of `b`, false otherwise.\n\nIn other words, returns true if `a` contains all the elements of `b`.",
                                    :ns "clojure.set",
                                    :name "superset?",
                                    :signature ["[a b]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/set"
                                              "cljs.core/set?"
                                              "clojure.set/subset?"],
                                    :full-name-encode "clojure.set_supersetQMARK",
                                    :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/clojure/set.cljs",
                                             :lines [138 142]},
                                    :full-name "clojure.set/superset?",
                                    :clj-symbol "clojure.set/superset?",
                                    :docstring "Is set1 a superset of set2?"},
           "cljs.repl/repl" {:ns "cljs.repl",
                             :name "repl",
                             :signature ["[repl-env & {:keys [verbose warn-on-undeclared special-fns]}]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.repl_repl",
                             :source {:code "(defn repl\n  [repl-env & {:keys [verbose warn-on-undeclared special-fns]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}\n          special-fns (merge default-special-fns special-fns)\n          is-special-fn? (set (keys special-fns))]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (is-special-fn? (first form)))\n           (do (apply (get special-fns (first form)) repl-env (rest form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/clj/cljs/repl.clj",
                                      :lines [149 174]},
                             :full-name "cljs.repl/repl",
                             :docstring "Note - repl will reload core.cljs every time, even if supplied old repl-env"},
           "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                              :name "IConnection",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.net_IConnection",
                                              :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [32 44]},
                                              :methods [{:name "connect",
                                                         :signature ["[this]"
                                                                     "[this opt1]"
                                                                     "[this opt1 opt2]"
                                                                     "[this opt1 opt2 opt3]"],
                                                         :docstring nil}
                                                        {:name "transmit",
                                                         :signature ["[this opt]"
                                                                     "[this opt opt2]"
                                                                     "[this opt opt2 opt3]"
                                                                     "[this opt opt2 opt3 opt4]"
                                                                     "[this opt opt2 opt3 opt4 opt5]"],
                                                         :docstring nil}
                                                        {:name "close",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.net/IConnection",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/let" {:description "Binds expressions to symbols and makes those symbols available only within\n`body`.\n\n`bindings` should be a vector with an even number of forms, ie: `[a1 b1, a2 b2,\na3 b3]`. The first item in a pair (the `a`s) should be a symbol that is assigned\nthe evaluation of the second item (the `b`s). These symbols (the `a`s) are then\navailable within `body` (and not outside of `body`).\n\nAnother way to think about this is that the binding symbols in `let` are like\nlocal `def`s that are only available within `let`'s scope.\n\nIn addition to direct symbol binding, `let` supports a destructuring syntax to\n\"break apart\" collections into multiple symbols. This destructuring syntax is\nlike it's own [mini-language] and allows for succinct code.\n\n`let` is a wrapper over one of ClojureScript's [special forms] and is a\nfundamental building block of the language. Many macros rely on `let`s binding\nsyntax and scope rules.\n\n[mini-language]:http://blog.jayfields.com/2010/07/clojure-destructuring.html\n[special forms]:http://clojure.org/special_forms",
                            :ns "cljs.core",
                            :name "let",
                            :signature ["[bindings & body]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/letfn"
                                      "cljs.core/if-let"],
                            :full-name-encode "cljs.core_let",
                            :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                     :repo "clojure",
                                     :tag "clojure-1.4.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [3957 3968]},
                            :extra-sources ({:code "(def\n  ^{:macro true\n    :added \"1.0\"}\n  let (fn* let [&form &env & decl] (cons 'let* decl)))",
                                             :repo "clojure",
                                             :tag "clojure-1.4.0",
                                             :filename "src/clj/clojure/core.clj",
                                             :lines [32 35]}),
                            :full-name "cljs.core/let",
                            :clj-symbol "clojure.core/let",
                            :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
           "cljs.core/dorun" {:description "Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.\n\n`dorun` walks through the successive `next`s of the sequence and returns nil.",
                              :ns "cljs.core",
                              :name "dorun",
                              :signature ["[coll]" "[n coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/doall"],
                              :full-name-encode "cljs.core_dorun",
                              :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5552 5563]},
                              :full-name "cljs.core/dorun",
                              :clj-symbol "clojure.core/dorun",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
           "cljs.core/pr-str" {:ns "cljs.core",
                               :name "pr-str",
                               :signature ["[& objs]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_pr-str",
                               :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [5701 5704]},
                               :full-name "cljs.core/pr-str",
                               :clj-symbol "clojure.core/pr-str",
                               :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintable."},
           "cljs.core/IPrintable" {:ns "cljs.core",
                                   :name "IPrintable",
                                   :type "protocol",
                                   :full-name-encode "cljs.core_IPrintable",
                                   :source {:code "(defprotocol IPrintable\n  (-pr-seq [o opts]))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [232 233]},
                                   :methods [{:name "-pr-seq",
                                              :signature ["[o opts]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IPrintable",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/defprotocol" {:ns "cljs.core",
                                    :name "defprotocol",
                                    :signature ["[psym & doc+methods]"],
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_defprotocol",
                                    :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (core/str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (core/string? (first doc+methods)) (next doc+methods) doc+methods)\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (core/str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         ((or\n                           (aget ~(fqn fname) (goog.typeOf ~(first sig)))\n                           (aget ~(fqn fname) \"_\")\n                           (throw (missing-protocol\n                                    ~(core/str psym \".\" fname) ~(first sig))))\n                          ~@sig))))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (core/str prefix (name fname)))]\n                   `(defn ~fname ~@(map (fn [sig]\n                                          (expand-sig fname\n                                                      (symbol (core/str slot \"$arity$\" (count sig)))\n                                                      sig))\n                                        sigs))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (~'js* \"{}\"))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [513 541]},
                                    :full-name "cljs.core/defprotocol",
                                    :clj-symbol "clojure.core/defprotocol"},
           "cljs.core/assert" {:description "Evaluates expression `expr` and throws an exception if it does not evaluate to\nlogical true.  Exception will include `message` if given.\n\nReturns `nil`.",
                               :ns "cljs.core",
                               :name "assert",
                               :signature ["[expr]" "[expr message]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core_assert",
                               :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [678 690]},
                               :extra-sources ({:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" (pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x))))))))",
                                                :repo "clojure",
                                                :tag "clojure-1.4.0",
                                                :filename "src/clj/clojure/core.clj",
                                                :lines [4246 4257]}),
                               :examples [{:id "1dc16f",
                                           :content "```clj\n(assert true)\n;;=> nil\n\n(assert false)\n;;=> Uncaught Error: Assert failed: false\n\n(assert (= 1 2) \"1 is not 2\")\n;;=> Uncaught Error: Assert failed: 1 is not 2\n;;   (= 1 2)\n```"}],
                               :full-name "cljs.core/assert",
                               :clj-symbol "clojure.core/assert",
                               :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
           "cljs.core/declare" {:description "Uses `def` to establish symbols of `names` with no bindings.\n\nUseful for making forward declarations.",
                                :ns "cljs.core",
                                :name "declare",
                                :signature ["[& names]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["special/def"],
                                :full-name-encode "cljs.core_declare",
                                :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                         :repo "clojure",
                                         :tag "clojure-1.4.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [2667 2670]},
                                :examples [{:id "5a2dc2",
                                            :content "```clj\na\n;; WARNING: Use of undeclared Var\n\n(declare a)\na\n;;=> nil\n```"}],
                                :full-name "cljs.core/declare",
                                :clj-symbol "clojure.core/declare",
                                :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
           "cljs.core/PersistentTreeMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentTreeMap",
                                                :type "var",
                                                :full-name-encode "cljs.core_PersistentTreeMapDOTEMPTY",
                                                :source {:code "(set! cljs.core.PersistentTreeMap/EMPTY (PersistentTreeMap. compare nil 0 nil 0))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [4980]},
                                                :full-name "cljs.core/PersistentTreeMap.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentTreeMap.EMPTY"},
           "cljs.core/fn?" {:description "Returns true if `f` is a function, false otherwise.",
                            :return-type boolean,
                            :ns "cljs.core",
                            :name "fn?",
                            :signature ["[f]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/ifn?"],
                            :full-name-encode "cljs.core_fnQMARK",
                            :source {:code "(defn ^boolean fn? [f]\n  (goog/isFunction f))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [852 853]},
                            :full-name "cljs.core/fn?",
                            :clj-symbol "clojure.core/fn?"},
           "cljs.core/associative?" {:description "Returns true if `coll` implements the `IAssociative` protocol, false otherwise.\n\nMaps and vectors are associative.",
                                     :return-type boolean,
                                     :ns "cljs.core",
                                     :name "associative?",
                                     :signature ["[coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_associativeQMARK",
                                     :source {:code "(defn ^boolean associative?\n  [x] (satisfies? IAssociative x))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [741 743]},
                                     :examples [{:id "29a37f",
                                                 :content "```clj\n(associative? [1 2 3])\n;;=> true\n\n(associative? {:a 1 :b 2})\n;;=> true\n\n(associative? #{1 2 3})\n;;=> false\n\n(associative? '(1 2 3))\n;;=> false\n```"}],
                                     :full-name "cljs.core/associative?",
                                     :clj-symbol "clojure.core/associative?",
                                     :docstring "Returns true if coll implements Associative"},
           "cljs.repl.rhino/load-javascript" {:ns "cljs.repl.rhino",
                                              :name "load-javascript",
                                              :type "function",
                                              :signature ["[repl-env ns url]"],
                                              :source {:code "(defn load-javascript [repl-env ns url]\n  (let [missing (remove #(contains? @loaded-libs %) ns)]\n    (when (seq missing)\n      (do (try \n            (-eval (io/reader url) repl-env (.toString url) 1)\n            ;; TODO: don't show errors for goog/base.js line number 105\n            (catch Throwable ex (println (.getMessage ex))))\n          (swap! loaded-libs (partial apply conj) missing)))))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/clj/cljs/repl/rhino.clj",
                                                       :lines [86 93]},
                                              :full-name "cljs.repl.rhino/load-javascript",
                                              :full-name-encode "cljs.repl.rhino_load-javascript",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/IList" {:ns "cljs.core",
                              :name "IList",
                              :history [["+" "0.0-1211"]],
                              :type "protocol",
                              :full-name-encode "cljs.core_IList",
                              :source {:code "(defprotocol IList\n  \"Marker interface indicating a persistent list\")",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [217 218]},
                              :full-name "cljs.core/IList",
                              :clj-symbol "clojure.lang/IPersistentList",
                              :docstring "Marker interface indicating a persistent list"},
           "cljs.core/list*" {:description "Creates a new list containing the items prepended to the rest, the last of which\nwill be treated as a sequence.",
                              :ns "cljs.core",
                              :name "list*",
                              :signature ["[args]"
                                          "[a args]"
                                          "[a b args]"
                                          "[a b c args]"
                                          "[a b c d & more]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/list"],
                              :full-name-encode "cljs.core_listSTAR",
                              :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1708 1716]},
                              :full-name "cljs.core/list*",
                              :clj-symbol "clojure.core/list*",
                              :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
           "cljs.core/reduce" {:description "`f` should be a function of 2 arguments. If `val` is not supplied, returns the\nresult of applying `f` to the first 2 items in `coll`, then applying `f` to that\nresult and the 3rd item, etc.\n\nIf `coll` contains no items, `f` must accept no arguments as well, and `reduce`\nreturns the result of calling `f` with no arguments.\n\nIf `coll` has only 1 item, it is returned and `f` is not called.\n\nIf `val` is supplied, returns the result of applying `f` to `val` and the first\nitem in `coll`, then applying `f` to that result and the 2nd item, etc.\n\nIf `coll` contains no items, returns `val` and `f` is not called.",
                               :ns "cljs.core",
                               :name "reduce",
                               :signature ["[f coll]" "[f val coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/reductions"
                                         "cljs.core/apply"
                                         "cljs.core/frequencies"],
                               :full-name-encode "cljs.core_reduce",
                               :source {:code "(defn reduce\n  ([f coll]\n     (if (satisfies? IReduce coll)\n       (-reduce coll f)\n       (seq-reduce f coll)))\n  ([f val coll]\n     (if (satisfies? IReduce coll)\n       (-reduce coll f val)\n       (seq-reduce f val coll))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [967 984]},
                               :full-name "cljs.core/reduce",
                               :clj-symbol "clojure.core/reduce",
                               :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
           "clojure.browser.event/has-listener" {:ns "clojure.browser.event",
                                                 :name "has-listener",
                                                 :type "function",
                                                 :signature ["[obj opt_type opt_capture]"],
                                                 :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                          :repo "clojurescript",
                                                          :tag "r1211",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [94]},
                                                 :full-name "clojure.browser.event/has-listener",
                                                 :full-name-encode "clojure.browser.event_has-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/PersistentHashMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentHashMap",
                                                :type "var",
                                                :full-name-encode "cljs.core_PersistentHashMapDOTEMPTY",
                                                :source {:code "(set! cljs.core.PersistentHashMap/EMPTY (PersistentHashMap. nil 0 nil false nil 0))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [4229]},
                                                :full-name "cljs.core/PersistentHashMap.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentHashMap.EMPTY"},
           "cljs.core/compare" {:description "Comparator.\n\nReturns a negative number, zero, or a positive number when `x` is logically\n\"less than\", \"equal to\", or \"greater than\" `y`.\n\nUses `IComparable` if available and `google.array.defaultCompare` for objects of\nthe same type. nil is treated as a special case and is always less than any\nother object.",
                                :ns "cljs.core",
                                :name "compare",
                                :signature ["[x y]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/sort-by"
                                          "cljs.core/sorted-set-by"
                                          "cljs.core/sorted-map-by"],
                                :full-name-encode "cljs.core_compare",
                                :source {:code "(defn compare\n  [x y]\n  (cond\n    (identical? (type x) (type y)) (garray/defaultCompare x y)\n    (nil? x) -1\n    (nil? y) 1\n    :else (throw (js/Error. \"compare on non-nil objects of different types\"))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [901 911]},
                                :examples [{:id "e13fa0",
                                            :content "```clj\n(compare 10 12)\n;;=> -1\n\n(compare 12 10)\n;;=> 1\n\n(compare 10 10)\n;;=> 0\n\n(compare 10 nil)\n;;=>  1\n\n(compare 10 (list 1 2 3))\n;; Error: compare on non-nil objects of different types\n```"}],
                                :full-name "cljs.core/compare",
                                :clj-symbol "clojure.core/compare",
                                :docstring "Comparator. Returns a negative number, zero, or a positive number\nwhen x is logically 'less than', 'equal to', or 'greater than'\ny. Uses google.array.defaultCompare for objects of the same type\nand special-cases nil to be less than any other object."},
           "cljs.core/contains?" {:description "Returns true if `k` is present in `coll`, otherwise returns false.\n\nNote that for numerically indexed collections like vectors and arrays, this\ntests if the numeric key is within the range of indexes.\n\n`contains?` operates in constant or logarithmic time; it will not perform a\nlinear search for a value.",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "contains?",
                                  :signature ["[coll k]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/some"
                                            "cljs.core/get"],
                                  :full-name-encode "cljs.core_containsQMARK",
                                  :source {:code "(defn ^boolean contains?\n  [coll v]\n  (if (identical? (-lookup coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [864 873]},
                                  :full-name "cljs.core/contains?",
                                  :clj-symbol "clojure.core/contains?",
                                  :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
           "cljs.core/prefer-method" {:ns "cljs.core",
                                      :name "prefer-method",
                                      :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_prefer-method",
                                      :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6372 6376]},
                                      :full-name "cljs.core/prefer-method",
                                      :clj-symbol "clojure.core/prefer-method",
                                      :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
           "cljs.core/array-seq" {:description "Creates a `seq` from a JavaScript array, starting at index `i` if given.",
                                  :ns "cljs.core",
                                  :name "array-seq",
                                  :signature ["[array]" "[array i]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_array-seq",
                                  :source {:code "(defn array-seq [array i]\n  (prim-seq array i))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [466 467]},
                                  :examples [{:id "9ef6de",
                                              :content "```clj\n(array-seq #js [1 2 3])\n;;=> (1 2 3)\n\n(array-seq #js [1 2 3] 1)\n;;=> (2 3)\n```"}],
                                  :full-name "cljs.core/array-seq"},
           "cljs.core/to-array-2d" {:description "Returns a (potentially-ragged) 2-dimensional JavaScript array containing the\ncontents of `coll`.",
                                    :ns "cljs.core",
                                    :name "to-array-2d",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :related ["cljs.core/to-array"],
                                    :full-name-encode "cljs.core_to-array-2d",
                                    :source {:code "(defn to-array-2d\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when xs\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1598 1607]},
                                    :full-name "cljs.core/to-array-2d",
                                    :clj-symbol "clojure.core/to-array-2d",
                                    :docstring "Returns a (potentially-ragged) 2-dimensional array\ncontaining the contents of coll."},
           "cljs.repl.browser/create-client-js-file" {:ns "cljs.repl.browser",
                                                      :name "create-client-js-file",
                                                      :type "function",
                                                      :signature ["[opts file-path]"],
                                                      :source {:code "(defn create-client-js-file [opts file-path]\n  (let [file (io/file file-path)]\n    (when (not (.exists file))\n      (spit file (compile-client-js opts)))\n    file))",
                                                               :repo "clojurescript",
                                                               :tag "r1211",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [331
                                                                       335]},
                                                      :full-name "cljs.repl.browser/create-client-js-file",
                                                      :full-name-encode "cljs.repl.browser_create-client-js-file",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "cljs.repl/*cljs-verbose*" {:ns "cljs.repl",
                                       :name "*cljs-verbose*",
                                       :type "dynamic var",
                                       :source {:code "(def ^:dynamic *cljs-verbose* false)",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [16]},
                                       :full-name "cljs.repl/*cljs-verbose*",
                                       :full-name-encode "cljs.repl_STARcljs-verboseSTAR",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue" {:ns "cljs.core",
                                        :name "PersistentQueue",
                                        :signature ["[meta count front rear __hash]"],
                                        :history [["+" "0.0-927"]],
                                        :type "type",
                                        :full-name-encode "cljs.core_PersistentQueue",
                                        :source {:code "(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n  \n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (-first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.PersistentQueue/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil nil)\n        cljs.core.List/EMPTY)))\n\n  ICounted\n  (-count [coll] count))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [2985 3033]},
                                        :full-name "cljs.core/PersistentQueue",
                                        :clj-symbol "clojure.lang/PersistentQueue"},
           "cljs.core/drop-last" {:description "Return a lazy sequence of all but the last `n` items in `s`.\n\n`n` defaults to 1.",
                                  :ns "cljs.core",
                                  :name "drop-last",
                                  :signature ["[s]" "[n s]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/drop"
                                            "cljs.core/drop-while"],
                                  :full-name-encode "cljs.core_drop-last",
                                  :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2098 2101]},
                                  :full-name "cljs.core/drop-last",
                                  :clj-symbol "clojure.core/drop-last",
                                  :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
           "cljs.core/PersistentVector.fromArray" {:ns "cljs.core",
                                                   :name "PersistentVector.fromArray",
                                                   :signature ["[xs]"],
                                                   :history [["+"
                                                              "0.0-1006"]],
                                                   :parent-type "PersistentVector",
                                                   :type "function",
                                                   :full-name-encode "cljs.core_PersistentVectorDOTfromArray",
                                                   :source {:code "(set! cljs.core.PersistentVector/fromArray\n      (fn [xs]\n        (loop [xs (seq xs) out (transient cljs.core.PersistentVector/EMPTY)]\n          (if xs\n            (recur (next xs) (conj! out (first xs)))\n            (persistent! out)))))",
                                                            :repo "clojurescript",
                                                            :tag "r1211",
                                                            :filename "src/cljs/cljs/core.cljs",
                                                            :lines [2664
                                                                    2669]},
                                                   :full-name "cljs.core/PersistentVector.fromArray"},
           "cljs.core/filterv" {:description "Returns a vector of the items in `coll` for which `(pred item)` returns true.\n\n`pred` must be free of side-effects.",
                                :ns "cljs.core",
                                :name "filterv",
                                :signature ["[pred coll]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core_filterv",
                                :source {:code "(defn filterv\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2259 2266]},
                                :full-name "cljs.core/filterv",
                                :clj-symbol "clojure.core/filterv",
                                :docstring "Returns a vector of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "cljs.reader/read-string" {:ns "cljs.reader",
                                      :name "read-string",
                                      :signature ["[s]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader_read-string",
                                      :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r true nil false)))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [356 360]},
                                      :extra-sources ({:code "(defn read-string\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading string\")\n     (identical? \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (identical? \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/cljs/reader.cljs",
                                                       :lines [232
                                                               241]}),
                                      :full-name "cljs.reader/read-string",
                                      :clj-symbol "clojure.core/read-string",
                                      :docstring "Reads one object from the string s"},
           "cljs.core/vector?" {:description "Returns true if `x` is a vector, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "vector?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/vector"
                                          "cljs.core/vec"],
                                :full-name-encode "cljs.core_vectorQMARK",
                                :source {:code "(defn ^boolean vector?\n  [x] (satisfies? IVector x))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [768 770]},
                                :full-name "cljs.core/vector?",
                                :clj-symbol "clojure.core/vector?",
                                :docstring "Return true if x satisfies IVector"},
           "cljs.core/defmulti" {:ns "cljs.core",
                                 :name "defmulti",
                                 :signature ["[mm-name & options]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core_defmulti",
                                 :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (core/string? (first options))\n                      (first options)\n                      nil)\n        options     (if (core/string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)]\n    (when (= (count options) 1)\n      (throw \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))\n    (let [options   (apply hash-map options)\n          default   (get options :default :default)\n          ;; hierarchy (get options :hierarchy #'cljs.core.global-hierarchy)\n\t  ]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n\t (let [method-table# (atom {})\n\t       prefer-table# (atom {})\n\t       method-cache# (atom {})\n\t       cached-hierarchy# (atom {})\n\t       hierarchy# (get ~options :hierarchy cljs.core/global-hierarchy)\n\t       ]\n\t   (cljs.core.MultiFn. ~(name mm-name) ~dispatch-fn ~default hierarchy#\n\t\t\t       method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [857 901]},
                                 :full-name "cljs.core/defmulti",
                                 :clj-symbol "clojure.core/defmulti",
                                 :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
           "cljs.core/List.EMPTY" {:ns "cljs.core",
                                   :name "List.EMPTY",
                                   :history [["+" "0.0-927"]],
                                   :parent-type "List",
                                   :type "var",
                                   :full-name-encode "cljs.core_ListDOTEMPTY",
                                   :source {:code "(set! cljs.core.List/EMPTY (EmptyList. nil))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1434]},
                                   :full-name "cljs.core/List.EMPTY",
                                   :clj-symbol "clojure.lang/PersistentList.EMPTY"},
           "clojure.browser.event/dispatch-event" {:ns "clojure.browser.event",
                                                   :name "dispatch-event",
                                                   :type "function",
                                                   :signature ["[src event]"],
                                                   :source {:code "(defn dispatch-event\n  [src event]\n  (goog.events/dispatchEvent src event))",
                                                            :repo "clojurescript",
                                                            :tag "r1211",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [75
                                                                    77]},
                                                   :full-name "clojure.browser.event/dispatch-event",
                                                   :full-name-encode "clojure.browser.event_dispatch-event",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "clojure.string/split-lines" {:description "Splits `s` on `\\n` or `\\r\\n`.",
                                         :ns "clojure.string",
                                         :name "split-lines",
                                         :signature ["[s]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :related ["clojure.string/split"],
                                         :full-name-encode "clojure.string_split-lines",
                                         :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/clojure/string.cljs",
                                                  :lines [101 104]},
                                         :full-name "clojure.string/split-lines",
                                         :clj-symbol "clojure.string/split-lines",
                                         :docstring "Splits s on \n or \r\n."},
           "cljs.repl.browser/loaded-libs" {:ns "cljs.repl.browser",
                                            :name "loaded-libs",
                                            :type "var",
                                            :source {:code "(def loaded-libs (atom #{}))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [30]},
                                            :full-name "cljs.repl.browser/loaded-libs",
                                            :full-name-encode "cljs.repl.browser_loaded-libs",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/areduce" {:description "For quickly reducing an expression `expr` across a JavaScript array `a`.  The\nexpression can use `ret` as the current result, which is initialized to `init`.\nIt can also use `idx` to get the current index.",
                                :ns "cljs.core",
                                :name "areduce",
                                :signature ["[a idx ret init expr]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/reduce"],
                                :full-name-encode "cljs.core_areduce",
                                :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [822 831]},
                                :examples [{:id "20a389",
                                            :content "```clj\n(def a #js [1 2 3])\n(areduce a i ret 0 (+ ret (aget a i)))\n;;=> 6\n```"}],
                                :full-name "cljs.core/areduce",
                                :clj-symbol "clojure.core/areduce",
                                :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the \nevaluation of expr at each step, returning ret."},
           "cljs.core/disj" {:description "disj(oin). Returns a new set of the same (hashed/sorted) type, that does not\ncontain key(s).",
                             :ns "cljs.core",
                             :name "disj",
                             :signature ["[coll]"
                                         "[coll k]"
                                         "[coll k & ks]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/dissoc"
                                       "cljs.core/disj!"
                                       "clojure.set/difference"],
                             :full-name-encode "cljs.core_disj",
                             :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n     (-disjoin coll k))\n  ([coll k & ks]\n     (let [ret (disj coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [707 717]},
                             :full-name "cljs.core/disj",
                             :clj-symbol "clojure.core/disj",
                             :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.core/IEditableCollection" {:ns "cljs.core",
                                            :name "IEditableCollection",
                                            :history [["+" "0.0-1211"]],
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IEditableCollection",
                                            :source {:code "(defprotocol IEditableCollection\n  (-as-transient [coll]))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [243 244]},
                                            :methods [{:name "-as-transient",
                                                       :signature ["[coll]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IEditableCollection",
                                            :clj-symbol "clojure.lang/IEditableCollection"},
           "clojure.browser.net/event-types" {:ns "clojure.browser.net",
                                              :name "event-types",
                                              :type "var",
                                              :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (merge\n          (js->clj goog.net.EventType)))))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [23 30]},
                                              :full-name "clojure.browser.net/event-types",
                                              :full-name-encode "clojure.browser.net_event-types",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.string/lower-case" {:description "Converts string to all lower-case.",
                                        :ns "clojure.string",
                                        :name "lower-case",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_lower-case",
                                        :source {:code "(defn lower-case\n  [s]\n  (. s (toLowerCase)))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [58 61]},
                                        :full-name "clojure.string/lower-case",
                                        :clj-symbol "clojure.string/lower-case",
                                        :docstring "Converts string to all lower-case."},
           "cljs.core/*print-fn*" {:ns "cljs.core",
                                   :name "*print-fn*",
                                   :docstring "Each runtime environment provides a diffenent way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                   :type "function",
                                   :source {:code "(def\n  ^{:doc \"Each runtime environment provides a diffenent way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\"}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [17 23]},
                                   :full-name "cljs.core/*print-fn*",
                                   :full-name-encode "cljs.core_STARprint-fnSTAR",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/str" {:description "`(str)` and `(str nil)` return the empty string.\n\n`(str x)` returns `x.toString()`.\n\nWith more than one argument, returns the concatenation of the `str` values of\nthe arguments.",
                            :ns "cljs.core",
                            :name "str",
                            :signature ["[]" "[x]" "[x & ys]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core_str",
                            :source {:code "(defn str\n  ([] \"\")\n  ([x] (cond\n        (symbol? x) (. x (substring 2 (.-length x)))\n        (keyword? x) (str* \":\" (. x (substring 2 (.-length x))))\n        (nil? x) \"\"\n        :else (. x (toString))))\n  ([x & ys]\n     ((fn [sb more]\n        (if more\n          (recur (. sb  (append (str (first more)))) (next more))\n          (str* sb)))\n      (gstring/StringBuffer. (str x)) ys)))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1257 1272]},
                            :extra-sources ({:code "(defmacro str [& xs]\n  (let [strs (->> (repeat (count xs) \"cljs.core.str(~{})\")\n                  (interpose \",\")\n                  (apply core/str))]\n   (concat (list 'js* (core/str \"[\" strs \"].join('')\")) xs)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [69 73]}),
                            :full-name "cljs.core/str",
                            :clj-symbol "clojure.core/str",
                            :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
           "cljs.core/ISequential" {:ns "cljs.core",
                                    :name "ISequential",
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core_ISequential",
                                    :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [214 215]},
                                    :full-name "cljs.core/ISequential",
                                    :clj-symbol "clojure.lang/Sequential",
                                    :docstring "Marker interface indicating a persistent collection of sequential items"},
           "cljs.core/set" {:description "Returns a set of the distinct elements of `coll`.",
                            :ns "cljs.core",
                            :name "set",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/hash-set"
                                      "cljs.core/sorted-set"
                                      "cljs.core/conj"
                                      "cljs.core/disj"
                                      "cljs.core/distinct"
                                      "clojure.set/join"
                                      "clojure.set/select"
                                      "clojure.set/difference"
                                      "clojure.set/intersection"
                                      "clojure.set/union"
                                      "clojure.set/index"
                                      "clojure.set/project"
                                      "clojure.set/rename"
                                      "clojure.set/rename-keys"
                                      "clojure.set/map-invert"],
                            :full-name-encode "cljs.core_set",
                            :source {:code "(defn set\n  [coll]\n  (loop [in (seq coll)\n         out (transient cljs.core.PersistentHashSet/EMPTY)]\n    (if (seq in)\n      (recur (next in) (conj! out (first in)))\n      (persistent! out))))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [5243 5250]},
                            :full-name "cljs.core/set",
                            :clj-symbol "clojure.core/set",
                            :docstring "Returns a set of the distinct elements of coll."},
           "special/def" {:description "Creates a global variable with the name of `symbol` and a namespace of the\ncurrent namespace.\n\nIf `init` is supplied, it is evaluated and the result is assigned to `symbol`.\n\n`doc-string` is an optional documentation string.\n\n`def` is one of ClojureScript's [special forms](http://clojure.org/special_forms)\nand is used by many macros to define common elements (ie: `defn`, `defmacro`,\netc).",
                          :ns "special",
                          :name "def",
                          :signature ["[symbol]"
                                      "[symbol init]"
                                      "[symbol doc-string init]"],
                          :history [["+" "0.0-927"]],
                          :type "special form",
                          :related ["cljs.core/defn"
                                    "cljs.core/fn"
                                    "cljs.core/defmacro"
                                    "cljs.core/defmulti"],
                          :full-name-encode "special_def",
                          :source {:code "(defmethod parse 'def\n  [op env form name]\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        tag (-> sym meta :tag)\n        dynamic (-> sym meta :dynamic)\n        ns-name (-> env :ns :name)]\n    (assert (not (namespace sym)) \"Can't def ns-qualified name\")\n    (let [env (if (or (and (not= ns-name 'cljs.core)\n                           (core-name? env sym))\n                      (get-in @namespaces [ns-name :uses sym]))\n                (let [ev (resolve-existing-var (dissoc env :locals) sym)]\n                  (when *cljs-warn-on-redef*\n                    (warning env\n                      (str \"WARNING: \" sym \" already refers to: \" (symbol (str (:ns ev)) (str sym))\n                           \" being replaced by: \" (symbol (str ns-name) (str sym)))))\n                  (swap! namespaces update-in [ns-name :excludes] conj sym)\n                  (update-in env [:ns :excludes] conj sym))\n                env)\n          name (munge (:name (resolve-var (dissoc env :locals) sym)))\n          init-expr (when (contains? args :init)\n                      (disallowing-recur\n                       (analyze (assoc env :context :expr) (:init args) sym)))\n          fn-var? (and init-expr (= (:op init-expr) :fn))\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (when-let [v (get-in @namespaces [ns-name :defs sym])]\n        (when (and *cljs-warn-on-fn-var*\n                   (not (-> sym meta :declared))\n                   (and (:fn-var v) (not fn-var?)))\n          (warning env\n            (str \"WARNING: \" (symbol (str ns-name) (str sym))\n                 \" no longer fn, references are stale\"))))\n      (swap! namespaces update-in [ns-name :defs sym]\n             (fn [m]\n               (let [m (assoc (or m {}) :name name)]\n                 (merge m\n                   (when tag {:tag tag})\n                   (when dynamic {:dynamic true})\n                   (when-let [line (:line env)]\n                     {:file *cljs-file* :line line})\n                   (when fn-var?\n                     {:fn-var true\n                      :variadic (:variadic init-expr)\n                      :max-fixed-arity (:max-fixed-arity init-expr)\n                      :method-params (map (fn [m]\n                                            (:params m))\n                                          (:methods init-expr))})))))\n      (merge {:env env :op :def :form form\n              :name name :doc doc :init init-expr}\n             (when tag {:tag tag})\n             (when dynamic {:dynamic true})\n             (when export-as {:export export-as})\n             (when init-expr {:children [init-expr]})))))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [883 941]},
                          :examples [{:id "a5f898",
                                      :content "```clj\n(def a)\na\n;;=> nil\n\n(def b 42)\nb\n;;=> 42\n\n(def c \"an optional docstring\" 42)\nc\n;;=> 42\n```"}],
                          :full-name "special/def",
                          :clj-symbol "clojure.core/def"},
           "cljs.core/print" {:ns "cljs.core",
                              :name "print",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_print",
                              :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5719 5724]},
                              :full-name "cljs.core/print",
                              :clj-symbol "clojure.core/print",
                              :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption."},
           "cljs.core/ArrayNode" {:ns "cljs.core",
                                  :name "ArrayNode",
                                  :signature ["[edit cnt arr]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "type",
                                  :full-name-encode "cljs.core_ArrayNode",
                                  :source {:code "(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (coercive-= nil node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc cljs.core.BitmapIndexedNode/EMPTY (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (coercive-not= nil node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-find [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (coercive-not= nil node)\n        (.inode-find node (+ shift 5) hash key)\n        nil)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (coercive-not= nil node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (coercive-= nil node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! cljs.core.BitmapIndexedNode/EMPTY edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (coercive-= nil node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (coercive-= nil n)\n            (if (<= cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (.-length arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [node (aget arr i)]\n            (if (coercive-not= node nil)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  @init\n                  (recur (inc i) init)))))\n          init)))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3794 3888]},
                                  :full-name "cljs.core/ArrayNode",
                                  :clj-symbol "clojure.lang/ArrayNode"},
           "cljs.core/type" {:ns "cljs.core",
                             :name "type",
                             :signature ["[x]"],
                             :history [["+" "0.0-971"]],
                             :type "function",
                             :full-name-encode "cljs.core_type",
                             :source {:code "(defn type [x]\n  (if (or (nil? x) (undefined? x))\n    nil\n    (js* \"(~{x}).constructor\")))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [290 293]},
                             :full-name "cljs.core/type",
                             :clj-symbol "clojure.core/type"},
           "clojure.string/blank?" {:description "True if `s` is nil, empty, or contains only whitespace.",
                                    :ns "clojure.string",
                                    :name "blank?",
                                    :signature ["[s]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string_blankQMARK",
                                    :source {:code "(defn blank?\n  [s]\n  (let [s (str s)]\n    (if (or\n         (not s)\n         (= \"\" s)\n         (re-matches #\"\\s+\" s))\n      true\n      false)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [133 142]},
                                    :full-name "clojure.string/blank?",
                                    :clj-symbol "clojure.string/blank?",
                                    :docstring "True is s is nil, empty, or contains only whitespace."},
           "syntax/keyword" {:description "Signifies a keyword, a string-like datatype often used as keys for maps.\nKeywords should not start with a number.\n\nKeywords can have an optional namespace. For example, `:foo/bar`. This is useful\nfor functions in a namespace to prevent key collisions on a globally accessible\nmap.\n\nPreceding a keyword with `::` will prepend the given keyword with the current\nnamespace.  For example, in the user namespace, `::foo` is read as `:user/foo`.\n\nIf a keyword is prefixed by `::` and is namespace-qualified, the namespace part is properly resolved.\nFor example, if `foo` is an alias of `cljs.core`, then `::foo/bar` evaluates to `:cljs.core/bar`.\nA reader exception is thrown if `foo` is not a namespace.",
                             :ns "syntax",
                             :name "keyword",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["cljs.core/keyword"
                                       "cljs.core/keyword?"],
                             :full-name-encode "syntax_keyword",
                             :source {:repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form ":",
                             :examples [{:id "e5fdbe",
                                         :content "```clj\n:foo\n;;=> :foo\n\n::foo\n;;=> :user/foo\n\n:a/foo\n;;=> :a/foo\n```"}
                                        {:id "9765fe",
                                         :content "A keyword is also callable for retrieving values from a map:\n\n```clj\n(def m {:foo 1})\n(:foo m)\n;;=> 1\n\n(def things [{:foo 1 :bar 2}\n             {:foo 3 :bar 4}\n             {:foo 5 :bar 6}])\n(map :foo things)\n;;=> (1 3 5)\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#keywords",
                             :full-name "syntax/keyword",
                             :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.dom/append" {:ns "clojure.browser.dom",
                                         :name "append",
                                         :type "function",
                                         :signature ["[parent & children]"],
                                         :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/clojure/browser/dom.cljs",
                                                  :lines [13 15]},
                                         :full-name "clojure.browser.dom/append",
                                         :full-name-encode "clojure.browser.dom_append",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/take-last" {:description "Returns a sequence of the last `n` items in `coll`.\n\nDepending on the type of collection, `take-last` may be no faster than linear\ntime. For vectors, please use `subvec`.",
                                  :ns "cljs.core",
                                  :name "take-last",
                                  :signature ["[n coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/last"
                                            "cljs.core/butlast"
                                            "cljs.core/drop-last"],
                                  :full-name-encode "cljs.core_take-last",
                                  :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2103 2110]},
                                  :full-name "cljs.core/take-last",
                                  :clj-symbol "clojure.core/take-last",
                                  :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
           "cljs.core/TransientHashMap" {:ns "cljs.core",
                                         :name "TransientHashMap",
                                         :signature ["[edit root count has-nil? nil-val]"],
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core_TransientHashMap",
                                         :source {:code "(deftype TransientHashMap [^:mutable edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (if (satisfies? IMapEntry o)\n        (.assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent\"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (array false)\n              node        (-> (if (nil? root)\n                                cljs.core.BitmapIndexedNode/EMPTY\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if (aget added-leaf? 0)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (array false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if (aget removed-leaf? 0)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (nth (.inode-find root 0 (hash k) k) 1))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (nth (.inode-find root 0 (hash k) k (array nil not-found)) 1))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key)))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [4239 4340]},
                                         :full-name "cljs.core/TransientHashMap",
                                         :clj-symbol "clojure.lang/TransientHashMap"},
           "clojure.set/intersection" {:description "Return a set that is the intersection of the input sets.",
                                       :ns "clojure.set",
                                       :name "intersection",
                                       :signature ["[s1]"
                                                   "[s1 s2]"
                                                   "[s1 s2 & sets]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["clojure.set/union"
                                                 "clojure.set/difference"
                                                 "clojure.set/superset?"
                                                 "clojure.set/project"],
                                       :full-name-encode "clojure.set_intersection",
                                       :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/clojure/set.cljs",
                                                :lines [31 44]},
                                       :full-name "clojure.set/intersection",
                                       :clj-symbol "clojure.set/intersection",
                                       :docstring "Return a set that is the intersection of the input sets"},
           "cljs.core/fnext" {:description "Same as `(first (next coll))`",
                              :ns "cljs.core",
                              :name "fnext",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/ffirst"
                                        "cljs.core/second"],
                              :full-name-encode "cljs.core_fnext",
                              :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [560 563]},
                              :examples [{:id "92383f",
                                          :content "```clj\n(fnext [1 2 3])\n;;=> 2\n\n(fnext [1 2])\n;;=> 2\n\n(fnext [1])\n;;=> nil\n\n(fnext [])\n;;=> nil\n```"}],
                              :full-name "cljs.core/fnext",
                              :clj-symbol "clojure.core/fnext",
                              :docstring "Same as (first (next x))"},
           "cljs.core/apply" {:description "Applies function `f` to the argument list formed by prepending intervening\narguments to `args`.",
                              :ns "cljs.core",
                              :name "apply",
                              :signature ["[f args]"
                                          "[f x args]"
                                          "[f x y args]"
                                          "[f x y z args]"
                                          "[f a b c d & args]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/map"],
                              :full-name-encode "cljs.core_apply",
                              :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count args (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc args)\n            (.cljs$lang$applyTo f args)))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist))))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1748 1794]},
                              :examples [{:id "174052",
                                          :content "```clj\n(max 1 2 3)\n;;=> 3\n\n(apply max [1 2 3])\n;;=> 3\n\n(apply max 1 [2 3])\n;;=> 3\n```"}],
                              :full-name "cljs.core/apply",
                              :clj-symbol "clojure.core/apply",
                              :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
           "clojure.walk/prewalk" {:ns "clojure.walk",
                                   :name "prewalk",
                                   :signature ["[f form]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.walk_prewalk",
                                   :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/clojure/walk.cljs",
                                            :lines [58 62]},
                                   :full-name "clojure.walk/prewalk",
                                   :clj-symbol "clojure.walk/prewalk",
                                   :docstring "Like postwalk, but does pre-order traversal."},
           "cljs.core/flatten" {:description "Takes any nested combination of sequential things (lists, vectors, etc.) and\nreturns their contents as a single, flat sequence.\n\n`(flatten nil)` returns nil.",
                                :ns "cljs.core",
                                :name "flatten",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_flatten",
                                :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2227 2233]},
                                :full-name "cljs.core/flatten",
                                :clj-symbol "clojure.core/flatten",
                                :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
           "cljs.core/get" {:description "Returns the value mapped to key `k`.\n\nReturns `not-found` or nil if `k` is not present in `o`.",
                            :ns "cljs.core",
                            :name "get",
                            :signature ["[o k]" "[o k not-found]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/get-in"],
                            :full-name-encode "cljs.core_get",
                            :source {:code "(defn get\n  ([o k]\n     (-lookup o k))\n  ([o k not-found]\n     (-lookup o k not-found)))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [650 655]},
                            :full-name "cljs.core/get",
                            :clj-symbol "clojure.core/get",
                            :docstring "Returns the value mapped to key, not-found or nil if key not present."},
           "cljs.core/.." {:description "For interop, the `..` macro allows method/property chaining on the given JavaScript object `o`.\n\nIt essentially combines the thread-first `->` macro with the `.` operator.",
                           :ns "cljs.core",
                           :name "..",
                           :signature ["[o form]" "[o form & more]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["special/."
                                     "cljs.core/->"
                                     "cljs.core/doto"],
                           :full-name-encode "cljs.core_DOTDOT",
                           :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                    :repo "clojure",
                                    :tag "clojure-1.4.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1511 1527]},
                           :examples [{:id "500658",
                                       :content "```js\n// JavaScript\n\"a b c d\".toUpperCase().replace(\"A\", \"X\")\n//=> \"X B C D\"\n```\n\n```clj\n;; ClojureScript\n(.. \"a b c d\"\n    toUpperCase\n    (replace \"A\" \"X\"))\n;;=> \"X B C D\"\n```\n\nThis is expanded to:\n\n```clj\n(. (. \"a b c d\" toUpperCase) (replace \"A\" \"X\"))\n```\n\n\nwhich is equivalent to:\n\n```clj\n(.replace (.toUpperCase \"a b c d\") \"A\" \"X\")\n;;=> \"X B C D\"\n```\n\nCompare to the equivalent form using the thread-first `->` macro:\n\n```clj\n(-> \"a b c d\"\n    .toUpperCase\n    (.replace \"A\" \"X\"))\n;;=> \"X B C D\"\n```"}],
                           :full-name "cljs.core/..",
                           :clj-symbol "clojure.core/..",
                           :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
           "cljs.core/Range" {:ns "cljs.core",
                              :name "Range",
                              :signature ["[meta start end step __hash]"],
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core_Range",
                              :source {:code "(deftype Range [meta start end step ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n  \n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step __hash))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeq\n  (-first [rng] start)\n  (-rest [rng]\n    (if (-seq rng)\n      (Range. meta (+ start step) end step nil)\n      (list)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-coll __hash))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (js/Math.ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        not-found)))\n\n  ISeqable\n  (-seq [rng]\n    (let [comp (if (pos? step) < >)]\n      (when (comp start end)\n        rng)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f s] (ci-reduce rng f s)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5400 5459]},
                              :full-name "cljs.core/Range",
                              :clj-symbol "clojure.lang/Range"},
           "cljs.core/zero?" {:description "Returns true if `n` is 0, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "zero?",
                              :signature ["[n]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/pos?"
                                        "cljs.core/neg?"],
                              :full-name-encode "cljs.core_zeroQMARK",
                              :source {:code "(defn ^boolean zero? [n]\n  (cljs.core/zero? n))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1225 1226]},
                              :extra-sources ({:code "(defmacro zero? [x]\n  `(== ~x 0))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [168 169]}),
                              :full-name "cljs.core/zero?",
                              :clj-symbol "clojure.core/zero?"},
           "cljs.core/identity" {:description "Returns its argument.",
                                 :ns "cljs.core",
                                 :name "identity",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/nil?"],
                                 :full-name-encode "cljs.core_identity",
                                 :source {:code "(defn identity [x] x)",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1851]},
                                 :full-name "cljs.core/identity",
                                 :clj-symbol "clojure.core/identity"},
           "cljs.core/first" {:description "Returns the first item in `coll` and calls `seq` on its argument.\n\nReturns nil when `coll` is nil.",
                              :ns "cljs.core",
                              :name "first",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/rest"
                                        "cljs.core/next"
                                        "cljs.core/nth"
                                        "cljs.core/second"
                                        "cljs.core/take"
                                        "cljs.core/ffirst"],
                              :full-name-encode "cljs.core_first",
                              :source {:code "(defn first\n  [coll]\n  (when (coercive-not= coll nil)\n    (if (satisfies? ISeq coll)\n      (-first coll)\n      (let [s (seq coll)]\n        (when (coercive-not= s nil)\n          (-first s))))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [508 517]},
                              :examples [{:id "40e413",
                                          :content "```clj\n(first [1 2 3])\n;;=> 1\n\n(first [])\n;;=> nil\n```"}],
                              :full-name "cljs.core/first",
                              :clj-symbol "clojure.core/first",
                              :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
           "cljs.reader/ratio-pattern" {:ns "cljs.reader",
                                        :name "ratio-pattern",
                                        :type "var",
                                        :source {:code "(def ratio-pattern (re-pattern \"([-+]?[0-9]+)/([0-9]+)\"))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [96]},
                                        :full-name "cljs.reader/ratio-pattern",
                                        :full-name-encode "cljs.reader_ratio-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/println-str" {:ns "cljs.core",
                                    :name "println-str",
                                    :signature ["[& objs]"],
                                    :history [["+" "0.0-1011"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_println-str",
                                    :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [5737 5740]},
                                    :full-name "cljs.core/println-str",
                                    :clj-symbol "clojure.core/println-str",
                                    :docstring "println to a string, returning it"},
           "cljs.core/>" {:description "Returns true if each successive number argument is less than the previous\none, false otherwise.",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name ">",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/>="],
                          :full-name-encode "cljs.core_GT",
                          :source {:code "(defn ^boolean >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1065 1075]},
                          :extra-sources ({:code "(defmacro >\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [147 150]}),
                          :examples [{:id "67180c",
                                      :content "```clj\n(> 1 2)\n;;=> false\n\n(> 2 1)\n;;=> true\n\n(> 2 2)\n;;=> false\n\n(> 6 5 4 3 2)\n;;=> true\n```"}],
                          :full-name "cljs.core/>",
                          :clj-symbol "clojure.core/>",
                          :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
           "cljs.core/juxt" {:description "Takes a set of functions and returns a function that is the juxtaposition of\nthose functions.\n\nThe returned function takes a variable number of arguments, and returns a vector\ncontaining the result of applying each function to the arguments (left-to-\nright).\n\n`((juxt a b c) x)` => `[(a x) (b x) (c x)]`",
                             :ns "cljs.core",
                             :name "juxt",
                             :signature ["[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f g h & fs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/partial"
                                       "cljs.core/comp"],
                             :full-name-encode "cljs.core_juxt",
                             :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [5516 5550]},
                             :full-name "cljs.core/juxt",
                             :clj-symbol "clojure.core/juxt",
                             :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
           "cljs.core/max" {:description "Returns the greatest number argument.",
                            :ns "cljs.core",
                            :name "max",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/min"
                                      "cljs.core/max-key"],
                            :full-name-encode "cljs.core_max",
                            :source {:code "(defn max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1093 1098]},
                            :extra-sources ({:code "(defmacro max\n  ([x] x)\n  ([x y] (list 'js* \"((~{} > ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [177 180]}),
                            :full-name "cljs.core/max",
                            :clj-symbol "clojure.core/max",
                            :docstring "Returns the greatest of the nums."},
           "cljs.core/*3" {:description "Only usable from a REPL.\n\nHolds the result of the third to last expression.",
                           :ns "cljs.core",
                           :name "*3",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*2"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR3",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [33 35]},
                           :examples [{:id "d7a6e9",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n(+ 4 8)\n;;=> 12\n\n(+ 1 2)\n;;=> 3\n\n*3\n;;=> 10\n\n(inc *3)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*3",
                           :clj-symbol "clojure.core/*3",
                           :docstring "bound in a repl thread to the third most recent value printed"},
           "cljs.core/TransientArrayMap" {:ns "cljs.core",
                                          :name "TransientArrayMap",
                                          :signature ["[editable? len arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_TransientArrayMap",
                                          :source {:code "(deftype TransientArrayMap [^:mutable editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (== idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. \"lookup after persistent!\"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (if (satisfies? IMapEntry o)\n        (-assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (== idx -1)\n          (if (<= (+ len 2) (* 2 cljs.core.PersistentArrayMap/HASHMAP_THRESHOLD))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array->transient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (>= idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. \"dissoc! after persistent!\")))))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [3449 3515]},
                                          :full-name "cljs.core/TransientArrayMap",
                                          :clj-symbol "clojure.lang/TransientArrayMap"},
           "cljs.core/number?" {:description "Returns true if `n` is a number, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "number?",
                                :signature ["[n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/integer?"],
                                :full-name-encode "cljs.core_numberQMARK",
                                :source {:code "(defn ^boolean number? [n]\n  (goog/isNumber n))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [849 850]},
                                :full-name "cljs.core/number?",
                                :clj-symbol "clojure.core/number?"},
           "cljs.core/array" {:description "Creates a JavaScript array containing `args`.\n\nThe tagged literal `#js [1 2 3]` is equivalent to `(array 1 2 3)`",
                              :ns "cljs.core",
                              :name "array",
                              :signature ["[& args]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/aclone"
                                        "cljs.core/make-array"
                                        "cljs.core/clj->js"],
                              :full-name-encode "cljs.core_array",
                              :source {:code "(defn array\n  [var-args]            ;; [& items]\n  (js* \"Array.prototype.slice.call(arguments)\"))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [75 79]},
                              :extra-sources ({:code "(defmacro array [& rest]\n  (let [xs-str (->> (repeat \"~{}\")\n                    (take (count rest))\n                    (interpose \",\")\n                    (apply core/str))]\n   (concat\n    (list 'js* (core/str \"[\" xs-str \"]\"))\n    rest)))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [786 793]}),
                              :examples [{:id "3a546d",
                                          :content "```clj\n(array 1 2 3)\n;;=> #js [1 2 3]\n\n(apply array [1 2 3])\n;;=> #js [1 2 3]\n\n#js [1 2 3]\n;;=> #js [1 2 3]\n```"}
                                         {:id "cca945",
                                          :content "When creating nested JavaScript arrays, you can opt to use `clj->js` instead:\n\n```clj\n(array 1 2 (array 3 4))\n;;=> #js [1 2 #js [3 4]]\n\n(clj->js [1 2 [3 4]])\n;;=> #js [1 2 #js [3 4]]\n```"}],
                              :full-name "cljs.core/array",
                              :docstring "Creates a new javascript array.\n@param {...*} var_args"},
           "cljs.core/nthnext" {:description "Returns the `n`th `next` of `coll`.\n\nReturns `(seq coll)` when `n` is 0.",
                                :ns "cljs.core",
                                :name "nthnext",
                                :signature ["[coll n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/nth"
                                          "cljs.core/drop"
                                          "cljs.core/nthrest"],
                                :full-name-encode "cljs.core_nthnext",
                                :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1234 1240]},
                                :full-name "cljs.core/nthnext",
                                :clj-symbol "clojure.core/nthnext",
                                :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
           "cljs.core/re-pattern" {:description "Returns an instance of RegExp which has compiled the provided string.",
                                   :ns "cljs.core",
                                   :name "re-pattern",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_re-pattern",
                                   :source {:code "(defn re-pattern\n  [s]\n  (let [[_ flags pattern] (re-find #\"^(?:\\(\\?([idmsux]*)\\))?(.*)\" s)]\n    (js/RegExp. pattern flags)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [5611 5615]},
                                   :full-name "cljs.core/re-pattern",
                                   :clj-symbol "clojure.core/re-pattern",
                                   :docstring "Returns an instance of RegExp which has compiled the provided string."},
           "cljs.core/missing-protocol" {:ns "cljs.core",
                                         :name "missing-protocol",
                                         :type "function",
                                         :signature ["[proto obj]"],
                                         :source {:code "(defn missing-protocol [proto obj]\n  (js/Error (js* \"~{}+~{}+~{}+~{}+~{}+~{}\"\n                 \"No protocol method \" proto\n                 \" defined for type \" (goog/typeOf obj) \": \" obj)))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [62 65]},
                                         :full-name "cljs.core/missing-protocol",
                                         :full-name-encode "cljs.core_missing-protocol",
                                         :history [["+" "0.0-927"]]},
           "clojure.browser.dom/set-text" {:ns "clojure.browser.dom",
                                           :name "set-text",
                                           :signature ["[e s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.dom_set-text",
                                           :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/clojure/browser/dom.cljs",
                                                    :lines [124 129]},
                                           :full-name "clojure.browser.dom/set-text",
                                           :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned."},
           "clojure.zip/up" {:ns "clojure.zip",
                             :name "up",
                             :signature ["[loc]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "clojure.zip_up",
                             :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [111 122]},
                             :full-name "clojure.zip/up",
                             :clj-symbol "clojure.zip/up",
                             :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
           "cljs.core/IWithMeta" {:ns "cljs.core",
                                  :name "IWithMeta",
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IWithMeta",
                                  :source {:code "(defprotocol IWithMeta\n  (-with-meta [o meta]))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [196 197]},
                                  :methods [{:name "-with-meta",
                                             :signature ["[o meta]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IWithMeta",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/bit-and-not" {:description "Bitwise \"and\" `x` with bitwise \"not\" `y`.  Same as `x & ~y` in JavaScript.",
                                    :ns "cljs.core",
                                    :name "bit-and-not",
                                    :signature ["[x y]"
                                                "[x y & more]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/bit-and"
                                              "cljs.core/bit-not"],
                                    :full-name-encode "cljs.core_bit-and-not",
                                    :source {:code "(defn bit-and-not\n  [x y] (cljs.core/bit-and-not x y))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1160 1162]},
                                    :extra-sources ({:code "(defmacro bit-and-not\n  ([x y] (list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/clj/cljs/core.clj",
                                                     :lines [210 212]}),
                                    :examples [{:id "16f35d",
                                                :content "Bits can be entered using radix notation:\n\n```clj\n(bit-and-not 2r1100 2r1010)\n;;=> 4\n;; 4 = 2r0100\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-and-not 12 10)\n;;=> 4\n```\n\nSame result using `bit-and` and `bit-not`:\n\n```clj\n(bit-and 12 (bit-not 10))\n;;=> 4\n```"}],
                                    :full-name "cljs.core/bit-and-not",
                                    :clj-symbol "clojure.core/bit-and-not",
                                    :docstring "Bitwise and"},
           "clojure.string/triml" {:description "Removes whitespace from the left side of string.",
                                   :ns "clojure.string",
                                   :name "triml",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string_triml",
                                   :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [111 114]},
                                   :full-name "clojure.string/triml",
                                   :clj-symbol "clojure.string/triml",
                                   :docstring "Removes whitespace from the left side of string."},
           "syntax/character" {:description "Signifies a single character string.  Carried over from Clojure for\ncompatibility.  They are represented as single character JavaScript strings.\n\n`\\c` = `\"c\"`\n\n| unicode characters  | constraints                                   |\n|---------------------|-----------------------------------------------|\n| `\\uXXXX`            | XXXX must have 4 digits outside 0xD7FF-0xE000 |\n| `\\oXXX`             | XXX is octal between 0 and 0377               |\n\n| special characters  | result   |\n|---------------------|----------|\n| `\\newline`          | `\"\\n\"`   |\n| `\\space`            | `\" \"`    |\n| `\\tab`              | `\"\\t\"`   |\n| `\\formfeed`         | `\"\\f\"`   |\n| `\\backspace`        | `\"\\b\"`   |\n| `\\return`           | `\"\\r\"`   |",
                               :ns "syntax",
                               :name "character",
                               :history [["+" "0.0-927"]],
                               :type "syntax",
                               :related ["syntax/string"
                                         "cljs.core/str"],
                               :full-name-encode "syntax_character",
                               :source {:repo "clojure",
                                        :tag "clojure-1.4.0",
                                        :filename "src/jvm/clojure/lang/LispReader.java",
                                        :lines [nil]},
                               :syntax-form "\\",
                               :examples [{:id "495a47",
                                           :content "```clj\n\\c\n;;=> \"c\"\n\n\\A\n;;=> \"A\"\n\n\\newline\n;;=> \"\\n\"\n\n\\u00a1\n;;=> \"¡\"\n\n\\o256\n;;=> \"®\"\n```"}],
                               :edn-doc "https://github.com/edn-format/edn#characters",
                               :full-name "syntax/character",
                               :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/unreadable" {:ns "syntax",
                                :name "unreadable",
                                :history [["+" "0.0-927"]],
                                :type "syntax",
                                :full-name-encode "syntax_unreadable",
                                :source {:repo "clojure",
                                         :tag "clojure-1.4.0",
                                         :filename "src/jvm/clojure/lang/LispReader.java",
                                         :lines [nil]},
                                :syntax-form "#<>",
                                :full-name "syntax/unreadable",
                                :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L115"},
           "clojure.string/split" {:description "Splits string on a regular expression. Optional argument limit is the maximum\nnumber of splits. Not lazy. Returns vector of the splits.",
                                   :ns "clojure.string",
                                   :name "split",
                                   :signature ["[s re]"
                                               "[s re limit]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/subs"
                                             "clojure.string/replace"
                                             "clojure.string/split-lines"],
                                   :full-name-encode "clojure.string_split",
                                   :source {:code "(defn split\n  ([s re]\n     (vec (.split (str s) re)))\n  ([s re limit]\n     (if (< limit 1)\n       (vec (.split (str s) re))\n       (loop [s s\n              limit limit\n              parts []]\n         (if (= limit 1)\n           (conj parts s)\n           (if-let [m (re-find re s)]\n             (let [index (.indexOf s m)]\n               (recur (.substring s (+ index (count m)))\n                      (dec limit)\n                      (conj parts (.substring s 0 index))))\n             (conj parts s)))))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [81 99]},
                                   :full-name "clojure.string/split",
                                   :clj-symbol "clojure.string/split",
                                   :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
           "cljs.core/hash-map" {:description "Returns a new hash map with supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                 :ns "cljs.core",
                                 :name "hash-map",
                                 :signature ["[& keyvals]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/array-map"
                                           "cljs.core/sorted-map"],
                                 :full-name-encode "cljs.core_hash-map",
                                 :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out (transient cljs.core.PersistentHashMap/EMPTY)]\n    (if in\n      (recur (nnext in) (assoc! out (first in) (second in)))\n      (persistent! out))))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4982 4989]},
                                 :full-name "cljs.core/hash-map",
                                 :clj-symbol "clojure.core/hash-map",
                                 :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
           "cljs.core/mapv" {:description "Returns a vector consisting of the result of applying `f` to the set of first\nitems of each coll, followed by applying `f` to the set of second items in each\ncoll, until any one of the colls is exhausted. Any remaining items in other\ncolls are ignored.\n\nFunction `f` should accept number-of-colls arguments.",
                             :ns "cljs.core",
                             :name "mapv",
                             :signature ["[f coll]"
                                         "[f c1 c2]"
                                         "[f c1 c2 c3]"
                                         "[f c1 c2 c3 & colls]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/map"],
                             :full-name-encode "cljs.core_mapv",
                             :source {:code "(defn mapv\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2243 2257]},
                             :full-name "cljs.core/mapv",
                             :clj-symbol "clojure.core/mapv",
                             :docstring "Returns a vector consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "cljs.core/rem" {:description "Returns the remainder of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).",
                            :ns "cljs.core",
                            :name "rem",
                            :signature ["[n d]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/quot"
                                      "cljs.core/mod"],
                            :full-name-encode "cljs.core_rem",
                            :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (js* \"(~{n} - (~{d} * ~{q}))\")))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1133 1137]},
                            :full-name "cljs.core/rem",
                            :clj-symbol "clojure.core/rem",
                            :docstring "remainder of dividing numerator by denominator."},
           "cljs.core/IRecord" {:ns "cljs.core",
                                :name "IRecord",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IRecord",
                                :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [220 221]},
                                :full-name "cljs.core/IRecord",
                                :clj-symbol "clojure.lang/IRecord",
                                :docstring "Marker interface indicating a record object"},
           "cljs.core/constantly" {:description "Returns a function that takes any number of arguments and always returns `x`.",
                                   :ns "cljs.core",
                                   :name "constantly",
                                   :signature ["[x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/repeatedly"],
                                   :full-name-encode "cljs.core_constantly",
                                   :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1863 1865]},
                                   :full-name "cljs.core/constantly",
                                   :clj-symbol "clojure.core/constantly",
                                   :docstring "Returns a function that takes any number of arguments and returns x."},
           "clojure.browser.dom/get-element" {:ns "clojure.browser.dom",
                                              :name "get-element",
                                              :type "function",
                                              :signature ["[id]"],
                                              :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/clojure/browser/dom.cljs",
                                                       :lines [98 99]},
                                              :full-name "clojure.browser.dom/get-element",
                                              :full-name-encode "clojure.browser.dom_get-element",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/and" {:description "Evaluates arguments one at a time from left to right. If an argument returns\nlogical false (nil or false), `and` returns that value and doesn't evaluate any\nof the other arguments, otherwise it returns the value of the last argument.\n\n`(and)` returns true.",
                            :ns "cljs.core",
                            :name "and",
                            :signature ["[]" "[x]" "[x & next]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/or" "special/if"],
                            :full-name-encode "cljs.core_and",
                            :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))",
                                     :repo "clojure",
                                     :tag "clojure-1.4.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [778 788]},
                            :examples [{:id "a39a73",
                                        :content "```clj\n(and)\n;;=> true\n\n(and false)\n;;=> false\n\n(and true)\n;;=> true\n\n(and true true)\n;;=> true\n\n(and true false)\n;;=> false\n\n(and false false)\n;;=> false\n```"}
                                       {:id "766638",
                                        :content "`nil` and `false` are the only falsy values and everything else is truthy:\n\n```clj\n(and \"foo\" \"bar\")\n;;=> \"bar\"\n\n(and \"foo\" nil)\n;;=> nil\n\n(and \"foo\" false)\n;;=> false\n\n(and nil \"foo\")\n;;=> nil\n\n(and false \"foo\")\n;;=> false\n```"}],
                            :full-name "cljs.core/and",
                            :clj-symbol "clojure.core/and",
                            :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
           "clojure.browser.repl/wrap-message" {:ns "clojure.browser.repl",
                                                :name "wrap-message",
                                                :type "function",
                                                :signature ["[t data]"],
                                                :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/cljs/clojure/browser/repl.cljs",
                                                         :lines [57
                                                                 58]},
                                                :full-name "clojure.browser.repl/wrap-message",
                                                :full-name-encode "clojure.browser.repl_wrap-message",
                                                :history [["+"
                                                           "0.0-927"]]},
           "clojure.browser.event/unlisten-by-key" {:ns "clojure.browser.event",
                                                    :name "unlisten-by-key",
                                                    :type "function",
                                                    :signature ["[key]"],
                                                    :source {:code "(defn unlisten-by-key\n  [key]\n  (goog.events/unlistenByKey key))",
                                                             :repo "clojurescript",
                                                             :tag "r1211",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [71
                                                                     73]},
                                                    :full-name "clojure.browser.event/unlisten-by-key",
                                                    :full-name-encode "clojure.browser.event_unlisten-by-key",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/try" {:ns "cljs.core",
                            :name "try",
                            :signature ["[& forms]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core_try",
                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [648 676]},
                            :full-name "cljs.core/try",
                            :clj-symbol "clojure.core/try",
                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/iterate" {:description "Returns a lazy sequence of `x`, `(f x)`, `(f (f x))` etc.\n\n`f` must be free of side-effects.",
                                :ns "cljs.core",
                                :name "iterate",
                                :signature ["[f x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/cycle"
                                          "cljs.core/repeatedly"
                                          "cljs.core/repeat"],
                                :full-name-encode "cljs.core_iterate",
                                :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2150 2153]},
                                :full-name "cljs.core/iterate",
                                :clj-symbol "clojure.core/iterate",
                                :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
           "cljs.core/lazy-seq" {:description "Returns a new lazy sequence.",
                                 :ns "cljs.core",
                                 :name "lazy-seq",
                                 :signature ["[& body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/lazy-cat"
                                           "cljs.core/realized?"
                                           "cljs.core/doall"
                                           "cljs.core/iterate"],
                                 :full-name-encode "cljs.core_lazy-seq",
                                 :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core.LazySeq nil false (fn [] ~@body)))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [561 562]},
                                 :full-name "cljs.core/lazy-seq",
                                 :clj-symbol "clojure.core/lazy-seq"},
           "specialrepl/load-file" {:description "Only usable from a REPL.\n\nLoad file at `filename`, then compiles and evaluates its code.",
                                    :ns "specialrepl",
                                    :name "load-file",
                                    :signature ["[filename]"],
                                    :history [["+" "0.0-927"]],
                                    :type "special form (repl)",
                                    :full-name-encode "specialrepl_load-file",
                                    :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (@comp/namespaces ns-name)\n                  (swap! comp/namespaces assoc ns-name {:name ns-name}))\n                (set! comp/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [138 147]},
                                    :examples [{:id "0903c5",
                                                :content "```clj\n(load-file \"path/to/foo.cljs\")\n```"}],
                                    :full-name "specialrepl/load-file",
                                    :clj-symbol "clojure.core/load-file"},
           "cljs.core/IndexedSeq" {:ns "cljs.core",
                                   :name "IndexedSeq",
                                   :signature ["[a i]"],
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core_IndexedSeq",
                                   :source {:code "(deftype IndexedSeq [a i]\n  Object\n  (toString [this]\n    (pr-str this))\n  \n  ISeqable\n  (-seq [this] this)\n\n  ASeq\n  ISeq\n  (-first [_] (aget a i))\n  (-rest [_] (if (< (inc i) (.-length a))\n               (IndexedSeq. a (inc i))\n               (list)))\n\n  ICounted\n  (-count [_] (- (.-length a) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (.-length a))\n        (aget a i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (.-length a))\n        (aget a i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IReduce\n  (-reduce [coll f]\n    (if (counted? a)\n      (ci-reduce a f (aget a i) (inc i))\n      (ci-reduce coll f (aget a i) 0)))\n  (-reduce [coll f start]\n    (if (counted? a)\n      (ci-reduce a f start i)\n      (ci-reduce coll f start 0)))\n\n  IHash\n  (-hash [coll] (hash-coll coll)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [413 460]},
                                   :full-name "cljs.core/IndexedSeq",
                                   :clj-symbol "clojure.lang/IndexedSeq"},
           "cljs.core/next" {:description "Returns a sequence of the items after the first and calls `seq` on its argument.\n\nReturns nil if `coll` is empty.",
                             :ns "cljs.core",
                             :name "next",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rest"
                                       "cljs.core/first"
                                       "cljs.core/fnext"],
                             :full-name-encode "cljs.core_next",
                             :source {:code "(defn next\n  [coll]\n  (if (coercive-not= coll nil)\n    (if (satisfies? ISeq coll)\n      (let [coll (-rest coll)]\n        (if (coercive-not= coll nil)\n          (if (satisfies? ASeq coll)\n            coll\n            (-seq coll))))\n      (seq (rest coll)))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [532 543]},
                             :examples [{:id "7db59a",
                                         :content "```clj\n(next [1 2 3])\n;;=> (2 3)\n\n(next [1 2])\n;;=> (2)\n\n(next [1])\n;;=> nil\n\n(next [])\n;;=> nil\n```"}],
                             :full-name "cljs.core/next",
                             :clj-symbol "clojure.core/next",
                             :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
           "cljs.core/*print-readably*" {:ns "cljs.core",
                                         :name "*print-readably*",
                                         :type "var",
                                         :source {:code "(def *print-readably* true)",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [5691]},
                                         :full-name "cljs.core/*print-readably*",
                                         :full-name-encode "cljs.core_STARprint-readablySTAR",
                                         :clj-symbol "clojure.core/*print-readably*",
                                         :history [["+" "0.0-927"]]},
           "cljs.repl.browser/repl-client-js" {:ns "cljs.repl.browser",
                                               :name "repl-client-js",
                                               :type "function",
                                               :signature ["[]"],
                                               :source {:code "(defn repl-client-js []\n  (slurp @(:client-js @server-state)))",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [166
                                                                167]},
                                               :full-name "cljs.repl.browser/repl-client-js",
                                               :full-name-encode "cljs.repl.browser_repl-client-js",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.repl.browser/parse-headers" {:ns "cljs.repl.browser",
                                              :name "parse-headers",
                                              :signature ["[header-lines]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser_parse-headers",
                                              :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [115
                                                               123]},
                                              :full-name "cljs.repl.browser/parse-headers",
                                              :docstring "Parse the headers of an HTTP POST request."},
           "cljs.core/last" {:description "Returns the last item in `coll` in linear time.\n\n`peek` is much faster than `last` for a vector.",
                             :ns "cljs.core",
                             :name "last",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/first"
                                       "cljs.core/next"
                                       "cljs.core/rest"
                                       "cljs.core/butlast"
                                       "cljs.core/take-last"],
                             :full-name-encode "cljs.core_last",
                             :source {:code "(defn last\n  [s]\n  (if (next s)\n    (recur (next s))\n    (first s)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [570 575]},
                             :examples [{:id "eb0836",
                                         :content "```clj\n(last [1 2 3])\n;;=> 3\n\n(last [1 2])\n;;=> 2\n\n(last [1])\n;;=> 1\n\n(last [])\n;;=> nil\n```"}],
                             :full-name "cljs.core/last",
                             :clj-symbol "clojure.core/last",
                             :docstring "Return the last item in coll, in linear time"},
           "cljs.core/bit-shift-left" {:description "Bitwise shift left `n` bits.  Same as `x << n` in JavaScript.",
                                       :ns "cljs.core",
                                       :name "bit-shift-left",
                                       :signature ["[x n]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["cljs.core/bit-shift-right"],
                                       :full-name-encode "cljs.core_bit-shift-left",
                                       :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1188 1190]},
                                       :extra-sources ({:code "(defmacro bit-shift-left [x n]\n  (list 'js* \"(~{} << ~{})\" x n))",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [223
                                                                224]}),
                                       :examples [{:id "67c34a",
                                                   :content "Bits can be entered using radix notation:\n\n```clj\n(bit-shift-left 2r0101 1)\n;;=> 10\n;; 10 = 2r1010\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-shift-left 5 1)\n;;=> 10\n```"}],
                                       :full-name "cljs.core/bit-shift-left",
                                       :clj-symbol "clojure.core/bit-shift-left",
                                       :docstring "Bitwise shift left"},
           "clojure.string/reverse" {:description "Returns `s` with its characters reversed.",
                                     :ns "clojure.string",
                                     :name "reverse",
                                     :signature ["[s]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string_reverse",
                                     :source {:code "(defn reverse\n  [s]\n  (.. s (split \"\") (reverse) (join \"\")))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [18 21]},
                                     :full-name "clojure.string/reverse",
                                     :clj-symbol "clojure.string/reverse",
                                     :docstring "Returns s with its characters reversed."},
           "cljs.core/min" {:description "Returns the least number argument.",
                            :ns "cljs.core",
                            :name "min",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/max"
                                      "cljs.core/min-key"],
                            :full-name-encode "cljs.core_min",
                            :source {:code "(defn min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1100 1105]},
                            :extra-sources ({:code "(defmacro min\n  ([x] x)\n  ([x y] (list 'js* \"((~{} < ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [182 185]}),
                            :examples [{:id "ab2de5",
                                        :content "```clj\n(min 1 2 3 4)\n;; => 1\n```\n\nApply it to a collection:\n\n```clj\n(apply min [1 2 3 4])\n;; => 1\n```"}],
                            :full-name "cljs.core/min",
                            :clj-symbol "clojure.core/min",
                            :docstring "Returns the least of the nums."},
           "cljs.reader/escape-char" {:ns "cljs.reader",
                                      :name "escape-char",
                                      :type "function",
                                      :signature ["[buffer reader]"],
                                      :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (get escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (if (or (identical? \\u ch) (numeric? ch))\n        (read-unicode-char reader ch)\n        (reader-error reader \"Unsupported escape charater: \\\\\" ch)))))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [149 157]},
                                      :full-name "cljs.reader/escape-char",
                                      :full-name-encode "cljs.reader_escape-char",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/read-map" {:ns "cljs.reader",
                                   :name "read-map",
                                   :type "function",
                                   :signature ["[rdr _]"],
                                   :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [213 218]},
                                   :full-name "cljs.reader/read-map",
                                   :full-name-encode "cljs.reader_read-map",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/seq" {:description "Returns a sequence on the collection. If the collection is empty, returns nil.\n\n`(seq nil)` returns nil.\n\n`seq` also works on strings.",
                            :ns "cljs.core",
                            :name "seq",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/seq?"
                                      "cljs.core/empty?"],
                            :full-name-encode "cljs.core_seq",
                            :source {:code "(defn seq\n  [coll]\n  (if (coercive-not= coll nil)\n    (if (satisfies? ASeq coll)\n      coll\n      (-seq coll))))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [498 506]},
                            :full-name "cljs.core/seq",
                            :clj-symbol "clojure.core/seq",
                            :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
           "cljs.core/long" {:ns "cljs.core",
                             :name "long",
                             :signature ["[x]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core_long",
                             :source {:code "(defn long\n  [x]\n  (fix x))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1117 1120]},
                             :full-name "cljs.core/long",
                             :clj-symbol "clojure.core/long",
                             :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.core/not-empty" {:description "Returns nil if `coll` is empty, else returns `coll`.",
                                  :ns "cljs.core",
                                  :name "not-empty",
                                  :signature ["[coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/empty"],
                                  :full-name-encode "cljs.core_not-empty",
                                  :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1809 1811]},
                                  :full-name "cljs.core/not-empty",
                                  :clj-symbol "clojure.core/not-empty",
                                  :docstring "If coll is empty, returns nil, else coll"},
           "syntax/hashbang" {:ns "syntax",
                              :name "hashbang",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :full-name-encode "syntax_hashbang",
                              :source {:repo "clojure",
                                       :tag "clojure-1.4.0",
                                       :filename "src/jvm/clojure/lang/LispReader.java",
                                       :lines [nil]},
                              :syntax-form "#!",
                              :full-name "syntax/hashbang",
                              :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L114"},
           "cljs.core/println" {:ns "cljs.core",
                                :name "println",
                                :signature ["[& objs]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_println",
                                :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (newline (pr-opts)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5731 5735]},
                                :full-name "cljs.core/println",
                                :clj-symbol "clojure.core/println",
                                :docstring "Same as print followed by (newline)"},
           "clojure.browser.repl/connect" {:ns "clojure.browser.repl",
                                           :name "connect",
                                           :signature ["[repl-server-url]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.repl_connect",
                                           :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection (net/xpc-connection\n                         {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n                          :evaluate-javascript\n                          (fn [js]\n                            (net/transmit\n                             repl-connection\n                             :send-result\n                             (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n                 (constantly nil)\n                 (fn [iframe]\n                   (set! iframe.style.display\n                         \"none\")))))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/clojure/browser/repl.cljs",
                                                    :lines [90 109]},
                                           :full-name "clojure.browser.repl/connect",
                                           :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function."},
           "clojure.browser.dom/insert-at" {:ns "clojure.browser.dom",
                                            :name "insert-at",
                                            :type "function",
                                            :signature ["[parent child index]"],
                                            :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [104 105]},
                                            :full-name "clojure.browser.dom/insert-at",
                                            :full-name-encode "clojure.browser.dom_insert-at",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/quot" {:description "Returns the quotient of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).",
                             :ns "cljs.core",
                             :name "quot",
                             :signature ["[n d]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rem"
                                       "cljs.core/mod"],
                             :full-name-encode "cljs.core_quot",
                             :source {:code "(defn quot\n  [n d]\n  (let [rem (mod n d)]\n    (fix (js* \"((~{n} - ~{rem}) / ~{d})\"))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1127 1131]},
                             :full-name "cljs.core/quot",
                             :clj-symbol "clojure.core/quot",
                             :docstring "quot[ient] of dividing numerator by denominator."},
           "clojure.browser.event/get-listener" {:ns "clojure.browser.event",
                                                 :name "get-listener",
                                                 :type "function",
                                                 :signature ["[src type listener opt_capt opt_handler]"],
                                                 :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                          :repo "clojurescript",
                                                          :tag "r1211",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [89]},
                                                 :full-name "clojure.browser.event/get-listener",
                                                 :full-name-encode "clojure.browser.event_get-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/filter" {:description "Returns a lazy sequence of the non-nil results of `(f item)`. Note, this means\nfalse return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                               :ns "cljs.core",
                               :name "filter",
                               :signature ["[f]" "[f coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/remove"
                                         "cljs.core/keep"],
                               :full-name-encode "cljs.core_filter",
                               :source {:code "(defn filter\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s) r (rest s)]\n        (if (pred f)\n          (cons f (filter pred r))\n          (filter pred r)))))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2195 2204]},
                               :full-name "cljs.core/filter",
                               :clj-symbol "clojure.core/filter",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "clojure.zip/branch?" {:ns "clojure.zip",
                                  :name "branch?",
                                  :signature ["[loc]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_branchQMARK",
                                  :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [64 67]},
                                  :full-name "clojure.zip/branch?",
                                  :clj-symbol "clojure.zip/branch?",
                                  :docstring "Returns true if the node at loc is a branch"},
           "special/if" {:description "If `test` is not false or nil, `then` is evaluated and returned. Otherwise,\n`else?` is evaluated and returned. `else?` defaults to nil if not provided.\n\n`if` is one of ClojureScript's [special forms](http://clojure.org/special_forms)\nand is a fundamental building block of the language. All other conditionals in\nClojureScript are based on `if`s notion of truthiness (ie: anything other than\nfalse or nil).",
                         :ns "special",
                         :name "if",
                         :signature ["[test then else?]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :related ["cljs.core/cond"
                                   "cljs.core/when"
                                   "cljs.core/if-let"
                                   "cljs.core/if-not"],
                         :full-name-encode "special_if",
                         :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name]\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (analyze env then)\n        else-expr (analyze env else)]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked @*unchecked-if*\n     :children [test-expr then-expr else-expr]}))",
                                  :repo "clojurescript",
                                  :tag "r1211",
                                  :filename "src/clj/cljs/compiler.clj",
                                  :lines [827 835]},
                         :examples [{:id "e591ff",
                                     :content "```clj\n(def v [1 2])\n\n(if (empty? v) \"empty!\" \"filled!\")\n;;=> \"filled!\"\n\n(str \"This vector is \"\n  (if (empty? v) \"empty!\" \"filled!\"))\n;;=> \"This vector is filled!\"\n```"}],
                         :full-name "special/if",
                         :clj-symbol "clojure.core/if"},
           "cljs.core/ObjMap" {:ns "cljs.core",
                               :name "ObjMap",
                               :type "type",
                               :signature ["[meta keys strobj update-count __hash]"],
                               :source {:code "(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n  \n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj update-count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.ObjMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (.-length keys))\n      (map #(vector % (aget strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (.-length keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (obj-map-contains-key? k strobj (aget strobj k) not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (goog/isString k)\n      (let [overwrite? (.hasOwnProperty strobj k)]\n        (if overwrite?\n          (let [new-strobj (goog.object/clone strobj)]\n            (aset new-strobj k v)\n            (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n          (if (< update-count cljs.core.ObjMap/HASHMAP_THRESHOLD) #_(< (.-length keys) cljs.core.ObjMap/HASHMAP_THRESHOLD)\n            (let [new-strobj (goog.object/clone strobj) ; append\n                  new-keys (aclone keys)]\n              (aset new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n            ;; too many keys, switching to PersistentHashMap\n            (obj-map->hash-map coll k v))))\n      ; non-string key. game over.\n      (obj-map->hash-map coll k v)))\n  (-contains-key? [coll k]\n    (obj-map-contains-key? k strobj))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and (goog/isString k) (.hasOwnProperty strobj k))\n      (let [new-keys (aclone keys)\n            new-strobj (goog.object/clone strobj)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3101 3182]},
                               :full-name "cljs.core/ObjMap",
                               :full-name-encode "cljs.core_ObjMap",
                               :history [["+" "0.0-927"]]},
           "cljs.core/zipmap" {:description "Returns a map with `keys` mapped to corresponding `vals`.\n\n<pre>user=> (zipmap [:a :b :c :d] [1 2 3 4])\n{:a 1, :b 2, :c 3, :d 4}</pre>",
                               :ns "cljs.core",
                               :name "zipmap",
                               :signature ["[keys vals]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/interleave"],
                               :full-name-encode "cljs.core_zipmap",
                               :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [5319 5329]},
                               :full-name "cljs.core/zipmap",
                               :clj-symbol "clojure.core/zipmap",
                               :docstring "Returns a map with the keys mapped to the corresponding vals."},
           "cljs.core/hash-combine" {:ns "cljs.core",
                                     :name "hash-combine",
                                     :type "function",
                                     :signature ["[seed hash]"],
                                     :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed (+ hash 0x9e3779b9\n                   (bit-shift-left seed 6)\n                   (bit-shift-right seed 2))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1309 1313]},
                                     :full-name "cljs.core/hash-combine",
                                     :full-name-encode "cljs.core_hash-combine",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/reversible?" {:description "Returns true if `coll` implements the `IReversible` protocol, false otherwise.\n\nVectors, sorted maps, and sorted sets implement `IReversible`.",
                                    :return-type boolean,
                                    :ns "cljs.core",
                                    :name "reversible?",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_reversibleQMARK",
                                    :source {:code "(defn ^boolean reversible? [coll]\n  (satisfies? IReversible coll))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1436 1437]},
                                    :full-name "cljs.core/reversible?",
                                    :clj-symbol "clojure.core/reversible?"},
           "syntax/arg" {:ns "syntax",
                         :name "arg",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :full-name-encode "syntax_arg",
                         :source {:repo "clojure",
                                  :tag "clojure-1.4.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "%",
                         :full-name "syntax/arg",
                         :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/max-key" {:description "Returns the `x` for which `(k x)` is greatest.\n\n`(k x)` should return a number.",
                                :ns "cljs.core",
                                :name "max-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/max"
                                          "cljs.core/min-key"],
                                :full-name-encode "cljs.core_max-key",
                                :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5331 5336]},
                                :full-name "cljs.core/max-key",
                                :clj-symbol "clojure.core/max-key",
                                :docstring "Returns the x for which (k x), a number, is greatest."},
           "clojure.zip/insert-child" {:ns "clojure.zip",
                                       :name "insert-child",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_insert-child",
                                       :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [194 198]},
                                       :full-name "clojure.zip/insert-child",
                                       :clj-symbol "clojure.zip/insert-child",
                                       :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
           "cljs.repl.browser/send-404" {:ns "cljs.repl.browser",
                                         :name "send-404",
                                         :type "function",
                                         :signature ["[conn path]"],
                                         :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [91 97]},
                                         :full-name "cljs.repl.browser/send-404",
                                         :full-name-encode "cljs.repl.browser_send-404",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/defrecord" {:ns "cljs.core",
                                  :name "defrecord",
                                  :signature ["[rsym fields & impls]"],
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core_defrecord",
                                  :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [r (:name (cljs.compiler/resolve-var (dissoc &env :locals) rsym))]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (list ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [503 511]},
                                  :full-name "cljs.core/defrecord",
                                  :clj-symbol "clojure.core/defrecord"},
           "cljs.repl.browser/repl-env" {:ns "cljs.repl.browser",
                                         :name "repl-env",
                                         :type "function",
                                         :signature ["[& {:as opts}]"],
                                         :source {:code "(defn repl-env [& {:as opts}]\n  (let [opts (merge {:port          9000\n                     :optimizations :simple\n                     :working-dir   \".repl\"\n                     :serve-static  true\n                     :static-dir    [\".\" \"out/\"]}\n                    opts)]\n    (do (swap! server-state\n               (fn [old] (assoc old :client-js\n                               (future (create-client-js-file\n                                        opts\n                                        (io/file (:working-dir opts) \"client.js\"))))))\n        opts)))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [337 349]},
                                         :full-name "cljs.repl.browser/repl-env",
                                         :full-name-encode "cljs.repl.browser_repl-env",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/butlast" {:description "Returns a sequence of all but the last item in `s`.\n\n`butlast` runs in linear time.",
                                :ns "cljs.core",
                                :name "butlast",
                                :signature ["[s]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/first"
                                          "cljs.core/rest"
                                          "cljs.core/last"
                                          "cljs.core/next"
                                          "cljs.core/drop-last"
                                          "cljs.core/take-last"],
                                :full-name-encode "cljs.core_butlast",
                                :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5292 5296]},
                                :examples [{:id "7a4676",
                                            :content "```clj\n(butlast [1 2 3])\n;;=> (1 2)\n\n(butlast [1 2])\n;;=> (1)\n\n(butlast [1])\n;;=> nil\n\n(butlast [])\n;;=> nil\n```"}],
                                :full-name "cljs.core/butlast",
                                :clj-symbol "clojure.core/butlast"},
           "cljs.core/print-str" {:ns "cljs.core",
                                  :name "print-str",
                                  :signature ["[& objs]"],
                                  :history [["+" "0.0-1011"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_print-str",
                                  :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [5726 5729]},
                                  :full-name "cljs.core/print-str",
                                  :clj-symbol "clojure.core/print-str",
                                  :docstring "print to a string, returning it"},
           "cljs.core/hash" {:ns "cljs.core",
                             :name "hash",
                             :signature ["[o]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_hash",
                             :source {:code "(defn hash [o]\n  (-hash o))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [719 720]},
                             :full-name "cljs.core/hash",
                             :clj-symbol "clojure.core/hash"},
           "cljs.core/bit-set" {:description "Set bit at index `n`.  Same as `x | (1 << y)` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-set",
                                :signature ["[x n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-clear"],
                                :full-name-encode "cljs.core_bit-set",
                                :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1178 1181]},
                                :extra-sources ({:code "(defmacro bit-set [x n]\n  (list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [232 233]}),
                                :examples [{:id "6a8a49",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-set 2r1100 1)\n;;=> 14\n;; 14 = 2r1110\n```\n\nSame number in decimal:\n\n```clj\n(bit-set 12 1)\n;;=> 14\n```"}],
                                :full-name "cljs.core/bit-set",
                                :clj-symbol "clojure.core/bit-set",
                                :docstring "Set bit at index n"},
           "cljs.core/concat" {:description "Returns a lazy sequence representing the concatenation of the elements in the\nsupplied collections.",
                               :ns "cljs.core",
                               :name "concat",
                               :signature ["[]"
                                           "[x]"
                                           "[x y]"
                                           "[x y & zs]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/conj"
                                         "cljs.core/into"],
                               :full-name-encode "cljs.core_concat",
                               :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (cons (first s) (concat (rest s) y))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (cons (first xys) (cat (rest xys) zs))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1688 1706]},
                               :full-name "cljs.core/concat",
                               :clj-symbol "clojure.core/concat",
                               :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
           "cljs.core/conj" {:description "conj(oin)\n\nReturns a new collection with the `x`s \"added\" to `coll`.\n\nThe \"addition\" may happen at different \"places\" depending on the collection\ntype.\n\n`(conj nil item)` returns `(item)`.",
                             :ns "cljs.core",
                             :name "conj",
                             :signature ["[]"
                                         "[coll]"
                                         "[coll x]"
                                         "[coll x & xs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/cons"
                                       "cljs.core/into"
                                       "cljs.core/peek"
                                       "cljs.core/pop"],
                             :full-name-encode "cljs.core_conj",
                             :source {:code "(defn conj\n  ([coll x]\n     (-conj coll x))\n  ([coll x & xs]\n     (if xs\n       (recur (conj coll x) (first xs) (next xs))\n       (conj coll x))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [585 594]},
                             :full-name "cljs.core/conj",
                             :clj-symbol "clojure.core/conj",
                             :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
           "clojure.set/difference" {:description "Return a set that is the first set without elements of the remaining sets.",
                                     :ns "clojure.set",
                                     :name "difference",
                                     :signature ["[s1]"
                                                 "[s1 s2]"
                                                 "[s1 s2 & sets]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["clojure.set/union"
                                               "clojure.set/intersection"
                                               "clojure.set/superset?"
                                               "clojure.set/project"],
                                     :full-name-encode "clojure.set_difference",
                                     :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [46 58]},
                                     :full-name "clojure.set/difference",
                                     :clj-symbol "clojure.set/difference",
                                     :docstring "Return a set that is the first set without elements of the remaining sets"},
           "cljs.core/when-first" {:description "With `bindings` as `x`, `xs`, roughly the same as `(when (seq xs) (let [x (first\nxs)] body))` but `xs` is evaluated only once.",
                                   :ns "cljs.core",
                                   :name "when-first",
                                   :signature ["[bindings & body]"],
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core_when-first",
                                   :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when (seq ~xs)\n       (let [~x (first ~xs)]\n         ~@body))))",
                                            :repo "clojure",
                                            :tag "clojure-1.4.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [4054 4066]},
                                   :full-name "cljs.core/when-first",
                                   :clj-symbol "clojure.core/when-first",
                                   :docstring "bindings => x xs\n\nSame as (when (seq xs) (let [x (first xs)] body))"},
           "cljs.core/distinct?" {:description "Returns true if no two of the arguments are `=`",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "distinct?",
                                  :signature ["[x]"
                                              "[x y]"
                                              "[x y & more]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/distinct"],
                                  :full-name-encode "cljs.core_distinctQMARK",
                                  :source {:code "(defn ^boolean distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [883 897]},
                                  :examples [{:id "b32799",
                                              :content "```clj\n(distinct? 1)\n;;=> true\n\n(distinct? 1 2)\n;;=> true\n\n(distinct? 1 1)\n;;=> false\n\n(distinct? 1 2 3)\n;;=> true\n\n(distinct? 1 2 1)\n;;=> false\n```\n\nApply it a collection:\n\n```clj\n(apply distinct? [1 2 3])\n;;=> true\n\n(apply distinct? [1 2 1])\n;;=> false\n```"}],
                                  :full-name "cljs.core/distinct?",
                                  :clj-symbol "clojure.core/distinct?",
                                  :docstring "Returns true if no two of the arguments are ="},
           "syntax/set" {:description "Signifies a literal set.  Values must be unique.",
                         :ns "syntax",
                         :name "set",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["cljs.core/hash-set"
                                   "cljs.core/sorted-set"
                                   "cljs.core/sorted-set-by"],
                         :full-name-encode "syntax_set",
                         :source {:repo "clojure",
                                  :tag "clojure-1.4.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "#{}",
                         :examples [{:id "f11ab6",
                                     :content "```clj\n#{1 2 3}\n;;=> #{1 2 3}\n```\n\nDuplicate values will cause an error:\n\n```clj\n#{1 1 2 3}\n;; Error: Duplicate key: 1\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#sets",
                         :full-name "syntax/set",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.repl.rhino/repl-env" {:ns "cljs.repl.rhino",
                                       :name "repl-env",
                                       :signature ["[]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.rhino_repl-env",
                                       :source {:code "(defn repl-env\n  []\n  (let [cx (Context/enter)\n        scope (.initStandardObjects cx)\n        base (io/resource \"goog/base.js\")\n        deps (io/resource \"goog/deps.js\")\n        new-repl-env {:cx cx :scope scope}]\n    (assert base \"Can't find goog/base.js in classpath\")\n    (assert deps \"Can't find goog/deps.js in classpath\")\n    (swap! current-repl-env (fn [old] new-repl-env))\n    (with-open [r (io/reader base)]\n      (-eval r new-repl-env \"goog/base.js\" 1))\n    (-eval bootjs new-repl-env \"bootjs\" 1)\n    ;; Load deps.js line-by-line to avoid 64K method limit\n    (doseq [^String line (line-seq (io/reader deps))]\n      (-eval line new-repl-env \"goog/deps.js\" 1))\n    new-repl-env))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/clj/cljs/repl/rhino.clj",
                                                :lines [122 140]},
                                       :full-name "cljs.repl.rhino/repl-env",
                                       :docstring "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls."},
           "cljs.core/HashCollisionNode" {:ns "cljs.core",
                                          :name "HashCollisionNode",
                                          :signature ["[edit collision-hash cnt arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_HashCollisionNode",
                                          :source {:code "(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (let [len (.-length arr)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (aset added-leaf? 0 true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (= (aget arr idx) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (== idx -1) inode\n            (== cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-find [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              nil\n            (= key (aget arr idx)) [(aget arr idx) (aget arr (inc idx))]\n            :else                  nil)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (= key (aget arr idx)) [(aget arr idx) (aget arr (inc idx))]\n            :else                  not-found)))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (if (> (.-length arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (aset added-leaf? 0 true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (.-length arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (aset added-leaf? 0 true)\n              (.ensure-editable inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (== idx -1)\n        inode\n        (do (aset removed-leaf? 0 true)\n            (if (== cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [3899 3995]},
                                          :full-name "cljs.core/HashCollisionNode",
                                          :clj-symbol "clojure.lang/HashCollisionNode"},
           "cljs.core/pos?" {:description "Returns true if `n` is greater than 0, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "pos?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/neg?"
                                       "cljs.core/zero?"],
                             :full-name-encode "cljs.core_posQMARK",
                             :source {:code "(defn ^boolean pos?\n  [n] (cljs.core/pos? n))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1221 1223]},
                             :extra-sources ({:code "(defmacro pos? [x]\n  `(> ~x 0))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [171 172]}),
                             :full-name "cljs.core/pos?",
                             :clj-symbol "clojure.core/pos?",
                             :docstring "Returns true if num is greater than zero, else false"},
           "cljs.core/into-array" {:description "Returns a new JavaScript array from the elements of `aseq`.",
                                   :ns "cljs.core",
                                   :name "into-array",
                                   :signature ["[aseq]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/to-array"
                                             "cljs.core/make-array"],
                                   :full-name-encode "cljs.core_into-array",
                                   :source {:code "(defn into-array\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [108 112]},
                                   :full-name "cljs.core/into-array",
                                   :clj-symbol "clojure.core/into-array"},
           "syntax/tagged-literal" {:ns "syntax",
                                    :name "tagged-literal",
                                    :history [["+" "0.0-1211"]],
                                    :type "syntax",
                                    :full-name-encode "syntax_tagged-literal",
                                    :source {:repo "clojure",
                                             :tag "clojure-1.4.0",
                                             :filename "src/jvm/clojure/lang/LispReader.java",
                                             :lines [nil]},
                                    :syntax-form "#",
                                    :edn-doc "https://github.com/edn-format/edn#tagged-elements",
                                    :full-name "syntax/tagged-literal",
                                    :clj-doc "http://clojure.org/reader#toc4"},
           "cljs.core/PersistentVector" {:ns "cljs.core",
                                         :name "PersistentVector",
                                         :signature ["[meta cnt shift root tail __hash]"],
                                         :history [["+" "0.0-1006"]],
                                         :type "type",
                                         :full-name-encode "cljs.core_PersistentVector",
                                         :source {:code "(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentVector. meta cnt shift root tail __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (== 1 cnt) (-with-meta cljs.core.PersistentVector/EMPTY meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) cljs.core.PersistentVector/EMPTY_NODE nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [new-tail (aclone tail)]\n        (.push new-tail o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (> (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentVector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (vector-seq coll 0))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IMapEntry\n  (-key [coll]\n    (-nth coll 0))\n  (-val [coll]\n    (-nth coll 1))\n\n  IAssociative\n  (-assoc [coll k v]\n    (cond\n       (and (<= 0 k) (< k cnt))\n       (if (<= (tail-off coll) k)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and k 0x01f) v)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root k v) tail nil))\n       (== k cnt) (-conj coll v)\n       :else (throw (js/Error. (str \"Index \" k \" out of bounds  [0,\" cnt \"]\")))))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce v f))\n  (-reduce [v f start]\n    (ci-reduce v f start))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (let [step-init (array 0 init)] ; [step 0 init init]\n      (loop [i 0]\n        (if (< i cnt)\n          (let [arr (array-for v i)\n                len (.-length arr)]\n            (let [init (loop [j 0 init (aget step-init 1)]\n                         (if (< j len)\n                           (let [init (f init (+ j i) (aget arr j))]\n                             (if (reduced? init)\n                               init\n                               (recur (inc j) init)))\n                           (do (aset step-init 0 len)\n                               (aset step-init 1 init)\n                               init)))]\n              (if (reduced? init)\n                @init\n                (recur (+ i (aget step-init 0))))))\n          (aget step-init 1)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail))))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2530 2660]},
                                         :full-name "cljs.core/PersistentVector",
                                         :clj-symbol "clojure.lang/PersistentVector"},
           "cljs.core/IHash" {:ns "cljs.core",
                              :name "IHash",
                              :type "protocol",
                              :full-name-encode "cljs.core_IHash",
                              :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [208 209]},
                              :methods [{:name "-hash",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IHash",
                              :history [["+" "0.0-927"]]},
           "cljs.core/is_proto_" {:ns "cljs.core",
                                  :name "is_proto_",
                                  :type "function",
                                  :signature ["[x]"],
                                  :source {:code "(defn is_proto_\n  [x]\n  (js* \"(~{x}).constructor.prototype === ~{x}\"))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [52 54]},
                                  :full-name "cljs.core/is_proto_",
                                  :full-name-encode "cljs.core_is_proto_",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/TransientVector" {:ns "cljs.core",
                                        :name "TransientVector",
                                        :signature ["[cnt shift root tail]"],
                                        :history [["+" "0.0-1211"]],
                                        :type "type",
                                        :full-name-encode "cljs.core_TransientVector",
                                        :source {:code "(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if (.-edit root)\n      (if (< (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (> (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (-assoc-n! tcoll key val))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if (.-edit root)\n      (cond\n        (and (<= 0 n) (< n cnt))\n        (if (<= (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (== n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str \"Index \" n \" out of bounds for TransientVector of length\" cnt))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [tcoll]\n    (if (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n        (== 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if (coercive-not= nr nil)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (< 5 shift) (coercive-= (pv-aget new-root 1) nil))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. \"pop! after persistent!\"))))\n\n  ICounted\n  (-count [coll]\n    (if (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. \"nth after persistent!\"))))\n\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [2821 2945]},
                                        :full-name "cljs.core/TransientVector",
                                        :clj-symbol "clojure.lang/TransientVector"},
           "cljs.core/keep-indexed" {:description "Returns a lazy sequence of the non-nil results of `(f index item)`. Note, this\nmeans false return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a stateful transducer when no collection is provided.",
                                     :ns "cljs.core",
                                     :name "keep-indexed",
                                     :signature ["[f]" "[f coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/map-indexed"
                                               "cljs.core/keep"],
                                     :full-name-encode "cljs.core_keep-indexed",
                                     :source {:code "(defn keep-indexed\n  ([f coll]\n     (let [keepi (fn kpi [idx coll]\n                   (lazy-seq\n                    (when-let [s (seq coll)]\n                      (let [x (f idx (first s))]\n                        (if (nil? x)\n                          (kpi (inc idx) (rest s))\n                          (cons x (kpi (inc idx) (rest s))))))))]\n       (keepi 0 coll))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1957 1969]},
                                     :full-name "cljs.core/keep-indexed",
                                     :clj-symbol "clojure.core/keep-indexed",
                                     :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
           "cljs.core/bit-shift-right" {:description "Bitwise shift right `n` bits.  Same as `x >> n` in JavaScript.",
                                        :ns "cljs.core",
                                        :name "bit-shift-right",
                                        :signature ["[x n]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :related ["cljs.core/bit-shift-left"
                                                  "cljs.core/unsigned-bit-shift-right"],
                                        :full-name-encode "cljs.core_bit-shift-right",
                                        :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [1192 1194]},
                                        :extra-sources ({:code "(defmacro bit-shift-right [x n]\n  (list 'js* \"(~{} >> ~{})\" x n))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [226
                                                                 227]}),
                                        :examples [{:id "5b75af",
                                                    :content "Bits can be entered using radix notation:\n\n```clj\n(bit-shift-right 2r1010 1)\n;;=> 5\n;; 5 = 2r0101\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-shift-right 10 1)\n;;=> 5\n```"}],
                                        :full-name "cljs.core/bit-shift-right",
                                        :clj-symbol "clojure.core/bit-shift-right",
                                        :docstring "Bitwise shift right"},
           "cljs.core/PersistentTreeSet" {:ns "cljs.core",
                                          :name "PersistentTreeSet",
                                          :signature ["[meta tree-map __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_PersistentTreeSet",
                                          :source {:code "(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeSet. meta tree-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentTreeSet/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-iset __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (map key (rseq tree-map)))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? tree-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5173 5239]},
                                          :full-name "cljs.core/PersistentTreeSet",
                                          :clj-symbol "clojure.lang/PersistentTreeSet"},
           "clojure.zip/insert-right" {:ns "clojure.zip",
                                       :name "insert-right",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_insert-right",
                                       :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [174 181]},
                                       :full-name "clojure.zip/insert-right",
                                       :clj-symbol "clojure.zip/insert-right",
                                       :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
           "cljs.core/make-hierarchy" {:ns "cljs.core",
                                       :name "make-hierarchy",
                                       :signature ["[]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core_make-hierarchy",
                                       :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [6129 6131]},
                                       :full-name "cljs.core/make-hierarchy",
                                       :clj-symbol "clojure.core/make-hierarchy",
                                       :docstring "Creates a hierarchy object for use with derive, isa? etc."},
           "cljs.core/repeat" {:description "Returns a lazy sequence of `x`s.\n\nThe length of the sequence is infinite, or `n` if provided.",
                               :ns "cljs.core",
                               :name "repeat",
                               :signature ["[x]" "[n x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/repeatedly"
                                         "cljs.core/cycle"
                                         "cljs.core/constantly"
                                         "cljs.core/dotimes"],
                               :full-name-encode "cljs.core_repeat",
                               :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2134 2137]},
                               :full-name "cljs.core/repeat",
                               :clj-symbol "clojure.core/repeat",
                               :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
           "syntax/syntax-quote" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nPrevent evaluation of the following form.\n\nAdds namespace-qualification to any symbols inside the following form by\nresolving them in the current context.\n\nAny non-namespaced symbols ending with `#` will resolve to a generated symbol\nof the same name with `_` and a unique ID appended.  All references to that\nsymbol within a syntax-quoted expression will resolve to the same generated\nsymbol.",
                                  :ns "syntax",
                                  :name "syntax-quote",
                                  :history [["+" "0.0-927"]],
                                  :type "syntax",
                                  :related ["syntax/quote"
                                            "syntax/unquote"
                                            "syntax/unquote-splicing"],
                                  :full-name-encode "syntax_syntax-quote",
                                  :source {:repo "clojure",
                                           :tag "clojure-1.4.0",
                                           :filename "src/jvm/clojure/lang/LispReader.java",
                                           :lines [nil]},
                                  :syntax-form "`",
                                  :examples [{:id "bffbdf",
                                              :content "```clj\n`foo\n;;=> cljs.user/foo\n\n`foo#\n;;=> foo__20418__auto__\n\n`(def foo 1)\n;;=> (def cljs.user/foo 1)\n```"}],
                                  :full-name "syntax/syntax-quote",
                                  :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.repl.rhino/goog-require" {:ns "cljs.repl.rhino",
                                           :name "goog-require",
                                           :type "function",
                                           :signature ["[rule]"],
                                           :source {:code "(defn goog-require [rule]\n  (when-not (contains? @loaded-libs rule)\n    (let [repl-env @current-repl-env\n          path (string/replace (comp/munge rule) \\. java.io.File/separatorChar)\n          cljs-path (str path \".cljs\")\n          js-path (str \"goog/\"\n                       (-eval (str \"goog.dependencies_.nameToPath['\" rule \"']\")\n                              repl-env\n                              \"<cljs repl>\"\n                              1))]\n      (if-let [res (io/resource cljs-path)]\n        (binding [comp/*cljs-ns* 'cljs.user]\n          (repl/load-stream repl-env res))\n        (if-let [res (io/resource js-path)]\n          (-eval (io/reader res) repl-env js-path 1)\n          (throw (Exception. (str \"Cannot find \" cljs-path \" or \" js-path \" in classpath\")))))\n      (swap! loaded-libs conj rule))))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/clj/cljs/repl/rhino.clj",
                                                    :lines [68 84]},
                                           :full-name "cljs.repl.rhino/goog-require",
                                           :full-name-encode "cljs.repl.rhino_goog-require",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/prn-str-with-opts" {:ns "cljs.core",
                                          :name "prn-str-with-opts",
                                          :signature ["[objs opts]"],
                                          :history [["+" "0.0-1011"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_prn-str-with-opts",
                                          :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (let [sb (pr-sb objs opts)]\n    (.append sb \\newline)\n    (str sb)))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5667 5672]},
                                          :full-name "cljs.core/prn-str-with-opts",
                                          :docstring "Same as pr-str-with-opts followed by (newline)"},
           "cljs.core/MultiFn" {:ns "cljs.core",
                                :name "MultiFn",
                                :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core_MultiFn",
                                :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n\n  (-dispatch [mf args] (do-dispatch mf dispatch-fn args))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6307 6354]},
                                :full-name "cljs.core/MultiFn",
                                :clj-symbol "clojure.lang/MultiFn"},
           "cljs.core/Reduced" {:ns "cljs.core",
                                :name "Reduced",
                                :type "type",
                                :signature ["[val]"],
                                :source {:code "(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [996 998]},
                                :full-name "cljs.core/Reduced",
                                :full-name-encode "cljs.core_Reduced",
                                :history [["+" "0.0-1211"]]},
           "cljs.core/not-any?" {:description "Returns false if `(pred x)` is logical true for any `x` in `coll`, else true.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "not-any?",
                                 :signature ["[pred coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/every?"
                                           "cljs.core/some"],
                                 :full-name-encode "cljs.core_not-anyQMARK",
                                 :source {:code "(defn ^boolean not-any?\n  [pred coll] (not (some pred coll)))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1836 1839]},
                                 :full-name "cljs.core/not-any?",
                                 :clj-symbol "clojure.core/not-any?",
                                 :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
           "cljs.reader/read-regex" {:ns "cljs.reader",
                                     :name "read-regex",
                                     :type "function",
                                     :signature ["[rdr ch]"],
                                     :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-string rdr ch) re-pattern))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [301 303]},
                                     :full-name "cljs.reader/read-regex",
                                     :full-name-encode "cljs.reader_read-regex",
                                     :history [["+" "0.0-927"]]},
           "clojure.zip/next" {:ns "clojure.zip",
                               :name "next",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_next",
                               :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [206 219]},
                               :full-name "clojure.zip/next",
                               :clj-symbol "clojure.zip/next",
                               :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
           "syntax/dispatch" {:ns "syntax",
                              :name "dispatch",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :full-name-encode "syntax_dispatch",
                              :source {:repo "clojure",
                                       :tag "clojure-1.4.0",
                                       :filename "src/jvm/clojure/lang/LispReader.java",
                                       :lines [nil]},
                              :syntax-form "#",
                              :edn-doc "https://github.com/edn-format/edn#-dispatch-character",
                              :full-name "syntax/dispatch",
                              :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/IFn" {:ns "cljs.core",
                            :name "IFn",
                            :history [["+" "0.0-971"]],
                            :type "protocol",
                            :full-name-encode "cljs.core_IFn",
                            :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q s]\n    [this a b c d e f g h i j k l m n o p q s t]\n    [this a b c d e f g h i j k l m n o p q s t rest]))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [116 138]},
                            :methods [{:name "-invoke",
                                       :signature ["[this]"
                                                   "[this a]"
                                                   "[this a b]"
                                                   "[this a b c]"
                                                   "[this a b c d]"
                                                   "[this a b c d e]"
                                                   "[this a b c d e f]"
                                                   "[this a b c d e f g]"
                                                   "[this a b c d e f g h]"
                                                   "[this a b c d e f g h i]"
                                                   "[this a b c d e f g h i j]"
                                                   "[this a b c d e f g h i j k]"
                                                   "[this a b c d e f g h i j k l]"
                                                   "[this a b c d e f g h i j k l m]"
                                                   "[this a b c d e f g h i j k l m n]"
                                                   "[this a b c d e f g h i j k l m n o]"
                                                   "[this a b c d e f g h i j k l m n o p]"
                                                   "[this a b c d e f g h i j k l m n o p q]"
                                                   "[this a b c d e f g h i j k l m n o p q s]"
                                                   "[this a b c d e f g h i j k l m n o p q s t]"
                                                   "[this a b c d e f g h i j k l m n o p q s t rest]"],
                                       :docstring nil}],
                            :full-name "cljs.core/IFn",
                            :clj-symbol "clojure.lang/IFn"},
           "cljs.core/aget" {:description "Returns the value at index `i` from JavaScript arrays and objects.\n\nCan be used to retrieve nested properties with the additional `idxs` arguments.",
                             :ns "cljs.core",
                             :name "aget",
                             :signature ["[array i]"
                                         "[array i & idxs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/.."
                                       "cljs.core/aset"
                                       "cljs.core/get"
                                       "cljs.core/nth"],
                             :full-name-encode "cljs.core_aget",
                             :source {:code "(defn aget\n  ([array i]\n     (cljs.core/aget array i))\n  ([array i & idxs]\n     (apply aget (aget array i) idxs)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [89 94]},
                             :extra-sources ({:code "(defmacro aget\n  ([a i]\n     (list 'js* \"(~{}[~{}])\" a i))\n  ([a i & idxs]\n     (let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n      `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~a ~i ~@idxs))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [105 110]}),
                             :examples [{:id "e36007",
                                         :content "```js\n// JavaScript\nvar a = {\"foo\": [5, 6]};\n\na[\"foo\"];\n//=> [5, 6]\n\na[\"foo\"][0];\n//=> 5\n```\n\n```clj\n;; ClojureScript\n(def a #js {:foo #js [5 6]})\n\n(aget a \"foo\")\n;;=> #js [5 6]\n\n(aget a \"foo\" 0)\n;;=> 5\n```"}
                                        {:id "c9029e",
                                         :content "```js\n// JavaScript\ndocument.location.href;\n//=> \"http://example.com\"\n```\n\nThe following are equivalent:\n\n```clj\n;; ClojureScript\n(aget js/document \"location\" \"href\")\n;;=> \"http://example.com\"\n\n(.. js/document -location -href)\n;;=> \"http://example.com\"\n```"}],
                             :full-name "cljs.core/aget",
                             :clj-symbol "clojure.core/aget",
                             :docstring "Returns the value at the index."},
           "cljs.core/if-let" {:description "When `test` is logical true, evaluates `then` with the value of `test` bound to\n`x`. Otherwise, evaluates `else` with no bindings.\n\n`else` defaults to nil.",
                               :ns "cljs.core",
                               :name "if-let",
                               :signature ["[[x test] then]"
                                           "[[x test] then else]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :related ["cljs.core/when-let"
                                         "special/if"],
                               :full-name-encode "cljs.core_if-let",
                               :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (and (vector? bindings) (nil? oldform)) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                        :repo "clojure",
                                        :tag "clojure-1.4.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [1668 1685]},
                               :full-name "cljs.core/if-let",
                               :clj-symbol "clojure.core/if-let",
                               :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
           "cljs.core//" {:description "If no denominators are supplied, returns 1/numerator, else returns numerator\ndivided by all of the denominators.",
                          :ns "cljs.core",
                          :name "/",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/*" "cljs.core/quot"],
                          :full-name-encode "cljs.core_SLASH",
                          :source {:code "(defn /\n  ([x] (/ 1 x))\n  ([x y] (js* \"(~{x} / ~{y})\")) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1034 1039]},
                          :extra-sources ({:code "(defmacro /\n  ([x] `(/ 1 ~x))\n  ([x y] (list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [132 135]}),
                          :examples [{:id "824bb7",
                                      :content "```clj\n(/ 6 3)\n;;=> 2\n\n(/ 6 3 2)\n;;=> 1\n\n(/ 10)\n;;=> 0.1\n\n(/ 1 3)\n;;=> 0.3333333333333333\n```"}],
                          :full-name "cljs.core//",
                          :clj-symbol "clojure.core//",
                          :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/min-key" {:description "Returns the `x` for which `(k x)` is least.\n\n`(k x)` should return a number.",
                                :ns "cljs.core",
                                :name "min-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/min"
                                          "cljs.core/max-key"],
                                :full-name-encode "cljs.core_min-key",
                                :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5338 5343]},
                                :full-name "cljs.core/min-key",
                                :clj-symbol "clojure.core/min-key",
                                :docstring "Returns the x for which (k x), a number, is least."},
           "clojure.zip/root" {:ns "clojure.zip",
                               :name "root",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_root",
                               :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [124 133]},
                               :full-name "clojure.zip/root",
                               :clj-symbol "clojure.zip/root",
                               :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
           "cljs.core/drop-while" {:description "Returns a lazy sequence of the items in `coll` starting from the first item for\nwhich `(pred item)` returns logical false.\n\nReturns a stateful transducer when no collection is provided.",
                                   :ns "cljs.core",
                                   :name "drop-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/take-while"
                                             "cljs.core/split-with"],
                                   :full-name-encode "cljs.core_drop-while",
                                   :source {:code "(defn drop-while\n  [pred coll]\n  (let [step (fn [pred coll]\n               (let [s (seq coll)]\n                 (if (and s (pred (first s)))\n                   (recur pred (rest s))\n                   s)))]\n    (lazy-seq (step pred coll))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2112 2121]},
                                   :full-name "cljs.core/drop-while",
                                   :clj-symbol "clojure.core/drop-while",
                                   :docstring "Returns a lazy sequence of the items in coll starting from the first\nitem for which (pred item) returns nil."},
           "cljs.repl.browser/send-repl-client-page" {:ns "cljs.repl.browser",
                                                      :name "send-repl-client-page",
                                                      :type "function",
                                                      :signature ["[opts conn request]"],
                                                      :source {:code "(defn send-repl-client-page\n  [opts conn request]\n  (send-and-close conn 200\n    (str \"<html><head><meta charset=\\\"UTF-8\\\"></head><body>\n          <script type=\\\"text/javascript\\\">\"\n         (repl-client-js)\n         \"</script>\"\n         \"<script type=\\\"text/javascript\\\">\n          clojure.browser.repl.client.start(\\\"http://\" (-> request :headers :host) \"\\\");\n          </script>\"\n         \"</body></html>\")\n    \"text/html\"))",
                                                               :repo "clojurescript",
                                                               :tag "r1211",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [169
                                                                       180]},
                                                      :full-name "cljs.repl.browser/send-repl-client-page",
                                                      :full-name-encode "cljs.repl.browser_send-repl-client-page",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "clojure.browser.repl/evaluate-javascript" {:ns "clojure.browser.repl",
                                                       :name "evaluate-javascript",
                                                       :signature ["[conn block]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.repl_evaluate-javascript",
                                                       :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch js/Error e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                :repo "clojurescript",
                                                                :tag "r1211",
                                                                :filename "src/cljs/clojure/browser/repl.cljs",
                                                                :lines [27
                                                                        36]},
                                                       :full-name "clojure.browser.repl/evaluate-javascript",
                                                       :docstring "Process a single block of JavaScript received from the server"},
           "cljs.core/set-validator!" {:description "Sets a validator function for atom `a`.\n\n`fn` must be nil or a side-effect-free function of one argument, which will be\npassed the intended new state on any state change. `fn` should return false or\nthrow an Error if the new state is unacceptable.\n\nIf the current value of `a` is unacceptable to `fn` when `set-validator!` is\ncalled, an Error will be thrown and the validator will not be set.\n\n`(set-validator! my-atom nil)` will remove the validator from `my-atom`.",
                                       :ns "cljs.core",
                                       :name "set-validator!",
                                       :signature ["[a fn]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["cljs.core/atom"
                                                 "cljs.core/get-validator"],
                                       :full-name-encode "cljs.core_set-validatorBANG",
                                       :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [5943 5951]},
                                       :full-name "cljs.core/set-validator!",
                                       :clj-symbol "clojure.core/set-validator!",
                                       :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
           "cljs.core/<" {:description "Returns true if each successive number argument is greater than the previous\none, false otherwise.",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name "<",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/<="],
                          :full-name-encode "cljs.core_LT",
                          :source {:code "(defn ^boolean <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1041 1051]},
                          :extra-sources ({:code "(defmacro <\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [137 140]}),
                          :examples [{:id "02e6d3",
                                      :content "```clj\n(< 1 2)\n;;=> true\n\n(< 2 1)\n;;=> false\n\n(< 1 1)\n;;=> false\n\n(< 2 3 4 5 6)\n;;=> true\n```"}],
                          :full-name "cljs.core/<",
                          :clj-symbol "clojure.core/<",
                          :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
           "cljs.core/fn" {:description "Defines a function.\n\n`name?` is an optional name of the function to be used inside `body`. This is\nuseful for recursive calls. Note that `name?` in `fn` is not the same as the\n`name` argument to `defn`, which defines a global symbol for the function.\n\n`params*` are the arguments to the function and a binding form for the symbols\nthat the arguments will take inside the body of the function. Functions can have\narity of 0-20 and there is no runtime enforcement of arity when calling a\nfunction (just like in JavaScript).\n\n`prepost-map?` is an optional map with optional keys `:pre` and `:post` that\ncontain collections of [pre or post conditions](http://blog.fogus.me/2009/12/21/clojures-pre-and-post/)\nfor the function.\n\n`body` is a series of expressions that execute when the function is called. The\narguments to the function are mapped to symbols in `params*` and are available\nin `body`. The value of the last expression in `body` is the return value of\ncalling the function.",
                           :ns "cljs.core",
                           :name "fn",
                           :signature ["[name? [params*] prepost-map? body]"
                                       "[name? ([params*] prepost-map? body)+]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/defn"
                                     "cljs.core/defn-"],
                           :full-name-encode "cljs.core_fn",
                           :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) (list sigs) sigs)\n          psig (fn* [sig]\n                 (let [[params & body] sig\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                    :repo "clojure",
                                    :tag "clojure-1.4.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [3989 4027]},
                           :extra-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n fn (fn* fn [&form &env & decl] \n         (.withMeta ^clojure.lang.IObj (cons 'fn* decl) \n                    (.meta ^clojure.lang.IMeta &form))))",
                                            :repo "clojure",
                                            :tag "clojure-1.4.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [42 47]}),
                           :full-name "cljs.core/fn",
                           :clj-symbol "clojure.core/fn",
                           :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
           "cljs.core/split-with" {:description "Returns a vector of `[(take-while pred coll) (drop-while pred coll)]`",
                                   :ns "cljs.core",
                                   :name "split-with",
                                   :signature ["[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/split-at"
                                             "clojure.string/split"
                                             "cljs.core/take-while"
                                             "cljs.core/drop-while"],
                                   :full-name-encode "cljs.core_split-with",
                                   :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [5477 5480]},
                                   :full-name "cljs.core/split-with",
                                   :clj-symbol "clojure.core/split-with",
                                   :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
           "cljs.core/IReduce" {:ns "cljs.core",
                                :name "IReduce",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IReduce",
                                :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [199 200]},
                                :methods [{:name "-reduce",
                                           :signature ["[coll f]"
                                                       "[coll f start]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IReduce",
                                :clj-symbol "clojure.lang/IReduce"},
           "cljs.reader/symbol-pattern" {:ns "cljs.reader",
                                         :name "symbol-pattern",
                                         :type "var",
                                         :source {:code "(def symbol-pattern (re-pattern \"[:]?([^0-9/].*/)?([^0-9/][^/]*)\"))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [98]},
                                         :full-name "cljs.reader/symbol-pattern",
                                         :full-name-encode "cljs.reader_symbol-pattern",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/repeatedly" {:description "Takes a function `f` of no args, presumably with side effects, and returns an\ninfinite (or length `n` if supplied) lazy sequence of calls to it.",
                                   :ns "cljs.core",
                                   :name "repeatedly",
                                   :signature ["[f]" "[n f]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/repeat"
                                             "cljs.core/iterate"
                                             "cljs.core/lazy-seq"
                                             "cljs.core/dotimes"
                                             "cljs.core/constantly"],
                                   :full-name-encode "cljs.core_repeatedly",
                                   :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2143 2148]},
                                   :full-name "cljs.core/repeatedly",
                                   :clj-symbol "clojure.core/repeatedly",
                                   :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
           "cljs.reader/read-delimited-list" {:ns "cljs.reader",
                                              :name "read-delimited-list",
                                              :type "function",
                                              :signature ["[delim rdr recursive?]"],
                                              :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a []]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF\"))\n      (if (identical? delim ch)\n        a\n        (if-let [macrofn (get macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (= mret rdr) a (conj a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (= o rdr) a (conj a o))))))))))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/cljs/reader.cljs",
                                                       :lines [168
                                                               181]},
                                              :full-name "cljs.reader/read-delimited-list",
                                              :full-name-encode "cljs.reader_read-delimited-list",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/undefined?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "undefined?",
                                   :signature ["[x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_undefinedQMARK",
                                   :source {:code "(defn ^boolean undefined? [x]\n  (cljs.core/undefined? x))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [815 816]},
                                   :extra-sources ({:code "(defmacro undefined? [x]\n  (bool-expr (list 'js* \"(void 0 === ~{})\" x)))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [99 100]}),
                                   :full-name "cljs.core/undefined?"},
           "clojure.zip/prev" {:ns "clojure.zip",
                               :name "prev",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_prev",
                               :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [221 230]},
                               :full-name "clojure.zip/prev",
                               :clj-symbol "clojure.zip/prev",
                               :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
           "cljs.core/seq?" {:description "Returns true if `x` is a sequence, false otherwise.\n\nAll collections can be converted into a sequence using `seq`.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "seq?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/seq"
                                       "cljs.core/sequential?"
                                       "cljs.core/vector?"
                                       "cljs.core/coll?"
                                       "cljs.core/list?"
                                       "cljs.core/map?"
                                       "cljs.core/set?"],
                             :full-name-encode "cljs.core_seqQMARK",
                             :source {:code "(defn ^boolean seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [821 826]},
                             :full-name "cljs.core/seq?",
                             :clj-symbol "clojure.core/seq?",
                             :docstring "Return true if s satisfies ISeq"},
           "cljs.core/prn-str" {:ns "cljs.core",
                                :name "prn-str",
                                :signature ["[& objs]"],
                                :history [["+" "0.0-1011"]],
                                :type "function",
                                :full-name-encode "cljs.core_prn-str",
                                :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5706 5709]},
                                :full-name "cljs.core/prn-str",
                                :clj-symbol "clojure.core/prn-str",
                                :docstring "Same as pr-str followed by (newline)"},
           "cljs.core/odd?" {:description "Returns true if `n` is an odd number.\n\nThrows an exception if `n` is not an integer.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "odd?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/even?"],
                             :full-name-encode "cljs.core_oddQMARK",
                             :source {:code "(defn ^boolean odd?\n  [n] (not (even? n)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1847 1849]},
                             :full-name "cljs.core/odd?",
                             :clj-symbol "clojure.core/odd?",
                             :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
           "cljs.core/cons" {:description "Returns a new sequence where `x` is the first element and `coll` is the rest.",
                             :ns "cljs.core",
                             :name "cons",
                             :signature ["[x coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/conj"],
                             :full-name-encode "cljs.core_cons",
                             :source {:code "(defn cons\n  [x coll]\n  (if (or (coercive-= coll nil)\n          (satisfies? ISeq coll))\n    (Cons. nil x coll nil)\n    (Cons. nil x (seq coll) nil)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1484 1490]},
                             :full-name "cljs.core/cons",
                             :clj-symbol "clojure.core/cons",
                             :docstring "Returns a new seq where x is the first element and seq is the rest."},
           "syntax/function" {:description "Create an anonymous function.\n\n`#(...)` = `(fn [args] (...))`\n\nUse `%` or `%1` to access the first argument.  Use `%2`, `%3` and so on to\naccess subsequent arguments.  Use `%&` to access the rest of the arguments past\nthe highest individually referenced argument.\n\nNote that `#(1)` does not create a function that returns `1`, for the same\nreason that `(1)` does evaluate to `1`.\n\n`#()` forms cannot be nested, since this would create an ambiguity between the\nautomatically assigned argument names.",
                              :ns "syntax",
                              :name "function",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :related ["cljs.core/fn"
                                        "cljs.core/defn"],
                              :full-name-encode "syntax_function",
                              :source {:repo "clojure",
                                       :tag "clojure-1.4.0",
                                       :filename "src/jvm/clojure/lang/LispReader.java",
                                       :lines [nil]},
                              :syntax-form "#()",
                              :examples [{:id "6a87de",
                                          :content "```clj\n(map #(* 2 %) [1 2 3])\n;;=> (2 4 6)\n\n(def f #(println %1 %2 %&))\n(f 1 2 3 4 5)\n;; prints: 1 2 (3 4)\n```"}],
                              :full-name "syntax/function",
                              :clj-doc "http://clojure.org/reader#toc2"},
           "special/deftype*" {:ns "special",
                               :name "deftype*",
                               :type "special form",
                               :source {:code "(defmethod parse 'deftype*\n  [_ env [_ tsym fields pmasks :as form] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :deftype* :as form :t t :fields fields :pmasks pmasks}))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/clj/cljs/compiler.clj",
                                        :lines [1162 1173]},
                               :full-name "special/deftype*",
                               :full-name-encode "special_deftypeSTAR",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/read-set" {:ns "cljs.reader",
                                   :name "read-set",
                                   :type "function",
                                   :signature ["[rdr _]"],
                                   :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [297 299]},
                                   :full-name "cljs.reader/read-set",
                                   :full-name-encode "cljs.reader_read-set",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/descendants" {:ns "cljs.core",
                                    :name "descendants",
                                    :signature ["[tag]" "[h tag]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_descendants",
                                    :source {:code "(defn descendants\n  ([tag] (descendants @global-hierarchy tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [6173 6180]},
                                    :full-name "cljs.core/descendants",
                                    :clj-symbol "clojure.core/descendants",
                                    :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on JavaScript type inheritance\nrelationships."},
           "syntax/nil" {:description "`nil` is a representation of nothing.\n\nIt is common for operations to safely handle `nil` without\ncausing exceptions.\n\nExpressions evaluate to `nil` if there is no value to return.",
                         :ns "syntax",
                         :name "nil",
                         :history [["+" "0.0-927"]],
                         :type "special symbol",
                         :full-name-encode "syntax_nil",
                         :source {:repo "clojure",
                                  :tag "clojure-1.4.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "nil",
                         :examples [{:id "17b92a",
                                     :content "```clj\nnil\n;;=> nil\n```\n\n`nil` can sometimes mean \"not found\":\n\n```clj\n(:foo {})\n;;=> nil\n```\n\n`nil` can also mean that the operation didn't make sense:\n\n```clj\n(:foo nil)\n;;=> nil\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#nil",
                         :full-name "syntax/nil",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/map" {:description "Signifies a map.  Must contain pairs of key-values.  Keys and values can be any type.",
                         :ns "syntax",
                         :name "map",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["cljs.core/hash-map"
                                   "cljs.core/array-map"
                                   "cljs.core/sorted-map"
                                   "cljs.core/sorted-map-by"],
                         :full-name-encode "syntax_map",
                         :source {:repo "clojure",
                                  :tag "clojure-1.4.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "{}",
                         :examples [{:id "4696ad",
                                     :content "```clj\n{:foo 1 :bar 2}\n;;=> {:foo 1, :bar 2}\n```\n\nUse any value as a key:\n\n```clj\n(def m {[1 2] 3})\n(get m [1 2])\n;;=> 3\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#maps",
                         :full-name "syntax/map",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "special/new" {:ns "special",
                          :name "new",
                          :type "special form",
                          :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args :as form] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         argexprs (vec (map #(analyze enve %) args))]\n     {:env env :op :new :form form :ctor ctorexpr :args argexprs\n      :children (into [ctorexpr] argexprs)})))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [1055 1062]},
                          :full-name "special/new",
                          :full-name-encode "special_new",
                          :clj-symbol "clojure.core/new",
                          :history [["+" "0.0-927"]]},
           "cljs.core/take-nth" {:description "Returns a lazy seq of every `n`th item in `coll`.\n\nReturns a stateful transducer when no collection is provided.",
                                 :ns "cljs.core",
                                 :name "take-nth",
                                 :signature ["[n]" "[n coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_take-nth",
                                 :source {:code "(defn take-nth\n  [n coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s) (take-nth n (drop n s))))))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [5470 5475]},
                                 :full-name "cljs.core/take-nth",
                                 :clj-symbol "clojure.core/take-nth",
                                 :docstring "Returns a lazy seq of every nth item in coll."},
           "cljs.reader/throwing-reader" {:ns "cljs.reader",
                                          :name "throwing-reader",
                                          :type "function",
                                          :signature ["[msg]"],
                                          :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [282 285]},
                                          :full-name "cljs.reader/throwing-reader",
                                          :full-name-encode "cljs.reader_throwing-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.browser/send-static" {:ns "cljs.repl.browser",
                                            :name "send-static",
                                            :type "function",
                                            :signature ["[opts conn {path :path, :as request}]"],
                                            :source {:code "(defn send-static [opts conn {path :path :as request}]\n  (if (and (:static-dir opts)\n           (not= \"/favicon.ico\" path))\n    (let [path   (if (= \"/\" path) \"/index.html\" path)\n          st-dir (:static-dir opts)]\n      (if-let [local-path (seq (for [x (if (string? st-dir) [st-dir] st-dir)\n                                     :when (.exists (io/file (str x path)))]\n                                 (str x path)))]\n        (send-and-close conn 200 (slurp (first local-path))\n                        (condp #(.endsWith %2 %1) path\n                          \".js\" \"text/javascript\"\n                          \".html\" \"text/html\"\n                          \"text/plain\"))\n        (send-404 conn path)))\n    (send-404 conn path)))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [182 196]},
                                            :full-name "cljs.repl.browser/send-static",
                                            :full-name-encode "cljs.repl.browser_send-static",
                                            :history [["+" "0.0-1211"]]},
           "cljs.core/even?" {:description "Returns true if `n` is an even number.\n\nThrows an exception if `n` is not an integer.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "even?",
                              :signature ["[n]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/odd?"],
                              :full-name-encode "cljs.core_evenQMARK",
                              :source {:code "(defn ^boolean even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1841 1845]},
                              :full-name "cljs.core/even?",
                              :clj-symbol "clojure.core/even?",
                              :docstring "Returns true if n is even, throws an exception if n is not an integer"},
           "syntax/number" {:description "Signifies a number.  ClojureScript numbers are the same as JavaScript numbers;\nthey are represented as double-precision 64-bit format IEEE 754 values.",
                            :ns "syntax",
                            :name "number",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :full-name-encode "syntax_number",
                            :source {:repo "clojure",
                                     :tag "clojure-1.4.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form " ",
                            :examples [{:id "f96060",
                                        :content "```clj\n123\n;;=> 123\n\n123.45\n;;=> 123.45\n```\n\nScientific notation;\n\n```clj\n12e3\n;;=> 12000\n\n1.2e-3\n;;=> 0.0012\n```\n\nStandard hex and octal notations:\n\n```clj\n0x1f\n;;=> 31\n\n010\n;;=> 8\n```\n\nRadix notation for using up to base 36.\n\n```clj\n2r10111\n;;=> 23\n\n8r32\n;;=> 26\n\n16rFF\n;;=> 255\n\n36rZ\n;;=> 35\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#integers",
                            :full-name "syntax/number",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "special/fn*" {:ns "special",
                          :name "fn*",
                          :type "special form",
                          :source {:code "(defmethod parse 'fn*\n  [op env [_ & args :as form] name]\n  (let [[name meths] (if (symbol? (first args))\n                       [(first args) (next args)]\n                       [name (seq args)])\n        ;;turn (fn [] ...) into (fn ([]...))\n        meths (if (vector? (first meths)) (list meths) meths)\n        mname (when name (munge name))\n        locals (:locals env)\n        locals (if name (assoc locals name {:name mname}) locals)\n        menv (if (> (count meths) 1) (assoc env :context :expr) env)\n        methods (map #(analyze-fn-method menv locals %) meths)\n        max-fixed-arity (apply max (map :max-fixed-arity methods))\n        variadic (boolean (some :variadic methods))]\n    ;;todo - validate unique arities, at most one variadic, variadic takes max required args\n    {:env env :op :fn :form form :name mname :methods methods :variadic variadic\n     :recur-frames *recur-frames* :loop-lets *loop-lets*\n     :jsdoc [(when variadic \"@param {...*} var_args\")]\n     :max-fixed-arity max-fixed-arity\n     :children (vec (mapcat block-children\n                            methods))}))",
                                   :repo "clojurescript",
                                   :tag "r1211",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [969 989]},
                          :full-name "special/fn*",
                          :full-name-encode "special_fnSTAR",
                          :history [["+" "0.0-927"]]},
           "clojure.set/subset?" {:description "Returns true if `a` is a subset of `b`, false otherwise.\n\nIn other words, returns true if all the elements of `a` can be found in `b`.",
                                  :ns "clojure.set",
                                  :name "subset?",
                                  :signature ["[a b]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/set"
                                            "cljs.core/set?"
                                            "clojure.set/superset?"],
                                  :full-name-encode "clojure.set_subsetQMARK",
                                  :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [132 136]},
                                  :full-name "clojure.set/subset?",
                                  :clj-symbol "clojure.set/subset?",
                                  :docstring "Is set1 a subset of set2?"},
           "cljs.core/flush" {:ns "cljs.core",
                              :name "flush",
                              :signature ["[]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_flush",
                              :source {:code "(defn flush [] ;stub\n  nil)",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5629 5630]},
                              :full-name "cljs.core/flush",
                              :clj-symbol "clojure.core/flush"},
           "cljs.core/long-array" {:ns "cljs.core",
                                   :name "long-array",
                                   :signature ["[size-or-seq]"
                                               "[size init-val-or-seq]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_long-array",
                                   :source {:code "(defn long-array\n  ([size-or-seq]\n     (cond\n      (number? size-or-seq) (long-array size-or-seq nil)\n      (seq? size-or-seq) (into-array size-or-seq)\n      :else (throw (js/Error. \"long-array called with something other than size or ISeq\"))))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1609 1628]},
                                   :full-name "cljs.core/long-array",
                                   :clj-symbol "clojure.core/long-array"},
           "cljs.reader/reader-error" {:ns "cljs.reader",
                                       :name "reader-error",
                                       :type "function",
                                       :signature ["[rdr & msg]"],
                                       :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (apply str msg)))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [69 71]},
                                       :full-name "cljs.reader/reader-error",
                                       :full-name-encode "cljs.reader_reader-error",
                                       :history [["+" "0.0-927"]]},
           "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                           :name "prewalk-replace",
                                           :signature ["[smap form]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk_prewalk-replace",
                                           :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [80 86]},
                                           :full-name "clojure.walk/prewalk-replace",
                                           :clj-symbol "clojure.walk/prewalk-replace",
                                           :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
           "cljs.core/*1" {:description "Only usable from a REPL.\n\nHolds the result of the last expression.",
                           :ns "cljs.core",
                           :name "*1",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*2"
                                     "cljs.core/*3"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR1",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [25 27]},
                           :examples [{:id "30a861",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n*1\n;;=> 10\n\n(inc *1)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*1",
                           :clj-symbol "clojure.core/*1",
                           :docstring "bound in a repl thread to the most recent value printed"},
           "cljs.core/subseq" {:description "`sc` must be a sorted collection.\n\n`test`, `start-test`, `end-test` must be `<`, `<=`, `>` or `>=`.\n\nReturns a sequence of those entries with keys `ek` for which\n`(test (.. sc comparator (compare ek key)) 0)` is true.",
                               :ns "cljs.core",
                               :name "subseq",
                               :signature ["[sc test key]"
                                           "[sc start-test start-key end-test end-key]"],
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :related ["cljs.core/rsubseq"
                                         "cljs.core/sorted-map"
                                         "cljs.core/sorted-set"
                                         "cljs.core/sorted-map-by"
                                         "cljs.core/sorted-set-by"],
                               :full-name-encode "cljs.core_subseq",
                               :source {:code "(defn subseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{> >=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [5370 5383]},
                               :full-name "cljs.core/subseq",
                               :clj-symbol "clojure.core/subseq",
                               :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/Set.EMPTY" {:ns "cljs.core",
                                  :name "Set.EMPTY",
                                  :history [["+" "0.0-927"]
                                            ["-" "0.0-1211"]],
                                  :parent-type "Set",
                                  :type "var",
                                  :full-name-encode "cljs.core_SetDOTEMPTY",
                                  :source {:code "(set! cljs.core.Set/EMPTY (Set. nil (hash-map)))",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2708]},
                                  :full-name "cljs.core/Set.EMPTY",
                                  :removed {:in "0.0-1211",
                                            :last-seen "0.0-1011"}},
           "cljs.reader/read-unicode-char" {:ns "cljs.reader",
                                            :name "read-unicode-char",
                                            :type "function",
                                            :signature ["[reader initch]"],
                                            :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [145 147]},
                                            :full-name "cljs.reader/read-unicode-char",
                                            :full-name-encode "cljs.reader_read-unicode-char",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/dissoc" {:description "dissoc(iate)\n\nReturns a new map that does not contain a mapping for key(s).\n\nHas no effect on the map type (hashed/sorted).",
                               :ns "cljs.core",
                               :name "dissoc",
                               :signature ["[coll]"
                                           "[coll k]"
                                           "[coll k & ks]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/assoc"
                                         "cljs.core/disj"
                                         "cljs.core/select-keys"],
                               :full-name-encode "cljs.core_dissoc",
                               :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n     (-dissoc coll k))\n  ([coll k & ks]\n     (let [ret (dissoc coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [670 680]},
                               :examples [{:id "fd6ae9",
                                           :content "```clj\n(dissoc {:key \"value\" :key2 \"value2\"} :key)\n;;=> {:key2 \"value2\"}\n```"}],
                               :full-name "cljs.core/dissoc",
                               :clj-symbol "clojure.core/dissoc",
                               :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
           "cljs.core/ffirst" {:description "Same as `(first (first coll))`.",
                               :ns "cljs.core",
                               :name "ffirst",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/first"
                                         "cljs.core/fnext"
                                         "cljs.core/nfirst"],
                               :full-name-encode "cljs.core_ffirst",
                               :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [550 553]},
                               :examples [{:id "575ba2",
                                           :content "```clj\n(ffirst [[1 2] [3 4] [5 6]])\n;;=> 1\n```"}],
                               :full-name "cljs.core/ffirst",
                               :clj-symbol "clojure.core/ffirst",
                               :docstring "Same as (first (first x))"},
           "clojure.zip/replace" {:ns "clojure.zip",
                                  :name "replace",
                                  :signature ["[loc node]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_replace",
                                  :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [183 187]},
                                  :full-name "clojure.zip/replace",
                                  :clj-symbol "clojure.zip/replace",
                                  :docstring "Replaces the node at this loc, without moving"},
           "cljs.core/vec" {:description "Creates a new vector containing the contents of `coll`",
                            :ns "cljs.core",
                            :name "vec",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/vector"
                                      "cljs.core/vector?"],
                            :full-name-encode "cljs.core_vec",
                            :source {:code "(defn vec [coll]\n  (reduce conj cljs.core.PersistentVector/EMPTY coll))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2671 2672]},
                            :full-name "cljs.core/vec",
                            :clj-symbol "clojure.core/vec"},
           "cljs.core/or" {:description "Evaluates arguments one at a time from left to right. If an argument returns\nlogical true, `or` returns that value and doesn't evaluate any of the other\narguments, otherwise it returns the value of the last argument.\n\n`(or)` returns nil.",
                           :ns "cljs.core",
                           :name "or",
                           :signature ["[]" "[x]" "[x & next]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/and" "special/if"],
                           :full-name-encode "cljs.core_or",
                           :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n      `(let [or# ~x]\n         (if or# or# (or ~@next)))))",
                                    :repo "clojure",
                                    :tag "clojure-1.4.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [790 800]},
                           :examples [{:id "d50433",
                                       :content "```clj\n(or)\n;;=> nil\n\n(or false)\n;;=> false\n\n(or true)\n;;=> true\n\n(or true true)\n;;=> true\n\n(or true false)\n;;=> true\n\n(or false false)\n;;=> false\n```"}
                                      {:id "62f291",
                                       :content "`nil` and `false` are the only falsy values and everything else is truthy:\n\n```clj\n(or \"foo\" \"bar\")\n;;=> \"bar\"\n\n(or \"foo\" nil)\n;;=> \"foo\"\n\n(or \"foo\" false)\n;;=> \"foo\"\n\n(or nil \"foo\")\n;;=> \"foo\"\n\n(or false \"foo\")\n;;=> \"foo\"\n```"}],
                           :full-name "cljs.core/or",
                           :clj-symbol "clojure.core/or",
                           :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
           "cljs.core/mod" {:description "Returns the modulus of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).\n\nTruncates toward negative infinity.",
                            :ns "cljs.core",
                            :name "mod",
                            :signature ["[n d]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/rem"],
                            :full-name-encode "cljs.core_mod",
                            :source {:code "(defn mod\n  [n d]\n  (cljs.core/mod n d))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1122 1125]},
                            :extra-sources ({:code "(defmacro mod [num div]\n  (list 'js* \"(~{} % ~{})\" num div))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [187 188]}),
                            :examples [{:id "8165e8",
                                        :content "```clj\n(mod -5 3)\n;;=> 1\n\n(mod 5 3)\n;;=> 2\n\n(mod 5 0)\n;;=> NaN\n```"}],
                            :full-name "cljs.core/mod",
                            :clj-symbol "clojure.core/mod",
                            :docstring "Modulus of num and div. Truncates toward negative infinity."},
           "cljs.core/aset" {:description "Sets `val` at index `i` in JavaScript arrays and objects.\n\nCan be used to set nested properties with the additional `idxs` arguments.",
                             :ns "cljs.core",
                             :name "aset",
                             :signature ["[array i val]"
                                         "[array idx idx2 & idxv]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/aget"
                                       "special/set!"
                                       "cljs.core/assoc-in"],
                             :full-name-encode "cljs.core_aset",
                             :source {:code "(defn aset\n  [array i val]\n  (cljs.core/aset array i val))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [96 99]},
                             :extra-sources ({:code "(defmacro aset [a i v]\n  (list 'js* \"(~{}[~{}] = ~{})\" a i v))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [112 113]}),
                             :examples [{:id "d1aa58",
                                         :content "```js\n// JavaScript\nvar a = {\"foo\": 3, \"bar\": [4, 5]};\n\na[\"foo\"] = 4;\na;\n//=> {\"foo\": 4, \"bar\": [4, 5]}\n\na[\"bar\"][0] = 6;\na;\n//=> {\"foo\": 4, \"bar\": [6, 5]}\n```\n\n```clj\n;; ClojureScript\n(def a #js {:foo 3, :bar #js [4 5]})\n\n(aset a \"foo\" 4)\na\n;;=> #js {:foo 4, :bar #js [4 5]}\n\n(aset a \"bar\" 0 6)\na\n;;=> #js {:foo 4, :bar #js [6 5]}\n```"}
                                        {:id "34bbf3",
                                         :content "```js\n// JavaScript\ndocument.location.href = \"http://example.com\";\n```\n\n```clj\n;; ClojureScript\n(aset js/document \"location\" \"href\" \"http://example.com\")\n```"}],
                             :full-name "cljs.core/aset",
                             :clj-symbol "clojure.core/aset",
                             :docstring "Sets the value at the index."},
           "cljs.core/second" {:description "Returns the second item in `coll`.\n\nSame as `(first (next coll))`",
                               :ns "cljs.core",
                               :name "second",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/first"
                                         "cljs.core/nth"
                                         "cljs.core/fnext"
                                         "cljs.core/next"],
                               :full-name-encode "cljs.core_second",
                               :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [545 548]},
                               :full-name "cljs.core/second",
                               :clj-symbol "clojure.core/second",
                               :docstring "Same as (first (next x))"},
           "cljs.core/bit-count" {:description "Counts the number of bits set in `x`.",
                                  :ns "cljs.core",
                                  :name "bit-count",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_bit-count",
                                  :source {:code "(defn bit-count\n  [n]\n  (loop [c 0 n n]\n    (if (zero? n)\n      c\n      (recur (inc c) (bit-and n (dec n))))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1200 1206]},
                                  :examples [{:id "35c78c",
                                              :content "Bits can be entered using radix notation:\n\n```clj\n(bit-count 2r1011)\n;;=> 3\n```\n\nSame number in decimal:\n\n```clj\n(bit-count 11)\n;;=> 3\n```"}],
                                  :full-name "cljs.core/bit-count",
                                  :docstring "Counts the number of bits set in n"},
           "clojure.set/rename" {:ns "clojure.set",
                                 :name "rename",
                                 :signature ["[xrel kmap]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set_rename",
                                 :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [83 86]},
                                 :full-name "clojure.set/rename",
                                 :clj-symbol "clojure.set/rename",
                                 :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/assoc!" {:description "assoc(iate) on transient collection\n\nWhen applied to a transient map, adds mapping of key(s) to val(s).\n\nWhen applied to a transient vector, sets the val at index.  Note - index must\nbe <= (count vector).\n\nReturns coll.",
                               :ns "cljs.core",
                               :name "assoc!",
                               :signature ["[tcoll key val]"
                                           "[tcoll key val & kvs]"],
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :related ["cljs.core/transient"
                                         "cljs.core/persistent!"],
                               :full-name-encode "cljs.core_assocBANG",
                               :source {:code "(defn assoc! [tcoll key val]\n  (-assoc! tcoll key val))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1730 1731]},
                               :examples [{:id "7d1e6b",
                                           :content "```clj\n(def tcoll (transient! {}))\n(assoc! tcoll :a 1)\n(assoc! tcoll :b 2)\n\ntcoll\n;;=> #<[object Object]> \n\n(:a tcoll)\n;;=> 1\n\n(:b tcoll)\n;;=> 2\n\n(def a (persistent! tcoll))\n;;=> {:a 1 :b 2}\n```"}],
                               :full-name "cljs.core/assoc!",
                               :clj-symbol "clojure.core/assoc!"},
           "cljs.core/delay?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "delay?",
                               :signature ["[x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_delayQMARK",
                               :source {:code "(defn ^boolean delay?\n  [x] (instance? cljs.core.Delay x))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6036 6038]},
                               :full-name "cljs.core/delay?",
                               :clj-symbol "clojure.core/delay?",
                               :docstring "returns true if x is a Delay created with delay"},
           "clojure.zip/left" {:ns "clojure.zip",
                               :name "left",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_left",
                               :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [150 155]},
                               :full-name "clojure.zip/left",
                               :clj-symbol "clojure.zip/left",
                               :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
           "cljs.reader/not-implemented" {:ns "cljs.reader",
                                          :name "not-implemented",
                                          :type "function",
                                          :signature ["[rdr ch]"],
                                          :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [187 189]},
                                          :full-name "cljs.reader/not-implemented",
                                          :full-name-encode "cljs.reader_not-implemented",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/IAssociative" {:ns "cljs.core",
                                     :name "IAssociative",
                                     :history [["+" "0.0-927"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core_IAssociative",
                                     :source {:code "(defprotocol IAssociative\n  (-contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (-assoc [coll k v]))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [164 167]},
                                     :methods [{:name "-contains-key?",
                                                :signature ["[coll k]"],
                                                :docstring nil}
                                               {:name "-assoc",
                                                :signature ["[coll k v]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IAssociative",
                                     :clj-symbol "clojure.lang/Associative"},
           "cljs.core/ObjMap.EMPTY" {:ns "cljs.core",
                                     :name "ObjMap.EMPTY",
                                     :type "var",
                                     :parent-type "ObjMap",
                                     :source {:code "(set! cljs.core.ObjMap/EMPTY (ObjMap. nil (array) (js-obj) 0 0))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3184]},
                                     :full-name "cljs.core/ObjMap.EMPTY",
                                     :full-name-encode "cljs.core_ObjMapDOTEMPTY",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/group-by" {:description "Returns a map of the elements of `coll` keyed by the result of running `f` on\neach element.\n\nThe value at each key will be a vector of the corresponding elements in the\norder they appeared in `coll`.",
                                 :ns "cljs.core",
                                 :name "group-by",
                                 :signature ["[f coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/partition-by"
                                           "cljs.core/frequencies"],
                                 :full-name-encode "cljs.core_group-by",
                                 :source {:code "(defn group-by\n  [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} coll))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [6118 6127]},
                                 :full-name "cljs.core/group-by",
                                 :clj-symbol "clojure.core/group-by",
                                 :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
           "cljs.core/sorted-map-by" {:description "Returns a new sorted map with supplied mappings, using the supplied comparator\nfunction.\n\n`keyvals` must be an even number of forms.",
                                      :ns "cljs.core",
                                      :name "sorted-map-by",
                                      :signature ["[comparator & keyvals]"],
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :related ["cljs.core/sorted-map"
                                                "cljs.core/subseq"
                                                "cljs.core/rsubseq"
                                                "cljs.core/sorted-set-by"],
                                      :full-name-encode "cljs.core_sorted-map-by",
                                      :source {:code "(defn sorted-map-by\n  ([comparator & keyvals]\n     (loop [in (seq keyvals)\n            out (cljs.core.PersistentTreeMap. comparator nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [5006 5014]},
                                      :full-name "cljs.core/sorted-map-by",
                                      :clj-symbol "clojure.core/sorted-map-by",
                                      :docstring "keyval => key val\nReturns a new sorted map with supplied mappings, using the supplied comparator."},
           "cljs.core/symbol" {:ns "cljs.core",
                               :name "symbol",
                               :signature ["[name]" "[ns name]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_symbol",
                               :source {:code "(defn symbol\n  ([name] (cond (symbol? name) name\n                (keyword? name) (str* \"\\uFDD1\" \"'\" (subs name 2)))\n     :else (str* \"\\uFDD1\" \"'\" name))\n  ([ns name] (symbol (str* ns \"/\" name))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1280 1285]},
                               :full-name "cljs.core/symbol",
                               :clj-symbol "clojure.core/symbol",
                               :docstring "Returns a Symbol with the given namespace and name."},
           "cljs.core/Delay" {:ns "cljs.core",
                              :name "Delay",
                              :signature ["[state f]"],
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core_Delay",
                              :source {:code "(deftype Delay [state f]\n  IDeref\n  (-deref [_]\n    (:value (swap! state (fn [{:keys [done] :as curr-state}]\n                           (if done\n                             curr-state,\n                             {:done true :value (f)})))))\n\n  IPending\n  (-realized? [d]\n    (:done @state)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6024 6034]},
                              :full-name "cljs.core/Delay",
                              :clj-symbol "clojure.lang/Delay"},
           "cljs.core/methods" {:ns "cljs.core",
                                :name "methods",
                                :signature ["[multifn]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_methods",
                                :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6378 6380]},
                                :full-name "cljs.core/methods",
                                :clj-symbol "clojure.core/methods",
                                :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
           "cljs.core/vector" {:description "Creates a new vector containing `args`.",
                               :ns "cljs.core",
                               :name "vector",
                               :signature ["[& args]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/vec"
                                         "cljs.core/vector?"
                                         "cljs.core/pop"
                                         "cljs.core/into"],
                               :full-name-encode "cljs.core_vector",
                               :source {:code "(defn vector [& args] (vec args))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2674]},
                               :full-name "cljs.core/vector",
                               :clj-symbol "clojure.core/vector"},
           "cljs.core/rand-int" {:description "Returns a random integer between 0 inclusive and `n` exclusive.",
                                 :ns "cljs.core",
                                 :name "rand-int",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/rand"],
                                 :full-name-encode "cljs.core_rand-int",
                                 :source {:code "(defn rand-int\n  [n] (js* \"Math.floor(Math.random() * ~{n})\"))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [6107 6109]},
                                 :extra-sources ({:code "(defn rand-int\n  [n] (fix (rand n)))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [1144 1146]}),
                                 :full-name "cljs.core/rand-int",
                                 :clj-symbol "clojure.core/rand-int",
                                 :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
           "cljs.core/PersistentQueue.EMPTY" {:ns "cljs.core",
                                              :name "PersistentQueue.EMPTY",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :parent-type "PersistentQueue",
                                              :type "var",
                                              :full-name-encode "cljs.core_PersistentQueueDOTEMPTY",
                                              :source {:code "(set! cljs.core.PersistentQueue/EMPTY (PersistentQueue. nil 0 nil [] 0))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [3035]},
                                              :full-name "cljs.core/PersistentQueue.EMPTY",
                                              :clj-symbol "clojure.lang/PersistentQueue.EMPTY"},
           "cljs.core/NodeSeq" {:ns "cljs.core",
                                :name "NodeSeq",
                                :signature ["[meta nodes i s __hash]"],
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core_NodeSeq",
                                :source {:code "(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (NodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      [(aget nodes i) (aget nodes (inc i))]\n      (first s)))\n\n  (-rest [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [4015 4057]},
                                :full-name "cljs.core/NodeSeq",
                                :clj-symbol "clojure.lang/NodeSeq"},
           "cljs.core/letfn" {:description "Takes a vector of function definitions `fnspecs` and binds the functions to\ntheir names. All of the names are available in all of the definitions of the\nfunctions as well as `body`.\n\n`fnspecs` must be a vector with an even number of forms. See `let`.\n\n`letfn` is a wrapper over one of ClojureScript's [special forms].\n\n[special forms]:http://clojure.org/special_forms",
                              :ns "cljs.core",
                              :name "letfn",
                              :signature ["[fnspecs & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/let"],
                              :full-name-encode "cljs.core_letfn",
                              :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                       :repo "clojure",
                                       :tag "clojure-1.4.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5789 5800]},
                              :full-name "cljs.core/letfn",
                              :clj-symbol "clojure.core/letfn",
                              :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
           "cljs.reader/read-discard" {:ns "cljs.reader",
                                       :name "read-discard",
                                       :type "function",
                                       :signature ["[rdr _]"],
                                       :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [305 308]},
                                       :full-name "cljs.reader/read-discard",
                                       :full-name-encode "cljs.reader_read-discard",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/gen-apply-to" {:ns "cljs.core",
                                     :name "gen-apply-to",
                                     :type "macro",
                                     :signature ["[]"],
                                     :source {:code "(defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [933 941]},
                                     :full-name "cljs.core/gen-apply-to",
                                     :full-name-encode "cljs.core_gen-apply-to",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/inc" {:description "Returns a number one greater than `x`.",
                            :ns "cljs.core",
                            :name "inc",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/dec"],
                            :full-name-encode "cljs.core_inc",
                            :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [375 377]},
                            :extra-sources ({:code "(defmacro inc [x]\n  `(+ ~x 1))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [165 166]}),
                            :full-name "cljs.core/inc",
                            :clj-symbol "clojure.core/inc",
                            :docstring "Returns a number one greater than num."},
           "cljs.core/name" {:description "Returns a string value of a keyword, string, or symbol.\n\n`(name :foo)` => `\"foo\"`\n\n`(name \"foo\")` => `\"foo\"`\n\n`(name 'foo)` => `\"foo\"`",
                             :ns "cljs.core",
                             :name "name",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_name",
                             :source {:code "(defn name\n  [x]\n  (cond\n    (string? x) x\n    (or (keyword? x) (symbol? x))\n      (let [i (.lastIndexOf x \"/\")]\n        (if (< i 0)\n          (subs x 2)\n          (subs x (inc i))))\n    :else (throw (js/Error. (str \"Doesn't support name: \" x)))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [5298 5308]},
                             :full-name "cljs.core/name",
                             :clj-symbol "clojure.core/name",
                             :docstring "Returns the name String of a string, symbol or keyword."},
           "cljs.core/cycle" {:description "Returns an infinite lazy sequence of repetitions of the items in `coll`.",
                              :ns "cljs.core",
                              :name "cycle",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/lazy-seq"
                                        "cljs.core/repeatedly"],
                              :full-name-encode "cljs.core_cycle",
                              :source {:code "(defn cycle\n  [coll] (lazy-seq\n          (when-let [s (seq coll)]\n            (concat s (cycle s)))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2123 2127]},
                              :full-name "cljs.core/cycle",
                              :clj-symbol "clojure.core/cycle",
                              :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
           "cljs.core/rsubseq" {:description "`sc` must be a sorted collection.\n\n`test`, `start-test`, `end-test` must be `<`, `<=`, `>` or `>=`.\n\nReturns a reverse sequence of those entries with keys `ek` for which\n`(test (.. sc comparator (compare ek key)) 0)` is true.",
                                :ns "cljs.core",
                                :name "rsubseq",
                                :signature ["[sc test key]"
                                            "[sc start-test start-key end-test end-key]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :related ["cljs.core/subseq"],
                                :full-name-encode "cljs.core_rsubseq",
                                :source {:code "(defn rsubseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{< <=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5385 5398]},
                                :full-name "cljs.core/rsubseq",
                                :clj-symbol "clojure.core/rsubseq",
                                :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a reverse seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/map" {:description "Returns a lazy sequence of applying function `f` to every element of `coll`.\n\nWhen more than one collection is provided, returns a lazy sequence consisting of\nthe result of applying `f` to the set of first items of each `c`, followed by\napplying `f` to the set of second items in each `c`, until any one of the `c`s\nis exhausted. Any remaining items in other `c`s are ignored. Function `f` should\naccept number-of-`c`s arguments.\n\nReturns a transducer when no collection is provided.",
                            :ns "cljs.core",
                            :name "map",
                            :signature ["[f]"
                                        "[f coll]"
                                        "[f c1 c2]"
                                        "[f c1 c2 c3]"
                                        "[f c1 c2 c3 & colls]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/map-indexed"
                                      "cljs.core/amap"
                                      "cljs.core/mapcat"
                                      "cljs.core/keep"
                                      "cljs.core/juxt"],
                            :full-name-encode "cljs.core_map",
                            :source {:code "(defn map\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (cons (f (first s)) (map f (rest s))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2049 2077]},
                            :full-name "cljs.core/map",
                            :clj-symbol "clojure.core/map",
                            :docstring "Returns a lazy sequence consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "syntax/list" {:description "Signifies a literal list.  When evaluated, it is interpreted as a call to some\ncode.  The first argument is called with the subsequent arguments.",
                          :ns "syntax",
                          :name "list",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :related ["syntax/vector" "syntax/quote"],
                          :full-name-encode "syntax_list",
                          :source {:repo "clojure",
                                   :tag "clojure-1.4.0",
                                   :filename "src/jvm/clojure/lang/LispReader.java",
                                   :lines [nil]},
                          :syntax-form "()",
                          :examples [{:id "cd26b0",
                                      :content "The following is a list that is evaluated to create var `a`:\n\n```clj\n(def a 1)\n```\n\nAn empty list is unevaluated and left as an empty list:\n\n```clj\n()\n;;=> ()\n```\n\nTo signify an unevaluated list, precede it with a quote:\n\n```clj\n'(1 2 3)\n;;=> (1 2 3)\n```"}],
                          :edn-doc "https://github.com/edn-format/edn#lists",
                          :full-name "syntax/list",
                          :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/amap" {:description "For quickly creating a new JavaScript array by mapping an expression `expr`\nacross a JavaScript array `a`.  The expression can use `ret` as the current\nresult, which is initialized to `a`.  It can also use `idx` to get the current\nindex.",
                             :ns "cljs.core",
                             :name "amap",
                             :signature ["[a idx ret expr]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/map"],
                             :full-name-encode "cljs.core_amap",
                             :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [807 820]},
                             :examples [{:id "3a7471",
                                         :content "```clj\n(def a #js [1 2 3])\n(amap a i ret (* 10 (aget a i)))\n;;=> #js [10 20 30]\n```"}
                                        {:id "0f57af",
                                         :content "You can also use `ret` inside the mapped expression if you want to use the\ncurrent result:\n\n```clj\n(def a #js [1 2 3])\n(amap a i ret (+ (if (pos? i)\n                   (aget ret (dec i))\n                   0)\n                 (* 10 (aget a i))))\n;;=> #js [10 30 60]\n```"}],
                             :full-name "cljs.core/amap",
                             :clj-symbol "clojure.core/amap",
                             :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting \neach element of ret to the evaluation of expr, returning the new \narray ret."},
           "clojure.zip/children" {:ns "clojure.zip",
                                   :name "children",
                                   :signature ["[loc]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip_children",
                                   :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [69 74]},
                                   :full-name "clojure.zip/children",
                                   :clj-symbol "clojure.zip/children",
                                   :docstring "Returns a seq of the children of node at loc, which must be a branch"},
           "special/set!" {:description "Sets `js-var` to `val` using the JavaScript `=` operator.",
                           :ns "special",
                           :name "set!",
                           :signature ["[js-var val]"],
                           :history [["+" "0.0-927"]],
                           :type "special form",
                           :related ["cljs.core/aset"
                                     "cljs.core/reset!"],
                           :full-name-encode "special_setBANG",
                           :source {:code "(defmethod parse 'set!\n  [_ env [_ target val alt :as form] _]\n  (let [[target val] (if alt\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n     (let [enve (assoc env :context :expr)\n           targetexpr (cond\n                       ;; TODO: proper resolve\n                       (= target '*unchecked-if*)\n                       (do\n                         (reset! *unchecked-if* val)\n                         ::set-unchecked-if)\n\n                       (symbol? target)\n                       (do\n                         (let [local (-> env :locals target)]\n                           (assert (or (nil? local)\n                                       (and (:field local)\n                                            (:mutable local)))\n                                   \"Can't set! local var or non-mutable field\"))\n                         (analyze-symbol enve target))\n\n                       :else\n                       (when (seq? target)\n                         (let [targetexpr (analyze-seq enve target nil)]\n                           (when (:field targetexpr)\n                             targetexpr))))\n           valexpr (analyze enve val)]\n       (assert targetexpr \"set! target must be a field or a symbol naming a var\")\n       (cond\n        (= targetexpr ::set-unchecked-if) {:env env :op :no-op}\n        :else {:env env :op :set! :form form :target targetexpr :val valexpr\n               :children [targetexpr valexpr]})))))",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [1064 1098]},
                           :full-name "special/set!",
                           :clj-symbol "clojure.core/set!"},
           "cljs.core/when-not" {:description "Evaluates `test`. If logical false, evaluates `body` in an implicit `do`.",
                                 :ns "cljs.core",
                                 :name "when-not",
                                 :signature ["[test & body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/when"
                                           "cljs.core/when-let"
                                           "special/if"],
                                 :full-name-encode "cljs.core_when-not",
                                 :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                          :repo "clojure",
                                          :tag "clojure-1.4.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [461 465]},
                                 :full-name "cljs.core/when-not",
                                 :clj-symbol "clojure.core/when-not",
                                 :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
           "clojure.set/index" {:ns "clojure.set",
                                :name "index",
                                :signature ["[xrel ks]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set_index",
                                :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [88 96]},
                                :full-name "clojure.set/index",
                                :clj-symbol "clojure.set/index",
                                :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
           "cljs.repl.browser/send-and-close" {:ns "cljs.repl.browser",
                                               :name "send-and-close",
                                               :signature ["[conn status form]"
                                                           "[conn status form content-type]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser_send-and-close",
                                               :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [68 89]},
                                               :full-name "cljs.repl.browser/send-and-close",
                                               :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response."},
           "clojure.browser.dom/log" {:ns "clojure.browser.dom",
                                      :name "log",
                                      :type "function",
                                      :signature ["[& args]"],
                                      :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/clojure/browser/dom.cljs",
                                               :lines [20 21]},
                                      :full-name "clojure.browser.dom/log",
                                      :full-name-encode "clojure.browser.dom_log",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.fromArray" {:ns "cljs.core",
                                         :name "Vector.fromArray",
                                         :signature ["[xs]"],
                                         :history [["+" "0.0-927"]],
                                         :parent-type "Vector",
                                         :type "function",
                                         :full-name-encode "cljs.core_VectorDOTfromArray",
                                         :source {:code "(set! cljs.core.Vector/fromArray (fn [xs] (Vector. nil xs nil)))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2422]},
                                         :full-name "cljs.core/Vector.fromArray"},
           "cljs.core/make-array" {:description "Creates an empty JavaScript array of size `size`.",
                                   :ns "cljs.core",
                                   :name "make-array",
                                   :signature ["[size]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/aclone"
                                             "cljs.core/array"],
                                   :full-name-encode "cljs.core_make-array",
                                   :source {:code "(defn make-array\n  ([size]\n     (js* \"new Array(~{size})\"))\n  ([type size]\n     (make-array size)))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [81 85]},
                                   :full-name "cljs.core/make-array",
                                   :clj-symbol "clojure.core/make-array"},
           "cljs.core/sorted-set-by" {:description "Returns a new sorted set with supplied `keys`, using the supplied `comparator`.",
                                      :ns "cljs.core",
                                      :name "sorted-set-by",
                                      :signature ["[comparator & keys]"],
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :related ["cljs.core/sorted-set"
                                                "cljs.core/sorted-map-by"
                                                "cljs.core/compare"],
                                      :full-name-encode "cljs.core_sorted-set-by",
                                      :source {:code "(defn sorted-set-by\n  ([comparator & keys]\n   (reduce -conj\n           (cljs.core.PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [5257 5262]},
                                      :full-name "cljs.core/sorted-set-by",
                                      :clj-symbol "clojure.core/sorted-set-by",
                                      :docstring "Returns a new sorted set with supplied keys, using the supplied comparator."},
           "cljs.core/partition-by" {:description "Applies `f` to each value in `coll`, splitting it each time `f` returns a new\nvalue. Returns a lazy sequence of partitions.\n\nReturns a stateful transducer when no collection is provided.",
                                     :ns "cljs.core",
                                     :name "partition-by",
                                     :signature ["[f]" "[f coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/partition"
                                               "cljs.core/partition-all"
                                               "cljs.core/group-by"],
                                     :full-name-encode "cljs.core_partition-by",
                                     :source {:code "(defn partition-by\n  [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           fv (f fst)\n           run (cons fst (take-while #(= fv (f %)) (next s)))]\n       (cons run (partition-by f (seq (drop (count run) s))))))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [5482 5491]},
                                     :full-name "cljs.core/partition-by",
                                     :clj-symbol "clojure.core/partition-by",
                                     :docstring "Applies f to each value in coll, splitting it each time f returns\na new value.  Returns a lazy seq of partitions."},
           "cljs.core/sort-by" {:description "Returns a sorted sequence of the items in `coll`, where the sort order is\ndetermined by comparing `(keyfn item)`.\n\n`comp` can be boolean-valued comparison function, or a -/0/+ valued comparator.\n\n`comp` defaults to `compare`.",
                                :ns "cljs.core",
                                :name "sort-by",
                                :signature ["[keyfn coll]"
                                            "[keyfn comp coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/sort"
                                          "cljs.core/compare"],
                                :full-name-encode "cljs.core_sort-by",
                                :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [942 950]},
                                :full-name "cljs.core/sort-by",
                                :clj-symbol "clojure.core/sort-by",
                                :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.core/with-meta" {:description "Returns an object of the same type and value as `obj`, with map `m` as its\nmetadata.",
                                  :ns "cljs.core",
                                  :name "with-meta",
                                  :signature ["[obj m]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/alter-meta!"
                                            "cljs.core/vary-meta"],
                                  :full-name-encode "cljs.core_with-meta",
                                  :source {:code "(defn with-meta\n  [o meta]\n  (-with-meta o meta))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [682 686]},
                                  :examples [{:id "f189d4",
                                              :content "```clj\n(def a ^:foo [1 2 3])\n(def b (with-meta a {:bar true}))\n\n(= a b)\n;;=> true\n\n(meta a)\n;;=> {:foo true}\n\n(meta b)\n;;=> {:bar true}\n```"}],
                                  :full-name "cljs.core/with-meta",
                                  :clj-symbol "clojure.core/with-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
           "cljs.core/NeverEquiv" {:ns "cljs.core",
                                   :name "NeverEquiv",
                                   :type "type",
                                   :signature ["[]"],
                                   :source {:code "(deftype NeverEquiv []\n  IEquiv\n  (-equiv [o other] false))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3037 3039]},
                                   :full-name "cljs.core/NeverEquiv",
                                   :full-name-encode "cljs.core_NeverEquiv",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/select-keys" {:description "Returns a map containing only those entries in `map` whose key is in `keys`.",
                                    :ns "cljs.core",
                                    :name "select-keys",
                                    :signature ["[map keys]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_select-keys",
                                    :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        ret)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [5060 5072]},
                                    :full-name "cljs.core/select-keys",
                                    :clj-symbol "clojure.core/select-keys",
                                    :docstring "Returns a map containing only those entries in map whose key is in keys"},
           "special/loop*" {:ns "special",
                            :name "loop*",
                            :type "special form",
                            :source {:code "(defmethod parse 'loop*\n  [op encl-env form _]\n  (analyze-let encl-env form true))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [1034 1036]},
                            :full-name "special/loop*",
                            :full-name-encode "special_loopSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.core/ISeq" {:ns "cljs.core",
                             :name "ISeq",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core_ISeq",
                             :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (-rest [coll]))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [157 159]},
                             :methods [{:name "-first",
                                        :signature ["[coll]"],
                                        :docstring nil}
                                       {:name "-rest",
                                        :signature ["[coll]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISeq",
                             :clj-symbol "clojure.lang/ISeq"},
           "cljs.core/disj!" {:ns "cljs.core",
                              :name "disj!",
                              :signature ["[tcoll val]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core_disjBANG",
                              :source {:code "(defn disj! [tcoll val]\n  (-disjoin! tcoll val))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1739 1740]},
                              :full-name "cljs.core/disj!",
                              :clj-symbol "clojure.core/disj!"},
           "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                            :name "postwalk-replace",
                                            :signature ["[smap form]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.walk_postwalk-replace",
                                            :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/cljs/clojure/walk.cljs",
                                                     :lines [88 94]},
                                            :full-name "clojure.walk/postwalk-replace",
                                            :clj-symbol "clojure.walk/postwalk-replace",
                                            :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
           "cljs.core/pr-with-opts" {:ns "cljs.core",
                                     :name "pr-with-opts",
                                     :signature ["[objs opts]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_pr-with-opts",
                                     :source {:code "(defn pr-with-opts\n  [objs opts]\n  (let [first-obj (first objs)]\n    (doseq [obj objs]\n      (when-not (identical? obj first-obj)\n        (string-print \" \"))\n      (doseq [string (pr-seq obj opts)]\n        (string-print string)))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [5674 5683]},
                                     :full-name "cljs.core/pr-with-opts",
                                     :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts"},
           "cljs.core/->>" {:description "The thread-last macro \"threads\" an expression through several forms as the last\nitem in a list.\n\nInserts `x` as the last item in the first form, making a list of it if it is not\na list already. If there are more forms, inserts the first form as the last item\nin second form, etc.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(->> x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x y z (d (a b c x)))</pre></td></tr></tbody></table>",
                            :ns "cljs.core",
                            :name "->>",
                            :signature ["[x & forms]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/->"],
                            :full-name-encode "cljs.core_-GTGT",
                            :source {:code "(defmacro ->>\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x)))\n  ([x form & more] `(->> (->> ~x ~form) ~@more)))",
                                     :repo "clojure",
                                     :tag "clojure-1.4.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [1541 1550]},
                            :examples [{:id "1dc72c",
                                        :content "Sequence transformation functions often take a sequence as the last argument,\nthus the thread-last macro is commonly used with them.  Here we compute the sum\nof the first 10 even squares:\n\n```clj\n(->> (range)\n     (map #(* % %))\n     (filter even?)\n     (take 10)\n     (reduce +))\n;;=> 1140\n```\n\nThis expands to:\n\n```clj\n(reduce +\n  (take 10\n    (filter even?\n      (map #(* % %)\n        (range)))))\n;;=> 1140\n```"}],
                            :full-name "cljs.core/->>",
                            :clj-symbol "clojure.core/->>",
                            :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
           "cljs.core/nil?" {:description "Returns true if `x` is nil, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "nil?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/true?"
                                       "cljs.core/false?"
                                       "cljs.core/identity"],
                             :full-name-encode "cljs.core_nilQMARK",
                             :source {:code "(defn ^boolean nil?\n  [x]\n  (coercive-= x nil))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [285 288]},
                             :extra-sources ({:code "(defmacro nil? [x]\n  `(coercive-= ~x nil))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [78 79]}),
                             :full-name "cljs.core/nil?",
                             :clj-symbol "clojure.core/nil?",
                             :docstring "Returns true if x is nil, false otherwise."},
           "cljs.repl.rhino/bootjs" {:ns "cljs.repl.rhino",
                                     :name "bootjs",
                                     :type "var",
                                     :return-type String,
                                     :source {:code "(def ^String bootjs (str \"goog.require = function(rule){\"\n                         \"Packages.clojure.lang.RT[\\\"var\\\"](\\\"cljs.repl.rhino\\\",\\\"goog-require\\\")\"\n                         \".invoke(rule);}\"))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/clj/cljs/repl/rhino.clj",
                                              :lines [22 24]},
                                     :full-name "cljs.repl.rhino/bootjs",
                                     :full-name-encode "cljs.repl.rhino_bootjs",
                                     :history [["+" "0.0-927"]]},
           "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                          :name "stringify-keys",
                                          :signature ["[m]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.walk_stringify-keys",
                                          :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/clojure/walk.cljs",
                                                   :lines [72 78]},
                                          :full-name "clojure.walk/stringify-keys",
                                          :clj-symbol "clojure.walk/stringify-keys",
                                          :docstring "Recursively transforms all map keys from keywords to strings."},
           "clojure.browser.repl/order" {:ns "clojure.browser.repl",
                                         :name "order",
                                         :type "var",
                                         :source {:code "(def order (atom 0))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/clojure/browser/repl.cljs",
                                                  :lines [55]},
                                         :full-name "clojure.browser.repl/order",
                                         :full-name-encode "clojure.browser.repl_order",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/memoize" {:description "Returns a memoized version of a referentially transparent function.\n\nA memoized version of a function keeps a cache of the mappings from arguments to\nresults in memory. When calls with the same arguments are repeated often, a\nmemoized function has higher performance at the expense of higher memory usage.",
                                :ns "cljs.core",
                                :name "memoize",
                                :signature ["[f]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_memoize",
                                :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [v (get @mem args)]\n        v\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6071 6083]},
                                :full-name "cljs.core/memoize",
                                :clj-symbol "clojure.core/memoize",
                                :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
           "cljs.core/pr-sequential" {:ns "cljs.core",
                                      :name "pr-sequential",
                                      :type "function",
                                      :signature ["[print-one begin sep end opts coll]"],
                                      :source {:code "(defn pr-sequential [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [5619 5623]},
                                      :full-name "cljs.core/pr-sequential",
                                      :full-name-encode "cljs.core_pr-sequential",
                                      :history [["+" "0.0-927"]]},
           "clojure.zip/make-node" {:ns "clojure.zip",
                                    :name "make-node",
                                    :signature ["[loc node children]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip_make-node",
                                    :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [76 80]},
                                    :full-name "clojure.zip/make-node",
                                    :clj-symbol "clojure.zip/make-node",
                                    :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
           "syntax/deref" {:description "Used to dereference a reference value (e.g. an atom).  Expands to `(deref ...)`.\n\n`@foo` = `(deref foo)`",
                           :ns "syntax",
                           :name "deref",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["cljs.core/deref"],
                           :full-name-encode "syntax_deref",
                           :source {:repo "clojure",
                                    :tag "clojure-1.4.0",
                                    :filename "src/jvm/clojure/lang/LispReader.java",
                                    :lines [nil]},
                           :syntax-form "@",
                           :examples [{:id "08f886",
                                       :content "```clj\n(def a (atom 1))\n@a\n;;=> 1\n\n(deref a)\n;;=> 1\n```"}],
                           :full-name "syntax/deref",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/PersistentVector.EMPTY" {:ns "cljs.core",
                                               :name "PersistentVector.EMPTY",
                                               :history [["+"
                                                          "0.0-1006"]],
                                               :parent-type "PersistentVector",
                                               :type "var",
                                               :full-name-encode "cljs.core_PersistentVectorDOTEMPTY",
                                               :source {:code "(set! cljs.core.PersistentVector/EMPTY (PersistentVector. nil 0 5 cljs.core.PersistentVector/EMPTY_NODE (array) 0))",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [2663]},
                                               :full-name "cljs.core/PersistentVector.EMPTY",
                                               :clj-symbol "clojure.lang/PersistentVector.EMPTY"},
           "specialrepl/load-namespace" {:description "Only usable from a REPL.\n\nLoad a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once\nand only once.",
                                         :ns "specialrepl",
                                         :name "load-namespace",
                                         :signature ["[name]"],
                                         :history [["+" "0.0-927"]],
                                         :type "special form (repl)",
                                         :full-name-encode "specialrepl_load-namespace",
                                         :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (@comp/namespaces ns-name)\n                  (swap! comp/namespaces assoc ns-name {:name ns-name}))\n                (set! comp/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/clj/cljs/repl.clj",
                                                  :lines [138 147]},
                                         :examples [{:id "0b1a1d",
                                                     :content "```clj\n(load-namespace 'clojure.set)\n```"}],
                                         :full-name "specialrepl/load-namespace"},
           "cljs.reader/float-pattern" {:ns "cljs.reader",
                                        :name "float-pattern",
                                        :type "var",
                                        :source {:code "(def float-pattern (re-pattern \"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\"))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [97]},
                                        :full-name "cljs.reader/float-pattern",
                                        :full-name-encode "cljs.reader_float-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/ancestors" {:ns "cljs.core",
                                  :name "ancestors",
                                  :signature ["[tag]" "[h tag]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_ancestors",
                                  :source {:code "(defn ancestors\n  ([tag] (ancestors @global-hierarchy tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [6165 6171]},
                                  :full-name "cljs.core/ancestors",
                                  :clj-symbol "clojure.core/ancestors",
                                  :docstring "Returns the immediate and indirect parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/integer?" {:description "Returns true if `n` is an integer, false otherwise.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "integer?",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/int"],
                                 :full-name-encode "cljs.core_integerQMARK",
                                 :source {:code "(defn ^boolean integer?\n  [n]\n  (and (number? n)\n       (js* \"(~{n} == ~{n}.toFixed())\")))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [858 862]},
                                 :full-name "cljs.core/integer?",
                                 :clj-symbol "clojure.core/integer?",
                                 :docstring "Returns true if n is an integer.  Warning: returns true on underflow condition."},
           "cljs.core/HashMap.EMPTY" {:ns "cljs.core",
                                      :name "HashMap.EMPTY",
                                      :type "var",
                                      :parent-type "HashMap",
                                      :source {:code "(set! cljs.core.HashMap/EMPTY (HashMap. nil 0 (js-obj) 0))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3292]},
                                      :full-name "cljs.core/HashMap.EMPTY",
                                      :full-name-encode "cljs.core_HashMapDOTEMPTY",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.EMPTY" {:ns "cljs.core",
                                     :name "Vector.EMPTY",
                                     :type "var",
                                     :parent-type "Vector",
                                     :source {:code "(set! cljs.core.Vector/EMPTY (Vector. nil (array) 0))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2420]},
                                     :full-name "cljs.core/Vector.EMPTY",
                                     :full-name-encode "cljs.core_VectorDOTEMPTY",
                                     :history [["+" "0.0-927"]]},
           "clojure.zip/xml-zip" {:ns "clojure.zip",
                                  :name "xml-zip",
                                  :signature ["[root]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_xml-zip",
                                  :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [50 58]},
                                  :full-name "clojure.zip/xml-zip",
                                  :clj-symbol "clojure.zip/xml-zip",
                                  :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
           "clojure.walk/walk" {:ns "clojure.walk",
                                :name "walk",
                                :signature ["[inner outer form]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.walk_walk",
                                :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/clojure/walk.cljs",
                                         :lines [37 48]},
                                :full-name "clojure.walk/walk",
                                :clj-symbol "clojure.walk/walk",
                                :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/ifn?" {:description "Returns true if `f` implements the `IFn` protocol, false otherwise.\n\nFunctions, keywords, map, sets, and vectors can be called as functions.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "ifn?",
                             :signature ["[f]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/fn?"],
                             :full-name-encode "cljs.core_ifnQMARK",
                             :source {:code "(defn ^boolean ifn? [f]\n  (or (fn? f) (satisfies? IFn f)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [855 856]},
                             :full-name "cljs.core/ifn?",
                             :clj-symbol "clojure.core/ifn?"},
           "cljs.core/bit-xor" {:description "Bitwise \"exclusive or\". Same as `x ^ y` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-xor",
                                :signature ["[x y]" "[x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-and"
                                          "cljs.core/bit-or"],
                                :full-name-encode "cljs.core_bit-xor",
                                :source {:code "(defn bit-xor\n  [x y] (cljs.core/bit-xor x y))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1148 1150]},
                                :extra-sources ({:code "(defmacro bit-xor\n  ([x y] (list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [206 208]}),
                                :examples [{:id "3ccd99",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-xor 2r1100 2r1010)\n;;=> 6\n;; 6 = 2r0110\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-xor 12 10)\n;;=> 6\n```"}],
                                :full-name "cljs.core/bit-xor",
                                :clj-symbol "clojure.core/bit-xor",
                                :docstring "Bitwise exclusive or"},
           "clojure.set/union" {:description "Return a set that is the union of the input sets.",
                                :ns "clojure.set",
                                :name "union",
                                :signature ["[]"
                                            "[s1]"
                                            "[s1 s2]"
                                            "[s1 s2 & sets]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["clojure.set/intersection"
                                          "clojure.set/difference"
                                          "clojure.set/superset?"],
                                :full-name-encode "clojure.set_union",
                                :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [19 29]},
                                :full-name "clojure.set/union",
                                :clj-symbol "clojure.set/union",
                                :docstring "Return a set that is the union of the input sets"},
           "cljs.core/case" {:description "Takes an expression and a set of clauses. Each clause can take the form of\neither:\n\n`test-constant result-expr`\n\n`(test-constant1 ... test-constantN)  result-expr`\n\nThe test-constants are not evaluated. They must be compile-time literals, and\nneed not be quoted. If the expression is equal to a test-constant, the\ncorresponding `result-expr` is returned. A single default expression can follow\nthe clauses, and its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an Error is thrown.\n\nUnlike `cond` and `condp`, `case` does a constant-time dispatch, the clauses are\nnot considered sequentially. All manner of constant expressions are acceptable\nin `case`, including numbers, strings, symbols, keywords, and ClojureScript\ncomposites thereof. Note that since lists are used to group multiple constants\nthat map to the same expression, a vector can be used to match a list if needed.\nThe test-constants need not be all of the same type.",
                             :ns "cljs.core",
                             :name "case",
                             :signature ["[e & clauses]"],
                             :history [["+" "0.0-1211"]],
                             :type "macro",
                             :related ["cljs.core/cond"
                                       "cljs.core/condp"],
                             :full-name-encode "cljs.core_case",
                             :source {:code "(defmacro case [e & clauses]\n  (let [default (if (odd? (count clauses))\n                  (last clauses)\n                  `(throw (js/Error. (core/str \"No matching clause: \" ~e))))\n        pairs (partition 2 clauses)]\n   `(condp = ~e\n      ~@(apply concat pairs)\n      ~default)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [639 646]},
                             :examples [{:id "09a90c",
                                         :content "```clj\n(def a 1)\n(def b 2)\n\n(case a\n  0 \"zero\"\n  1 \"one\"\n  \"default\")\n;;=> \"one\"\n\n(case b\n  0 \"zero\"\n  1 \"one\"\n  \"default\")\n;;=> \"default\"\n\n(case b\n  0 \"zero\"\n  1 \"one\")\n;; Error: No matching clause: 2\n```"}],
                             :full-name "cljs.core/case",
                             :clj-symbol "clojure.core/case"},
           "cljs.repl/IJavaScriptEnv" {:ns "cljs.repl",
                                       :name "IJavaScriptEnv",
                                       :type "protocol",
                                       :full-name-encode "cljs.repl_IJavaScriptEnv",
                                       :source {:code "(defprotocol IJavaScriptEnv\n  (-setup [this] \"initialize the environment\")\n  (-evaluate [this filename line js] \"evaluate a javascript string\")\n  (-load [this ns url] \"load code at url into the environment\")\n  (-tear-down [this] \"dispose of the environment\"))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [18 22]},
                                       :methods [{:name "-setup",
                                                  :signature ["[this]"],
                                                  :docstring "initialize the environment"}
                                                 {:name "-evaluate",
                                                  :signature ["[this filename line js]"],
                                                  :docstring "evaluate a javascript string"}
                                                 {:name "-load",
                                                  :signature ["[this ns url]"],
                                                  :docstring "load code at url into the environment"}
                                                 {:name "-tear-down",
                                                  :signature ["[this]"],
                                                  :docstring "dispose of the environment"}],
                                       :full-name "cljs.repl/IJavaScriptEnv",
                                       :history [["+" "0.0-927"]]},
           "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                         :name "PushbackReader",
                                         :type "protocol",
                                         :full-name-encode "cljs.reader_PushbackReader",
                                         :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [12 15]},
                                         :methods [{:name "read-char",
                                                    :signature ["[reader]"],
                                                    :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                   {:name "unread",
                                                    :signature ["[reader ch]"],
                                                    :docstring "Push back a single character on to the stream"}],
                                         :full-name "cljs.reader/PushbackReader",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/isa?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "isa?",
                             :signature ["[child parent]"
                                         "[h child parent]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_isaQMARK",
                             :source {:code "(defn ^boolean isa?\n  ([child parent] (isa? @global-hierarchy child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (== (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (== i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [6137 6155]},
                             :full-name "cljs.core/isa?",
                             :clj-symbol "clojure.core/isa?",
                             :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a JavaScript type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
           "clojure.browser.net/xhr-connection" {:ns "clojure.browser.net",
                                                 :name "xhr-connection",
                                                 :signature ["[]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net_xhr-connection",
                                                 :source {:code "(defn xhr-connection\n  []\n  (goog.net.XhrIo.))",
                                                          :repo "clojurescript",
                                                          :tag "r1211",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [83
                                                                  86]},
                                                 :full-name "clojure.browser.net/xhr-connection",
                                                 :docstring "Returns an XhrIo connection"},
           "cljs.core/subs" {:description "Returns the substring of `s` beginning at `start` inclusive, and ending at `end`\nexclusive.\n\n`end` defaults to the length of the string.",
                             :ns "cljs.core",
                             :name "subs",
                             :signature ["[s start]" "[s start end]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_subs",
                             :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1274 1278]},
                             :full-name "cljs.core/subs",
                             :clj-symbol "clojure.core/subs",
                             :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
           "syntax/unquote" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nIntended for use inside a syntax-quote.\n\nForces evaluation of the following form.",
                             :ns "syntax",
                             :name "unquote",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/syntax-quote"
                                       "syntax/unquote-splicing"],
                             :full-name-encode "syntax_unquote",
                             :source {:repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form "~",
                             :examples [{:id "1ff51e",
                                         :content "```clj\n(def foo 1)\n`~foo\n;;=> 1\n\n`(def foo ~foo)\n;;=> (def cljs.user/foo 1)\n```"}],
                             :full-name "syntax/unquote",
                             :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/symbol?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "symbol?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_symbolQMARK",
                                :source {:code "(defn ^boolean symbol? [x]\n  (and (goog/isString x)\n       (identical? (.charAt x 0) \\uFDD1)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [845 847]},
                                :full-name "cljs.core/symbol?",
                                :clj-symbol "clojure.core/symbol?"},
           "clojure.string/replace" {:description "Replaces all instance of `match` with `replacement` in `s`.\n\nThe options for match / replacement are:\n\n| match  | replacement |\n|--------|-------------|\n| string | string      |\n| regex  | string      |\n| regex  | function    |",
                                     :ns "clojure.string",
                                     :name "replace",
                                     :signature ["[s match replacement]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/subs"
                                               "clojure.string/split"
                                               "clojure.string/replace-first"],
                                     :full-name-encode "clojure.string_replace",
                                     :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [23 34]},
                                     :full-name "clojure.string/replace",
                                     :clj-symbol "clojure.string/replace",
                                     :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/string?" {:description "Returns true if `x` is a string, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "string?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_stringQMARK",
                                :source {:code "(defn ^boolean string? [x]\n  (and (goog/isString x)\n       (not (or (identical? (.charAt x 0) \\uFDD0)\n                (identical? (.charAt x 0) \\uFDD1)))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [836 839]},
                                :full-name "cljs.core/string?",
                                :clj-symbol "clojure.core/string?"},
           "cljs.core/partition-all" {:description "Returns a lazy sequence of lists like `partition`, but may include partitions\nwith fewer than `n` items at the end.\n\nReturns a stateful transducer when no collection is provided.",
                                      :ns "cljs.core",
                                      :name "partition-all",
                                      :signature ["[n]"
                                                  "[n coll]"
                                                  "[n step coll]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :related ["cljs.core/partition"
                                                "cljs.core/partition-by"],
                                      :full-name-encode "cljs.core_partition-all",
                                      :source {:code "(defn partition-all\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [5345 5353]},
                                      :full-name "cljs.core/partition-all",
                                      :clj-symbol "clojure.core/partition-all",
                                      :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end."},
           "cljs.core/RedNode" {:ns "cljs.core",
                                :name "RedNode",
                                :type "type",
                                :signature ["[key val left right __hash]"],
                                :source {:code "(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. \"red-black tree invariant violation\")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  (toString [this]\n    (pr-str this))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [4607 4752]},
                                :full-name "cljs.core/RedNode",
                                :full-name-encode "cljs.core_RedNode",
                                :history [["+" "0.0-1211"]]},
           "cljs.core/merge-with" {:description "Returns a map that consists of the rest of the maps `conj`-ed onto the first.\n\nIf a key occurs in more than one map, the mapping(s) from the latter (left-to-\nright) will be combined with the mapping in the result by calling `(f val-in-\nresult val-in-latter)`.",
                                   :ns "cljs.core",
                                   :name "merge-with",
                                   :signature ["[f & maps]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/merge"],
                                   :full-name-encode "cljs.core_merge-with",
                                   :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [5044 5058]},
                                   :full-name "cljs.core/merge-with",
                                   :clj-symbol "clojure.core/merge-with",
                                   :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
           "cljs.core/key" {:description "Returns the key of the map entry.",
                            :ns "cljs.core",
                            :name "key",
                            :signature ["[map-entry]"],
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :related ["cljs.core/keys"],
                            :full-name-encode "cljs.core_key",
                            :source {:code "(defn key\n  [map-entry]\n  (-key map-entry))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [5021 5024]},
                            :full-name "cljs.core/key",
                            :clj-symbol "clojure.core/key",
                            :docstring "Returns the key of the map entry."},
           "clojure.browser.dom/set-properties" {:ns "clojure.browser.dom",
                                                 :name "set-properties",
                                                 :signature ["[e m]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom_set-properties",
                                                 :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (apply gobject/create (interleave (keys m) (vals m)))))",
                                                          :repo "clojurescript",
                                                          :tag "r1211",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [136
                                                                  140]},
                                                 :full-name "clojure.browser.dom/set-properties",
                                                 :docstring "Set properties on an element"},
           "cljs.core/ITransientAssociative" {:ns "cljs.core",
                                              :name "ITransientAssociative",
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "protocol",
                                              :full-name-encode "cljs.core_ITransientAssociative",
                                              :source {:code "(defprotocol ITransientAssociative\n  (-assoc! [tcoll key val]))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [250
                                                               251]},
                                              :methods [{:name "-assoc!",
                                                         :signature ["[tcoll key val]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/ITransientAssociative",
                                              :clj-symbol "clojure.lang/ITransientAssociative"},
           "cljs.core/trampoline" {:ns "cljs.core",
                                   :name "trampoline",
                                   :signature ["[f]" "[f & args]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_trampoline",
                                   :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6085 6099]},
                                   :full-name "cljs.core/trampoline",
                                   :clj-symbol "clojure.core/trampoline",
                                   :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
           "cljs.repl.browser/handle-connection" {:ns "cljs.repl.browser",
                                                  :name "handle-connection",
                                                  :type "function",
                                                  :signature ["[opts conn]"],
                                                  :source {:code "(defn handle-connection\n  [opts conn]\n  (let [rdr (BufferedReader. (InputStreamReader. (.getInputStream conn)))]\n    (if-let [request (read-request rdr)]\n      (case (:method request)\n        :get (handle-get opts conn request)\n        :post (handle-post conn (read-string (:content request)))\n        (.close conn))\n      (.close conn))))",
                                                           :repo "clojurescript",
                                                           :tag "r1211",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [247
                                                                   255]},
                                                  :full-name "cljs.repl.browser/handle-connection",
                                                  :full-name-encode "cljs.repl.browser_handle-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "clojure.browser.repl/send-print" {:ns "clojure.browser.repl",
                                              :name "send-print",
                                              :signature ["[url data]"
                                                          "[url data n]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl_send-print",
                                              :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [41 53]},
                                              :full-name "clojure.browser.repl/send-print",
                                              :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times."},
           "cljs.core/ICounted" {:ns "cljs.core",
                                 :name "ICounted",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_ICounted",
                                 :source {:code "(defprotocol ICounted\n  (-count [coll] \"constant time count\"))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [140 141]},
                                 :methods [{:name "-count",
                                            :signature ["[coll]"],
                                            :docstring "constant time count"}],
                                 :full-name "cljs.core/ICounted",
                                 :clj-symbol "clojure.lang/Counted"},
           "cljs.core/IEquiv" {:ns "cljs.core",
                               :name "IEquiv",
                               :type "protocol",
                               :full-name-encode "cljs.core_IEquiv",
                               :source {:code "(defprotocol IEquiv\n  (-equiv [o other]))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [205 206]},
                               :methods [{:name "-equiv",
                                          :signature ["[o other]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IEquiv",
                               :history [["+" "0.0-927"]]},
           "cljs.core/reduce-kv" {:description "Reduces an associative collection.\n\n`f` should be a function of 3 arguments. Returns the result of applying `f` to\n`init`, the first key and the first value in `coll`, then applying `f` to that\nresult and the 2nd key and value, etc.\n\nIf `coll` contains no entries, returns `init` and `f` is not called.\n\nNote that `reduce-kv` is supported on vectors, where the keys will be the\nordinals.",
                                  :ns "cljs.core",
                                  :name "reduce-kv",
                                  :signature ["[f init coll]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :related ["cljs.core/reduce"],
                                  :full-name-encode "cljs.core_reduce-kv",
                                  :source {:code "(defn reduce-kv\n  ([f init coll]\n     (-kv-reduce coll f init)))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [986 994]},
                                  :full-name "cljs.core/reduce-kv",
                                  :clj-symbol "clojure.core/reduce-kv",
                                  :docstring "Reduces an associative collection. f should be a function of 3\narguments. Returns the result of applying f to init, the first key\nand the first value in coll, then applying f to that result and the\n2nd key and value, etc. If coll contains no entries, returns init\nand f is not called. Note that reduce-kv is supported on vectors,\nwhere the keys will be the ordinals."},
           "cljs.core/js-delete" {:description "Deletes property `key` in JavaScript object `obj`.\n\nEquivalent to `delete obj[key]` in JavaScript.",
                                  :ns "cljs.core",
                                  :name "js-delete",
                                  :signature ["[obj key]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/dissoc"],
                                  :full-name-encode "cljs.core_js-delete",
                                  :source {:code "(defn js-delete [obj key]\n  (js* \"delete ~{obj}[~{key}]\"))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [784 785]},
                                  :examples [{:id "5b24ea",
                                              :content "```clj\n(def a #js {:foo 1 :bar 2})\n(js-delete a \"foo\")\n\na\n;;=> #js {:bar 2}\n```"}],
                                  :full-name "cljs.core/js-delete"},
           "cljs.core/PersistentTreeSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentTreeSet",
                                                :type "var",
                                                :full-name-encode "cljs.core_PersistentTreeSetDOTEMPTY",
                                                :source {:code "(set! cljs.core.PersistentTreeSet/EMPTY (PersistentTreeSet. nil (sorted-map) 0))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [5241]},
                                                :full-name "cljs.core/PersistentTreeSet.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentTreeSet.EMPTY"},
           "cljs.core/comment" {:description "Ignores all `body` forms (i.e. \"commenting out\"). Returns nil.\n\nThis is often used near the bottom of a file to hold expressions that test\ndifferent functions during development.  Specific expressions within the\n`comment` can then be selected and evaluated from some editors.\n\nYou can also use `;` to \"comment out\" code until the end of a line.",
                                :ns "cljs.core",
                                :name "comment",
                                :signature ["[& body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_comment",
                                :source {:code "(defmacro comment\n  [& body])",
                                         :repo "clojure",
                                         :tag "clojure-1.4.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [4165 4168]},
                                :examples [{:id "482fd7",
                                            :content "```clj\n(comment 123)\n;;=> nil\n\n(comment\n  (foo 1 2 3)\n  (bar \"hello\"))\n;;=> nil\n```\n\nInner forms must still be syntactically correct:\n\n```clj\n(comment [1 2 3]])\n;; Error: Unmatched delimiter ]\n\n(comment a : b)\n;; Error: Invalid token :\n```"}],
                                :full-name "cljs.core/comment",
                                :clj-symbol "clojure.core/comment",
                                :docstring "Ignores body, yields nil"},
           "cljs.reader/special-symbols" {:ns "cljs.reader",
                                          :name "special-symbols",
                                          :type "var",
                                          :source {:code "(def special-symbols\n  {\"nil\" nil\n   \"true\" true\n   \"false\" false})",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [243 246]},
                                          :full-name "cljs.reader/special-symbols",
                                          :full-name-encode "cljs.reader_special-symbols",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/BitmapIndexedNode.EMPTY" {:ns "cljs.core",
                                                :name "BitmapIndexedNode.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "BitmapIndexedNode",
                                                :type "var",
                                                :full-name-encode "cljs.core_BitmapIndexedNodeDOTEMPTY",
                                                :source {:code "(set! cljs.core.BitmapIndexedNode/EMPTY (BitmapIndexedNode. nil 0 (make-array 0)))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [3779]},
                                                :full-name "cljs.core/BitmapIndexedNode.EMPTY",
                                                :clj-symbol "clojure.lang/BitmapIndexedNode.EMPTY"},
           "cljs.core/alength" {:description "For interop, it returns the length of a JavaScript array or string.",
                                :ns "cljs.core",
                                :name "alength",
                                :signature ["[a]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/count"],
                                :full-name-encode "cljs.core_alength",
                                :source {:code "(defn alength\n  [array]\n  (.-length array))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [101 104]},
                                :extra-sources ({:code "(defmacro alength [a]\n  (list 'js* \"~{}.length\" a))",
                                                 :repo "clojurescript",
                                                 :tag "r1211",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [804 805]}),
                                :examples [{:id "26f79f",
                                            :content "```clj\n(def a #js [1 2 3])\n\n(alength a)\n;;=> 3\n\n(.-length a)\n;;=> 3\n\n(aget a \"length\")\n;;=> 3\n\n(count a)\n;;=> 3\n```"}],
                                :full-name "cljs.core/alength",
                                :clj-symbol "clojure.core/alength",
                                :docstring "Returns the length of the array. Works on arrays of all types."},
           "cljs.core/mk-bound-fn" {:ns "cljs.core",
                                    :name "mk-bound-fn",
                                    :type "function",
                                    :signature ["[sc test key]"],
                                    :source {:code "(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [5364 5368]},
                                    :full-name "cljs.core/mk-bound-fn",
                                    :full-name-encode "cljs.core_mk-bound-fn",
                                    :history [["+" "0.0-1211"]]},
           "special/quote" {:ns "special",
                            :name "quote",
                            :type "special form",
                            :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _]\n  {:op :constant :env env :form x})",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [1051 1053]},
                            :full-name "special/quote",
                            :full-name-encode "special_quote",
                            :clj-symbol "clojure.core/quote",
                            :history [["+" "0.0-927"]]},
           "cljs.core/VectorNode" {:ns "cljs.core",
                                   :name "VectorNode",
                                   :type "type",
                                   :signature ["[edit arr]"],
                                   :source {:code "(deftype VectorNode [edit arr])",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2426]},
                                   :full-name "cljs.core/VectorNode",
                                   :full-name-encode "cljs.core_VectorNode",
                                   :history [["+" "0.0-1211"]]},
           "cljs.core/tree-seq" {:description "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n\n`branch?` must be a function of one argument that returns true if passed a node\nthat can have children (but may not).\n\n`children` must be a function of one argument that returns a sequence of the\nchildren. `children` will only be called on nodes for which `branch?` returns\ntrue.\n\n`root` is the root node of the tree.",
                                 :ns "cljs.core",
                                 :name "tree-seq",
                                 :signature ["[branch? children root]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_tree-seq",
                                 :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2212 2225]},
                                 :full-name "cljs.core/tree-seq",
                                 :clj-symbol "clojure.core/tree-seq",
                                 :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
           "cljs.reader/read-unmatched-delimiter" {:ns "cljs.reader",
                                                   :name "read-unmatched-delimiter",
                                                   :type "function",
                                                   :signature ["[rdr ch]"],
                                                   :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmached delimiter \" ch))",
                                                            :repo "clojurescript",
                                                            :tag "r1211",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [199
                                                                    201]},
                                                   :full-name "cljs.reader/read-unmatched-delimiter",
                                                   :full-name-encode "cljs.reader_read-unmatched-delimiter",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/every-pred" {:description "Takes a set of predicate functions and returns a function `f` that returns true\nif all of its composing predicates return a logical true value against all of\nits arguments, else it returns false.\n\nNote that `f` is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates.",
                                   :ns "cljs.core",
                                   :name "every-pred",
                                   :signature ["[p]"
                                               "[p1 p2]"
                                               "[p1 p2 p3]"
                                               "[p1 p2 p3 & ps]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/some-fn"
                                             "cljs.core/and"],
                                   :full-name-encode "cljs.core_every-pred",
                                   :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1971 2008]},
                                   :full-name "cljs.core/every-pred",
                                   :clj-symbol "clojure.core/every-pred",
                                   :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
           "syntax/js-ns" {:ns "syntax",
                           :name "js-ns",
                           :syntax-form "js/",
                           :type "special namespace",
                           :full-name "syntax/js-ns",
                           :full-name-encode "syntax_js-ns",
                           :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashSet" {:ns "cljs.core",
                                          :name "PersistentHashSet",
                                          :signature ["[meta hash-map __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_PersistentHashSet",
                                          :source {:code "(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n  \n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashSet. meta hash-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentHashSet/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-iset __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (transient hash-map))))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5078 5132]},
                                          :full-name "cljs.core/PersistentHashSet",
                                          :clj-symbol "clojure.lang/PersistentHashSet"},
           "clojure.set/rename-keys" {:ns "clojure.set",
                                      :name "rename-keys",
                                      :signature ["[map kmap]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.set_rename-keys",
                                      :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (and (not= old new)\n                (contains? m old))\n         (-> m (assoc new (get m old)) (dissoc old))\n         m)) \n     map kmap))",
                                               :repo "clojurescript",
                                               :tag "r1211",
                                               :filename "src/cljs/clojure/set.cljs",
                                               :lines [72 81]},
                                      :full-name "clojure.set/rename-keys",
                                      :clj-symbol "clojure.set/rename-keys",
                                      :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/peek" {:description "Returns the first element of a list; same as `first`.\n\nReturns the last element of a vector, and much more efficient than using `last`.\n\nReturns nil if `coll` is empty.",
                             :ns "cljs.core",
                             :name "peek",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/first"
                                       "cljs.core/pop"
                                       "cljs.core/conj"],
                             :full-name-encode "cljs.core_peek",
                             :source {:code "(defn peek\n  [coll]\n  (-peek coll))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [694 698]},
                             :examples [{:id "4abc4c",
                                         :content "With vectors:\n\n```clj\n(peek [1 2 3])\n;;=> 3\n\n(peek [1 2])\n;;=> 2\n\n(peek [1])\n;;=> 1\n\n(peek [])\n;;=> nil\n```"}
                                        {:id "d50bd0",
                                         :content "With lists:\n\n```clj\n(peek '(1 2 3))\n;;=> 1\n\n(peek '(1 2))\n;;=> 1\n\n(peek '(1))\n;;=> 1\n\n(peek '())\n;;=> nil\n```"}],
                             :full-name "cljs.core/peek",
                             :clj-symbol "clojure.core/peek",
                             :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
           "cljs.core/pr-str-with-opts" {:ns "cljs.core",
                                         :name "pr-str-with-opts",
                                         :signature ["[objs opts]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_pr-str-with-opts",
                                         :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (str (pr-sb objs opts)))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [5661 5665]},
                                         :full-name "cljs.core/pr-str-with-opts",
                                         :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts"},
           "cljs.core/ITransientVector" {:ns "cljs.core",
                                         :name "ITransientVector",
                                         :history [["+" "0.0-1211"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core_ITransientVector",
                                         :source {:code "(defprotocol ITransientVector\n  (-assoc-n! [tcoll n val])\n  (-pop! [tcoll]))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [256 258]},
                                         :methods [{:name "-assoc-n!",
                                                    :signature ["[tcoll n val]"],
                                                    :docstring nil}
                                                   {:name "-pop!",
                                                    :signature ["[tcoll]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/ITransientVector",
                                         :clj-symbol "clojure.lang/ITransientVector"},
           "cljs.core/map?" {:description "Returns true if `x` is a map, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "map?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/hash-map"
                                       "cljs.core/sorted-map"],
                             :full-name-encode "cljs.core_mapQMARK",
                             :source {:code "(defn ^boolean map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [761 766]},
                             :full-name "cljs.core/map?",
                             :clj-symbol "clojure.core/map?",
                             :docstring "Return true if x satisfies IMap"},
           "cljs.reader/StringPushbackReader" {:ns "cljs.reader",
                                               :name "StringPushbackReader",
                                               :type "type",
                                               :signature ["[s index-atom buffer-atom]"],
                                               :source {:code "(deftype StringPushbackReader [s index-atom buffer-atom]\n  PushbackReader\n  (read-char [reader]\n             (if (empty? @buffer-atom)\n               (let [idx @index-atom]\n                 (swap! index-atom inc)\n                 (nth s idx))\n               (let [buf @buffer-atom]\n                 (swap! buffer-atom rest)\n                 (first buf))))\n  (unread [reader ch] (swap! buffer-atom #(cons ch %))))",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [18 28]},
                                               :full-name "cljs.reader/StringPushbackReader",
                                               :full-name-encode "cljs.reader_StringPushbackReader",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/PersistentTreeMap" {:ns "cljs.core",
                                          :name "PersistentTreeMap",
                                          :signature ["[comp tree cnt meta __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_PersistentTreeMap",
                                          :source {:code "(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  (entry-at [coll k]\n    (loop [t tree]\n      (if (coercive-not= t nil)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentTreeMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if (coercive-not= tree nil)\n      (tree-map-kv-reduce tree f init)\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if (coercive-not= n nil)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (coercive-= t nil)\n        (let [found-node (nth found 0)]\n          (if (= v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (coercive-not= (.entry-at coll k) nil))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (coercive-= t nil)\n        (if (coercive-= (nth found 0) nil)\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if (coercive-not= t nil)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (if (coercive-= stack nil)\n            (PersistentTreeMapSeq. nil stack ascending? -1))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [4859 4978]},
                                          :full-name "cljs.core/PersistentTreeMap",
                                          :clj-symbol "clojure.lang/PersistentTreeMap"},
           "cljs.core/HashMap.fromArrays" {:ns "cljs.core",
                                           :name "HashMap.fromArrays",
                                           :signature ["[ks vs]"],
                                           :history [["+" "0.0-927"]],
                                           :parent-type "HashMap",
                                           :type "function",
                                           :full-name-encode "cljs.core_HashMapDOTfromArrays",
                                           :source {:code "(set! cljs.core.HashMap/fromArrays (fn [ks vs]\n  (let [len (.-length ks)]\n    (loop [i 0, out cljs.core.HashMap/EMPTY]\n      (if (< i len)\n        (recur (inc i) (assoc out (aget ks i) (aget vs i)))\n        out)))))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3294 3299]},
                                           :full-name "cljs.core/HashMap.fromArrays"},
           "cljs.core/deref" {:description "Returns the current value of atom `x`.\n\nThe `@` reader macro is often used instead of `deref`. `@foo` is the same thing\nas `(deref foo)`.",
                              :ns "cljs.core",
                              :name "deref",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/atom"],
                              :full-name-encode "cljs.core_deref",
                              :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5939 5941]},
                              :full-name "cljs.core/deref",
                              :clj-symbol "clojure.core/deref"},
           "cljs.core/reductions" {:description "Returns a lazy sequence of the intermediate values of the reduction (as per\n`reduce`) of `coll` by `f`, starting with `init`.",
                                   :ns "cljs.core",
                                   :name "reductions",
                                   :signature ["[f coll]"
                                               "[f init coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/reduce"],
                                   :full-name-encode "cljs.core_reductions",
                                   :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [5502 5514]},
                                   :full-name "cljs.core/reductions",
                                   :clj-symbol "clojure.core/reductions",
                                   :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
           "cljs.core/false?" {:description "Returns true if `x` is the value false, false otherwise.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "false?",
                               :signature ["[x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/true?"
                                         "cljs.core/not"],
                               :full-name-encode "cljs.core_falseQMARK",
                               :source {:code "(defn ^boolean false?\n  [x] (cljs.core/false? x))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [807 809]},
                               :extra-sources ({:code "(defmacro false? [x]\n  (bool-expr (list 'js* \"~{} === false\" x)))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [96 97]}),
                               :full-name "cljs.core/false?",
                               :clj-symbol "clojure.core/false?",
                               :docstring "Returns true if x is the value false, false otherwise."},
           "cljs.core/bit-flip" {:description "Flip bit at index `n`.  Same as `x ^ (1 << y)` in JavaScript.",
                                 :ns "cljs.core",
                                 :name "bit-flip",
                                 :signature ["[x n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/bit-set"
                                           "cljs.core/bit-clear"],
                                 :full-name-encode "cljs.core_bit-flip",
                                 :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1169 1172]},
                                 :extra-sources ({:code "(defmacro bit-flip [x n]\n  (list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [217 218]}),
                                 :examples [{:id "5d7ee0",
                                             :content "Bits can be entered using radix notation:\n\n```clj\n(bit-flip 2r1111 2)\n;;=> 11\n;; 11 = 2r1011\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-flip 15 2)\n;;=> 11\n```"}],
                                 :full-name "cljs.core/bit-flip",
                                 :clj-symbol "clojure.core/bit-flip",
                                 :docstring "Flip bit at index n"},
           "cljs.core/ISet" {:ns "cljs.core",
                             :name "ISet",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core_ISet",
                             :source {:code "(defprotocol ISet\n  (-disjoin [coll v]))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [177 178]},
                             :methods [{:name "-disjoin",
                                        :signature ["[coll v]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISet",
                             :clj-symbol "clojure.lang/IPersistentSet"},
           "cljs.core/LazySeq" {:ns "cljs.core",
                                :name "LazySeq",
                                :signature ["[meta realized x __hash]"],
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core_LazySeq",
                                :source {:code "(deftype LazySeq [meta realized x ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta realized x __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first (lazy-seq-value coll)))\n  (-rest [coll] (rest (lazy-seq-value coll)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] (seq (lazy-seq-value coll))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1555 1584]},
                                :full-name "cljs.core/LazySeq",
                                :clj-symbol "clojure.lang/LazySeq"},
           "cljs.core/pop!" {:ns "cljs.core",
                             :name "pop!",
                             :signature ["[tcoll]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core_popBANG",
                             :source {:code "(defn pop! [tcoll]\n  (-pop! tcoll))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1736 1737]},
                             :full-name "cljs.core/pop!",
                             :clj-symbol "clojure.core/pop!"},
           "cljs.repl.rhino/IEval" {:ns "cljs.repl.rhino",
                                    :name "IEval",
                                    :type "protocol",
                                    :full-name-encode "cljs.repl.rhino_IEval",
                                    :source {:code "(defprotocol IEval\n  (-eval [this env filename line]))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/clj/cljs/repl/rhino.clj",
                                             :lines [26 27]},
                                    :methods [{:name "-eval",
                                               :signature ["[this env filename line]"],
                                               :docstring nil}],
                                    :full-name "cljs.repl.rhino/IEval",
                                    :history [["+" "0.0-927"]]},
           "cljs.repl.browser/start-server" {:ns "cljs.repl.browser",
                                             :name "start-server",
                                             :signature ["[opts]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser_start-server",
                                             :source {:code "(defn start-server\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! server-state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                                      :repo "clojurescript",
                                                      :tag "r1211",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [264 269]},
                                             :full-name "cljs.repl.browser/start-server",
                                             :docstring "Start the server on the specified port."},
           "cljs.core/*2" {:description "Only usable from a REPL.\n\nHolds the result of the second to last expression.",
                           :ns "cljs.core",
                           :name "*2",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*3"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR2",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [29 31]},
                           :examples [{:id "208d41",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n(+ 4 8)\n;;=> 12\n\n*2\n;;=> 10\n\n(inc *2)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*2",
                           :clj-symbol "clojure.core/*2",
                           :docstring "bound in a repl thread to the second most recent value printed"},
           "clojure.browser.event/total-listener-count" {:ns "clojure.browser.event",
                                                         :name "total-listener-count",
                                                         :type "function",
                                                         :signature ["[]"],
                                                         :source {:code "(defn total-listener-count []\n  (goog.events/getTotalListenerCount))",
                                                                  :repo "clojurescript",
                                                                  :tag "r1211",
                                                                  :filename "src/cljs/clojure/browser/event.cljs",
                                                                  :lines [85
                                                                          86]},
                                                         :full-name "clojure.browser.event/total-listener-count",
                                                         :full-name-encode "clojure.browser.event_total-listener-count",
                                                         :history [["+"
                                                                    "0.0-927"]]},
           "cljs.core/alter-meta!" {:description "Alter the metadata of `data` to be `(apply f its-current-meta args)`.\n\nMetadata of vars cannot be altered since they are statically determined at compile-time.",
                                    :ns "cljs.core",
                                    :name "alter-meta!",
                                    :signature ["[data f & args]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/with-meta"
                                              "cljs.core/vary-meta"],
                                    :full-name-encode "cljs.core_alter-metaBANG",
                                    :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [5958 5965]},
                                    :examples [{:id "8378a0",
                                                :content "Metadata of symbols and collections can be altered:\n\n```clj\n(def a ^:foo [1 2 3])\n(meta a)\n;;=> {:foo true}\n\n(alter-meta! a assoc :bar true)\n(meta a)\n;;=> {:foo true, :bar true}\n```\n\nMetadata of vars cannot be altered:\n\n```clj\n(def a [1 2 3])\n(meta #'a)\n;;=> {:arglists (), :test nil, :name a, :column 1, :line 1, :file \"<cljs repl>\", :doc nil, :ns cljs.user}\n\n(alter-meta! #'a assoc :bar true)\n(:bar (meta #'a))\n;;=> nil\n```"}],
                                    :full-name "cljs.core/alter-meta!",
                                    :clj-symbol "clojure.core/alter-meta!",
                                    :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
           "clojure.browser.dom/click-element" {:ns "clojure.browser.dom",
                                                :name "click-element",
                                                :type "function",
                                                :signature ["[e]"],
                                                :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                         :repo "clojurescript",
                                                         :tag "r1211",
                                                         :filename "src/cljs/clojure/browser/dom.cljs",
                                                         :lines [147
                                                                 149]},
                                                :full-name "clojure.browser.dom/click-element",
                                                :full-name-encode "clojure.browser.dom_click-element",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/bit-shift-right-zero-fill" {:ns "cljs.core",
                                                  :name "bit-shift-right-zero-fill",
                                                  :signature ["[x n]"],
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_bit-shift-right-zero-fill",
                                                  :source {:code "(defn bit-shift-right-zero-fill\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))",
                                                           :repo "clojurescript",
                                                           :tag "r1211",
                                                           :filename "src/cljs/cljs/core.cljs",
                                                           :lines [1196
                                                                   1198]},
                                                  :extra-sources ({:code "(defmacro bit-shift-right-zero-fill [x n]\n  (list 'js* \"(~{} >>> ~{})\" x n))",
                                                                   :repo "clojurescript",
                                                                   :tag "r1211",
                                                                   :filename "src/clj/cljs/core.clj",
                                                                   :lines [229
                                                                           230]}),
                                                  :full-name "cljs.core/bit-shift-right-zero-fill",
                                                  :docstring "Bitwise shift right with zero fill"},
           "cljs.repl.browser/server-loop" {:ns "cljs.repl.browser",
                                            :name "server-loop",
                                            :type "function",
                                            :signature ["[opts server-socket]"],
                                            :source {:code "(defn server-loop\n  [opts server-socket]\n  (let [conn (.accept server-socket)]\n    (do (.setKeepAlive conn true)\n        (future (handle-connection opts conn))\n        (recur opts server-socket))))",
                                                     :repo "clojurescript",
                                                     :tag "r1211",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [257 262]},
                                            :full-name "cljs.repl.browser/server-loop",
                                            :full-name-encode "cljs.repl.browser_server-loop",
                                            :history [["+" "0.0-927"]]},
           "cljs.reader/read-meta" {:ns "cljs.reader",
                                    :name "read-meta",
                                    :type "function",
                                    :signature ["[rdr _]"],
                                    :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [287 295]},
                                    :full-name "cljs.reader/read-meta",
                                    :full-name-encode "cljs.reader_read-meta",
                                    :history [["+" "0.0-927"]]},
           "special/try*" {:ns "special",
                           :name "try*",
                           :type "special form",
                           :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze-block\n                   (assoc env :context :statement)\n                   fblock))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        mname (when name (munge name))\n        locals (if name\n                 (assoc locals name {:name mname})\n                 locals)\n        catch (when cblock\n                (analyze-block (assoc catchenv :locals locals) (rest cblock)))\n        body (if name (pop body) body)\n        try (when body\n              (analyze-block (if (or name finally) catchenv env) body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name mname\n     :catch catch\n     :children (vec (mapcat block-children\n                            [try catch finally]))}))",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [847 881]},
                           :full-name "special/try*",
                           :full-name-encode "special_trySTAR",
                           :history [["+" "0.0-927"]]},
           "syntax/ignore" {:description "Causes the following form to be completely skipped by the reader.  This is a\nmore complete removal than the `comment` macro which yields nil.",
                            :ns "syntax",
                            :name "ignore",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["syntax/comment"
                                      "cljs.core/comment"],
                            :full-name-encode "syntax_ignore",
                            :source {:repo "clojure",
                                     :tag "clojure-1.4.0",
                                     :filename "src/jvm/clojure/lang/LispReader.java",
                                     :lines [nil]},
                            :syntax-form "#_",
                            :examples [{:id "f36d7a",
                                        :content "```clj\n{:foo #_bar 2}\n;;=> {:foo 2}\n```\n\nTo comment out the last line of a function without worrying about commenting out\nthe trailing parentheses:\n\n```clj\n(defn foo []\n  (println \"hello\")\n  #_(println \"world\"))\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#discard",
                            :full-name "syntax/ignore",
                            :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/range" {:description "Returns a lazy sequence of nums from `start` (inclusive) to `end` (exclusive),\nby `step`, where `start` defaults to 0, `step` to 1, and `end` to infinity.",
                              :ns "cljs.core",
                              :name "range",
                              :signature ["[]"
                                          "[end]"
                                          "[start end]"
                                          "[start end step]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/repeat"],
                              :full-name-encode "cljs.core_range",
                              :source {:code "(defn range\n  ([] (range 0 js/Number.MAX_VALUE 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step nil)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5461 5468]},
                              :full-name "cljs.core/range",
                              :clj-symbol "clojure.core/range",
                              :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
           "cljs.repl.browser/read-post" {:ns "cljs.repl.browser",
                                          :name "read-post",
                                          :type "function",
                                          :signature ["[line rdr]"],
                                          :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/clj/cljs/repl/browser.clj",
                                                   :lines [142 151]},
                                          :full-name "cljs.repl.browser/read-post",
                                          :full-name-encode "cljs.repl.browser_read-post",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/reify" {:ns "cljs.core",
                              :name "reify",
                              :signature ["[& impls]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core_reify",
                              :source {:code "(defmacro reify [& impls]\n  (let [t      (gensym \"t\")\n        locals (keys (:locals &env))\n        ns     (-> &env :ns :name)\n        munge  cljs.compiler/munge\n        ns-t   (list 'js* (core/str (munge ns) \".\" (munge t)))]\n    `(do\n       (when (undefined? ~ns-t)\n         (deftype ~t [~@locals __meta#]\n           cljs.core.IWithMeta\n           (~'-with-meta [_# __meta#]\n             (new ~t ~@locals __meta#))\n           cljs.core.IMeta\n           (~'-meta [_#] __meta#)\n           ~@impls))\n       (new ~t ~@locals nil))))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [265 280]},
                              :full-name "cljs.core/reify",
                              :clj-symbol "clojure.core/reify"},
           "cljs.core/satisfies?" {:ns "cljs.core",
                                   :name "satisfies?",
                                   :signature ["[psym x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core_satisfiesQMARK",
                                   :source {:code "(defmacro satisfies?\n  [psym x]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        prefix (protocol-prefix p)\n        xsym (gensym)\n        [part bit] (fast-path-protocols p)\n        msym (symbol (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    `(let [~xsym ~x]\n       (if (coercive-not= ~xsym nil)\n         (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit))\n                 ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n           true\n           (if (coercive-not (. ~xsym ~msym))\n             (cljs.core/type_satisfies_ ~psym ~xsym)\n             false))\n         (cljs.core/type_satisfies_ ~psym ~xsym)))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [543 559]},
                                   :full-name "cljs.core/satisfies?",
                                   :clj-symbol "clojure.core/satisfies?",
                                   :docstring "Returns true if x satisfies the protocol"},
           "cljs.core/nth" {:description "Returns the value at index `n` or `not-found` if the index is out of bounds.\n\n`nth` will throw an exception if `n` is out of bounds and `not-found` is not\nsupplied.\n\n`nth` works for Strings, Arrays, Regex Matchers, Lists, and Sequences. For\nSequences, `nth` takes O(n) time.",
                            :ns "cljs.core",
                            :name "nth",
                            :signature ["[coll n]"
                                        "[coll n not-found]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/first"
                                      "cljs.core/second"
                                      "cljs.core/nthnext"
                                      "cljs.core/get"],
                            :full-name-encode "cljs.core_nth",
                            :source {:code "(defn nth\n  ([coll n]\n     (if (satisfies? IIndexed coll)\n       (-nth coll (.floor js/Math n))\n       (linear-traversal-nth coll (.floor js/Math n))))\n  ([coll n not-found]\n     (if (satisfies? IIndexed coll)\n       (-nth coll (.floor js/Math n) not-found)\n       (linear-traversal-nth coll (.floor js/Math n) not-found))))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [636 648]},
                            :full-name "cljs.core/nth",
                            :clj-symbol "clojure.core/nth",
                            :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
           "cljs.core/list" {:description "Creates a new list containing `items`.",
                             :ns "cljs.core",
                             :name "list",
                             :signature ["[& items]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/vector"
                                       "cljs.core/list?"],
                             :full-name-encode "cljs.core_list",
                             :source {:code "(defn list [& items]\n  (reduce conj () (reverse items)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1447 1448]},
                             :full-name "cljs.core/list",
                             :clj-symbol "clojure.core/list"},
           "cljs.core/defn" {:description "Defines a function.\n\n`doc-string?` is an optional documentation string.\n\n`attr-map?` is an optional map of [metadata](http://clojure.org/metadata) to\nattach to the global variable name.\n\n`prepost-map?` is an optional map with optional keys `:pre` and `:post` that\ncontain collections of [pre or post conditions](http://blog.fogus.me/2009/12/21/clojures-pre-and-post/)\nfor the function.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(defn foo [a b c]\n  (\\* a b c))</pre></td>\n      <td><pre>\n(def foo\n  (fn [a b c]\n    (\\* a b c)))</pre></td></tr></tbody></table>",
                             :ns "cljs.core",
                             :name "defn",
                             :signature ["[name doc-string? attr-map? [params*] prepost-map? body]"
                                         "[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["special/def"
                                       "cljs.core/defn-"
                                       "cljs.core/defmacro"
                                       "cljs.core/fn"],
                             :full-name-encode "cljs.core_defn",
                             :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                      :repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [263 309]},
                             :full-name "cljs.core/defn",
                             :clj-symbol "clojure.core/defn",
                             :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata. prepost-map defines a map with optional keys\n :pre and :post that contain collections of pre or post conditions."},
           "cljs.core/rand-nth" {:description "Returns a random element from a sequential collection `coll`.\n\nHas the same performance characteristics as `nth`.",
                                 :ns "cljs.core",
                                 :name "rand-nth",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/rand"],
                                 :full-name-encode "cljs.core_rand-nth",
                                 :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [6111 6116]},
                                 :full-name "cljs.core/rand-nth",
                                 :clj-symbol "clojure.core/rand-nth",
                                 :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
           "cljs.core/atom" {:description "Creates and returns an atom with an initial value of `x`.\n\n`opts` is an optional map with optional keys `:meta` and `:validator`.\n\n`:meta` should be a [metadata-map](http://clojure.org/metadata) for the atom.\n\n`:validator` should be a validator function for the atom. See `set-validator!`\nfor more information.",
                             :ns "cljs.core",
                             :name "atom",
                             :signature ["[x]" "[x opts]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/atom"
                                       "cljs.core/swap!"
                                       "cljs.core/reset!"
                                       "cljs.core/set-validator!"
                                       "cljs.core/get-validator"],
                             :full-name-encode "cljs.core_atom",
                             :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [5883 5898]},
                             :examples [{:id "e6a38a",
                                         :content "```clj\n(def a (atom 1))\n\n@a\n;;=> 1\n\n(reset! a 2)\n@a\n;;=> 2\n\n(swap! a inc)\n@a\n;;=> 3\n```"}],
                             :full-name "cljs.core/atom",
                             :clj-symbol "clojure.core/atom",
                             :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
           "cljs.reader/read-keyword" {:ns "cljs.reader",
                                       :name "read-keyword",
                                       :type "function",
                                       :signature ["[reader initch]"],
                                       :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        [token ns name] (re-matches symbol-pattern token)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if ns\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                :repo "clojurescript",
                                                :tag "r1211",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [256 267]},
                                       :full-name "cljs.reader/read-keyword",
                                       :full-name-encode "cljs.reader_read-keyword",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/Vector" {:ns "cljs.core",
                               :name "Vector",
                               :type "type",
                               :signature ["[meta array __hash]"],
                               :source {:code "(deftype Vector [meta array ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (.-length array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (.-length array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array nil))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (.-length array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (.-length array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (.-length array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (.-length array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2333 2418]},
                               :full-name "cljs.core/Vector",
                               :full-name-encode "cljs.core_Vector",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/skip-line" {:ns "cljs.reader",
                                    :name "skip-line",
                                    :signature ["[reader _]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader_skip-line",
                                    :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (identical? ch \\n) (identical? ch \\r) (nil? ch))\n        reader\n        (recur)))))",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [86 93]},
                                    :full-name "cljs.reader/skip-line",
                                    :docstring "Advances the reader to the end of a line. Returns the reader"},
           "cljs.core/namespace" {:ns "cljs.core",
                                  :name "namespace",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_namespace",
                                  :source {:code "(defn namespace\n  [x]\n  (if (or (keyword? x) (symbol? x))\n    (let [i (.lastIndexOf x \"/\")]\n      (when (> i -1)\n        (subs x 2 i)))\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [5310 5317]},
                                  :full-name "cljs.core/namespace",
                                  :clj-symbol "clojure.core/namespace",
                                  :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
           "cljs.nodejs/require" {:ns "cljs.nodejs",
                                  :name "require",
                                  :type "var",
                                  :source {:code "(def require (js* \"require\"))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [7]},
                                  :full-name "cljs.nodejs/require",
                                  :full-name-encode "cljs.nodejs_require",
                                  :history [["+" "0.0-927"]]},
           "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                              :name "EventType",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.event_EventType",
                                              :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                       :repo "clojurescript",
                                                       :tag "r1211",
                                                       :filename "src/cljs/clojure/browser/event.cljs",
                                                       :lines [17 18]},
                                              :methods [{:name "event-types",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.event/EventType",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.repl.rhino/rhino-setup" {:ns "cljs.repl.rhino",
                                          :name "rhino-setup",
                                          :type "function",
                                          :signature ["[repl-env]"],
                                          :source {:code "(defn rhino-setup [repl-env]\n  (let [env {:context :statement :locals {} :ns (@comp/namespaces comp/*cljs-ns*)}\n        scope (:scope repl-env)]\n    (repl/load-file repl-env \"cljs/core.cljs\")\n    (swap! loaded-libs conj \"cljs.core\")\n    (repl/evaluate-form repl-env\n                        env\n                        \"<cljs repl>\"\n                        '(ns cljs.user))\n    (ScriptableObject/putProperty scope\n                                  \"out\"\n                                  (Context/javaToJS System/out scope))\n    (repl/evaluate-form repl-env\n                        env\n                        \"<cljs repl>\"\n                        '(set! *print-fn* (fn [x] (.print js/out x))))))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [95 110]},
                                          :full-name "cljs.repl.rhino/rhino-setup",
                                          :full-name-encode "cljs.repl.rhino_rhino-setup",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/merge" {:description "Returns a map that consists of the rest of the maps `conj`-ed onto the first.\n\nIf a key occurs in more than one map, the mapping from the rightmost map will\n\"win\".",
                              :ns "cljs.core",
                              :name "merge",
                              :signature ["[& maps]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/merge-with"
                                        "cljs.core/hash-map"],
                              :full-name-encode "cljs.core_merge",
                              :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                       :repo "clojurescript",
                                       :tag "r1211",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [5036 5042]},
                              :full-name "cljs.core/merge",
                              :clj-symbol "clojure.core/merge",
                              :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
           "clojure.browser.repl/send-result" {:ns "clojure.browser.repl",
                                               :name "send-result",
                                               :type "function",
                                               :signature ["[connection url data]"],
                                               :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/cljs/clojure/browser/repl.cljs",
                                                        :lines [38 39]},
                                               :full-name "clojure.browser.repl/send-result",
                                               :full-name-encode "clojure.browser.repl_send-result",
                                               :history [["+"
                                                          "0.0-927"]]},
           "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                           :name "keywordize-keys",
                                           :signature ["[m]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk_keywordize-keys",
                                           :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [64 70]},
                                           :full-name "clojure.walk/keywordize-keys",
                                           :clj-symbol "clojure.walk/keywordize-keys",
                                           :docstring "Recursively transforms all map keys from strings to keywords."},
           "cljs.core/reduced" {:ns "cljs.core",
                                :name "reduced",
                                :signature ["[x]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core_reduced",
                                :source {:code "(defn reduced\n  [x]\n  (Reduced. x))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1005 1008]},
                                :full-name "cljs.core/reduced",
                                :docstring "Wraps x in a way such that a reduce will terminate with the value x"},
           "cljs.core/derive" {:ns "cljs.core",
                               :name "derive",
                               :signature ["[tag parent]"
                                           "[h tag parent]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_derive",
                               :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap! global-hierarchy derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6182 6214]},
                               :full-name "cljs.core/derive",
                               :clj-symbol "clojure.core/derive",
                               :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "clojure.zip/zipper" {:ns "clojure.zip",
                                 :name "zipper",
                                 :signature ["[branch? children make-node root]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_zipper",
                                 :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [18 32]},
                                 :full-name "clojure.zip/zipper",
                                 :clj-symbol "clojure.zip/zipper",
                                 :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
           "clojure.zip/remove" {:ns "clojure.zip",
                                 :name "remove",
                                 :signature ["[loc]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_remove",
                                 :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [237 251]},
                                 :full-name "clojure.zip/remove",
                                 :clj-symbol "clojure.zip/remove",
                                 :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
           "syntax/var" {:description "Accesses the var attached to the given symbol.\n\n`#'x` = `(var x)`",
                         :ns "syntax",
                         :name "var",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["special/var"],
                         :full-name-encode "syntax_var",
                         :source {:repo "clojure",
                                  :tag "clojure-1.4.0",
                                  :filename "src/jvm/clojure/lang/LispReader.java",
                                  :lines [nil]},
                         :syntax-form "#'",
                         :examples [{:id "673ef6",
                                     :content "Access the metadata of a var:\n\n```clj\n(def x 123)\n(meta #'x)\n;;=> {:arglists (), :test nil, :name x, :column 1, :line 1, :file \"<cljs repl>\", :doc nil, :ns cljs.user}\n```"}],
                         :full-name "syntax/var",
                         :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/find" {:description "Returns the map entry for key `k`, or nil if `k` is not found.",
                             :ns "cljs.core",
                             :name "find",
                             :signature ["[coll k]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/get"
                                       "cljs.core/get-in"],
                             :full-name-encode "cljs.core_find",
                             :source {:code "(defn find\n  [coll k]\n  (when (and coll\n             (associative? coll)\n             (contains? coll k))\n    [k (-lookup coll k)]))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [875 881]},
                             :full-name "cljs.core/find",
                             :clj-symbol "clojure.core/find",
                             :docstring "Returns the map entry for key, or nil if key not present."},
           "cljs.core/*print-dup*" {:ns "cljs.core",
                                    :name "*print-dup*",
                                    :type "var",
                                    :source {:code "(def *print-dup* false)",
                                             :repo "clojurescript",
                                             :tag "r1211",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [5693]},
                                    :full-name "cljs.core/*print-dup*",
                                    :full-name-encode "cljs.core_STARprint-dupSTAR",
                                    :clj-symbol "clojure.core/*print-dup*",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/object-array" {:ns "cljs.core",
                                     :name "object-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :history [["+" "0.0-1211"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_object-array",
                                     :source {:code "(defn object-array\n  ([size-or-seq]\n     (cond\n      (number? size-or-seq) (object-array size-or-seq nil)\n      (seq? size-or-seq) (into-array size-or-seq)\n      :else (throw (js/Error. \"object-array called with something other than size or ISeq\"))))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1651 1670]},
                                     :full-name "cljs.core/object-array",
                                     :clj-symbol "clojure.core/object-array"},
           "cljs.core/indexed?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "indexed?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_indexedQMARK",
                                 :source {:code "(defn ^boolean indexed?\n  [x] (satisfies? IIndexed x))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [753 755]},
                                 :full-name "cljs.core/indexed?",
                                 :docstring "Returns true if coll implements nth in constant time"},
           "cljs.core/partial" {:description "Takes a function `f` and fewer than the normal arguments to `f`. Returns a\nfunction that takes a variable number of additional arguments. When called, the\nreturned function calls `f` with the original arguments plus the additional\narguments.\n\n`((partial f a b) c d)` => `(f a b c d)`",
                                :ns "cljs.core",
                                :name "partial",
                                :signature ["[f]"
                                            "[f arg1]"
                                            "[f arg1 arg2]"
                                            "[f arg1 arg2 arg3]"
                                            "[f arg1 arg2 arg3 & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/comp"
                                          "cljs.core/juxt"],
                                :full-name-encode "cljs.core_partial",
                                :source {:code "(defn partial\n  ([f arg1]\n   (fn [& args] (apply f arg1 args)))\n  ([f arg1 arg2]\n   (fn [& args] (apply f arg1 arg2 args)))\n  ([f arg1 arg2 arg3]\n   (fn [& args] (apply f arg1 arg2 arg3 args)))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1896 1907]},
                                :full-name "cljs.core/partial",
                                :clj-symbol "clojure.core/partial",
                                :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
           "cljs.core/keyword?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "keyword?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_keywordQMARK",
                                 :source {:code "(defn ^boolean keyword? [x]\n  (and (goog/isString x)\n       (identical? (.charAt x 0) \\uFDD0)))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [841 843]},
                                 :full-name "cljs.core/keyword?",
                                 :clj-symbol "clojure.core/keyword?"},
           "clojure.browser.event/fire-listeners" {:ns "clojure.browser.event",
                                                   :name "fire-listeners",
                                                   :type "function",
                                                   :signature ["[obj type capture event]"],
                                                   :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                            :repo "clojurescript",
                                                            :tag "r1211",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [82
                                                                    83]},
                                                   :full-name "clojure.browser.event/fire-listeners",
                                                   :full-name-encode "clojure.browser.event_fire-listeners",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/interleave" {:description "Returns a lazy seq of the first item in each collection, then the second items,\nthen the third, etc.",
                                   :ns "cljs.core",
                                   :name "interleave",
                                   :signature ["[c1 c2]"
                                               "[c1 c2 & colls]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/interpose"
                                             "cljs.core/zipmap"],
                                   :full-name-encode "cljs.core_interleave",
                                   :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2155 2167]},
                                   :full-name "cljs.core/interleave",
                                   :clj-symbol "clojure.core/interleave",
                                   :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
           "cljs.core/TransientHashSet" {:ns "cljs.core",
                                         :name "TransientHashSet",
                                         :signature ["[transient-map]"],
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core_TransientHashSet",
                                         :source {:code "(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [5136 5171]},
                                         :full-name "cljs.core/TransientHashSet",
                                         :clj-symbol "clojure.lang/TransientHashSet"},
           "cljs.core/*flush-on-newline*" {:ns "cljs.core",
                                           :name "*flush-on-newline*",
                                           :type "var",
                                           :source {:code "(def *flush-on-newline* true)",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [5690]},
                                           :full-name "cljs.core/*flush-on-newline*",
                                           :full-name-encode "cljs.core_STARflush-on-newlineSTAR",
                                           :clj-symbol "clojure.core/*flush-on-newline*",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/get-in" {:description "Returns the value in a nested associative structure, where `ks` is a sequence of\nkeys.\n\nReturns nil if the key is not found, or `not-found` if supplied.",
                               :ns "cljs.core",
                               :name "get-in",
                               :signature ["[m ks]"
                                           "[m ks not-found]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/assoc-in"
                                         "cljs.core/update-in"
                                         "cljs.core/find"
                                         "cljs.core/get"],
                               :full-name-encode "cljs.core_get-in",
                               :source {:code "(defn get-in\n  ([m ks]\n     (reduce get m ks))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))",
                                        :repo "clojurescript",
                                        :tag "r1211",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2290 2307]},
                               :full-name "cljs.core/get-in",
                               :clj-symbol "clojure.core/get-in",
                               :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of ke(ys. Returns nil if the key is not present,\nor the not-found value if supplied."},
           "clojure.browser.dom/element" {:ns "clojure.browser.dom",
                                          :name "element",
                                          :type "function",
                                          :signature ["[tag-or-text]"
                                                      "[tag & children]"],
                                          :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                   :repo "clojurescript",
                                                   :tag "r1211",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [81 90]},
                                          :full-name "clojure.browser.dom/element",
                                          :full-name-encode "clojure.browser.dom_element",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prim-seq" {:ns "cljs.core",
                                 :name "prim-seq",
                                 :type "function",
                                 :signature ["[prim i]"],
                                 :source {:code "(defn prim-seq [prim i]\n  (when-not (zero? (.-length prim))\n    (IndexedSeq. prim i)))",
                                          :repo "clojurescript",
                                          :tag "r1211",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [462 464]},
                                 :full-name "cljs.core/prim-seq",
                                 :full-name-encode "cljs.core_prim-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/<=" {:description "Returns true if each successive number argument is greater than or equal to the\nprevious one, false otherwise.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name "<=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/<"],
                           :full-name-encode "cljs.core_LTEQ",
                           :source {:code "(defn ^boolean <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r1211",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1053 1063]},
                           :extra-sources ({:code "(defmacro <=\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r1211",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [142 145]}),
                           :examples [{:id "adb3fd",
                                       :content "```clj\n(<= 1 2)\n;;=> true\n\n(<= 2 2)\n;;=> true\n\n(<= 3 2)\n;;=> false\n\n(<= 2 3 4 5 6)\n;;=> true\n```"}],
                           :full-name "cljs.core/<=",
                           :clj-symbol "clojure.core/<=",
                           :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
           "clojure.set/map-invert" {:ns "clojure.set",
                                     :name "map-invert",
                                     :signature ["[m]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set_map-invert",
                                     :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [98 100]},
                                     :full-name "clojure.set/map-invert",
                                     :clj-symbol "clojure.set/map-invert",
                                     :docstring "Returns the map with the vals mapped to the keys."},
           "clojure.browser.event/listen" {:ns "clojure.browser.event",
                                           :name "listen",
                                           :type "function",
                                           :signature ["[src type fn]"
                                                       "[src type fn capture?]"],
                                           :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (goog.events/listen src\n                         (get (event-types src) type type)\n                         fn\n                         capture?)))",
                                                    :repo "clojurescript",
                                                    :tag "r1211",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [44 51]},
                                           :full-name "clojure.browser.event/listen",
                                           :full-name-encode "clojure.browser.event_listen",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/neg?" {:description "Returns true if `n` is less than 0, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "neg?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/pos?"
                                       "cljs.core/zero?"],
                             :full-name-encode "cljs.core_negQMARK",
                             :source {:code "(defn ^boolean neg?\n  [x] (cljs.core/neg? x))",
                                      :repo "clojurescript",
                                      :tag "r1211",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1228 1230]},
                             :extra-sources ({:code "(defmacro neg? [x]\n  `(< ~x 0))",
                                              :repo "clojurescript",
                                              :tag "r1211",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [174 175]}),
                             :full-name "cljs.core/neg?",
                             :clj-symbol "clojure.core/neg?",
                             :docstring "Returns true if num is less than zero, else false"},
           "clojure.browser.dom/replace-node" {:ns "clojure.browser.dom",
                                               :name "replace-node",
                                               :signature ["[old-node new-node]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.dom_replace-node",
                                               :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                        :repo "clojurescript",
                                                        :tag "r1211",
                                                        :filename "src/cljs/clojure/browser/dom.cljs",
                                                        :lines [114
                                                                122]},
                                               :full-name "clojure.browser.dom/replace-node",
                                               :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string."},
           "syntax/boolean" {:description "`true` or `false`",
                             :ns "syntax",
                             :name "boolean",
                             :history [["+" "0.0-927"]],
                             :type "special symbol",
                             :related ["cljs.core/boolean"
                                       "special/if"
                                       "cljs.core/if-not"
                                       "cljs.core/not"
                                       "cljs.core/cond"],
                             :full-name-encode "syntax_boolean",
                             :source {:repo "clojure",
                                      :tag "clojure-1.4.0",
                                      :filename "src/jvm/clojure/lang/LispReader.java",
                                      :lines [nil]},
                             :syntax-form ["true" "false"],
                             :examples [{:id "1afc59",
                                         :content "```clj\ntrue\n;;=> true\n\nfalse\n;;=> false\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#booleans",
                             :full-name "syntax/boolean",
                             :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/destructure" {:ns "syntax",
                                 :name "destructure",
                                 :history [["+" "0.0-927"]],
                                 :type "binding",
                                 :full-name-encode "syntax_destructure",
                                 :source {:code "(defn destructure [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n               (let [pvec\n                     (fn [bvec b val]\n                       (let [gvec (gensym \"vec__\")]\n                         (loop [ret (-> bvec (conj gvec) (conj val))\n                                n 0\n                                bs b\n                                seen-rest? false]\n                           (if (seq bs)\n                             (let [firstb (first bs)]\n                               (cond\n                                (= firstb '&) (recur (pb ret (second bs) (list `nthnext gvec n))\n                                                     n\n                                                     (nnext bs)\n                                                     true)\n                                (= firstb :as) (pb ret (second bs) gvec)\n                                :else (if seen-rest?\n                                        (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                        (recur (pb ret firstb  (list `nth gvec n nil))\n                                               (inc n)\n                                               (next bs)\n                                               seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (let [gmap (or (:as b) (gensym \"map__\"))\n                             defaults (:or b)]\n                         (loop [ret (-> bvec (conj gmap) (conj v)\n                                        (conj gmap) (conj `(if (seq? ~gmap) (apply hash-map ~gmap) ~gmap)))\n                                bes (reduce1\n                                     (fn [bes entry]\n                                       (reduce1 #(assoc %1 %2 ((val entry) %2))\n                                               (dissoc bes (key entry))\n                                               ((key entry) bes)))\n                                     (dissoc b :as :or)\n                                     {:keys #(keyword (str %)), :strs str, :syms #(list `quote %)})]\n                           (if (seq bes)\n                             (let [bb (key (first bes))\n                                   bk (val (first bes))\n                                   has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (list `get gmap bk (defaults bb))\n                                                   (list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                 (cond\n                  (symbol? b) (-> bvec (conj b) (conj v))\n                  (vector? b) (pvec bvec b v)\n                  (map? b) (pmap bvec b v)\n                  :else (throw (new Exception (str \"Unsupported binding form: \" b))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (reduce1 process-entry [] bents))))",
                                          :repo "clojure",
                                          :tag "clojure-1.4.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [3900 3955]},
                                 :syntax-form [":keys"
                                               ":syms"
                                               ":strs"
                                               ":or"
                                               ":as"
                                               "&"],
                                 :full-name "syntax/destructure",
                                 :clj-doc "http://clojure.org/special_forms#toc18"},
           "special/catch" {:description "`catch` should be used inside of a `try` expression.\n\n`exception-type` should be the type of exception thrown (usually `js/Error` or\n`js/Object`). When there is a match, the thrown exception will be bound to\n`name` inside of `expr*` and `expr*` will be evaluated and returned as the value\nof the `try` expression.",
                            :ns "special",
                            :name "catch",
                            :signature ["[exception-type name expr*]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :related ["special/try"
                                      "special/finally"
                                      "special/throw"],
                            :full-name-encode "special_catch",
                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                     :repo "clojurescript",
                                     :tag "r1211",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [648 676]},
                            :full-name "special/catch",
                            :clj-symbol "clojure.core/catch",
                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/reverse" {:description "Returns a sequence of the items in `coll` in reverse order. Not lazy.",
                                :ns "cljs.core",
                                :name "reverse",
                                :signature ["[coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/rseq"],
                                :full-name-encode "cljs.core_reverse",
                                :source {:code "(defn reverse\n  [coll]\n  (reduce conj () coll))",
                                         :repo "clojurescript",
                                         :tag "r1211",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1442 1445]},
                                :full-name "cljs.core/reverse",
                                :clj-symbol "clojure.core/reverse",
                                :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
           "cljs.repl.browser/ordering" {:ns "cljs.repl.browser",
                                         :name "ordering",
                                         :type "var",
                                         :source {:code "(def ordering (agent {:expecting nil :fns {}}))",
                                                  :repo "clojurescript",
                                                  :tag "r1211",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [207]},
                                         :full-name "cljs.repl.browser/ordering",
                                         :full-name-encode "cljs.repl.browser_ordering",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/realized?" {:description "Returns true if a value has been produced for a lazy sequence.",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "realized?",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/lazy-seq"],
                                  :full-name-encode "cljs.core_realizedQMARK",
                                  :source {:code "(defn ^boolean realized?\n  [d]\n  (-realized? d))",
                                           :repo "clojurescript",
                                           :tag "r1211",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [6047 6050]},
                                  :full-name "cljs.core/realized?",
                                  :clj-symbol "clojure.core/realized?",
                                  :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}},
 :api {:syntax {:changes [{:cljs-version "0.0-927",
                           :cljs-date "2012-01-20",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790",
                           :added #{"syntax/Math-ns"
                                    "syntax/symbol"
                                    "syntax/vector"
                                    "syntax/string"
                                    "syntax/comment"
                                    "syntax/quote"
                                    "syntax/keyword-qualify"
                                    "syntax/meta"
                                    "syntax/regex"
                                    "syntax/eval"
                                    "syntax/unquote-splicing"
                                    "syntax/keyword"
                                    "syntax/character"
                                    "syntax/unreadable"
                                    "syntax/hashbang"
                                    "syntax/arg"
                                    "syntax/set"
                                    "syntax/syntax-quote"
                                    "syntax/dispatch"
                                    "syntax/function"
                                    "syntax/nil"
                                    "syntax/map"
                                    "syntax/number"
                                    "syntax/list"
                                    "syntax/deref"
                                    "syntax/unquote"
                                    "syntax/js-ns"
                                    "syntax/ignore"
                                    "syntax/var"
                                    "syntax/boolean"
                                    "syntax/destructure"}}
                          {:cljs-version "0.0-971",
                           :cljs-date "2012-01-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-993",
                           :cljs-date "2012-02-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1006",
                           :cljs-date "2012-03-30",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1011",
                           :cljs-date "2012-04-02",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1211",
                           :cljs-date "2012-05-09",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376",
                           :added #{"syntax/tagged-literal"}}],
                :symbol-names #{"syntax/Math-ns"
                                "syntax/symbol"
                                "syntax/vector"
                                "syntax/string"
                                "syntax/comment"
                                "syntax/quote"
                                "syntax/keyword-qualify"
                                "syntax/meta"
                                "syntax/regex"
                                "syntax/eval"
                                "syntax/unquote-splicing"
                                "syntax/keyword"
                                "syntax/character"
                                "syntax/unreadable"
                                "syntax/hashbang"
                                "syntax/arg"
                                "syntax/set"
                                "syntax/tagged-literal"
                                "syntax/syntax-quote"
                                "syntax/dispatch"
                                "syntax/function"
                                "syntax/nil"
                                "syntax/map"
                                "syntax/number"
                                "syntax/list"
                                "syntax/deref"
                                "syntax/unquote"
                                "syntax/js-ns"
                                "syntax/ignore"
                                "syntax/var"
                                "syntax/boolean"
                                "syntax/destructure"}},
       :library {:changes [{:cljs-version "0.0-927",
                            :cljs-date "2012-01-20",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/keys"
                                     "cljs.core/reset!"
                                     "clojure.set/select"
                                     "cljs.core/delay"
                                     "cljs.core/bit-not"
                                     "cljs.core/partition"
                                     "cljs.core/parents"
                                     "cljs.core/aclone"
                                     "cljs.core/reset-meta!"
                                     "special/defrecord*"
                                     "cljs.reader/dispatch-macros"
                                     "cljs.core/ICollection"
                                     "cljs.core/every?"
                                     "clojure.zip/node"
                                     "cljs.core/IEmptyableCollection"
                                     "clojure.zip/right"
                                     "cljs.core/=="
                                     "special/."
                                     "clojure.browser.net/*timeout*"
                                     "cljs.core/remove-method"
                                     "cljs.core/frequencies"
                                     "cljs.core/pop"
                                     "cljs.core/not-every?"
                                     "cljs.core/some-fn"
                                     "clojure.browser.event/remove-all"
                                     "cljs.core/doto"
                                     "cljs.core/take-while"
                                     "cljs.reader/escape-char-map"
                                     "clojure.browser.event/all-listeners"
                                     "cljs.core/vals"
                                     "cljs.core/IDeref"
                                     "clojure.browser.dom/log-obj"
                                     "cljs.core/for"
                                     "cljs.core/instance?"
                                     "cljs.reader/read-comment"
                                     "cljs.reader/read-number"
                                     "cljs.core/ILookup"
                                     "cljs.core/when"
                                     "clojure.browser.dom/set-value"
                                     "cljs.reader/read-past"
                                     "cljs.core/to-array"
                                     "cljs.core/interpose"
                                     "clojure.browser.net/ICrossPageChannel"
                                     "special/finally"
                                     "cljs.core/Cons"
                                     "cljs.core/re-find"
                                     "cljs.core/IMeta"
                                     "cljs.core/assoc-in"
                                     "clojure.string/join"
                                     "clojure.zip/rights"
                                     "cljs.core/split-at"
                                     "clojure.zip/append-child"
                                     "cljs.core/binding"
                                     "cljs.core/Set"
                                     "cljs.reader/macro-terminating?"
                                     "cljs.core/prefers"
                                     "cljs.core/vary-meta"
                                     "cljs.core/when-let"
                                     "cljs.core/drop"
                                     "cljs.core/while"
                                     "cljs.core/import-macros"
                                     "cljs.core/string-print"
                                     "cljs.core/-"
                                     "clojure.zip/vector-zip"
                                     "cljs.core/js->clj"
                                     "cljs.core/List"
                                     "cljs.core/identical?"
                                     "cljs.core/*main-cli-fn*"
                                     "clojure.browser.dom/html->dom"
                                     "cljs.core/some"
                                     "cljs.core/doall"
                                     "cljs.core/condp"
                                     "clojure.zip/down"
                                     "cljs.core/IPending"
                                     "cljs.core/count"
                                     "cljs.core/bit-test"
                                     "cljs.core/loop"
                                     "cljs.core/subvec"
                                     "cljs.core/bit-clear"
                                     "cljs.core/gensym"
                                     "special/recur"
                                     "cljs.core/+"
                                     "cljs.core/comp"
                                     "cljs.reader/desugar-meta"
                                     "cljs.core/pr"
                                     "clojure.string/upper-case"
                                     "clojure.browser.event/expose"
                                     "clojure.browser.event/listen-once"
                                     "cljs.core/empty?"
                                     "cljs.core/newline"
                                     "cljs.core/replace"
                                     "cljs.core/rand"
                                     "cljs.core/add-watch"
                                     "clojure.string/capitalize"
                                     "cljs.core/replicate"
                                     "special/do"
                                     "cljs.core/sequential?"
                                     "cljs.core/underive"
                                     "cljs.core/get-method"
                                     "cljs.core/="
                                     "cljs.core/defn-"
                                     "cljs.reader/read-symbol"
                                     "cljs.reader/push-back-reader"
                                     "cljs.core/deftype"
                                     "cljs.core/Subvec"
                                     "special/ns"
                                     "cljs.core/extend-protocol"
                                     "cljs.reader/read"
                                     "cljs.core/EmptyList"
                                     "clojure.walk/postwalk"
                                     "clojure.zip/edit"
                                     "cljs.core/re-seq"
                                     "cljs.reader/read-list"
                                     "cljs.core/Atom"
                                     "cljs.core/IMap"
                                     "cljs.reader/read-vector"
                                     "clojure.set/join"
                                     "cljs.core/HashMap"
                                     "cljs.reader/int-pattern"
                                     "cljs.core/swap!"
                                     "cljs.core/dec"
                                     "clojure.browser.dom/remove-children"
                                     "cljs.core/get-validator"
                                     "cljs.core/coll?"
                                     "cljs.core/bit-or"
                                     "cljs.core/nfirst"
                                     "cljs.core/keep"
                                     "cljs.core/take"
                                     "cljs.core/cond"
                                     "cljs.core/bit-and"
                                     "cljs.core/ObjMap.fromObject"
                                     "clojure.browser.event/unique-event-id"
                                     "clojure.set/project"
                                     "special/js*"
                                     "clojure.string/trim-newline"
                                     "specialrepl/in-ns"
                                     "special/let*"
                                     "special/throw"
                                     "clojure.zip/insert-left"
                                     "cljs.core/true?"
                                     "clojure.browser.net/xpc-connection"
                                     "cljs.core/not"
                                     "cljs.core/js-obj"
                                     "cljs.core/complement"
                                     "cljs.core/spread"
                                     "cljs.core/keyword"
                                     "cljs.core/sort"
                                     "clojure.string/trim"
                                     "cljs.core/meta"
                                     "cljs.core/time"
                                     "cljs.core/boolean"
                                     "cljs.reader/read-token"
                                     "cljs.core/update-in"
                                     "cljs.core/map-indexed"
                                     "cljs.core/IStack"
                                     "cljs.core/IIndexed"
                                     "clojure.browser.repl/repl-print"
                                     "clojure.browser.net/xpc-config-fields"
                                     "cljs.core/nnext"
                                     "cljs.core/*print-meta*"
                                     "cljs.reader/read-dispatch"
                                     "cljs.core/distinct"
                                     "cljs.reader/wrapping-reader"
                                     "cljs.core/prn"
                                     "clojure.zip/leftmost"
                                     "cljs.core/>="
                                     "cljs.reader/macros"
                                     "cljs.core/doseq"
                                     "cljs.core/*"
                                     "cljs.core/into"
                                     "cljs.core/defmethod"
                                     "cljs.core/rest"
                                     "cljs.core/dotimes"
                                     "clojure.zip/lefts"
                                     "clojure.browser.dom/ensure-element"
                                     "cljs.core/defmacro"
                                     "cljs.core/remove"
                                     "cljs.core/if-not"
                                     "clojure.zip/path"
                                     "cljs.core/mapcat"
                                     "cljs.core/IWatchable"
                                     "clojure.zip/rightmost"
                                     "cljs.core/->"
                                     "cljs.core/remove-all-methods"
                                     "clojure.string/replace-first"
                                     "clojure.browser.dom/get-value"
                                     "cljs.nodejs/process"
                                     "cljs.core/not="
                                     "cljs.core/js-keys"
                                     "clojure.zip/seq-zip"
                                     "cljs.core/IVector"
                                     "cljs.core/empty"
                                     "cljs.core/re-matches"
                                     "clojure.browser.dom/DOMBuilder"
                                     "cljs.core/extend-type"
                                     "cljs.core/ISeqable"
                                     "cljs.core/assoc"
                                     "clojure.browser.repl/xpc-connection"
                                     "cljs.core/IDerefWithTimeout"
                                     "clojure.browser.repl/start-evaluator"
                                     "clojure.browser.event/unlisten"
                                     "cljs.core/fnil"
                                     "cljs.core/this-as"
                                     "cljs.core/PersistentQueueSeq"
                                     "cljs.core/counted?"
                                     "clojure.string/trimr"
                                     "cljs.core/force"
                                     "cljs.core/compare-and-set!"
                                     "cljs.core/set?"
                                     "clojure.string/escape"
                                     "cljs.core/remove-watch"
                                     "cljs.core/IMultiFn"
                                     "clojure.zip/end?"
                                     "clojure.set/superset?"
                                     "clojure.browser.net/IConnection"
                                     "cljs.core/let"
                                     "cljs.core/dorun"
                                     "cljs.core/pr-str"
                                     "cljs.core/IPrintable"
                                     "cljs.core/defprotocol"
                                     "cljs.core/assert"
                                     "cljs.core/declare"
                                     "cljs.core/fn?"
                                     "cljs.core/associative?"
                                     "cljs.core/list*"
                                     "cljs.core/reduce"
                                     "clojure.browser.event/has-listener"
                                     "cljs.core/compare"
                                     "cljs.core/contains?"
                                     "cljs.core/prefer-method"
                                     "cljs.core/array-seq"
                                     "cljs.core/PersistentQueue"
                                     "cljs.core/drop-last"
                                     "cljs.reader/read-string"
                                     "cljs.core/vector?"
                                     "cljs.core/defmulti"
                                     "cljs.core/List.EMPTY"
                                     "clojure.browser.event/dispatch-event"
                                     "clojure.string/split-lines"
                                     "cljs.core/areduce"
                                     "cljs.core/disj"
                                     "clojure.browser.net/event-types"
                                     "clojure.string/lower-case"
                                     "cljs.core/*print-fn*"
                                     "cljs.core/str"
                                     "cljs.core/ISequential"
                                     "cljs.core/set"
                                     "special/def"
                                     "cljs.core/print"
                                     "clojure.string/blank?"
                                     "clojure.browser.dom/append"
                                     "cljs.core/take-last"
                                     "clojure.set/intersection"
                                     "cljs.core/fnext"
                                     "cljs.core/apply"
                                     "clojure.walk/prewalk"
                                     "cljs.core/flatten"
                                     "cljs.core/get"
                                     "cljs.core/.."
                                     "cljs.core/Range"
                                     "cljs.core/zero?"
                                     "cljs.core/identity"
                                     "cljs.core/first"
                                     "cljs.reader/ratio-pattern"
                                     "cljs.core/>"
                                     "cljs.core/juxt"
                                     "cljs.core/max"
                                     "cljs.core/*3"
                                     "cljs.core/number?"
                                     "cljs.core/array"
                                     "cljs.core/nthnext"
                                     "cljs.core/re-pattern"
                                     "cljs.core/missing-protocol"
                                     "clojure.browser.dom/set-text"
                                     "clojure.zip/up"
                                     "cljs.core/IWithMeta"
                                     "cljs.core/bit-and-not"
                                     "clojure.string/triml"
                                     "clojure.string/split"
                                     "cljs.core/hash-map"
                                     "cljs.core/rem"
                                     "cljs.core/IRecord"
                                     "cljs.core/constantly"
                                     "clojure.browser.dom/get-element"
                                     "cljs.core/and"
                                     "clojure.browser.repl/wrap-message"
                                     "clojure.browser.event/unlisten-by-key"
                                     "cljs.core/try"
                                     "cljs.core/iterate"
                                     "cljs.core/lazy-seq"
                                     "specialrepl/load-file"
                                     "cljs.core/IndexedSeq"
                                     "cljs.core/next"
                                     "cljs.core/*print-readably*"
                                     "cljs.core/last"
                                     "cljs.core/bit-shift-left"
                                     "clojure.string/reverse"
                                     "cljs.core/min"
                                     "cljs.reader/escape-char"
                                     "cljs.reader/read-map"
                                     "cljs.core/seq"
                                     "cljs.core/not-empty"
                                     "cljs.core/println"
                                     "clojure.browser.repl/connect"
                                     "clojure.browser.dom/insert-at"
                                     "cljs.core/quot"
                                     "clojure.browser.event/get-listener"
                                     "cljs.core/filter"
                                     "clojure.zip/branch?"
                                     "special/if"
                                     "cljs.core/ObjMap"
                                     "cljs.core/zipmap"
                                     "cljs.core/hash-combine"
                                     "cljs.core/max-key"
                                     "clojure.zip/insert-child"
                                     "cljs.core/defrecord"
                                     "cljs.core/butlast"
                                     "cljs.core/hash"
                                     "cljs.core/bit-set"
                                     "cljs.core/concat"
                                     "cljs.core/conj"
                                     "clojure.set/difference"
                                     "cljs.core/when-first"
                                     "cljs.core/distinct?"
                                     "cljs.core/pos?"
                                     "cljs.core/IHash"
                                     "cljs.core/is_proto_"
                                     "cljs.core/keep-indexed"
                                     "cljs.core/bit-shift-right"
                                     "clojure.zip/insert-right"
                                     "cljs.core/make-hierarchy"
                                     "cljs.core/repeat"
                                     "cljs.core/MultiFn"
                                     "cljs.core/not-any?"
                                     "cljs.reader/read-regex"
                                     "clojure.zip/next"
                                     "cljs.core/aget"
                                     "cljs.core/if-let"
                                     "cljs.core//"
                                     "cljs.core/min-key"
                                     "clojure.zip/root"
                                     "cljs.core/drop-while"
                                     "clojure.browser.repl/evaluate-javascript"
                                     "cljs.core/set-validator!"
                                     "cljs.core/<"
                                     "cljs.core/fn"
                                     "cljs.core/split-with"
                                     "cljs.core/IReduce"
                                     "cljs.reader/symbol-pattern"
                                     "cljs.core/repeatedly"
                                     "cljs.reader/read-delimited-list"
                                     "cljs.core/undefined?"
                                     "clojure.zip/prev"
                                     "cljs.core/seq?"
                                     "cljs.core/odd?"
                                     "cljs.core/cons"
                                     "special/deftype*"
                                     "cljs.reader/read-set"
                                     "cljs.core/descendants"
                                     "special/new"
                                     "cljs.core/take-nth"
                                     "cljs.reader/throwing-reader"
                                     "cljs.core/even?"
                                     "special/fn*"
                                     "clojure.set/subset?"
                                     "cljs.core/flush"
                                     "cljs.reader/reader-error"
                                     "clojure.walk/prewalk-replace"
                                     "cljs.core/*1"
                                     "cljs.core/Set.EMPTY"
                                     "cljs.reader/read-unicode-char"
                                     "cljs.core/dissoc"
                                     "cljs.core/ffirst"
                                     "clojure.zip/replace"
                                     "cljs.core/vec"
                                     "cljs.core/or"
                                     "cljs.core/mod"
                                     "cljs.core/aset"
                                     "cljs.core/second"
                                     "clojure.set/rename"
                                     "cljs.core/delay?"
                                     "clojure.zip/left"
                                     "cljs.reader/not-implemented"
                                     "cljs.core/IAssociative"
                                     "cljs.core/ObjMap.EMPTY"
                                     "cljs.core/group-by"
                                     "cljs.core/symbol"
                                     "cljs.core/Delay"
                                     "cljs.core/methods"
                                     "cljs.core/vector"
                                     "cljs.core/rand-int"
                                     "cljs.core/PersistentQueue.EMPTY"
                                     "cljs.core/letfn"
                                     "cljs.reader/read-discard"
                                     "cljs.core/inc"
                                     "cljs.core/name"
                                     "cljs.core/cycle"
                                     "cljs.core/map"
                                     "cljs.core/amap"
                                     "clojure.zip/children"
                                     "special/set!"
                                     "cljs.core/when-not"
                                     "clojure.set/index"
                                     "clojure.browser.dom/log"
                                     "cljs.core/Vector.fromArray"
                                     "cljs.core/partition-by"
                                     "cljs.core/sort-by"
                                     "cljs.core/with-meta"
                                     "cljs.core/NeverEquiv"
                                     "cljs.core/select-keys"
                                     "special/loop*"
                                     "cljs.core/ISeq"
                                     "clojure.walk/postwalk-replace"
                                     "cljs.core/pr-with-opts"
                                     "cljs.core/->>"
                                     "cljs.core/nil?"
                                     "clojure.walk/stringify-keys"
                                     "clojure.browser.repl/order"
                                     "cljs.core/memoize"
                                     "cljs.core/pr-sequential"
                                     "clojure.zip/make-node"
                                     "specialrepl/load-namespace"
                                     "cljs.reader/float-pattern"
                                     "cljs.core/ancestors"
                                     "cljs.core/integer?"
                                     "cljs.core/HashMap.EMPTY"
                                     "cljs.core/Vector.EMPTY"
                                     "clojure.zip/xml-zip"
                                     "clojure.walk/walk"
                                     "cljs.core/bit-xor"
                                     "clojure.set/union"
                                     "cljs.reader/PushbackReader"
                                     "cljs.core/isa?"
                                     "clojure.browser.net/xhr-connection"
                                     "cljs.core/subs"
                                     "cljs.core/symbol?"
                                     "clojure.string/replace"
                                     "cljs.core/string?"
                                     "cljs.core/partition-all"
                                     "cljs.core/merge-with"
                                     "clojure.browser.dom/set-properties"
                                     "cljs.core/trampoline"
                                     "clojure.browser.repl/send-print"
                                     "cljs.core/ICounted"
                                     "cljs.core/IEquiv"
                                     "cljs.core/js-delete"
                                     "cljs.core/comment"
                                     "cljs.reader/special-symbols"
                                     "cljs.core/alength"
                                     "special/quote"
                                     "cljs.core/tree-seq"
                                     "cljs.reader/read-unmatched-delimiter"
                                     "cljs.core/every-pred"
                                     "clojure.set/rename-keys"
                                     "cljs.core/peek"
                                     "cljs.core/pr-str-with-opts"
                                     "cljs.core/map?"
                                     "cljs.reader/StringPushbackReader"
                                     "cljs.core/HashMap.fromArrays"
                                     "cljs.core/deref"
                                     "cljs.core/reductions"
                                     "cljs.core/false?"
                                     "cljs.core/bit-flip"
                                     "cljs.core/ISet"
                                     "cljs.core/LazySeq"
                                     "cljs.core/*2"
                                     "clojure.browser.event/total-listener-count"
                                     "cljs.core/alter-meta!"
                                     "clojure.browser.dom/click-element"
                                     "cljs.reader/read-meta"
                                     "special/try*"
                                     "cljs.core/range"
                                     "cljs.core/reify"
                                     "cljs.core/satisfies?"
                                     "cljs.core/nth"
                                     "cljs.core/list"
                                     "cljs.core/defn"
                                     "cljs.core/rand-nth"
                                     "cljs.core/atom"
                                     "cljs.reader/read-keyword"
                                     "cljs.core/Vector"
                                     "cljs.reader/skip-line"
                                     "cljs.core/namespace"
                                     "cljs.nodejs/require"
                                     "clojure.browser.event/EventType"
                                     "cljs.core/merge"
                                     "clojure.browser.repl/send-result"
                                     "clojure.walk/keywordize-keys"
                                     "cljs.core/derive"
                                     "clojure.zip/zipper"
                                     "clojure.zip/remove"
                                     "cljs.core/find"
                                     "cljs.core/*print-dup*"
                                     "cljs.core/partial"
                                     "cljs.core/keyword?"
                                     "clojure.browser.event/fire-listeners"
                                     "cljs.core/interleave"
                                     "cljs.core/*flush-on-newline*"
                                     "cljs.core/get-in"
                                     "clojure.browser.dom/element"
                                     "cljs.core/prim-seq"
                                     "cljs.core/<="
                                     "clojure.set/map-invert"
                                     "clojure.browser.event/listen"
                                     "cljs.core/neg?"
                                     "clojure.browser.dom/replace-node"
                                     "special/catch"
                                     "cljs.core/reverse"
                                     "cljs.core/realized?"}}
                           {:cljs-version "0.0-971",
                            :cljs-date "2012-01-27",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/type" "cljs.core/IFn"}}
                           {:cljs-version "0.0-993",
                            :cljs-date "2012-02-27",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790"}
                           {:cljs-version "0.0-1006",
                            :cljs-date "2012-03-30",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/PersistentVector.EMPTY_NODE"
                                     "cljs.core/PersistentVector.fromArray"
                                     "cljs.core/PersistentVector"
                                     "cljs.core/PersistentVector.EMPTY"}}
                           {:cljs-version "0.0-1011",
                            :cljs-date "2012-04-02",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/println-str"
                                     "cljs.core/print-str"
                                     "cljs.core/prn-str-with-opts"
                                     "cljs.core/prn-str"}}
                           {:cljs-version "0.0-1211",
                            :cljs-date "2012-05-09",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"cljs.core/ITransientCollection"
                                     "cljs.core/transient"
                                     "cljs.core/dissoc!"
                                     "cljs.core/PersistentArrayMap.fromArrays"
                                     "cljs.core/ITransientSet"
                                     "cljs.core/array-map"
                                     "cljs.core/rseq"
                                     "cljs.core/ITransientMap"
                                     "cljs.core/ArrayNodeSeq"
                                     "cljs.core/list?"
                                     "cljs.core/val"
                                     "cljs.core/BitmapIndexedNode"
                                     "cljs.core/IMapEntry"
                                     "cljs.core/*unchecked-if*"
                                     "cljs.core/seqable?"
                                     "cljs.core/sorted-map"
                                     "cljs.core/ASeq"
                                     "cljs.core/reduceable?"
                                     "cljs.core/vector-seq"
                                     "cljs.core/conj!"
                                     "cljs.core/PersistentHashMap"
                                     "cljs.core/IReversible"
                                     "cljs.core/IKVReduce"
                                     "cljs.core/BlackNode"
                                     "cljs.core/PersistentHashSet.EMPTY"
                                     "cljs.core/PersistentArrayMap"
                                     "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                     "cljs.core/int"
                                     "cljs.core/ISorted"
                                     "cljs.core/double-array"
                                     "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                     "cljs.core/PersistentArrayMap.EMPTY"
                                     "cljs.core/reduced?"
                                     "cljs.core/PersistentTreeMapSeq"
                                     "cljs.core/persistent!"
                                     "cljs.core/PersistentHashMap.fromArrays"
                                     "cljs.core/sorted-set"
                                     "cljs.core/PersistentTreeMap.EMPTY"
                                     "cljs.core/IList"
                                     "cljs.core/PersistentHashMap.EMPTY"
                                     "cljs.core/to-array-2d"
                                     "cljs.core/filterv"
                                     "cljs.core/IEditableCollection"
                                     "cljs.core/ArrayNode"
                                     "cljs.core/TransientHashMap"
                                     "cljs.core/TransientArrayMap"
                                     "cljs.core/mapv"
                                     "cljs.core/long"
                                     "cljs.core/reversible?"
                                     "cljs.core/HashCollisionNode"
                                     "cljs.core/into-array"
                                     "cljs.core/TransientVector"
                                     "cljs.core/PersistentTreeSet"
                                     "cljs.core/Reduced"
                                     "cljs.core/long-array"
                                     "cljs.core/subseq"
                                     "cljs.core/bit-count"
                                     "cljs.core/assoc!"
                                     "cljs.core/sorted-map-by"
                                     "cljs.core/NodeSeq"
                                     "cljs.core/gen-apply-to"
                                     "cljs.core/rsubseq"
                                     "cljs.core/make-array"
                                     "cljs.core/sorted-set-by"
                                     "cljs.core/disj!"
                                     "cljs.core/ifn?"
                                     "cljs.core/case"
                                     "cljs.core/RedNode"
                                     "cljs.core/key"
                                     "cljs.core/ITransientAssociative"
                                     "cljs.core/reduce-kv"
                                     "cljs.core/PersistentTreeSet.EMPTY"
                                     "cljs.core/BitmapIndexedNode.EMPTY"
                                     "cljs.core/mk-bound-fn"
                                     "cljs.core/VectorNode"
                                     "cljs.core/PersistentHashSet"
                                     "cljs.core/ITransientVector"
                                     "cljs.core/PersistentTreeMap"
                                     "cljs.core/pop!"
                                     "cljs.core/bit-shift-right-zero-fill"
                                     "cljs.core/reduced"
                                     "cljs.core/object-array"
                                     "cljs.core/indexed?"
                                     "cljs.core/TransientHashSet"},
                            :removed #{"cljs.core/Set"
                                       "cljs.core/Set.EMPTY"}}],
                 :symbol-names #{"cljs.core/keys"
                                 "cljs.core/reset!"
                                 "cljs.core/ITransientCollection"
                                 "cljs.core/transient"
                                 "clojure.set/select"
                                 "cljs.core/delay"
                                 "cljs.core/bit-not"
                                 "cljs.core/partition"
                                 "cljs.core/parents"
                                 "cljs.core/aclone"
                                 "cljs.core/reset-meta!"
                                 "special/defrecord*"
                                 "cljs.reader/dispatch-macros"
                                 "cljs.core/ICollection"
                                 "cljs.core/every?"
                                 "clojure.zip/node"
                                 "cljs.core/IEmptyableCollection"
                                 "clojure.zip/right"
                                 "cljs.core/=="
                                 "cljs.core/dissoc!"
                                 "special/."
                                 "clojure.browser.net/*timeout*"
                                 "cljs.core/remove-method"
                                 "cljs.core/PersistentArrayMap.fromArrays"
                                 "cljs.core/frequencies"
                                 "cljs.core/pop"
                                 "cljs.core/not-every?"
                                 "cljs.core/some-fn"
                                 "clojure.browser.event/remove-all"
                                 "cljs.core/doto"
                                 "cljs.core/take-while"
                                 "cljs.reader/escape-char-map"
                                 "clojure.browser.event/all-listeners"
                                 "cljs.core/ITransientSet"
                                 "cljs.core/vals"
                                 "cljs.core/IDeref"
                                 "cljs.core/array-map"
                                 "clojure.browser.dom/log-obj"
                                 "cljs.core/for"
                                 "cljs.core/instance?"
                                 "cljs.core/rseq"
                                 "cljs.core/PersistentVector.EMPTY_NODE"
                                 "cljs.reader/read-comment"
                                 "cljs.core/ITransientMap"
                                 "cljs.reader/read-number"
                                 "cljs.core/ILookup"
                                 "cljs.core/when"
                                 "cljs.core/ArrayNodeSeq"
                                 "cljs.core/list?"
                                 "cljs.core/val"
                                 "clojure.browser.dom/set-value"
                                 "cljs.core/BitmapIndexedNode"
                                 "cljs.reader/read-past"
                                 "cljs.core/to-array"
                                 "cljs.core/interpose"
                                 "cljs.core/IMapEntry"
                                 "clojure.browser.net/ICrossPageChannel"
                                 "special/finally"
                                 "cljs.core/Cons"
                                 "cljs.core/re-find"
                                 "cljs.core/IMeta"
                                 "cljs.core/assoc-in"
                                 "clojure.string/join"
                                 "cljs.core/*unchecked-if*"
                                 "cljs.core/seqable?"
                                 "clojure.zip/rights"
                                 "cljs.core/split-at"
                                 "clojure.zip/append-child"
                                 "cljs.core/binding"
                                 "cljs.core/Set"
                                 "cljs.core/sorted-map"
                                 "cljs.reader/macro-terminating?"
                                 "cljs.core/prefers"
                                 "cljs.core/vary-meta"
                                 "cljs.core/when-let"
                                 "cljs.core/ASeq"
                                 "cljs.core/drop"
                                 "cljs.core/reduceable?"
                                 "cljs.core/while"
                                 "cljs.core/import-macros"
                                 "cljs.core/string-print"
                                 "cljs.core/-"
                                 "cljs.core/vector-seq"
                                 "clojure.zip/vector-zip"
                                 "cljs.core/conj!"
                                 "cljs.core/js->clj"
                                 "cljs.core/List"
                                 "cljs.core/identical?"
                                 "cljs.core/*main-cli-fn*"
                                 "clojure.browser.dom/html->dom"
                                 "cljs.core/some"
                                 "cljs.core/doall"
                                 "cljs.core/condp"
                                 "clojure.zip/down"
                                 "cljs.core/IPending"
                                 "cljs.core/count"
                                 "cljs.core/bit-test"
                                 "cljs.core/loop"
                                 "cljs.core/subvec"
                                 "cljs.core/bit-clear"
                                 "cljs.core/gensym"
                                 "special/recur"
                                 "cljs.core/+"
                                 "cljs.core/comp"
                                 "cljs.reader/desugar-meta"
                                 "cljs.core/pr"
                                 "clojure.string/upper-case"
                                 "clojure.browser.event/expose"
                                 "clojure.browser.event/listen-once"
                                 "cljs.core/empty?"
                                 "cljs.core/newline"
                                 "cljs.core/PersistentHashMap"
                                 "cljs.core/replace"
                                 "cljs.core/rand"
                                 "cljs.core/add-watch"
                                 "clojure.string/capitalize"
                                 "cljs.core/replicate"
                                 "special/do"
                                 "cljs.core/sequential?"
                                 "cljs.core/underive"
                                 "cljs.core/get-method"
                                 "cljs.core/="
                                 "cljs.core/defn-"
                                 "cljs.reader/read-symbol"
                                 "cljs.reader/push-back-reader"
                                 "cljs.core/deftype"
                                 "cljs.core/Subvec"
                                 "special/ns"
                                 "cljs.core/IReversible"
                                 "cljs.core/extend-protocol"
                                 "cljs.reader/read"
                                 "cljs.core/EmptyList"
                                 "clojure.walk/postwalk"
                                 "clojure.zip/edit"
                                 "cljs.core/re-seq"
                                 "cljs.reader/read-list"
                                 "cljs.core/IKVReduce"
                                 "cljs.core/Atom"
                                 "cljs.core/IMap"
                                 "cljs.reader/read-vector"
                                 "clojure.set/join"
                                 "cljs.core/HashMap"
                                 "cljs.reader/int-pattern"
                                 "cljs.core/swap!"
                                 "cljs.core/dec"
                                 "clojure.browser.dom/remove-children"
                                 "cljs.core/BlackNode"
                                 "cljs.core/get-validator"
                                 "cljs.core/coll?"
                                 "cljs.core/bit-or"
                                 "cljs.core/nfirst"
                                 "cljs.core/keep"
                                 "cljs.core/take"
                                 "cljs.core/PersistentHashSet.EMPTY"
                                 "cljs.core/cond"
                                 "cljs.core/bit-and"
                                 "cljs.core/ObjMap.fromObject"
                                 "cljs.core/PersistentArrayMap"
                                 "clojure.browser.event/unique-event-id"
                                 "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                 "clojure.set/project"
                                 "cljs.core/int"
                                 "special/js*"
                                 "clojure.string/trim-newline"
                                 "specialrepl/in-ns"
                                 "special/let*"
                                 "special/throw"
                                 "clojure.zip/insert-left"
                                 "cljs.core/true?"
                                 "clojure.browser.net/xpc-connection"
                                 "cljs.core/not"
                                 "cljs.core/js-obj"
                                 "cljs.core/complement"
                                 "cljs.core/spread"
                                 "cljs.core/keyword"
                                 "cljs.core/sort"
                                 "clojure.string/trim"
                                 "cljs.core/meta"
                                 "cljs.core/time"
                                 "cljs.core/boolean"
                                 "cljs.reader/read-token"
                                 "cljs.core/update-in"
                                 "cljs.core/map-indexed"
                                 "cljs.core/IStack"
                                 "cljs.core/ISorted"
                                 "cljs.core/IIndexed"
                                 "clojure.browser.repl/repl-print"
                                 "clojure.browser.net/xpc-config-fields"
                                 "cljs.core/nnext"
                                 "cljs.core/*print-meta*"
                                 "cljs.reader/read-dispatch"
                                 "cljs.core/distinct"
                                 "cljs.reader/wrapping-reader"
                                 "cljs.core/double-array"
                                 "cljs.core/prn"
                                 "clojure.zip/leftmost"
                                 "cljs.core/>="
                                 "cljs.reader/macros"
                                 "cljs.core/doseq"
                                 "cljs.core/*"
                                 "cljs.core/into"
                                 "cljs.core/defmethod"
                                 "cljs.core/rest"
                                 "cljs.core/dotimes"
                                 "clojure.zip/lefts"
                                 "clojure.browser.dom/ensure-element"
                                 "cljs.core/defmacro"
                                 "cljs.core/remove"
                                 "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                 "cljs.core/if-not"
                                 "clojure.zip/path"
                                 "cljs.core/mapcat"
                                 "cljs.core/IWatchable"
                                 "clojure.zip/rightmost"
                                 "cljs.core/PersistentArrayMap.EMPTY"
                                 "cljs.core/->"
                                 "cljs.core/remove-all-methods"
                                 "clojure.string/replace-first"
                                 "cljs.core/reduced?"
                                 "clojure.browser.dom/get-value"
                                 "cljs.nodejs/process"
                                 "cljs.core/not="
                                 "cljs.core/PersistentTreeMapSeq"
                                 "cljs.core/js-keys"
                                 "clojure.zip/seq-zip"
                                 "cljs.core/IVector"
                                 "cljs.core/persistent!"
                                 "cljs.core/empty"
                                 "cljs.core/re-matches"
                                 "clojure.browser.dom/DOMBuilder"
                                 "cljs.core/extend-type"
                                 "cljs.core/ISeqable"
                                 "cljs.core/assoc"
                                 "clojure.browser.repl/xpc-connection"
                                 "cljs.core/IDerefWithTimeout"
                                 "clojure.browser.repl/start-evaluator"
                                 "clojure.browser.event/unlisten"
                                 "cljs.core/PersistentHashMap.fromArrays"
                                 "cljs.core/sorted-set"
                                 "cljs.core/fnil"
                                 "cljs.core/this-as"
                                 "cljs.core/PersistentQueueSeq"
                                 "cljs.core/counted?"
                                 "clojure.string/trimr"
                                 "cljs.core/force"
                                 "cljs.core/compare-and-set!"
                                 "cljs.core/set?"
                                 "clojure.string/escape"
                                 "cljs.core/remove-watch"
                                 "cljs.core/IMultiFn"
                                 "clojure.zip/end?"
                                 "clojure.set/superset?"
                                 "clojure.browser.net/IConnection"
                                 "cljs.core/let"
                                 "cljs.core/dorun"
                                 "cljs.core/pr-str"
                                 "cljs.core/IPrintable"
                                 "cljs.core/defprotocol"
                                 "cljs.core/assert"
                                 "cljs.core/declare"
                                 "cljs.core/PersistentTreeMap.EMPTY"
                                 "cljs.core/fn?"
                                 "cljs.core/associative?"
                                 "cljs.core/IList"
                                 "cljs.core/list*"
                                 "cljs.core/reduce"
                                 "clojure.browser.event/has-listener"
                                 "cljs.core/PersistentHashMap.EMPTY"
                                 "cljs.core/compare"
                                 "cljs.core/contains?"
                                 "cljs.core/prefer-method"
                                 "cljs.core/array-seq"
                                 "cljs.core/to-array-2d"
                                 "cljs.core/PersistentQueue"
                                 "cljs.core/drop-last"
                                 "cljs.core/PersistentVector.fromArray"
                                 "cljs.core/filterv"
                                 "cljs.reader/read-string"
                                 "cljs.core/vector?"
                                 "cljs.core/defmulti"
                                 "cljs.core/List.EMPTY"
                                 "clojure.browser.event/dispatch-event"
                                 "clojure.string/split-lines"
                                 "cljs.core/areduce"
                                 "cljs.core/disj"
                                 "cljs.core/IEditableCollection"
                                 "clojure.browser.net/event-types"
                                 "clojure.string/lower-case"
                                 "cljs.core/*print-fn*"
                                 "cljs.core/str"
                                 "cljs.core/ISequential"
                                 "cljs.core/set"
                                 "special/def"
                                 "cljs.core/print"
                                 "cljs.core/ArrayNode"
                                 "cljs.core/type"
                                 "clojure.string/blank?"
                                 "clojure.browser.dom/append"
                                 "cljs.core/take-last"
                                 "cljs.core/TransientHashMap"
                                 "clojure.set/intersection"
                                 "cljs.core/fnext"
                                 "cljs.core/apply"
                                 "clojure.walk/prewalk"
                                 "cljs.core/flatten"
                                 "cljs.core/get"
                                 "cljs.core/.."
                                 "cljs.core/Range"
                                 "cljs.core/zero?"
                                 "cljs.core/identity"
                                 "cljs.core/first"
                                 "cljs.reader/ratio-pattern"
                                 "cljs.core/println-str"
                                 "cljs.core/>"
                                 "cljs.core/juxt"
                                 "cljs.core/max"
                                 "cljs.core/*3"
                                 "cljs.core/TransientArrayMap"
                                 "cljs.core/number?"
                                 "cljs.core/array"
                                 "cljs.core/nthnext"
                                 "cljs.core/re-pattern"
                                 "cljs.core/missing-protocol"
                                 "clojure.browser.dom/set-text"
                                 "clojure.zip/up"
                                 "cljs.core/IWithMeta"
                                 "cljs.core/bit-and-not"
                                 "clojure.string/triml"
                                 "clojure.string/split"
                                 "cljs.core/hash-map"
                                 "cljs.core/mapv"
                                 "cljs.core/rem"
                                 "cljs.core/IRecord"
                                 "cljs.core/constantly"
                                 "clojure.browser.dom/get-element"
                                 "cljs.core/and"
                                 "clojure.browser.repl/wrap-message"
                                 "clojure.browser.event/unlisten-by-key"
                                 "cljs.core/try"
                                 "cljs.core/iterate"
                                 "cljs.core/lazy-seq"
                                 "specialrepl/load-file"
                                 "cljs.core/IndexedSeq"
                                 "cljs.core/next"
                                 "cljs.core/*print-readably*"
                                 "cljs.core/last"
                                 "cljs.core/bit-shift-left"
                                 "clojure.string/reverse"
                                 "cljs.core/min"
                                 "cljs.reader/escape-char"
                                 "cljs.reader/read-map"
                                 "cljs.core/seq"
                                 "cljs.core/long"
                                 "cljs.core/not-empty"
                                 "cljs.core/println"
                                 "clojure.browser.repl/connect"
                                 "clojure.browser.dom/insert-at"
                                 "cljs.core/quot"
                                 "clojure.browser.event/get-listener"
                                 "cljs.core/filter"
                                 "clojure.zip/branch?"
                                 "special/if"
                                 "cljs.core/ObjMap"
                                 "cljs.core/zipmap"
                                 "cljs.core/hash-combine"
                                 "cljs.core/reversible?"
                                 "cljs.core/max-key"
                                 "clojure.zip/insert-child"
                                 "cljs.core/defrecord"
                                 "cljs.core/butlast"
                                 "cljs.core/print-str"
                                 "cljs.core/hash"
                                 "cljs.core/bit-set"
                                 "cljs.core/concat"
                                 "cljs.core/conj"
                                 "clojure.set/difference"
                                 "cljs.core/when-first"
                                 "cljs.core/distinct?"
                                 "cljs.core/HashCollisionNode"
                                 "cljs.core/pos?"
                                 "cljs.core/into-array"
                                 "cljs.core/PersistentVector"
                                 "cljs.core/IHash"
                                 "cljs.core/is_proto_"
                                 "cljs.core/TransientVector"
                                 "cljs.core/keep-indexed"
                                 "cljs.core/bit-shift-right"
                                 "cljs.core/PersistentTreeSet"
                                 "clojure.zip/insert-right"
                                 "cljs.core/make-hierarchy"
                                 "cljs.core/repeat"
                                 "cljs.core/prn-str-with-opts"
                                 "cljs.core/MultiFn"
                                 "cljs.core/Reduced"
                                 "cljs.core/not-any?"
                                 "cljs.reader/read-regex"
                                 "clojure.zip/next"
                                 "cljs.core/IFn"
                                 "cljs.core/aget"
                                 "cljs.core/if-let"
                                 "cljs.core//"
                                 "cljs.core/min-key"
                                 "clojure.zip/root"
                                 "cljs.core/drop-while"
                                 "clojure.browser.repl/evaluate-javascript"
                                 "cljs.core/set-validator!"
                                 "cljs.core/<"
                                 "cljs.core/fn"
                                 "cljs.core/split-with"
                                 "cljs.core/IReduce"
                                 "cljs.reader/symbol-pattern"
                                 "cljs.core/repeatedly"
                                 "cljs.reader/read-delimited-list"
                                 "cljs.core/undefined?"
                                 "clojure.zip/prev"
                                 "cljs.core/seq?"
                                 "cljs.core/prn-str"
                                 "cljs.core/odd?"
                                 "cljs.core/cons"
                                 "special/deftype*"
                                 "cljs.reader/read-set"
                                 "cljs.core/descendants"
                                 "special/new"
                                 "cljs.core/take-nth"
                                 "cljs.reader/throwing-reader"
                                 "cljs.core/even?"
                                 "special/fn*"
                                 "clojure.set/subset?"
                                 "cljs.core/flush"
                                 "cljs.core/long-array"
                                 "cljs.reader/reader-error"
                                 "clojure.walk/prewalk-replace"
                                 "cljs.core/*1"
                                 "cljs.core/subseq"
                                 "cljs.core/Set.EMPTY"
                                 "cljs.reader/read-unicode-char"
                                 "cljs.core/dissoc"
                                 "cljs.core/ffirst"
                                 "clojure.zip/replace"
                                 "cljs.core/vec"
                                 "cljs.core/or"
                                 "cljs.core/mod"
                                 "cljs.core/aset"
                                 "cljs.core/second"
                                 "cljs.core/bit-count"
                                 "clojure.set/rename"
                                 "cljs.core/assoc!"
                                 "cljs.core/delay?"
                                 "clojure.zip/left"
                                 "cljs.reader/not-implemented"
                                 "cljs.core/IAssociative"
                                 "cljs.core/ObjMap.EMPTY"
                                 "cljs.core/group-by"
                                 "cljs.core/sorted-map-by"
                                 "cljs.core/symbol"
                                 "cljs.core/Delay"
                                 "cljs.core/methods"
                                 "cljs.core/vector"
                                 "cljs.core/rand-int"
                                 "cljs.core/PersistentQueue.EMPTY"
                                 "cljs.core/NodeSeq"
                                 "cljs.core/letfn"
                                 "cljs.reader/read-discard"
                                 "cljs.core/gen-apply-to"
                                 "cljs.core/inc"
                                 "cljs.core/name"
                                 "cljs.core/cycle"
                                 "cljs.core/rsubseq"
                                 "cljs.core/map"
                                 "cljs.core/amap"
                                 "clojure.zip/children"
                                 "special/set!"
                                 "cljs.core/when-not"
                                 "clojure.set/index"
                                 "clojure.browser.dom/log"
                                 "cljs.core/Vector.fromArray"
                                 "cljs.core/make-array"
                                 "cljs.core/sorted-set-by"
                                 "cljs.core/partition-by"
                                 "cljs.core/sort-by"
                                 "cljs.core/with-meta"
                                 "cljs.core/NeverEquiv"
                                 "cljs.core/select-keys"
                                 "special/loop*"
                                 "cljs.core/ISeq"
                                 "cljs.core/disj!"
                                 "clojure.walk/postwalk-replace"
                                 "cljs.core/pr-with-opts"
                                 "cljs.core/->>"
                                 "cljs.core/nil?"
                                 "clojure.walk/stringify-keys"
                                 "clojure.browser.repl/order"
                                 "cljs.core/memoize"
                                 "cljs.core/pr-sequential"
                                 "clojure.zip/make-node"
                                 "cljs.core/PersistentVector.EMPTY"
                                 "specialrepl/load-namespace"
                                 "cljs.reader/float-pattern"
                                 "cljs.core/ancestors"
                                 "cljs.core/integer?"
                                 "cljs.core/HashMap.EMPTY"
                                 "cljs.core/Vector.EMPTY"
                                 "clojure.zip/xml-zip"
                                 "clojure.walk/walk"
                                 "cljs.core/ifn?"
                                 "cljs.core/bit-xor"
                                 "clojure.set/union"
                                 "cljs.core/case"
                                 "cljs.reader/PushbackReader"
                                 "cljs.core/isa?"
                                 "clojure.browser.net/xhr-connection"
                                 "cljs.core/subs"
                                 "cljs.core/symbol?"
                                 "clojure.string/replace"
                                 "cljs.core/string?"
                                 "cljs.core/partition-all"
                                 "cljs.core/RedNode"
                                 "cljs.core/merge-with"
                                 "cljs.core/key"
                                 "clojure.browser.dom/set-properties"
                                 "cljs.core/ITransientAssociative"
                                 "cljs.core/trampoline"
                                 "clojure.browser.repl/send-print"
                                 "cljs.core/ICounted"
                                 "cljs.core/IEquiv"
                                 "cljs.core/reduce-kv"
                                 "cljs.core/js-delete"
                                 "cljs.core/PersistentTreeSet.EMPTY"
                                 "cljs.core/comment"
                                 "cljs.reader/special-symbols"
                                 "cljs.core/BitmapIndexedNode.EMPTY"
                                 "cljs.core/alength"
                                 "cljs.core/mk-bound-fn"
                                 "special/quote"
                                 "cljs.core/VectorNode"
                                 "cljs.core/tree-seq"
                                 "cljs.reader/read-unmatched-delimiter"
                                 "cljs.core/every-pred"
                                 "cljs.core/PersistentHashSet"
                                 "clojure.set/rename-keys"
                                 "cljs.core/peek"
                                 "cljs.core/pr-str-with-opts"
                                 "cljs.core/ITransientVector"
                                 "cljs.core/map?"
                                 "cljs.reader/StringPushbackReader"
                                 "cljs.core/PersistentTreeMap"
                                 "cljs.core/HashMap.fromArrays"
                                 "cljs.core/deref"
                                 "cljs.core/reductions"
                                 "cljs.core/false?"
                                 "cljs.core/bit-flip"
                                 "cljs.core/ISet"
                                 "cljs.core/LazySeq"
                                 "cljs.core/pop!"
                                 "cljs.core/*2"
                                 "clojure.browser.event/total-listener-count"
                                 "cljs.core/alter-meta!"
                                 "clojure.browser.dom/click-element"
                                 "cljs.core/bit-shift-right-zero-fill"
                                 "cljs.reader/read-meta"
                                 "special/try*"
                                 "cljs.core/range"
                                 "cljs.core/reify"
                                 "cljs.core/satisfies?"
                                 "cljs.core/nth"
                                 "cljs.core/list"
                                 "cljs.core/defn"
                                 "cljs.core/rand-nth"
                                 "cljs.core/atom"
                                 "cljs.reader/read-keyword"
                                 "cljs.core/Vector"
                                 "cljs.reader/skip-line"
                                 "cljs.core/namespace"
                                 "cljs.nodejs/require"
                                 "clojure.browser.event/EventType"
                                 "cljs.core/merge"
                                 "clojure.browser.repl/send-result"
                                 "clojure.walk/keywordize-keys"
                                 "cljs.core/reduced"
                                 "cljs.core/derive"
                                 "clojure.zip/zipper"
                                 "clojure.zip/remove"
                                 "cljs.core/find"
                                 "cljs.core/*print-dup*"
                                 "cljs.core/object-array"
                                 "cljs.core/indexed?"
                                 "cljs.core/partial"
                                 "cljs.core/keyword?"
                                 "clojure.browser.event/fire-listeners"
                                 "cljs.core/interleave"
                                 "cljs.core/TransientHashSet"
                                 "cljs.core/*flush-on-newline*"
                                 "cljs.core/get-in"
                                 "clojure.browser.dom/element"
                                 "cljs.core/prim-seq"
                                 "cljs.core/<="
                                 "clojure.set/map-invert"
                                 "clojure.browser.event/listen"
                                 "cljs.core/neg?"
                                 "clojure.browser.dom/replace-node"
                                 "special/catch"
                                 "cljs.core/reverse"
                                 "cljs.core/realized?"}},
       :compiler {:changes [{:cljs-version "0.0-927",
                             :cljs-date "2012-01-20",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790",
                             :added #{"cljs.repl.rhino/current-repl-env"
                                      "cljs.repl/evaluate-form"
                                      "cljs.repl/load-stream"
                                      "cljs.repl.browser/read-get"
                                      "cljs.repl.browser/load-javascript"
                                      "cljs.repl.browser/add-in-order"
                                      "cljs.repl/load-namespace"
                                      "cljs.repl.rhino/loaded-libs"
                                      "cljs.repl.browser/run-in-order"
                                      "cljs.repl.browser/compile-client-js"
                                      "cljs.repl.browser/handle-get"
                                      "cljs.repl.browser/stop-server"
                                      "cljs.repl.browser/read-request"
                                      "cljs.repl/load-file"
                                      "cljs.repl.browser/browser-eval"
                                      "cljs.repl.browser/server-state"
                                      "cljs.repl.browser/send-for-eval"
                                      "cljs.repl.browser/constrain-order"
                                      "cljs.repl.rhino/rhino-eval"
                                      "cljs.repl.browser/read-headers"
                                      "cljs.repl/repl"
                                      "cljs.repl.rhino/load-javascript"
                                      "cljs.repl.browser/create-client-js-file"
                                      "cljs.repl/*cljs-verbose*"
                                      "cljs.repl.browser/loaded-libs"
                                      "cljs.repl.browser/repl-client-js"
                                      "cljs.repl.browser/parse-headers"
                                      "cljs.repl.browser/send-404"
                                      "cljs.repl.browser/repl-env"
                                      "cljs.repl.rhino/repl-env"
                                      "cljs.repl.rhino/goog-require"
                                      "cljs.repl.browser/send-repl-client-page"
                                      "cljs.repl.browser/send-and-close"
                                      "cljs.repl.rhino/bootjs"
                                      "cljs.repl/IJavaScriptEnv"
                                      "cljs.repl.browser/handle-connection"
                                      "cljs.repl.rhino/IEval"
                                      "cljs.repl.browser/start-server"
                                      "cljs.repl.browser/server-loop"
                                      "cljs.repl.browser/read-post"
                                      "cljs.repl.rhino/rhino-setup"
                                      "cljs.repl.browser/ordering"}}
                            {:cljs-version "0.0-971",
                             :cljs-date "2012-01-27",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-993",
                             :cljs-date "2012-02-27",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790",
                             :added #{"cljs.repl/default-special-fns"}}
                            {:cljs-version "0.0-1006",
                             :cljs-date "2012-03-30",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-1011",
                             :cljs-date "2012-04-02",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-1211",
                             :cljs-date "2012-05-09",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376",
                             :added #{"cljs.repl.browser/send-static"}}],
                  :symbol-names #{"cljs.repl.rhino/current-repl-env"
                                  "cljs.repl/evaluate-form"
                                  "cljs.repl/load-stream"
                                  "cljs.repl.browser/read-get"
                                  "cljs.repl.browser/load-javascript"
                                  "cljs.repl.browser/add-in-order"
                                  "cljs.repl/load-namespace"
                                  "cljs.repl.rhino/loaded-libs"
                                  "cljs.repl.browser/run-in-order"
                                  "cljs.repl.browser/compile-client-js"
                                  "cljs.repl.browser/handle-get"
                                  "cljs.repl.browser/stop-server"
                                  "cljs.repl.browser/read-request"
                                  "cljs.repl/load-file"
                                  "cljs.repl.browser/browser-eval"
                                  "cljs.repl.browser/server-state"
                                  "cljs.repl.browser/send-for-eval"
                                  "cljs.repl.browser/constrain-order"
                                  "cljs.repl/default-special-fns"
                                  "cljs.repl.rhino/rhino-eval"
                                  "cljs.repl.browser/read-headers"
                                  "cljs.repl/repl"
                                  "cljs.repl.rhino/load-javascript"
                                  "cljs.repl.browser/create-client-js-file"
                                  "cljs.repl/*cljs-verbose*"
                                  "cljs.repl.browser/loaded-libs"
                                  "cljs.repl.browser/repl-client-js"
                                  "cljs.repl.browser/parse-headers"
                                  "cljs.repl.browser/send-404"
                                  "cljs.repl.browser/repl-env"
                                  "cljs.repl.rhino/repl-env"
                                  "cljs.repl.rhino/goog-require"
                                  "cljs.repl.browser/send-repl-client-page"
                                  "cljs.repl.browser/send-static"
                                  "cljs.repl.browser/send-and-close"
                                  "cljs.repl.rhino/bootjs"
                                  "cljs.repl/IJavaScriptEnv"
                                  "cljs.repl.browser/handle-connection"
                                  "cljs.repl.rhino/IEval"
                                  "cljs.repl.browser/start-server"
                                  "cljs.repl.browser/server-loop"
                                  "cljs.repl.browser/read-post"
                                  "cljs.repl.rhino/rhino-setup"
                                  "cljs.repl.browser/ordering"}}}}
