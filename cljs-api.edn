{:release {:cljs-version "0.0-2911",
           :cljs-tag "r2911",
           :cljs-date "2015-02-21",
           :clj-version "1.6.0",
           :clj-tag "clojure-1.6.0",
           :treader-version "0.8.10",
           :treader-tag "tools.reader-0.8.10",
           :gclosure-lib "0.0-20140718-946a7d39"},
 :clj-not-cljs #{"clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.core/*in*"
                 "clojure.main/demunge"
                 "clojure.core.protocols/kv-reduce"
                 "clojure.core/release-pending-sends"
                 "clojure.lang/AReference"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.lang/AMapEntry"
                 "clojure.lang/IHashEq"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.java.io/file"
                 "clojure.lang/FnLoaderThunk"
                 "clojure.test/*load-tests*"
                 "clojure.core/->Vec"
                 "clojure.test/deftest-"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.lang/LazilyPersistentVector"
                 "clojure.core/proxy-super"
                 "clojure.core/refer"
                 "clojure.lang/Numbers"
                 "clojure.core/record?"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.lang/ILookupThunk"
                 "clojure.core.protocols/CollReduce"
                 "clojure.core/future-call"
                 "clojure.pprint/print-table"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.pprint/*print-base*"
                 "clojure.core/load-string"
                 "clojure.lang/LispReader"
                 "clojure.core/pmap"
                 "clojure.lang/ARef"
                 "clojure.test/file-position"
                 "clojure.lang/Repl"
                 "clojure.core.protocols/IKVReduce"
                 "clojure.lang/RestFn"
                 "clojure.lang/Compiler"
                 "clojure.lang/IProxy"
                 "clojure.core/send"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.pprint/pprint-indent"
                 "clojure.lang/PersistentStructMap"
                 "clojure.reflect/map->Field"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.lang/Util"
                 "clojure.core/agent-error"
                 "clojure.lang/Obj"
                 "clojure.core/ns-refers"
                 "clojure.lang/Binding"
                 "clojure.core/num"
                 "clojure.lang/IPersistentMap"
                 "clojure.lang/IRef"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.java.io/make-writer"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/init-proxy"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.core/default-data-readers"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.lang/LineNumberingPushbackReader"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.lang/EnumerationSeq"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.core/await"
                 "clojure.core/supers"
                 "clojure.reflect/Field"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.instant/parse-timestamp"
                 "clojure.java.io/make-output-stream"
                 "clojure.lang/BigInt"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.lang/APersistentVector"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.pprint/pprint-tab"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.lang/IReference"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.reflect/->AsmReflector"
                 "clojure.core/ref-set"
                 "clojure.reflect/->Method"
                 "clojure.core/->ArrayChunk"
                 "clojure.test.tap/with-tap-output"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/*data-readers*"
                 "clojure.core/use"
                 "clojure.lang/Intrinsics"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.lang/Compile"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.lang/Reflector"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.lang/Namespace"
                 "clojure.lang/ILookupSite"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.lang/Agent"
                 "clojure.reflect/->Constructor"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.main/repl-requires"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/with-in-str"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.lang/ATransientSet"
                 "clojure.core/with-bindings*"
                 "clojure.instant/read-instant-timestamp"
                 "clojure.lang/ArityException"
                 "clojure.reflect/->Field"
                 "clojure.core/*default-data-reader-fn*"
                 "clojure.core/update-proxy"
                 "clojure.lang/APersistentMap"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/promise"
                 "clojure.instant/validated"
                 "clojure.core/*compile-files*"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.reflect/resolve-class"
                 "clojure.edn/read"
                 "clojure.java.io/as-file"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/send-via"
                 "clojure.core/set-agent-send-executor!"
                 "clojure.core/create-ns"
                 "clojure.lang/IObj"
                 "clojure.lang/APersistentSet"
                 "clojure.core/aset-int"
                 "clojure.edn/read-string"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.reflect/map->Method"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.lang/IBlockingDeref"
                 "clojure.test/with-test"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.lang/ATransientMap"
                 "clojure.template/apply-template"
                 "clojure.core/set-agent-send-off-executor!"
                 "clojure.core/cast"
                 "clojure.lang/XMLHandler"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.lang/TransactionalHashMap"
                 "clojure.core/ensure"
                 "clojure.string/re-quote-replacement"
                 "clojure.lang/AFunction"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.lang/IKeywordLookup"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/bound-fn"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/locking"
                 "clojure.lang/IType"
                 "clojure.core.protocols/coll-reduce"
                 "clojure.core/char-array"
                 "clojure.lang/Murmur3"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.lang/IteratorSeq"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.lang/AFn"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/thread-bound?"
                 "clojure.lang/MapEntry"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/->VecSeq"
                 "clojure.lang/IPersistentCollection"
                 "clojure.core/resolve"
                 "clojure.core/->VecNode"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/file-seq"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core.reducers/->Cat"
                 "clojure.core/get-thread-bindings"
                 "clojure.stacktrace/e"
                 "clojure.lang/MapEquivalence"
                 "clojure.lang/DynamicClassLoader"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.instant/read-instant-date"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.reflect/map->Constructor"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/error-mode"
                 "clojure.lang/MethodImplCache"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.lang/EdnReader"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.lang/RT"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.lang/Ref"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.lang/ProxyHandler"
                 "clojure.core/decimal?"
                 "clojure.core/definterface"
                 "clojure.core/pcalls"
                 "clojure.lang/KeywordLookupSite"
                 "clojure.lang/StringSeq"
                 "clojure.core/ns-unalias"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.lang/ArraySeq"
                 "clojure.pprint/pprint"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.main/main"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.lang/IExceptionInfo"
                 "clojure.core/dosync"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.lang/LockingTransaction"
                 "clojure.lang/SeqEnumeration"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.test/report"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.core/bound?"
                 "clojure.instant/read-instant-calendar"
                 "clojure.java.io/writer"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.reflect/->JavaReflector"
                 "clojure.lang/Settable"
                 "clojure.lang/Script"
                 "clojure.core/*compiler-options*"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.main/with-read-known"
                 "clojure.lang/Ratio"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"},
 :symbols {"cljs.core/keys" {:description "Returns a sequence of the keys in `hash-map`.",
                             :ns "cljs.core",
                             :name "keys",
                             :signature ["[hash-map]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/vals"],
                             :full-name-encode "cljs.core_keys",
                             :source {:code "(defn keys\n  [hash-map]\n  (when-let [mseq (seq hash-map)]\n    (KeySeq. mseq nil)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7234 7238]},
                             :full-name "cljs.core/keys",
                             :clj-symbol "clojure.core/keys",
                             :docstring "Returns a sequence of the map's keys."},
           "cljs.core/unchecked-negate" {:ns "cljs.core",
                                         :name "unchecked-negate",
                                         :signature ["[x]"],
                                         :history [["+" "0.0-1798"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_unchecked-negate",
                                         :source {:code "(defn unchecked-negate [x]\n  (cljs.core/unchecked-negate x))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2006 2007]},
                                         :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-negate\n  ([x] `(- ~x)))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/clj/cljs/core.clj",
                                                          :lines [399
                                                                  400]}),
                                         :full-name "cljs.core/unchecked-negate",
                                         :clj-symbol "clojure.core/unchecked-negate"},
           "cljs.core/reset!" {:description "Sets the value of atom `a` to `new-value` without regard for the current value.\n\nReturns `new-value`.",
                               :ns "cljs.core",
                               :name "reset!",
                               :signature ["[a new-value]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/swap!"
                                         "cljs.core/compare-and-set!"
                                         "cljs.core/atom"],
                               :full-name-encode "cljs.core_resetBANG",
                               :source {:code "(defn reset!\n  [a new-value]\n  (if (instance? Atom a)\n    (let [validate (.-validator a)]\n      (when-not (nil? validate)\n        (assert (validate new-value) \"Validator rejected reference state\"))\n      (let [old-value (.-state a)]\n        (set! (.-state a) new-value)\n        (when-not (nil? (.-watches a))\n          (-notify-watches a old-value new-value))\n        new-value))\n    (-reset! a new-value)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3539 3552]},
                               :full-name "cljs.core/reset!",
                               :clj-symbol "clojure.core/reset!",
                               :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
           "cljs.core/ITransientCollection" {:ns "cljs.core",
                                             :name "ITransientCollection",
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core_ITransientCollection",
                                             :source {:code "(defprotocol ITransientCollection\n  (^clj -conj! [tcoll val])\n  (^clj -persistent! [tcoll]))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [380 382]},
                                             :methods [{:name "-conj!",
                                                        :signature ["[tcoll val]"],
                                                        :docstring nil}
                                                       {:name "-persistent!",
                                                        :signature ["[tcoll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/ITransientCollection",
                                             :clj-symbol "clojure.lang/ITransientCollection"},
           "cljs.core/transient" {:ns "cljs.core",
                                  :name "transient",
                                  :signature ["[coll]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_transient",
                                  :source {:code "(defn transient\n  [coll]\n  (-as-transient coll))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2915 2918]},
                                  :full-name "cljs.core/transient",
                                  :clj-symbol "clojure.core/transient",
                                  :docstring "Returns a new, transient version of the collection, in constant time."},
           "cljs.core/Fn" {:ns "cljs.core",
                           :name "Fn",
                           :history [["+" "0.0-1552"]],
                           :type "protocol",
                           :full-name-encode "cljs.core_Fn",
                           :source {:code "(defprotocol Fn\n  \"Marker protocol\")",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [231 232]},
                           :full-name "cljs.core/Fn",
                           :clj-symbol "clojure.lang/Fn",
                           :docstring "Marker protocol"},
           "clojure.data/EqualityPartition" {:ns "clojure.data",
                                             :name "EqualityPartition",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "protocol",
                                             :full-name-encode "clojure.data_EqualityPartition",
                                             :source {:code "(defprotocol EqualityPartition\n  \"Implementation detail. Subject to change.\"\n  (equality-partition [x] \"Implementation detail. Subject to change.\"))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/clojure/data.cljs",
                                                      :lines [75 77]},
                                             :methods [{:name "equality-partition",
                                                        :signature ["[x]"],
                                                        :docstring "Implementation detail. Subject to change."}],
                                             :full-name "clojure.data/EqualityPartition",
                                             :clj-symbol "clojure.data/EqualityPartition",
                                             :docstring "Implementation detail. Subject to change."},
           "cljs.core/ex-message" {:ns "cljs.core",
                                   :name "ex-message",
                                   :signature ["[ex]"],
                                   :history [["+" "0.0-1576"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_ex-message",
                                   :source {:code "(defn ex-message\n  [ex]\n  (when (instance? js/Error ex)\n    (.-message ex)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [9222 9228]},
                                   :full-name "cljs.core/ex-message",
                                   :docstring "Alpha - subject to change.\nReturns the message attached to the given Error / ExceptionInfo object.\nFor non-Errors returns nil."},
           "cljs.repl.nashorn/repl-filename" {:ns "cljs.repl.nashorn",
                                              :name "repl-filename",
                                              :type "var",
                                              :source {:code "(def repl-filename \"<cljs repl>\")",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/repl/nashorn.clj",
                                                       :lines [143]},
                                              :full-name "cljs.repl.nashorn/repl-filename",
                                              :full-name-encode "cljs.repl.nashorn_repl-filename",
                                              :history [["+"
                                                         "0.0-2814"]]},
           "cljs.test/test-vars-block" {:ns "cljs.test",
                                        :name "test-vars-block",
                                        :signature ["[vars]"],
                                        :history [["+" "0.0-2814"]],
                                        :type "function",
                                        :full-name-encode "cljs.test_test-vars-block",
                                        :source {:code "(defn test-vars-block\n  [vars]\n  (map\n   (fn [[ns vars]]\n     (fn []\n       (block\n        (let [env (get-current-env)\n              once-fixtures (get-in env [:once-fixtures ns])\n              each-fixtures (get-in env [:each-fixtures ns])]\n          (case (execution-strategy once-fixtures each-fixtures)\n            :async\n            (->> vars\n                 (filter (comp :test meta))\n                 (mapcat (comp (partial wrap-map-fixtures each-fixtures)\n                               test-var-block))\n                 (wrap-map-fixtures once-fixtures))\n            :sync\n            (do\n              (update-current-env! [:async-disabled]\n                                   (constantly\n                                    \"Async tests require fixtures to be specified as maps\"))\n              (let [each-fixture-fn (join-fixtures each-fixtures)]\n                [(fn []\n                   ((join-fixtures once-fixtures)\n                    (fn []\n                      (doseq [v vars]\n                        (when (:test (meta v))\n                          (each-fixture-fn\n                           (fn []\n                             (test-var v)))))))\n                   (update-current-env! [:async-disabled]\n                                        (constantly nil)))])))))))\n   (group-by (comp :ns meta) vars)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/test.cljs",
                                                 :lines [520 554]},
                                        :full-name "cljs.test/test-vars-block",
                                        :docstring "Like test-vars, but returns a block for further composition and\nlater execution."},
           "clojure.set/select" {:description "Returns a set of the elements for which `pred` is true.",
                                 :ns "clojure.set",
                                 :name "select",
                                 :signature ["[pred xset]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/filter"],
                                 :full-name-encode "clojure.set_select",
                                 :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [61 65]},
                                 :full-name "clojure.set/select",
                                 :clj-symbol "clojure.set/select",
                                 :docstring "Returns a set of the elements for which pred is true"},
           "cljs.core/hash-unordered-coll" {:return-type number,
                                            :ns "cljs.core",
                                            :name "hash-unordered-coll",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-2261"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_hash-unordered-coll",
                                            :source {:code "(defn ^number hash-unordered-coll\n  [coll]\n  (loop [n 0 hash-code 0 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ hash-code (hash (first coll))) 0) (next coll))\n      (mix-collection-hash hash-code n))))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [839 849]},
                                            :full-name "cljs.core/hash-unordered-coll",
                                            :clj-symbol "clojure.core/hash-unordered-coll",
                                            :docstring "Returns the hash code, consistent with =, for an external unordered\ncollection implementing Iterable. For maps, the iterator should\nreturn map entries whose hash is computed as\n  (hash-ordered-coll [k v]).\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "cljs.core/delay" {:ns "cljs.core",
                              :name "delay",
                              :signature ["[& body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core_delay",
                              :source {:code "(defmacro delay [& body]\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  `(new cljs.core/Delay (fn [] ~@body) nil))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1097 1102]},
                              :full-name "cljs.core/delay",
                              :clj-symbol "clojure.core/delay"},
           "cljs.core/float" {:return-type number,
                              :ns "cljs.core",
                              :name "float",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core_float",
                              :source {:code "(defn ^number float [x] x)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1950]},
                              :extra-sources ({:code "(defmacro float [x] x)",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [363]}),
                              :full-name "cljs.core/float",
                              :clj-symbol "clojure.core/float"},
           "cljs.core/bit-not" {:description "Bitwise complement.  Same as `~x` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-not",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_bit-not",
                                :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2121 2123]},
                                :extra-sources ({:code "(defmacro ^::ana/numeric bit-not [x]\n  (core/list 'js* \"(~ ~{})\" x))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [490 491]}),
                                :examples [{:id "d4c5e3",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-not 2r1100)\n;;=> -13\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-not 12)\n;;=> -13\n```"}],
                                :full-name "cljs.core/bit-not",
                                :clj-symbol "clojure.core/bit-not",
                                :docstring "Bitwise complement"},
           "cljs.core/partition" {:description "Returns a lazy sequence of lists of `n` items each, at offsets `step` apart.\n\nIf `step` is not supplied, defaults to `n`, i.e. the partitions do not overlap.\n\nIf a `pad` collection is supplied, its elements will be used as necessary to\ncomplete the last partition up to `n` items.\n\nReturns a partition with less than `n` items if there are not enough padding\nelements.",
                                  :ns "cljs.core",
                                  :name "partition",
                                  :signature ["[n coll]"
                                              "[n step coll]"
                                              "[n step pad coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/partition-all"
                                            "cljs.core/split-at"
                                            "cljs.core/partition-by"],
                                  :full-name-encode "cljs.core_partition",
                                  :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (== n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (== n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [4060 4080]},
                                  :full-name "cljs.core/partition",
                                  :clj-symbol "clojure.core/partition",
                                  :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition up to n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "cljs.core/IEncodeJS" {:ns "cljs.core",
                                  :name "IEncodeJS",
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IEncodeJS",
                                  :source {:code "(defprotocol IEncodeJS\n  (-clj->js [x] \"Recursively transforms clj values to JavaScript\")\n  (-key->js [x] \"Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)\"))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8635 8638]},
                                  :methods [{:name "-clj->js",
                                             :signature ["[x]"],
                                             :docstring "Recursively transforms clj values to JavaScript"}
                                            {:name "-key->js",
                                             :signature ["[x]"],
                                             :docstring "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}],
                                  :full-name "cljs.core/IEncodeJS",
                                  :history [["+" "0.0-1552"]]},
           "cljs.core/parents" {:ns "cljs.core",
                                :name "parents",
                                :signature ["[tag]" "[h tag]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_parents",
                                :source {:code "(defn parents\n  ([tag] (parents @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8800 8806]},
                                :full-name "cljs.core/parents",
                                :clj-symbol "clojure.core/parents",
                                :docstring "Returns the immediate parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/aclone" {:description "Creates a clone of the given JavaScript array `arr`.  The result is a new\nJavaScript array, which is a shallow copy, not a deep copy.",
                               :ns "cljs.core",
                               :name "aclone",
                               :signature ["[arr]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/array"
                                         "cljs.core/make-array"],
                               :full-name-encode "cljs.core_aclone",
                               :source {:code "(defn aclone\n  [arr]\n  (let [len (alength arr)\n        new-arr (make-array len)]\n    (dotimes [i len]\n      (aset new-arr i (aget arr i)))\n    new-arr))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [173 180]},
                               :examples [{:id "422c4e",
                                           :content "```clj\n(def a #js [1 2 3])\n(def b (aclone a))\n(aset b 0 4)\n\na\n;;=> #js [1 2 3]\n\nb\n;;=> #js [4 2 3]\n```"}],
                               :full-name "cljs.core/aclone",
                               :clj-symbol "clojure.core/aclone",
                               :docstring "Returns a javascript array, cloned from the passed in array"},
           "cljs.core/reset-meta!" {:ns "cljs.core",
                                    :name "reset-meta!",
                                    :signature ["[iref m]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_reset-metaBANG",
                                    :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [8474 8477]},
                                    :full-name "cljs.core/reset-meta!",
                                    :clj-symbol "clojure.core/reset-meta!",
                                    :docstring "Atomically resets the metadata for an atom"},
           "cljs.core/IReset" {:ns "cljs.core",
                               :name "IReset",
                               :type "protocol",
                               :full-name-encode "cljs.core_IReset",
                               :source {:code "(defprotocol IReset\n  (-reset! [o new-value]))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [416 417]},
                               :methods [{:name "-reset!",
                                          :signature ["[o new-value]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IReset",
                               :history [["+" "0.0-2173"]]},
           "special/defrecord*" {:ns "special",
                                 :name "defrecord*",
                                 :type "special form",
                                 :source {:code "(defmethod parse 'defrecord*\n  [_ env form _ _]\n  (parse-type :defrecord* env form) )",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/clj/cljs/analyzer.clj",
                                          :lines [1425 1427]},
                                 :full-name "special/defrecord*",
                                 :full-name-encode "special_defrecordSTAR",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/Box" {:ns "cljs.core",
                            :name "Box",
                            :signature ["[val]"],
                            :history [["+" "0.0-1424"]],
                            :type "type",
                            :full-name-encode "cljs.core_Box",
                            :source {:code "(deftype Box [^:mutable val])",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [5592]},
                            :full-name "cljs.core/Box",
                            :clj-symbol "clojure.lang/Box"},
           "cljs.reader/dispatch-macros" {:ns "cljs.reader",
                                          :name "dispatch-macros",
                                          :type "function",
                                          :signature ["[s]"],
                                          :source {:code "(defn dispatch-macros [s]\n  (cond\n   (identical? s \"{\") read-set\n   (identical? s \"<\") (throwing-reader \"Unreadable form\")\n   (identical? s \"\\\"\") read-regex\n   (identical? s\"!\") read-comment\n   (identical? s \"_\") read-discard\n   :else nil))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [415 422]},
                                          :full-name "cljs.reader/dispatch-macros",
                                          :full-name-encode "cljs.reader_dispatch-macros",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/current-repl-env" {:ns "cljs.repl.rhino",
                                               :name "current-repl-env",
                                               :type "var",
                                               :source {:code "(def current-repl-env (atom nil))",
                                                        :repo "clojurescript",
                                                        :tag "r2511",
                                                        :filename "src/clj/cljs/repl/rhino.clj",
                                                        :lines [18]},
                                               :full-name "cljs.repl.rhino/current-repl-env",
                                               :full-name-encode "cljs.repl.rhino_current-repl-env",
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-2629"]],
                                               :removed {:in "0.0-2629",
                                                         :last-seen "0.0-2511"}},
           "cljs.core/int-rotate-left" {:return-type number,
                                        :ns "cljs.core",
                                        :name "int-rotate-left",
                                        :signature ["[x n]"],
                                        :history [["+" "0.0-2261"]],
                                        :type "function",
                                        :full-name-encode "cljs.core_int-rotate-left",
                                        :source {:code "(defn ^number int-rotate-left [x n]\n  (bit-or\n    (bit-shift-left x n)\n    (unsigned-bit-shift-right x (- n))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [448 451]},
                                        :full-name "cljs.core/int-rotate-left"},
           "cljs.core/ICollection" {:ns "cljs.core",
                                    :name "ICollection",
                                    :type "protocol",
                                    :full-name-encode "cljs.core_ICollection",
                                    :source {:code "(defprotocol ICollection\n  (^clj -conj [coll o]))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [268 269]},
                                    :methods [{:name "-conj",
                                               :signature ["[coll o]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/ICollection",
                                    :history [["+" "0.0-927"]]},
           "cljs.build.api/cljs-dependents-for-macro-namespaces" {:ns "cljs.build.api",
                                                                  :name "cljs-dependents-for-macro-namespaces",
                                                                  :signature ["[namespaces]"],
                                                                  :history [["+"
                                                                             "0.0-2496"]],
                                                                  :type "function",
                                                                  :full-name-encode "cljs.build.api_cljs-dependents-for-macro-namespaces",
                                                                  :source {:code "(defn cljs-dependents-for-macro-namespaces\n  [namespaces]\n  (map :name\n       (let [namespaces-set (set namespaces)]\n         (filter (fn [x] (not-empty\n                         (intersection namespaces-set (-> x :require-macros vals set))))\n                 (vals (:cljs.analyzer/namespaces @env/*compiler*))))))",
                                                                           :repo "clojurescript",
                                                                           :tag "r2911",
                                                                           :filename "src/clj/cljs/build/api.clj",
                                                                           :lines [45
                                                                                   64]},
                                                                  :full-name "cljs.build.api/cljs-dependents-for-macro-namespaces",
                                                                  :docstring "Takes a list of Clojure (.clj) namespaces that define macros and\nreturns a list ClojureScript (.cljs) namespaces that depend on those macro\nnamespaces.\n\nFor example where example.macros is defined in the clojure file\n\"example/macros.clj\" and both 'example.core and 'example.util are\nClojureScript namespaces that require and use the macros from\n'example.macros :\n(cljs-dependents-for-macro-namespaces 'example.macros) ->\n('example.core 'example.util)\n\nThis must be called when cljs.env/*compiler* is bound to the\ncompile env that you are inspecting. See cljs.env/with-compile-env."},
           "cljs.core/every?" {:description "Returns true if `(pred x)` is logical true for every `x` in `coll`, else false.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "every?",
                               :signature ["[pred coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/some"
                                         "cljs.core/not-any?"],
                               :full-name-encode "cljs.core_everyQMARK",
                               :source {:code "(defn ^boolean every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3295 3302]},
                               :full-name "cljs.core/every?",
                               :clj-symbol "clojure.core/every?",
                               :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
           "clojure.zip/node" {:ns "clojure.zip",
                               :name "node",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_node",
                               :source {:code "(defn node\n  [loc] (loc 0))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [60 62]},
                               :full-name "clojure.zip/node",
                               :clj-symbol "clojure.zip/node",
                               :docstring "Returns the node at loc"},
           "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                             :name "IEmptyableCollection",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IEmptyableCollection",
                                             :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [265 266]},
                                             :methods [{:name "-empty",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEmptyableCollection",
                                             :history [["+" "0.0-927"]]},
           "clojure.zip/right" {:ns "clojure.zip",
                                :name "right",
                                :signature ["[loc]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip_right",
                                :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [135 140]},
                                :full-name "clojure.zip/right",
                                :clj-symbol "clojure.zip/right",
                                :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
           "cljs.core/int-array" {:ns "cljs.core",
                                  :name "int-array",
                                  :signature ["[size-or-seq]"
                                              "[size init-val-or-seq]"],
                                  :history [["+" "0.0-1798"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_int-array",
                                  :source {:code "(defn int-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (int-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2781 2799]},
                                  :full-name "cljs.core/int-array",
                                  :clj-symbol "clojure.core/int-array"},
           "cljs.core/LazyTransformer.createMulti" {:ns "cljs.core",
                                                    :name "LazyTransformer.createMulti",
                                                    :signature ["[xform colls]"],
                                                    :history [["+"
                                                               "0.0-2301"]],
                                                    :parent-type "LazyTransformer",
                                                    :type "function",
                                                    :full-name-encode "cljs.core_LazyTransformerDOTcreateMulti",
                                                    :source {:code "(set! (.-createMulti LazyTransformer)\n  (fn [xform colls]\n    (let [iters (array)]\n      (doseq [coll colls]\n        (.push iters (iter coll)))\n      (LazyTransformer.\n        (multi-stepper xform iters (make-array (alength iters)))\n        nil nil nil))))",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [3268
                                                                     3275]},
                                                    :full-name "cljs.core/LazyTransformer.createMulti"},
           "cljs.core/==" {:description "This is an equality check for numbers of different types that was carried over from Clojure,\nto allow compatibility when converting code to ClojureScript.\n\nSince there is only a single number type in JavaScript, 64-bit floating point, there is no\nreason to use the `==` operator in ClojureScript.\n\nBehavior on non-number arguments is undefined.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name "==",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/="
                                     "cljs.core/identical?"],
                           :full-name-encode "cljs.core_EQEQ",
                           :source {:code "(defn ^boolean ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [2158 2169]},
                           :extra-sources ({:code "(defmacro ^::ana/numeric ==\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [455 458]}),
                           :examples [{:id "5ac342",
                                       :content "```clj\n(== 1 1)\n;;=> true\n\n(== 1 2)\n;;=> false\n```"}],
                           :full-name "cljs.core/==",
                           :clj-symbol "clojure.core/==",
                           :docstring "Returns non-nil if nums all have the equivalent\nvalue, otherwise false. Behavior on non nums is\nundefined."},
           "cljs.core/dissoc!" {:ns "cljs.core",
                                :name "dissoc!",
                                :signature ["[tcoll key]"
                                            "[tcoll key & ks]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core_dissocBANG",
                                :source {:code "(defn dissoc!\n  ([tcoll key]\n    (-dissoc! tcoll key))\n  ([tcoll key & ks]\n    (let [ntcoll (-dissoc! tcoll key)]\n      (if ks\n        (recur ntcoll (first ks) (next ks))\n        ntcoll))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2952 2960]},
                                :full-name "cljs.core/dissoc!",
                                :clj-symbol "clojure.core/dissoc!",
                                :docstring "Returns a transient map that doesn't contain a mapping for key(s)."},
           "cljs.repl/self-require?" {:ns "cljs.repl",
                                      :name "self-require?",
                                      :type "function",
                                      :signature ["[specs]"],
                                      :source {:code "(defn self-require? [specs]\n  (some\n    (fn [quoted-spec-or-kw]\n      (and (not (keyword? quoted-spec-or-kw))\n           (let [spec (second quoted-spec-or-kw)\n                 ns (if (sequential? spec)\n                      (first spec)\n                      spec)]\n             (= ns ana/*cljs-ns*))))\n    specs))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [464 473]},
                                      :full-name "cljs.repl/self-require?",
                                      :full-name-encode "cljs.repl_self-requireQMARK",
                                      :history [["+" "0.0-2911"]]},
           "special/." {:description "For interop, the `.` special form allows access to member properties of the\ngiven JavaScript object `o`.\n\nIf the second operand is a symbol preceded with a hyphen as in `-p`, the\nexpression will result in the value of the property named `p`.\n\nIf the second operand is a symbol that is not preceded with a hyphen as in `m`,\nthe expression will evaluate to a call of the method named `m`.  Any additional\noperands will be passed as arguments to the method.\n\nThe __preferred, idiomatic__ way to access members of a JavaScript object is to\nuse the following sugar:\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Sugar</th>\n      <th>Expands To</th></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><pre>(.-p o)</pre></td>\n      <td><pre>(. o -p)</pre></td>\n    </tr>\n    <tr>\n      <td><pre>(.m o)</pre></td>\n      <td><pre>(. o m)</pre></td>\n    </tr>\n    <tr>\n      <td><pre>(.m o 1 2)</pre></td>\n      <td><pre>(. o m 1 2)</pre></td>\n    </tr>\n  </tbody>\n</table>",
                        :ns "special",
                        :name ".",
                        :signature ["[o -p]"
                                    "[o m]"
                                    "[o m 1 2]"
                                    "[o (m 1 2)]"],
                        :history [["+" "0.0-927"]],
                        :type "special form",
                        :related ["cljs.core/.." "cljs.core/aget"],
                        :full-name-encode "special_DOT",
                        :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+] :as form] _ _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)]\n     (case dot-action\n           ::access {:env env :op :dot :form form\n                     :target targetexpr\n                     :field field\n                     :children [targetexpr]\n                     :tag (-> form meta :tag)}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :form form\n                       :target targetexpr\n                       :method method\n                       :args argexprs\n                       :children (into [targetexpr] argexprs)\n                       :tag (-> form meta :tag)})))))",
                                 :repo "clojurescript",
                                 :tag "r2911",
                                 :filename "src/clj/cljs/analyzer.clj",
                                 :lines [1485 1503]},
                        :examples [{:id "22ccbb",
                                    :content "We can access the JavaScript properties of a string:\n\n```js\n// JavaScript\nvar m = \"Hello World\";\nm.length;\n//=> 11\n```\n\n```clj\n;; ClojureScript\n(def m \"Hello World\")\n(.-length m)\n;;=> 11\n```\n\nWe can also call member functions on the string:\n\n```js\n// JavaScript\nm.toUpperCase();\n//=> \"HELLO WORLD\"\n\nm.replace(\"H\", \"\");\n//=> \"ello World\";\n```\n\n```clj\n;; ClojureScript\n(.toUpperCase m)\n;;=> \"HELLO WORLD\"\n\n(.replace m \"H\" \"\")\n;;=> \"ello World\"\n```"}
                                   {:id "7c5e58",
                                    :content "Create a JavaScript object `o`:\n\n```clj\n(def o #js {:foo \"bar\"})\n```\n\nYou can get the value at property `\"foo\"` with any of the following:\n\n```clj\n(. o -foo)\n;;=> \"bar\"\n\n(.-foo o)\n;;=> \"bar\"\n\n(aget o \"foo\")\n;;=> \"bar\"\n```"}],
                        :full-name "special/.",
                        :clj-symbol "clojure.core/."},
           "clojure.reflect/meta" {:ns "clojure.reflect",
                                   :name "meta",
                                   :signature ["[sym cb]"],
                                   :history [["+" "0.0-1503"]],
                                   :type "function",
                                   :full-name-encode "clojure.reflect_meta",
                                   :source {:code "(defn meta\n  [sym cb]\n  (query-reflection (str \"var=\" (js/encodeURIComponent (str sym)))\n                    #(cb (evaluate-javascript %))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/clojure/reflect.cljs",
                                            :lines [24 30]},
                                   :full-name "clojure.reflect/meta",
                                   :docstring "Queries the reflection api with a fully qualified symbol, then calls\ncallback fn cb with the evaluated cljs map containing that symbol's\nmeta information."},
           "syntax/Math-ns" {:ns "syntax",
                             :name "Math-ns",
                             :syntax-form "Math/",
                             :type "special namespace",
                             :clj-doc "http://clojure.org/java_interop#toc6",
                             :full-name "syntax/Math-ns",
                             :full-name-encode "syntax_Math-ns",
                             :history [["+" "0.0-927"]]},
           "clojure.browser.net/*timeout*" {:ns "clojure.browser.net",
                                            :name "*timeout*",
                                            :type "var",
                                            :source {:code "(def *timeout* 10000)",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/browser/net.cljs",
                                                     :lines [19]},
                                            :full-name "clojure.browser.net/*timeout*",
                                            :full-name-encode "clojure.browser.net_STARtimeoutSTAR",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/remove-method" {:ns "cljs.core",
                                      :name "remove-method",
                                      :signature ["[multifn dispatch-val]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_remove-method",
                                      :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [9134 9137]},
                                      :full-name "cljs.core/remove-method",
                                      :clj-symbol "clojure.core/remove-method",
                                      :docstring "Removes the method of multimethod associated with dispatch-value."},
           "cljs.core/array-chunk" {:ns "cljs.core",
                                    :name "array-chunk",
                                    :type "function",
                                    :signature ["[arr]"
                                                "[arr off]"
                                                "[arr off end]"],
                                    :source {:code "(defn array-chunk\n  ([arr]\n     (ArrayChunk. arr 0 (alength arr)))\n  ([arr off]\n     (ArrayChunk. arr off (alength arr)))\n  ([arr off end]\n     (ArrayChunk. arr off end)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2664 2670]},
                                    :full-name "cljs.core/array-chunk",
                                    :full-name-encode "cljs.core_array-chunk",
                                    :history [["+" "0.0-1424"]]},
           "clojure.core.reducers/drop" {:ns "clojure.core.reducers",
                                         :name "drop",
                                         :signature ["[n]" "[n coll]"],
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers_drop",
                                         :source {:code "(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [178 190]},
                                         :full-name "clojure.core.reducers/drop",
                                         :clj-symbol "clojure.core.reducers/drop",
                                         :docstring "Elides the first n values from the reduction of coll."},
           "syntax/symbol" {:description "Signifies a symbol.  When evaluated, its result will be the value that the symbol\nis bound to.\n\nSome naming rules:\n\n- must not begin with a number\n- can contain special characters `*`, `+`, `!`, `-`, `_`, `?`\n- symbols starting or ending with a decimal are reserved for interop purposes\n\nSymbols can have an optional namespace. For example, `foo/bar` evaluates to the\nvalue of the `bar` symbol of the `foo` namespace.\n\nTo access symbols in the global JavaScript context, use the namespace `js`.\nFor example, use `js/document` to get the global `document` JavaScript object.",
                            :ns "syntax",
                            :name "symbol",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/symbol"
                                      "cljs.core/symbol?"],
                            :full-name-encode "syntax_symbol",
                            :source {:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                     :repo "tools.reader",
                                     :tag "tools.reader-0.8.10",
                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                     :lines [275 301]},
                            :syntax-form " ",
                            :examples [{:id "cd60a5",
                                        :content "The following has two symbols, `def` and `a`:\n\n```clj\n(def a 1)\n```\n\nThe evaluation of the symbols is controlled by the evaluation of the list `(def\na 1)`.  `def` evaluates to a special form, which suppresses the evaluation of\n`a` since it is just being used as a name for the bound value `1`.\n\nWhen a symbol is by itself, it will evaluated to 1:\n\n```clj\na\n;;=> 1\n```\n\nTo signify an unevaluated symbol, precede it with a quote:\n\n```clj\n'a\n;;=> a\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#symbols",
                            :full-name "syntax/symbol",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.net/IWebSocket" {:ns "clojure.browser.net",
                                             :name "IWebSocket",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.net_IWebSocket",
                                             :source {:code "(defprotocol IWebSocket\n  (open? [this]))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/clojure/browser/net.cljs",
                                                      :lines [143 144]},
                                             :methods [{:name "open?",
                                                        :signature ["[this]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.net/IWebSocket",
                                             :history [["+"
                                                        "0.0-2911"]]},
           "cljs.core/PersistentArrayMap.fromArrays" {:ns "cljs.core",
                                                      :name "PersistentArrayMap.fromArrays",
                                                      :signature ["[ks vs]"],
                                                      :history [["+"
                                                                 "0.0-1211"]
                                                                ["-"
                                                                 "0.0-1798"]],
                                                      :parent-type "PersistentArrayMap",
                                                      :type "function",
                                                      :full-name-encode "cljs.core_PersistentArrayMapDOTfromArrays",
                                                      :source {:code "(set! cljs.core.PersistentArrayMap/fromArrays\n      (fn [ks vs]\n        (let [len (count ks)]\n          (loop [i   0\n                 out (transient cljs.core.PersistentArrayMap/EMPTY)]\n            (if (< i len)\n              (recur (inc i) (assoc! out (aget ks i) (aget vs i)))\n              (persistent! out))))))",
                                                               :repo "clojurescript",
                                                               :tag "r1586",
                                                               :filename "src/cljs/cljs/core.cljs",
                                                               :lines [3976
                                                                       3983]},
                                                      :full-name "cljs.core/PersistentArrayMap.fromArrays",
                                                      :removed {:in "0.0-1798",
                                                                :last-seen "0.0-1586"}},
           "cljs.core/frequencies" {:description "Returns a map from distinct items in `coll` to the number of times they appear.\n\n`(frequencies [:a :a :b])` => `{:a 2, :b 1}`",
                                    :ns "cljs.core",
                                    :name "frequencies",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/group-by"
                                              "cljs.core/distinct"],
                                    :full-name-encode "cljs.core_frequencies",
                                    :source {:code "(defn frequencies\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7974 7981]},
                                    :full-name "cljs.core/frequencies",
                                    :clj-symbol "clojure.core/frequencies",
                                    :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
           "cljs.core/pop" {:description "For a list, returns a new list without the first item.\n\nFor a vector, returns a new vector without the last item.",
                            :ns "cljs.core",
                            :name "pop",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/peek"
                                      "cljs.core/rest"
                                      "cljs.core/conj"],
                            :full-name-encode "cljs.core_pop",
                            :source {:code "(defn pop\n  [coll]\n  (when-not (nil? coll)\n    (-pop coll)))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1476 1482]},
                            :examples [{:id "6bd9f7",
                                        :content "With vectors:\n\n```clj\n(pop [1 2 3])\n;;=> [1 2]\n\n(pop [1 2])\n;;=> [1]\n\n(pop [1])\n;;=> []\n\n(pop [])\n;; Error: Can't pop empty vector\n```"}
                                       {:id "81221f",
                                        :content "With lists:\n\n```clj\n(pop '(1 2 3))\n;;=> (2 3)\n\n(pop '(1 2))\n;;=> (2)\n\n(pop '(1))\n;;=> ()\n\n(pop '())\n;; Error: Can't pop empty list\n```"}],
                            :full-name "cljs.core/pop",
                            :clj-symbol "clojure.core/pop",
                            :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
           "cljs.repl/with-read-known" {:ns "cljs.repl",
                                        :name "with-read-known",
                                        :signature ["[& body]"],
                                        :history [["+" "0.0-2719"]
                                                  ["-" "0.0-2911"]],
                                        :type "macro",
                                        :full-name-encode "cljs.repl_with-read-known",
                                        :source {:code "(defmacro with-read-known\n  [& body]\n  `(binding [*read-eval* (if (= :unknown *read-eval*) true *read-eval*)]\n     ~@body))",
                                                 :repo "clojurescript",
                                                 :tag "r2850",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [84 89]},
                                        :full-name "cljs.repl/with-read-known",
                                        :docstring "Evaluates body with *read-eval* set to a \"known\" value,\ni.e. substituting true for :unknown if necessary.",
                                        :removed {:in "0.0-2911",
                                                  :last-seen "0.0-2850"}},
           "cljs.core/flatmap" {:ns "cljs.core",
                                :name "flatmap",
                                :signature ["[f]" "[f coll]"],
                                :history [["+" "0.0-2301"]
                                          ["-" "0.0-2341"]],
                                :type "function",
                                :full-name-encode "cljs.core_flatmap",
                                :source {:code "(defn flatmap\n  ([f]\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([result] (f1 result))\n       ([result input]\n          (reduce (preserving-reduced f1) result (f input))))))\n  ([f coll] (sequence (flatmap f) coll)))",
                                         :repo "clojurescript",
                                         :tag "r2322",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8139 8150]},
                                :full-name "cljs.core/flatmap",
                                :docstring "maps f over coll and concatenates the results.  Thus function f\nshould return a collection.  Returns a transducer when no collection\nis provided.",
                                :removed {:in "0.0-2341",
                                          :last-seen "0.0-2322"}},
           "cljs.core/not-every?" {:description "Returns false if `(pred x)` is logical true for every `x` in `coll`, else true.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "not-every?",
                                   :signature ["[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/every?"
                                             "cljs.core/not-any?"
                                             "cljs.core/some"],
                                   :full-name-encode "cljs.core_not-everyQMARK",
                                   :source {:code "(defn ^boolean not-every?\n  [pred coll] (not (every? pred coll)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3304 3307]},
                                   :full-name "cljs.core/not-every?",
                                   :clj-symbol "clojure.core/not-every?",
                                   :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
           "cljs.core/js-invoke" {:description "Invoke JavaScript object `obj` method via string `s`. Needed when the string is\nnot a valid unquoted property name.",
                                  :ns "cljs.core",
                                  :name "js-invoke",
                                  :signature ["[obj s & args]"],
                                  :history [["+" "0.0-2411"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_js-invoke",
                                  :source {:code "(defn js-invoke\n  [obj s & args]\n  (.apply (aget obj s) obj (into-array args)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [223 227]},
                                  :examples [{:id "373cce",
                                              :content "If we have a JavaScript object with an unusual property name:\n\n```js\n// JavaScript\nvar obj = {\n  \"my sum\": function(a,b) { return a+b; }\n};\n```\n\nWe can invoke it from ClojureScript:\n\n```clj\n(js-invoke js/obj \"my sum\" 1 2)\n;=> 3\n```"}],
                                  :full-name "cljs.core/js-invoke",
                                  :docstring "Invoke JavaScript object method via string. Needed when the\nstring is not a valid unquoted property name."},
           "cljs.core/some-fn" {:description "Takes a set of predicate functions and returns a function `f` that returns the\nfirst logical true value returned by one of its composing predicates against any\nof its arguments, else it returns logical false.\n\nNote that `f` is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates.",
                                :ns "cljs.core",
                                :name "some-fn",
                                :signature ["[p]"
                                            "[p1 p2]"
                                            "[p1 p2 p3]"
                                            "[p1 p2 p3 & ps]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/every-pred"
                                          "cljs.core/some"
                                          "cljs.core/or"],
                                :full-name-encode "cljs.core_some-fn",
                                :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3697 3734]},
                                :full-name "cljs.core/some-fn",
                                :clj-symbol "clojure.core/some-fn",
                                :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
           "syntax/vector" {:description "Signifies a literal vector.",
                            :ns "syntax",
                            :name "vector",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/vector"
                                      "cljs.core/vec"],
                            :full-name-encode "syntax_vector",
                            :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                     :repo "tools.reader",
                                     :tag "tools.reader-0.8.10",
                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                     :lines [591 610]},
                            :extra-sources [{:code "(defn- read-vector\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-vector (read-delimited \\] rdr true)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (with-meta the-vector\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [188 203]}],
                            :syntax-form "[]",
                            :examples [{:id "18e143",
                                        :content "```clj\n[1 2 3]\n;;=> [1 2 3]\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#vectors",
                            :full-name "syntax/vector",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.event/remove-all" {:ns "clojure.browser.event",
                                               :name "remove-all",
                                               :type "function",
                                               :signature ["[opt_obj opt_type opt_capt]"],
                                               :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/clojure/browser/event.cljs",
                                                        :lines [100]},
                                               :full-name "clojure.browser.event/remove-all",
                                               :full-name-encode "clojure.browser.event_remove-all",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/doto" {:ns "cljs.core",
                             :name "doto",
                             :signature ["[x & forms]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core_doto",
                             :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [3533 3548]},
                             :full-name "cljs.core/doto",
                             :clj-symbol "clojure.core/doto",
                             :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
           "cljs.core/take-while" {:description "Returns a lazy sequence of successive items from `coll` while `(pred item)`\nreturns true. `pred` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                                   :ns "cljs.core",
                                   :name "take-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/drop-while"
                                             "cljs.core/split-with"],
                                   :full-name-encode "cljs.core_take-while",
                                   :source {:code "(defn take-while\n  ([pred]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (if (pred input)\n              (rf result input)\n              (reduced result))))))\n  ([pred coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (when (pred (first s))\n           (cons (first s) (take-while pred (rest s))))))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7744 7761]},
                                   :full-name "cljs.core/take-while",
                                   :clj-symbol "clojure.core/take-while",
                                   :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "cljs.repl/evaluate-form" {:ns "cljs.repl",
                                      :name "evaluate-form",
                                      :signature ["[repl-env env filename form]"
                                                  "[repl-env env filename form wrap]"
                                                  "[repl-env env filename form wrap opts]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl_evaluate-form",
                                      :source {:code "(defn evaluate-form\n  ([repl-env env filename form]\n    (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n    (evaluate-form repl-env env filename form wrap *repl-opts*))\n  ([repl-env env filename form wrap opts]\n   (binding [ana/*cljs-file* filename]\n     (let [ast (ana/analyze env form opts)\n           js (comp/emit-str ast)\n           wrap-js\n           ;; TODO: check opts as well - David\n           (if (:source-map repl-env)\n             (binding [comp/*source-map-data*\n                       (atom {:source-map (sorted-map)\n                              :gen-col 0\n                              :gen-line 0})]\n               (let [js (comp/emit-str (ana/no-warn (ana/analyze env (wrap form) opts)))\n                     t (System/currentTimeMillis)]\n                 (str js\n                   \"\\n//# sourceURL=repl-\" t \".js\"\n                   \"\\n//# sourceMappingURL=data:application/json;base64,\"\n                   (DatatypeConverter/printBase64Binary\n                     (.getBytes\n                       (sm/encode\n                         {(str \"repl-\" t \".cljs\")\n                          (:source-map @comp/*source-map-data*)}\n                         {:lines (+ (:gen-line @comp/*source-map-data*) 3)\n                          :file (str \"repl-\" t \".js\")\n                          :sources-content\n                          [(or (:source (meta form))\n                             ;; handle strings / primitives without metadata\n                             (with-out-str (pr form)))]})\n                       \"UTF-8\")))))\n             (comp/emit-str (ana/no-warn (ana/analyze env (wrap form) opts))))]\n       (when (= (:op ast) :ns)\n         (load-dependencies repl-env\n           (into (vals (:requires ast))\n             (distinct (vals (:uses ast))))\n           opts))\n       (when *cljs-verbose*\n         ((:print opts) js))\n       (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n         (case (:status ret)\n           :error (throw\n                    (ex-info (:value ret)\n                      {:type :js-eval-error\n                       :error ret\n                       :repl-env repl-env\n                       :form form}))\n           :exception (throw\n                        (ex-info (:value ret)\n                          {:type :js-eval-exception\n                           :error ret\n                           :repl-env repl-env\n                           :form form\n                           :js js}))\n           :success (:value ret)))))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [333 392]},
                                      :full-name "cljs.repl/evaluate-form",
                                      :docstring "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader."},
           "cljs.reader/escape-char-map" {:ns "cljs.reader",
                                          :name "escape-char-map",
                                          :type "function",
                                          :signature ["[c]"],
                                          :source {:code "(defn escape-char-map [c]\n  (cond\n   (identical? c \\t) \"\\t\"\n   (identical? c \\r) \"\\r\"\n   (identical? c \\n) \"\\n\"\n   (identical? c \\\\) \\\\\n   (identical? c \\\") \\\"\n   (identical? c \\b) \"\\b\"\n   (identical? c \\f) \"\\f\"\n   :else nil))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [152 161]},
                                          :full-name "cljs.reader/escape-char-map",
                                          :full-name-encode "cljs.reader_escape-char-map",
                                          :history [["+" "0.0-927"]]},
           "clojure.browser.event/all-listeners" {:ns "clojure.browser.event",
                                                  :name "all-listeners",
                                                  :type "function",
                                                  :signature ["[obj type capture]"],
                                                  :source {:code "(defn all-listeners [obj type capture])",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/cljs/clojure/browser/event.cljs",
                                                           :lines [92]},
                                                  :full-name "clojure.browser.event/all-listeners",
                                                  :full-name-encode "clojure.browser.event_all-listeners",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/ITransientSet" {:ns "cljs.core",
                                      :name "ITransientSet",
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core_ITransientSet",
                                      :source {:code "(defprotocol ITransientSet\n  (^clj -disjoin! [tcoll v]))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [394 395]},
                                      :methods [{:name "-disjoin!",
                                                 :signature ["[tcoll v]"],
                                                 :docstring nil}],
                                      :full-name "cljs.core/ITransientSet",
                                      :clj-symbol "clojure.lang/ITransientSet"},
           "cljs.core/vals" {:description "Returns a sequence of the values in `hash-map`.",
                             :ns "cljs.core",
                             :name "vals",
                             :signature ["[hash-map]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/keys"],
                             :full-name-encode "cljs.core_vals",
                             :source {:code "(defn vals\n  [hash-map]\n  (when-let [mseq (seq hash-map)]\n    (ValSeq. mseq nil)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7302 7306]},
                             :full-name "cljs.core/vals",
                             :clj-symbol "clojure.core/vals",
                             :docstring "Returns a sequence of the map's values."},
           "cljs.core/IDeref" {:ns "cljs.core",
                               :name "IDeref",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core_IDeref",
                               :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [312 313]},
                               :methods [{:name "-deref",
                                          :signature ["[o]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IDeref",
                               :clj-symbol "clojure.lang/IDeref"},
           "cljs.build.api/parse-js-ns" {:ns "cljs.build.api",
                                         :name "parse-js-ns",
                                         :signature ["[f]"],
                                         :history [["+" "0.0-2629"]],
                                         :type "function",
                                         :full-name-encode "cljs.build.api_parse-js-ns",
                                         :source {:code "(defn parse-js-ns\n  [f]\n  (closure/parse-js-ns f))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/build/api.clj",
                                                  :lines [73 78]},
                                         :full-name "cljs.build.api/parse-js-ns",
                                         :docstring "Given a Google Closure style JavaScript file or resource return the namespace\ninformation for the given file. Only returns the value extracted from the\nfirst provide statement."},
           "cljs.core/string-hash-cache" {:ns "cljs.core",
                                          :name "string-hash-cache",
                                          :type "var",
                                          :source {:code "(def string-hash-cache (js-obj))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [513]},
                                          :full-name "cljs.core/string-hash-cache",
                                          :full-name-encode "cljs.core_string-hash-cache",
                                          :history [["+" "0.0-1424"]]},
           "cljs.core/array-map" {:description "Returns a new array map (a map implemented with arrays) with the supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                  :ns "cljs.core",
                                  :name "array-map",
                                  :signature ["[& keyvals]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :related ["cljs.core/assoc"
                                            "cljs.core/hash-map"
                                            "cljs.core/sorted-map"],
                                  :full-name-encode "cljs.core_array-map",
                                  :source {:code "(defn array-map\n  [& keyvals]\n  (.fromArray cljs.core/PersistentArrayMap (apply array keyvals) true false))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [7139 7143]},
                                  :extra-sources ({:code "(defmacro array-map\n  ([] '(.-EMPTY cljs.core/PersistentArrayMap))\n  ([& kvs]\n     (let [keys (map first (partition 2 kvs))]\n       (if (core/and (every? #(= (:op %) :constant)\n                       (map #(cljs.analyzer/analyze &env %) keys))\n                     (= (count (into #{} keys)) (count keys)))\n         `(cljs.core/PersistentArrayMap. nil ~(clojure.core// (count kvs) 2) (array ~@kvs) nil)\n         `(.fromArray cljs.core/PersistentArrayMap (array ~@kvs) true false)))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [1430 1438]}),
                                  :examples [{:id "198026",
                                              :content "```clj\n(array-map :a 10)\n;;=> {:a 10}\n\n(array-map :a 10 :b 20)\n;;=> {:a 10 :b 20}\n```"}],
                                  :full-name "cljs.core/array-map",
                                  :clj-symbol "clojure.core/array-map",
                                  :docstring "keyval => key val\nReturns a new array map with supplied mappings."},
           "clojure.browser.dom/log-obj" {:ns "clojure.browser.dom",
                                          :name "log-obj",
                                          :type "function",
                                          :signature ["[obj]"],
                                          :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [23 24]},
                                          :full-name "clojure.browser.dom/log-obj",
                                          :full-name-encode "clojure.browser.dom_log-obj",
                                          :history [["+" "0.0-927"]]},
           "cljs.nodejs/enable-util-print!" {:ns "cljs.nodejs",
                                             :name "enable-util-print!",
                                             :type "function",
                                             :signature ["[]"],
                                             :source {:code "(defn enable-util-print! []\n  (set! *print-newline* false)\n  (set! *print-fn*\n    (fn [& args]\n      (.apply (.-log js/console) js/console (into-array args)))))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/nodejs.cljs",
                                                      :lines [18 22]},
                                             :full-name "cljs.nodejs/enable-util-print!",
                                             :full-name-encode "cljs.nodejs_enable-util-printBANG",
                                             :history [["+"
                                                        "0.0-2156"]]},
           "cljs.core/for" {:description "List comprehension.\n\nTakes a vector of one or more binding-form/collection-expr pairs, each followed\nby zero or more modifiers, and yields a lazy sequence of evaluations of expr.\n\nCollections are iterated in a nested fashion, rightmost fastest, and nested\ncoll-exprs can refer to bindings created in prior binding-forms. Supported\nmodifiers are: `:let [binding-form expr ...]`, `:while test`, `:when test`.",
                            :ns "cljs.core",
                            :name "for",
                            :signature ["[seq-exprs body-expr]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/doseq"
                                      "cljs.core/doall"
                                      "special/recur"],
                            :full-name-encode "cljs.core_for",
                            :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (core/keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (ex-info (apply core/str msg) {})))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (core/cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (core/keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_ \"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                            (loop [~gxs ~gxs]\n                              (when-first [~bind ~gxs]\n                                ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (core/cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (core/keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# ^not-native (chunk-first ~gxs)\n                                           size# (count c#)\n                                           ~gb (chunk-buffer size#)]\n                                       (if (coercive-boolean\n                                            (loop [~gi 0]\n                                              (if (< ~gi size#)\n                                                (let [~bind (-nth c# ~gi)]\n                                                  ~(do-cmod mod-pairs))\n                                                true)))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [1254 1339]},
                            :extra-sources ({:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce1 (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                             (loop [~gxs ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (chunk-buffer size#)]\n                                       (if (loop [~gi (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [~bind (.nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))",
                                             :repo "clojure",
                                             :tag "clojure-1.6.0",
                                             :filename "src/clj/clojure/core.clj",
                                             :lines [4254 4339]}),
                            :full-name "cljs.core/for",
                            :clj-symbol "clojure.core/for",
                            :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
           "syntax/inst-literal" {:ns "syntax",
                                  :name "inst-literal",
                                  :history [["+" "0.0-1424"]],
                                  :type "tagged literal",
                                  :full-name-encode "syntax_inst-literal",
                                  :source {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/tagged_literals.clj",
                                           :lines [44 48]},
                                  :extra-sources [{:code "(defn read-inst\n  [form]\n  (when-not (string? form)\n    (throw (RuntimeException. \"Instance literal expects a string for its timestamp.\")))\n  (try\n    (inst/read-instant-date form)\n    (catch Throwable e\n      (throw (RuntimeException. (.getMessage e))))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [19 26]}],
                                  :syntax-form "#inst \"\"",
                                  :edn-doc "https://github.com/edn-format/edn#inst-rfc-3339-format",
                                  :full-name "syntax/inst-literal",
                                  :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.6.0/src/clj/clojure/core.clj#L6947"},
           "cljs.core/unchecked-multiply-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-multiply-int",
                                               :signature ["[]"
                                                           "[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_unchecked-multiply-int",
                                               :source {:code "(defn ^number unchecked-multiply-int\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply-int x y))\n  ([x y & more] (reduce unchecked-multiply-int (cljs.core/unchecked-multiply-int x y) more)))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [1999
                                                                2004]},
                                               :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-multiply-int\n  ([& xs] `(* ~@xs)))",
                                                                :repo "clojurescript",
                                                                :tag "r2911",
                                                                :filename "src/clj/cljs/core.clj",
                                                                :lines [396
                                                                        397]}),
                                               :full-name "cljs.core/unchecked-multiply-int",
                                               :clj-symbol "clojure.core/unchecked-multiply-int",
                                               :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/cond->" {:description "Takes an expression and a set of test/form pairs. Threads `expr` (via `->`)\nthrough each form for which the corresponding test expression is true.\n\nNote that, unlike `cond` branching, `cond->` threading does not short circuit\nafter the first true test expression.",
                               :ns "cljs.core",
                               :name "cond->",
                               :signature ["[expr & clauses]"],
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :related ["cljs.core/->"
                                         "cljs.core/->>"
                                         "cljs.core/cond->>"
                                         "cljs.core/cond"],
                               :full-name-encode "cljs.core_cond-GT",
                               :source {:code "(defmacro cond->\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (-> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                        :repo "clojure",
                                        :tag "clojure-1.6.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [6885 6897]},
                               :examples [{:id "f08338",
                                           :content "```clj\n(def a 12)\n(cond-> a\n  (> a 10) (str \" is greater than 10\")\n  (< a 20) (str \" and less than 20\"))\n;;=> \"12 is greater than 10 and less than 20\"\n```"}],
                               :full-name "cljs.core/cond->",
                               :clj-symbol "clojure.core/cond->",
                               :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->)\nthrough each form for which the corresponding test\nexpression is true. Note that, unlike cond branching, cond-> threading does\nnot short circuit after the first true test expression."},
           "cljs.repl/load-stream" {:ns "cljs.repl",
                                    :name "load-stream",
                                    :type "function",
                                    :signature ["[repl-env filename res]"],
                                    :source {:code "(defn load-stream [repl-env filename res]\n  (let [env (ana/empty-env)]\n    (doseq [form (ana/forms-seq res filename)]\n      (let [env (assoc env :ns (ana/get-namespace ana/*cljs-ns*))]\n        (evaluate-form repl-env env filename form)))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [394 398]},
                                    :full-name "cljs.repl/load-stream",
                                    :full-name-encode "cljs.repl_load-stream",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/instance?" {:description "Returns true if `o` is an instance of type `t`, false otherwise.",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "instance?",
                                  :signature ["[t o]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/type"],
                                  :full-name-encode "cljs.core_instanceQMARK",
                                  :source {:code "(defn ^boolean instance? [t o]\n  (cljs.core/instance? t o))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [573 574]},
                                  :extra-sources ({:code "(defmacro instance? [t o]\n  ;; Google Closure warns about some references to RegExp, so\n  ;; (instance? RegExp ...) needs to be inlined, but the expansion\n  ;; should preserve the order of argument evaluation.\n  (bool-expr (if (clojure.core/symbol? t)\n               (core/list 'js* \"(~{} instanceof ~{})\" o t)\n               `(let [t# ~t o# ~o]\n                  (~'js* \"(~{} instanceof ~{})\" o# t#)))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [322 329]}),
                                  :full-name "cljs.core/instance?",
                                  :clj-symbol "clojure.core/instance?"},
           "cljs.core/ValSeq" {:ns "cljs.core",
                               :name "ValSeq",
                               :signature ["[mseq _meta]"],
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core_ValSeq",
                               :source {:code "(deftype ValSeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta] (ValSeq. mseq new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-val me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (ValSeq. nseq _meta)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (ValSeq. nseq _meta))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7245 7298]},
                               :full-name "cljs.core/ValSeq",
                               :clj-symbol "clojure.lang/ValSeq"},
           "cljs.core/rseq" {:description "Returns a sequence of the items in `coll` in reverse order in constant time.\n\nReturns nil if `coll` is empty.\n\n`coll` must be a vector or a sorted-map.",
                             :return-type seq,
                             :ns "cljs.core",
                             :name "rseq",
                             :signature ["[coll]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/reverse"],
                             :full-name-encode "cljs.core_rseq",
                             :source {:code "(defn ^seq rseq [coll]\n  (-rseq coll))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2394 2395]},
                             :full-name "cljs.core/rseq",
                             :clj-symbol "clojure.core/rseq"},
           "cljs.core/PersistentVector.EMPTY_NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY_NODE",
                                                    :history [["+"
                                                               "0.0-1006"]
                                                              ["-"
                                                               "0.0-2301"]],
                                                    :parent-type "PersistentVector",
                                                    :type "var",
                                                    :full-name-encode "cljs.core_PersistentVectorDOTEMPTY_NODE",
                                                    :source {:code "(set! cljs.core.PersistentVector.EMPTY_NODE (VectorNode. nil (make-array 32)))",
                                                             :repo "clojurescript",
                                                             :tag "r2280",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [3667]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY_NODE",
                                                    :removed {:in "0.0-2301",
                                                              :last-seen "0.0-2280"}},
           "cljs.repl/repl-prompt" {:ns "cljs.repl",
                                    :name "repl-prompt",
                                    :type "function",
                                    :signature ["[]"],
                                    :source {:code "(defn repl-prompt []\n  (print (str \"ClojureScript:\" ana/*cljs-ns* \"> \")))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [555 556]},
                                    :full-name "cljs.repl/repl-prompt",
                                    :full-name-encode "cljs.repl_repl-prompt",
                                    :history [["+" "0.0-2911"]]},
           "cljs.reader/read-comment" {:ns "cljs.reader",
                                       :name "read-comment",
                                       :type "var",
                                       :source {:code "(def read-comment skip-line)",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [268]},
                                       :full-name "cljs.reader/read-comment",
                                       :full-name-encode "cljs.reader_read-comment",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl.node/socket" {:ns "cljs.repl.node",
                                    :name "socket",
                                    :type "function",
                                    :signature ["[host port]"],
                                    :source {:code "(defn socket [host port]\n  (let [socket (Socket. host port)\n        in     (io/reader socket)\n        out    (io/writer socket)]\n    {:socket socket :in in :out out}))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl/node.clj",
                                             :lines [23 27]},
                                    :full-name "cljs.repl.node/socket",
                                    :full-name-encode "cljs.repl.node_socket",
                                    :history [["+" "0.0-2629"]]},
           "cljs.core/ITransientMap" {:ns "cljs.core",
                                      :name "ITransientMap",
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core_ITransientMap",
                                      :source {:code "(defprotocol ITransientMap\n  (^clj -dissoc! [tcoll key]))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [387 388]},
                                      :methods [{:name "-dissoc!",
                                                 :signature ["[tcoll key]"],
                                                 :docstring nil}],
                                      :full-name "cljs.core/ITransientMap",
                                      :clj-symbol "clojure.lang/ITransientMap"},
           "cljs.core/*loaded-libs*" {:ns "cljs.core",
                                      :name "*loaded-libs*",
                                      :type "dynamic var",
                                      :source {:code "(defonce ^:dynamic *loaded-libs* nil)",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [40]},
                                      :full-name "cljs.core/*loaded-libs*",
                                      :full-name-encode "cljs.core_STARloaded-libsSTAR",
                                      :history [["+" "0.0-2655"]]},
           "cljs.reader/read-number" {:ns "cljs.reader",
                                      :name "read-number",
                                      :type "function",
                                      :signature ["[reader initch]"],
                                      :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (macros ch))\n      (do\n        (unread reader ch)\n        (let [s (.toString buffer)]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [281 291]},
                                      :full-name "cljs.reader/read-number",
                                      :full-name-encode "cljs.reader_read-number",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/ILookup" {:ns "cljs.core",
                                :name "ILookup",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_ILookup",
                                :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [286 287]},
                                :methods [{:name "-lookup",
                                           :signature ["[o k]"
                                                       "[o k not-found]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ILookup",
                                :clj-symbol "clojure.lang/ILookup"},
           "cljs.core/when" {:description "Evaluates `test`. If logical true, evaluates `body` in an implicit `do`.\n\n`when` is often used instead of `if` for conditions that do not have an \"else\".",
                             :ns "cljs.core",
                             :name "when",
                             :signature ["[test & body]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/when-not"
                                       "cljs.core/when-let"
                                       "special/if"],
                             :full-name-encode "cljs.core_when",
                             :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [471 475]},
                             :full-name "cljs.core/when",
                             :clj-symbol "clojure.core/when",
                             :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
           "cljs.core/ArrayNodeSeq" {:ns "cljs.core",
                                     :name "ArrayNodeSeq",
                                     :type "type",
                                     :signature ["[meta nodes i s __hash]"],
                                     :source {:code "(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (ArrayNodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll] (create-array-node-seq nil nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6151 6186]},
                                     :full-name "cljs.core/ArrayNodeSeq",
                                     :full-name-encode "cljs.core_ArrayNodeSeq",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/list?" {:description "Returns true if `x` is a list, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "list?",
                              :signature ["[x]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :related ["cljs.core/seq?"
                                        "cljs.core/sequential?"
                                        "cljs.core/coll?"],
                              :full-name-encode "cljs.core_listQMARK",
                              :source {:code "(defn ^boolean list? [x]\n  (satisfies? IList x))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2476 2477]},
                              :full-name "cljs.core/list?",
                              :clj-symbol "clojure.core/list?"},
           "cljs.core/val" {:description "Returns the value in the map entry.",
                            :ns "cljs.core",
                            :name "val",
                            :signature ["[map-entry]"],
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :related ["cljs.core/vals"],
                            :full-name-encode "cljs.core_val",
                            :source {:code "(defn val\n  [map-entry]\n  (-val map-entry))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [7308 7311]},
                            :full-name "cljs.core/val",
                            :clj-symbol "clojure.core/val",
                            :docstring "Returns the value in the map entry."},
           "clojure.browser.dom/set-value" {:ns "clojure.browser.dom",
                                            :name "set-value",
                                            :signature ["[e v]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom_set-value",
                                            :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [142 145]},
                                            :full-name "clojure.browser.dom/set-value",
                                            :docstring "Set the value property for an element."},
           "cljs.repl.browser/read-get" {:ns "cljs.repl.browser",
                                         :name "read-get",
                                         :signature ["[line rdr]"],
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser_read-get",
                                         :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [154 159]},
                                         :full-name "cljs.repl.browser/read-get",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/BitmapIndexedNode" {:ns "cljs.core",
                                          :name "BitmapIndexedNode",
                                          :signature ["[edit bitmap arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_BitmapIndexedNode",
                                          :source {:code "(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc (.-EMPTY BitmapIndexedNode)\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (== bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (key-test key key-or-nil)\n                (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))\n                :else inode)))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)  (.inode-lookup val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil) val-or-node\n                :else not-found)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil)          [key-or-nil val-or-node]\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (== bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (alength earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (< (* 2 n) (alength arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (set! (.-val added-leaf?) true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc! (.-EMPTY BitmapIndexedNode)\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (== bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (key-test key key-or-nil)\n                (do (aset removed-leaf? 0 true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5655 5849]},
                                          :full-name "cljs.core/BitmapIndexedNode",
                                          :clj-symbol "clojure.lang/BitmapIndexedNode"},
           "cljs.repl.node/close-socket" {:ns "cljs.repl.node",
                                          :name "close-socket",
                                          :type "function",
                                          :signature ["[s]"],
                                          :source {:code "(defn close-socket [s]\n  (.close (:in s))\n  (.close (:out s))\n  (.close (:socket s)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/repl/node.clj",
                                                   :lines [29 32]},
                                          :full-name "cljs.repl.node/close-socket",
                                          :full-name-encode "cljs.repl.node_close-socket",
                                          :history [["+" "0.0-2629"]]},
           "cljs.reader/read-past" {:ns "cljs.reader",
                                    :name "read-past",
                                    :signature ["[pred rdr]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader_read-past",
                                    :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [216 223]},
                                    :full-name "cljs.reader/read-past",
                                    :docstring "Read until first character that doesn't match pred, returning\nchar."},
           "cljs.repl.browser/load-javascript" {:ns "cljs.repl.browser",
                                                :name "load-javascript",
                                                :signature ["[repl-env provides url]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser_load-javascript",
                                                :source {:code "(defn load-javascript\n  [repl-env provides url]\n  (let [missing (remove #(contains? @loaded-libs %) provides)]\n    (when (seq missing)\n      (browser-eval (slurp url))\n      (swap! loaded-libs (partial apply conj) missing))))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [183
                                                                 193]},
                                                :full-name "cljs.repl.browser/load-javascript",
                                                :docstring "Accepts a REPL environment, a list of namespaces, and a URL for a\nJavaScript file which contains the implementation for the list of\nnamespaces. Will load the JavaScript file into the REPL environment\nif any of the namespaces have not already been loaded from the\nClojureScript REPL."},
           "cljs.core/to-array" {:ns "cljs.core",
                                 :name "to-array",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_to-array",
                                 :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2760 2768]},
                                 :full-name "cljs.core/to-array",
                                 :clj-symbol "clojure.core/to-array",
                                 :docstring "Naive impl of to-array as a start."},
           "cljs.core/interpose" {:description "Returns a lazy seq of the elements of `coll` separated by `sep`.",
                                  :ns "cljs.core",
                                  :name "interpose",
                                  :signature ["[sep coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/interleave"
                                            "clojure.string/join"],
                                  :full-name-encode "cljs.core_interpose",
                                  :source {:code "(defn interpose\n  ([sep]\n    (fn [rf]\n      (let [started (volatile! false)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if @started\n              (let [sepr (rf result sep)]\n                (if (reduced? sepr)\n                  sepr\n                  (rf sepr input)))\n              (do\n                (vreset! started true)\n                (rf result input))))))))\n  ([sep coll] (drop 1 (interleave (repeat sep) coll))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3916 3933]},
                                  :full-name "cljs.core/interpose",
                                  :clj-symbol "clojure.core/interpose",
                                  :docstring "Returns a lazy seq of the elements of coll separated by sep"},
           "cljs.core/IMapEntry" {:ns "cljs.core",
                                  :name "IMapEntry",
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IMapEntry",
                                  :source {:code "(defprotocol IMapEntry\n  (-key [coll])\n  (-val [coll]))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [298 300]},
                                  :methods [{:name "-key",
                                             :signature ["[coll]"],
                                             :docstring nil}
                                            {:name "-val",
                                             :signature ["[coll]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IMapEntry",
                                  :clj-symbol "clojure.lang/IMapEntry"},
           "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                    :name "ICrossPageChannel",
                                                    :type "protocol",
                                                    :full-name-encode "clojure.browser.net_ICrossPageChannel",
                                                    :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [86
                                                                     87]},
                                                    :methods [{:name "register-service",
                                                               :signature ["[this service-name fn]"
                                                                           "[this service-name fn encode-json?]"],
                                                               :docstring nil}],
                                                    :full-name "clojure.browser.net/ICrossPageChannel",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "special/finally" {:description "`finally` should be the last form inside of a `try` expression. It is optional.\n\n`finally` clauses are always evaluated for their side effects whether there was\nan error or not, but they are never the return value of a `try` expression.",
                              :ns "special",
                              :name "finally",
                              :signature ["[expr*]"],
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :related ["special/try"
                                        "special/catch"
                                        "special/throw"],
                              :full-name-encode "special_finally",
                              :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [606 665]},
                              :full-name "special/finally",
                              :clj-symbol "clojure.core/finally"},
           "cljs.core/Cons" {:ns "cljs.core",
                             :name "Cons",
                             :signature ["[meta first rest __hash]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_Cons",
                             :source {:code "(deftype Cons [meta first rest ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (Cons. meta first rest __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  INext\n  (-next [coll]\n    (if (nil? rest) nil (seq rest)))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll __hash))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n  \n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2419 2464]},
                             :full-name "cljs.core/Cons",
                             :clj-symbol "clojure.lang/Cons"},
           "cljs.core/re-find" {:description "Returns the first regex match, if any, of `s` to `re`, using `re.exec(s)`.\n\nReturns a vector, containing first the matching substring, then any capturing\ngroups if the regular expression contains capturing groups.",
                                :ns "cljs.core",
                                :name "re-find",
                                :signature ["[re s]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_re-find",
                                :source {:code "(defn re-find\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when-not (nil? matches)\n        (if (== (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. \"re-find must match against a string.\"))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8077 8089]},
                                :full-name "cljs.core/re-find",
                                :clj-symbol "clojure.core/re-find",
                                :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
           "cljs.core/IMeta" {:ns "cljs.core",
                              :name "IMeta",
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core_IMeta",
                              :source {:code "(defprotocol IMeta\n  (^clj-or-nil -meta [o]))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [318 319]},
                              :methods [{:name "-meta",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IMeta",
                              :clj-symbol "clojure.lang/IMeta"},
           "cljs.core/js-str" {:description "Convert `s` to string using JavaScript's coercion behavior.\n\nEquivalent to `''+s` in JavaScript.",
                               :ns "cljs.core",
                               :name "js-str",
                               :signature ["[s]"],
                               :history [["+" "0.0-2341"]],
                               :type "macro",
                               :related ["cljs.core/str"],
                               :full-name-encode "cljs.core_js-str",
                               :source {:code "(defmacro js-str [s]\n  (core/list 'js* \"''+~{}\" s))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [1667 1668]},
                               :examples [{:id "e92009",
                                           :content "```clj\n(js-str 23)\n;;=> \"23\"\n\n(js-str #js {:foo 1})\n;;=> \"[Object object]\"\n```"}],
                               :full-name "cljs.core/js-str"},
           "cljs.repl/repl*" {:ns "cljs.repl",
                              :name "repl*",
                              :type "function",
                              :signature ["[repl-env {:keys [init need-prompt prompt flush read eval print caught reader print-no-newline source-map-inline], :or {caught repl-caught, eval eval-cljs, print-no-newline print, flush flush, read repl-read, init (fn* [] ()), print println, source-map-inline true, prompt repl-prompt, reader (fn* [] (readers/source-logging-push-back-reader (PushbackReader. (io/reader *in*)) 1 \"NO_SOURCE_FILE\")), need-prompt (fn* [] (if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)))}, :as opts}]"],
                              :source {:code "(defn repl*\n  [repl-env {:keys [init need-prompt prompt flush read eval print caught reader print-no-newline source-map-inline]\n             :or {init #()\n                  need-prompt #(if (readers/indexing-reader? *in*)\n                                 (== (readers/get-column-number *in*) 1)\n                                 (identity true))\n                  prompt repl-prompt\n                  flush flush\n                  read repl-read\n                  eval eval-cljs\n                  print println\n                  caught repl-caught\n                  reader #(readers/source-logging-push-back-reader\n                           (PushbackReader. (io/reader *in*))\n                           1 \"NO_SOURCE_FILE\")\n                  print-no-newline print\n                  source-map-inline true}\n             :as opts}]\n  (print \"To quit, type:\" :cljs/quit)\n  (let [ups-deps (cljsc/get-upstream-deps)\n        {:keys [analyze-path repl-verbose warn-on-undeclared special-fns static-fns] :as opts\n         :or   {warn-on-undeclared true}}\n        (assoc (merge (-repl-options repl-env) opts)\n          :init init\n          :need-prompt prompt\n          :flush flush\n          :read read\n          :print print\n          :caught caught\n          :reader reader\n          :print-no-newline print-no-newline\n          :source-map-inline source-map-inline\n          :ups-libs (:libs ups-deps)\n          :ups-foreign-libs (:foreign-libs ups-deps))]\n    (env/with-compiler-env\n     (or (::env/compiler repl-env) (env/default-compiler-env opts))\n     (binding [ana/*cljs-ns* 'cljs.user\n               *cljs-verbose* repl-verbose\n               ana/*cljs-warnings*\n               (assoc ana/*cljs-warnings*\n                 :unprovided warn-on-undeclared\n                 :undeclared-var warn-on-undeclared\n                 :undeclared-ns warn-on-undeclared\n                 :undeclared-ns-form warn-on-undeclared)\n               ana/*cljs-static-fns* static-fns\n               *repl-opts* opts]\n       ;; TODO: the follow should become dead code when the REPL is\n       ;; sufficiently enhanced to understand :cache-analysis - David\n       (let [env {:context :expr :locals {}}\n             special-fns (merge default-special-fns special-fns)\n             is-special-fn? (set (keys special-fns))\n             request-prompt (Object.)\n             request-exit (Object.)\n             opts (try\n                    (if-let [merge-opts (:merge-opts (-setup repl-env opts))]\n                      (merge opts merge-opts)\n                      opts)\n                    (catch Throwable e\n                      (caught e repl-env opts)\n                      opts))\n             read-eval-print\n             (fn []\n               (let [input (binding [*ns* (create-ns ana/*cljs-ns*)\n                                     reader/*data-readers* tags/*cljs-data-readers*\n                                     reader/*alias-map*\n                                     (apply merge\n                                       ((juxt :requires :require-macros)\n                                         (ana/get-namespace ana/*cljs-ns*)))]\n                             (repl-read request-prompt request-exit))]\n                 (or ({request-exit request-exit\n                       :cljs/quit request-exit\n                       request-prompt request-prompt} input)\n                   (if (and (seq? input) (is-special-fn? (first input)))\n                     (do\n                       ((get special-fns (first input)) repl-env env input opts)\n                       (print nil))\n                     (let [value (eval repl-env env input opts)]\n                       (print value))))))]\n         (comp/with-core-cljs opts\n           (fn []\n             (try\n               (when analyze-path\n                 (analyze-source analyze-path opts))\n               (evaluate-form repl-env env \"<cljs repl>\"\n                 (with-meta\n                   '(ns cljs.user\n                      (:require [cljs.repl :refer-macros [doc]]))\n                   {:line 1 :column 1})\n                 identity opts)\n               (catch Throwable e\n                 (caught e repl-env opts)))\n             (when-let [src (:watch opts)]\n               (future\n                 (let [log-file (io/file (util/output-directory opts) \"watch.log\")]\n                   (print \"Watch compilation log available at:\" (str log-file))\n                   (try\n                     (binding [*out* (FileWriter. log-file)]\n                       (cljsc/watch src (dissoc opts :watch)))\n                     (catch Throwable e\n                       (caught e repl-env opts))))))\n             (binding [*in* (if (true? (:source-map-inline opts))\n                              *in*\n                              (reader))]\n               (try\n                 (init)\n                 (catch Throwable e\n                   (caught e repl-env opts)))\n               ;; try to let things flush before printing prompt\n               (prompt)\n               (flush)\n               (loop []\n                 (when-not\n                   (try\n                     (identical? (read-eval-print) request-exit)\n                     (catch Throwable e\n                       (caught e repl-env opts)\n                       nil))\n                   (when (need-prompt)\n                     (prompt)\n                     (flush))\n                   (recur)))))))\n         (-tear-down repl-env)))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/clj/cljs/repl.clj",
                                       :lines [575 696]},
                              :full-name "cljs.repl/repl*",
                              :full-name-encode "cljs.repl_replSTAR",
                              :history [["+" "0.0-2629"]]},
           "cljs.test/are" {:ns "cljs.test",
                            :name "are",
                            :signature ["[argv expr & args]"],
                            :history [["+" "0.0-2629"]],
                            :type "macro",
                            :full-name-encode "cljs.test_are",
                            :source {:code "(defmacro are\n  [argv expr & args]\n  (if (or\n        ;; (are [] true) is meaningless but ok\n        (and (empty? argv) (empty? args))\n        ;; Catch wrong number of args\n        (and (pos? (count argv))\n          (pos? (count args))\n          (zero? (mod (count args) (count argv)))))\n    `(clojure.template/do-template ~argv (is ~expr) ~@args)\n    (throw (IllegalArgumentException. \"The number of args doesn't match are's argv.\"))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/test.clj",
                                     :lines [167 189]},
                            :full-name "cljs.test/are",
                            :clj-symbol "clojure.test/are",
                            :docstring "Checks multiple assertions with a template expression.\nSee clojure.template/do-template for an explanation of\ntemplates.\n\nExample: (are [x y] (= x y)  \n              2 (+ 1 1)\n              4 (* 2 2))\nExpands to: \n         (do (is (= 2 (+ 1 1)))\n             (is (= 4 (* 2 2))))\n\nNote: This breaks some reporting features, such as line numbers."},
           "cljs.core/RangeIterator" {:ns "cljs.core",
                                      :name "RangeIterator",
                                      :type "type",
                                      :signature ["[i end step]"],
                                      :source {:code "(deftype RangeIterator [^:mutable i end step]\n  Object\n  (hasNext [_]\n    (if (pos? step)\n      (< i end)\n      (> i end)))\n  (next [_]\n    (let [ret i]\n      (set! i (+ i step))\n      ret)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7799 7808]},
                                      :full-name "cljs.core/RangeIterator",
                                      :full-name-encode "cljs.core_RangeIterator",
                                      :history [["+" "0.0-2371"]]},
           "cljs.core/iterator" {:ns "cljs.core",
                                 :name "iterator",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-2268"]
                                           ["-" "0.0-2371"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_iterator",
                                 :source {:code "(defn iterator [coll]\n  (Iterator. (seq coll)))",
                                          :repo "clojurescript",
                                          :tag "r2356",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4870 4871]},
                                 :full-name "cljs.core/iterator",
                                 :removed {:in "0.0-2371",
                                           :last-seen "0.0-2356"}},
           "cljs.core/assoc-in" {:description "Associates a value in a nested associative structure, where `ks` is a sequence\nof keys and `v` is the new value. Returns a new nested structure.\n\nIf any levels do not exist, hash-maps will be created.",
                                 :ns "cljs.core",
                                 :name "assoc-in",
                                 :signature ["[m [k & ks] v]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/assoc"
                                           "cljs.core/update-in"
                                           "cljs.core/get-in"],
                                 :full-name-encode "cljs.core_assoc-in",
                                 :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4103 4110]},
                                 :examples [{:id "e76f20",
                                             :content "```clj\n(def users [{:name \"James\" :age 26}\n            {:name \"John\" :age 43}])\n```\n\nUpdate the age of the second (index 1) user:\n\n```clj\n(assoc-in users [1 :age] 44)\n;;=> [{:name \"James\", :age 26}\n;;    {:name \"John\", :age 44}]\n```\n\nInsert the password of the second (index 1) user:\n\n```clj\n(assoc-in users [1 :password] \"nhoJ\")\n;;=> [{:name \"James\", :age 26}\n;;    {:password \"nhoJ\", :name \"John\", :age 43}]\n```"}],
                                 :full-name "cljs.core/assoc-in",
                                 :clj-symbol "clojure.core/assoc-in",
                                 :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
           "special/letfn*" {:ns "special",
                             :name "letfn*",
                             :type "special form",
                             :source {:code "(defmethod parse 'letfn*\n  [op env [_ bindings & exprs :as form] name _]\n  (when-not (and (vector? bindings) (even? (count bindings)))\n    (throw (error env \"bindings must be vector of even number of elements\")))\n  (let [n->fexpr (into {} (map (juxt first second) (partition 2 bindings)))\n        names    (keys n->fexpr)\n        context  (:context env)\n        ;; first pass to collect information for recursive references\n        [meth-env bes]\n        (reduce (fn [[{:keys [locals] :as env} bes] n]\n                  (let [ret-tag (-> n meta :tag)\n                        fexpr (no-warn (analyze env (n->fexpr n)))\n                        be (cond->\n                             {:name n\n                              :fn-var true\n                              :line (get-line n env)\n                              :column (get-col n env)\n                              :local true\n                              :shadow (locals n)\n                              :variadic (:variadic fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))\n                              :methods (:methods fexpr)}\n                             ret-tag (assoc :ret-tag ret-tag))]\n                    [(assoc-in env [:locals n] be)\n                     (conj bes be)]))\n                [env []] names)\n        meth-env (assoc meth-env :context :expr)\n        ;; the real pass\n        [meth-env bes]\n        (reduce (fn [[meth-env bes] {:keys [name shadow] :as be}]\n                  (let [env (assoc-in meth-env [:locals name] shadow)\n                        fexpr (analyze env (n->fexpr name))\n                        be' (assoc be\n                              :init fexpr\n                              :variadic (:variadic fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))\n                              :methods (:methods fexpr))]\n                    [(assoc-in env [:locals name] be')\n                     (conj bes be')]))\n          [meth-env []] bes)\n        expr (analyze (assoc meth-env :context (if (= :expr context) :return context)) `(do ~@exprs))]\n    {:env env :op :letfn :bindings bes :expr expr :form form\n     :children (conj (vec (map :init bes)) expr)}))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/clj/cljs/analyzer.clj",
                                      :lines [876 920]},
                             :full-name "special/letfn*",
                             :full-name-encode "special_letfnSTAR",
                             :history [["+" "0.0-1236"]]},
           "clojure.string/join" {:description "Returns a string of all elements in `coll`, as returned by `(seq coll)`,\nseparated by an optional separator.",
                                  :ns "clojure.string",
                                  :name "join",
                                  :signature ["[coll]"
                                              "[separator coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string_join",
                                  :source {:code "(defn join\n  ([coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if coll\n       (recur (. sb (append (str (first coll)))) (next coll))\n       (.toString sb))))\n  ([separator coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if coll\n       (do\n         (. sb (append (str (first coll))))\n         (let [coll (next coll)]\n           (when-not (nil? coll)\n             (. sb (append separator)))\n           (recur sb coll)))\n       (.toString sb)))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [49 66]},
                                  :full-name "clojure.string/join",
                                  :clj-symbol "clojure.string/join",
                                  :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
           "cljs.core/*unchecked-if*" {:ns "cljs.core",
                                       :name "*unchecked-if*",
                                       :type "var",
                                       :source {:code "(def *unchecked-if* false)",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [18]},
                                       :full-name "cljs.core/*unchecked-if*",
                                       :full-name-encode "cljs.core_STARunchecked-ifSTAR",
                                       :history [["+" "0.0-1211"]]},
           "cljs.core/some?" {:description "Returns true if `x` is not nil, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "some?",
                              :signature ["[x]"],
                              :history [["+" "0.0-2261"]],
                              :type "function",
                              :related ["cljs.core/true?"
                                        "cljs.core/nil?"],
                              :full-name-encode "cljs.core_someQMARK",
                              :source {:code "(defn ^boolean some?\n  [x] (not (nil? x)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [104 106]},
                              :full-name "cljs.core/some?",
                              :clj-symbol "clojure.core/some?",
                              :docstring "Returns true if x is not nil, false otherwise."},
           "cljs.core/seqable?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "seqable?",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_seqableQMARK",
                                 :source {:code "(defn ^boolean seqable?\n  [s]\n  (satisfies? ISeqable s))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1603 1606]},
                                 :full-name "cljs.core/seqable?",
                                 :docstring "Return true if s satisfies ISeqable"},
           "clojure.zip/rights" {:ns "clojure.zip",
                                 :name "rights",
                                 :signature ["[loc]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_rights",
                                 :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [92 95]},
                                 :full-name "clojure.zip/rights",
                                 :clj-symbol "clojure.zip/rights",
                                 :docstring "Returns a seq of the right siblings of this loc"},
           "cljs.core/split-at" {:description "Returns a vector of `[(take n coll) (drop n coll)]`.",
                                 :ns "cljs.core",
                                 :name "split-at",
                                 :signature ["[n coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/split-with"
                                           "clojure.string/split"],
                                 :full-name-encode "cljs.core_split-at",
                                 :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3876 3879]},
                                 :full-name "cljs.core/split-at",
                                 :clj-symbol "clojure.core/split-at",
                                 :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
           "clojure.zip/append-child" {:ns "clojure.zip",
                                       :name "append-child",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_append-child",
                                       :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [200 204]},
                                       :full-name "clojure.zip/append-child",
                                       :clj-symbol "clojure.zip/append-child",
                                       :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
           "cljs.core/binding" {:description "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit `do`, then\nre-establishes the bindings that existed before.\n\nThe new bindings are made in parallel (unlike `let`); all init-exprs are\nevaluated before the vars are bound to their new values.",
                                :ns "cljs.core",
                                :name "binding",
                                :signature ["[bindings & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/let"],
                                :full-name-encode "cljs.core_binding",
                                :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)]\n    (cljs.analyzer/confirm-bindings &env names)\n    `(with-redefs ~bindings ~@body)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1126 1137]},
                                :examples [{:id "7dd17f",
                                            :content "```clj\n(def ^:dynamic *foo* 1)\n\n(defn do-something []\n  (println *foo*))\n\n(binding [*foo* 2]\n  (do-something))\n;;=> prints 2\n\n*foo*\n;;=> 1\n```"}],
                                :full-name "cljs.core/binding",
                                :clj-symbol "clojure.core/binding",
                                :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
           "cljs.test/get-current-env" {:ns "cljs.test",
                                        :name "get-current-env",
                                        :type "function",
                                        :signature ["[]"],
                                        :source {:code "(defn get-current-env []\n  (or *current-env* (empty-env)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/test.cljs",
                                                 :lines [261 262]},
                                        :full-name "cljs.test/get-current-env",
                                        :full-name-encode "cljs.test_get-current-env",
                                        :history [["+" "0.0-2496"]]},
           "cljs.core/Set" {:ns "cljs.core",
                            :name "Set",
                            :signature ["[meta hash-map]"],
                            :history [["+" "0.0-927"]
                                      ["-" "0.0-1211"]],
                            :type "type",
                            :full-name-encode "cljs.core_Set",
                            :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2659 2706]},
                            :full-name "cljs.core/Set",
                            :removed {:in "0.0-1211",
                                      :last-seen "0.0-1011"}},
           "cljs.core/sorted-map" {:description "Returns a new sorted map with supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                   :ns "cljs.core",
                                   :name "sorted-map",
                                   :signature ["[& keyvals]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/sorted-map-by"
                                             "cljs.core/subseq"
                                             "cljs.core/rsubseq"
                                             "cljs.core/sorted-set"
                                             "cljs.core/array-map"
                                             "cljs.core/hash-map"],
                                   :full-name-encode "cljs.core_sorted-map",
                                   :source {:code "(defn sorted-map\n  ([& keyvals]\n     (loop [in (seq keyvals) out (.-EMPTY PersistentTreeMap)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7158 7165]},
                                   :full-name "cljs.core/sorted-map",
                                   :clj-symbol "clojure.core/sorted-map",
                                   :docstring "keyval => key val\nReturns a new sorted map with supplied mappings."},
           "cljs.reader/macro-terminating?" {:return-type boolean,
                                             :ns "cljs.reader",
                                             :name "macro-terminating?",
                                             :signature ["[ch]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.reader_macro-terminatingQMARK",
                                             :source {:code "(defn ^boolean macro-terminating? [ch]\n  (and (not (identical? ch \"#\"))\n       (not (identical? ch \\'))\n       (not (identical? ch \":\"))\n       (macros ch)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/reader.cljs",
                                                      :lines [73 77]},
                                             :full-name "cljs.reader/macro-terminating?"},
           "cljs.test/join-fixtures" {:ns "cljs.test",
                                      :name "join-fixtures",
                                      :signature ["[fixtures]"],
                                      :history [["+" "0.0-2496"]],
                                      :type "function",
                                      :full-name-encode "cljs.test_join-fixtures",
                                      :source {:code "(defn join-fixtures\n  [fixtures]\n  (reduce compose-fixtures default-fixture fixtures))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/test.cljs",
                                               :lines [482 488]},
                                      :full-name "cljs.test/join-fixtures",
                                      :clj-symbol "clojure.test/join-fixtures",
                                      :docstring "Composes a collection of fixtures, in order.  Always returns a valid\nfixture function, even if the collection is empty.\n\nNOTE: Incompatible with map fixtures."},
           "cljs.core/prefers" {:ns "cljs.core",
                                :name "prefers",
                                :signature ["[multifn]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_prefers",
                                :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [9154 9156]},
                                :full-name "cljs.core/prefers",
                                :clj-symbol "clojure.core/prefers",
                                :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
           "cljs.test/assert-predicate" {:ns "cljs.test",
                                         :name "assert-predicate",
                                         :signature ["[msg form]"],
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test_assert-predicate",
                                         :source {:code "(defn assert-predicate\n  [msg form]\n  (let [args (rest form)\n        pred (first form)]\n    `(let [values# (list ~@args)\n           result# (apply ~pred values#)]\n       (if result#\n         (cljs.test/do-report\n           {:type :pass, :message ~msg,\n            :expected '~form, :actual (cons ~pred values#)})\n         (cljs.test/do-report\n           {:type :fail, :message ~msg,\n            :expected '~form, :actual (list '~'not (cons '~pred values#))}))\n       result#)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/test.clj",
                                                  :lines [24 42]},
                                         :full-name "cljs.test/assert-predicate",
                                         :clj-symbol "clojure.test/assert-predicate",
                                         :docstring "Returns generic assertion code for any functional predicate.  The\n'expected' argument to 'report' will contains the original form, the\n'actual' argument will contain the form with all its sub-forms\nevaluated.  If the predicate returns false, the 'actual' form will\nbe wrapped in (not...)."},
           "cljs.core/vary-meta" {:description "Returns an object of the same type and value as `obj`, with\n`(apply f (meta obj) args)` as its metadata.",
                                  :ns "cljs.core",
                                  :name "vary-meta",
                                  :signature ["[obj f & args]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/alter-meta!"
                                            "cljs.core/with-meta"],
                                  :full-name-encode "cljs.core_vary-meta",
                                  :source {:code "(defn vary-meta\n  ([obj f]\n   (with-meta obj (f (meta obj))))\n  ([obj f a]\n   (with-meta obj (f (meta obj) a)))\n  ([obj f a b]\n   (with-meta obj (f (meta obj) a b)))\n  ([obj f a b c]\n   (with-meta obj (f (meta obj) a b c)))\n  ([obj f a b c d]\n   (with-meta obj (f (meta obj) a b c d)))\n  ([obj f a b c d & args]\n   (with-meta obj (apply f (meta obj) a b c d args))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3035 3049]},
                                  :examples [{:id "8cca62",
                                              :content "```clj\n(def a ^:foo [1 2 3])\n(def b (vary-meta a assoc :bar true))\n\n(= a b)\n;;=> true\n\n(meta a)\n;;=> {:foo true}\n\n(meta b)\n;;=> {:foo true, :bar true}\n```"}],
                                  :full-name "cljs.core/vary-meta",
                                  :clj-symbol "clojure.core/vary-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
           "cljs.core/unchecked-add" {:return-type number,
                                      :ns "cljs.core",
                                      :name "unchecked-add",
                                      :signature ["[]"
                                                  "[x]"
                                                  "[x y]"
                                                  "[x y & more]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_unchecked-add",
                                      :source {:code "(defn ^number unchecked-add\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add x y))\n  ([x y & more] (reduce unchecked-add (cljs.core/unchecked-add x y) more)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1959 1964]},
                                      :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-add\n  ([& xs] `(+ ~@xs)))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [372
                                                               373]}),
                                      :full-name "cljs.core/unchecked-add",
                                      :clj-symbol "clojure.core/unchecked-add",
                                      :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/when-let" {:description "When `test` is logical true, evaluates `body` with the value of `test` bound to\n`x`.",
                                 :ns "cljs.core",
                                 :name "when-let",
                                 :signature ["[[x test] & body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/if-let"
                                           "cljs.core/when"
                                           "cljs.core/when-not"
                                           "special/if"
                                           "cljs.core/when-first"],
                                 :full-name-encode "cljs.core_when-let",
                                 :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                          :repo "clojure",
                                          :tag "clojure-1.6.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [1741 1754]},
                                 :full-name "cljs.core/when-let",
                                 :clj-symbol "clojure.core/when-let",
                                 :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
           "clojure.core.reducers/folder" {:ns "clojure.core.reducers",
                                           :name "folder",
                                           :signature ["[coll xf]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers_folder",
                                           :source {:code "(defn folder\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       CollFold\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [79 94]},
                                           :full-name "clojure.core.reducers/folder",
                                           :clj-symbol "clojure.core.reducers/folder",
                                           :docstring "Given a foldable collection, and a transformation function xf,\nreturns a foldable collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.core/ASeq" {:ns "cljs.core",
                             :name "ASeq",
                             :type "protocol",
                             :full-name-encode "cljs.core_ASeq",
                             :source {:code "(defprotocol ASeq)",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [277]},
                             :full-name "cljs.core/ASeq",
                             :clj-symbol "clojure.lang/ASeq",
                             :history [["+" "0.0-1211"]]},
           "cljs.core/drop" {:description "Returns a lazy sequence of all but the first `n` items in `coll`.\n\nReturns a stateful transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "drop",
                             :signature ["[n]" "[n coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/take"
                                       "cljs.core/drop-last"
                                       "cljs.core/drop-while"
                                       "cljs.core/nthnext"
                                       "cljs.core/nthrest"],
                             :full-name-encode "cljs.core_drop",
                             :source {:code "(defn drop\n  ([n]\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na]\n                (vswap! na dec)\n                (if (pos? n)\n                  result\n                  (rf result input))))))))\n  ([n coll]\n     (let [step (fn [n coll]\n                  (let [s (seq coll)]\n                    (if (and (pos? n) s)\n                      (recur (dec n) (rest s))\n                      s)))]\n       (lazy-seq (step n coll)))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3808 3829]},
                             :full-name "cljs.core/drop",
                             :clj-symbol "clojure.core/drop",
                             :docstring "Returns a lazy sequence of all but the first n items in coll.\nReturns a stateful transducer when no collection is provided."},
           "cljs.core/ArrayList" {:ns "cljs.core",
                                  :name "ArrayList",
                                  :type "type",
                                  :signature ["[arr]"],
                                  :source {:code "(deftype ArrayList [^:mutable arr]\n  Object\n  (add [_ x] (.push arr x))\n  (size [_] (alength arr))\n  (clear [_] (set! arr (array)))\n  (isEmpty [_] (zero? (alength arr)))\n  (toArray [_] arr))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [7702 7708]},
                                  :full-name "cljs.core/ArrayList",
                                  :full-name-encode "cljs.core_ArrayList",
                                  :history [["+" "0.0-2301"]]},
           "cljs.core/stepper" {:ns "cljs.core",
                                :name "stepper",
                                :type "function",
                                :signature ["[xform iter]"],
                                :source {:code "(defn stepper [xform iter]\n  (letfn [(stepfn\n            ([result]\n               (let [lt (if (reduced? result)\n                          @result\n                          result)]\n                 (set! (.-stepper lt) nil)\n                 result))\n            ([result input]\n               (let [lt result]\n                 (set! (.-first lt) input)\n                 (set! (.-rest lt) (lazy-transformer (.-stepper lt)))\n                 (set! (.-stepper lt) nil)\n                 (.-rest lt))))]\n   (Stepper. (xform stepfn) iter)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3144 3158]},
                                :full-name "cljs.core/stepper",
                                :full-name-encode "cljs.core_stepper",
                                :history [["+" "0.0-2301"]]},
           "cljs.core/IAtom" {:ns "cljs.core",
                              :name "IAtom",
                              :type "protocol",
                              :full-name-encode "cljs.core_IAtom",
                              :source {:code "(defprotocol IAtom)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [414]},
                              :full-name "cljs.core/IAtom",
                              :history [["+" "0.0-2173"]]},
           "cljs.core/reduceable?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "reduceable?",
                                    :signature ["[x]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_reduceableQMARK",
                                    :source {:code "(defn ^boolean reduceable?\n  [x] (satisfies? IReduce x))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1530 1532]},
                                    :full-name "cljs.core/reduceable?",
                                    :docstring "Returns true if coll satisfies IReduce"},
           "cljs.core/while" {:description "Repeatedly executes `body` while `test` expression is true. Presumes some\nside-effect will cause `test` to become false or nil.\n\nReturns nil.",
                              :ns "cljs.core",
                              :name "while",
                              :signature ["[test & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/loop"],
                              :full-name-encode "cljs.core_while",
                              :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                       :repo "clojure",
                                       :tag "clojure-1.6.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5824 5832]},
                              :full-name "cljs.core/while",
                              :clj-symbol "clojure.core/while",
                              :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
           "cljs.core/import-macros" {:ns "cljs.core",
                                      :name "import-macros",
                                      :type "macro",
                                      :signature ["[ns [& vars]]"],
                                      :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(do (def ~sym (deref ~var))\n                                     ;for AOT compilation\n                                     (alter-meta! (var ~sym) assoc :macro true)))\n                       syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [47 57]},
                                      :full-name "cljs.core/import-macros",
                                      :full-name-encode "cljs.core_import-macros",
                                      :history [["+" "0.0-927"]]},
           "cljs.repl.browser/add-in-order" {:ns "cljs.repl.browser",
                                             :name "add-in-order",
                                             :type "function",
                                             :signature ["[{:keys [expecting fns]} order f]"],
                                             :source {:code "(defn add-in-order [{:keys [expecting fns]} order f]\n  {:expecting (or expecting order)\n   :fns (assoc fns order f)})",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [133 135]},
                                             :full-name "cljs.repl.browser/add-in-order",
                                             :full-name-encode "cljs.repl.browser_add-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/string-print" {:ns "cljs.core",
                                     :name "string-print",
                                     :type "function",
                                     :signature ["[x]"],
                                     :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [8137 8139]},
                                     :full-name "cljs.core/string-print",
                                     :full-name-encode "cljs.core_string-print",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/ES6IteratorSeq" {:ns "cljs.core",
                                       :name "ES6IteratorSeq",
                                       :type "type",
                                       :signature ["[value iter _rest]"],
                                       :source {:code "(deftype ES6IteratorSeq [value iter ^:mutable _rest]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] value)\n  (-rest [_]\n    (when (nil? _rest)\n      (set! _rest (es6-iterator-seq iter)))\n    _rest))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [795 803]},
                                       :full-name "cljs.core/ES6IteratorSeq",
                                       :full-name-encode "cljs.core_ES6IteratorSeq",
                                       :history [["+" "0.0-2411"]]},
           "cljs.core/-" {:description "If no `y`s are supplied, returns the negation of `x`, else subtracts the `y`s\nfrom `x` and returns the result.",
                          :return-type number,
                          :ns "cljs.core",
                          :name "-",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/+"],
                          :full-name-encode "cljs.core_-",
                          :source {:code "(defn ^number -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1850 1855]},
                          :extra-sources ({:code "(defmacro ^::ana/numeric -\n  ([x] (core/list 'js* \"(- ~{})\" x))\n  ([x y] (core/list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [414 417]}),
                          :examples [{:id "0a974e",
                                      :content "```clj\n(- 1)\n;;=> -1\n\n(- 6 3)\n;;=> 3\n\n(- 10 3 2)\n;;=> 5\n```"}],
                          :full-name "cljs.core/-",
                          :clj-symbol "clojure.core/-",
                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/vector-seq" {:ns "cljs.core",
                                   :name "vector-seq",
                                   :signature ["[v offset]"],
                                   :history [["+" "0.0-1211"]
                                             ["-" "0.0-1424"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_vector-seq",
                                   :source {:code "(defn vector-seq [v offset]\n  (let [c (-count v)]\n    (when (pos? c)\n      (reify\n        IPrintable\n        (-pr-seq [vseq opts] (pr-sequential pr-seq \"(\" \" \" \")\" opts vseq))\n        ISequential\n        IEquiv\n        (-equiv [vseq other] (equiv-sequential vseq other))\n        ASeq\n        ISeq\n        (-first [_] (-nth v offset))\n        (-rest [_]\n          (let [offset (inc offset)]\n            (if (< offset c)\n              (vector-seq v offset)\n              ())))\n        ISeqable\n        (-seq [vseq] vseq)))))",
                                            :repo "clojurescript",
                                            :tag "r1236",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2522 2540]},
                                   :full-name "cljs.core/vector-seq",
                                   :removed {:in "0.0-1424",
                                             :last-seen "0.0-1236"}},
           "cljs.core/IIterable" {:ns "cljs.core",
                                  :name "IIterable",
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IIterable",
                                  :source {:code "(defprotocol IIterable\n  (-iterator [coll]))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [425 426]},
                                  :methods [{:name "-iterator",
                                             :signature ["[coll]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IIterable",
                                  :history [["+" "0.0-2356"]]},
           "cljs.test/testing-contexts-str" {:ns "cljs.test",
                                             :name "testing-contexts-str",
                                             :signature ["[]"],
                                             :history [["+"
                                                        "0.0-2496"]],
                                             :type "function",
                                             :full-name-encode "cljs.test_testing-contexts-str",
                                             :source {:code "(defn testing-contexts-str\n  []\n  (apply str (interpose \" \" (reverse (:testing-contexts (get-current-env))))))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/test.cljs",
                                                      :lines [289 293]},
                                             :full-name "cljs.test/testing-contexts-str",
                                             :clj-symbol "clojure.test/testing-contexts-str",
                                             :docstring "Returns a string representation of the current test context. Joins\nstrings in *testing-contexts* with spaces."},
           "clojure.zip/vector-zip" {:ns "clojure.zip",
                                     :name "vector-zip",
                                     :signature ["[root]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.zip_vector-zip",
                                     :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/clojure/zip.cljs",
                                              :lines [42 48]},
                                     :full-name "clojure.zip/vector-zip",
                                     :clj-symbol "clojure.zip/vector-zip",
                                     :docstring "Returns a zipper for nested vectors, given a root vector"},
           "cljs.reader/read-2-chars" {:ns "cljs.reader",
                                       :name "read-2-chars",
                                       :type "function",
                                       :signature ["[reader]"],
                                       :source {:code "(defn read-2-chars [reader]\n  (.toString\n    (StringBuffer.\n      (read-char reader)\n      (read-char reader))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [167 171]},
                                       :full-name "cljs.reader/read-2-chars",
                                       :full-name-encode "cljs.reader_read-2-chars",
                                       :history [["+" "0.0-1424"]]},
           "cljs.core/chunk" {:ns "cljs.core",
                              :name "chunk",
                              :type "function",
                              :signature ["[b]"],
                              :source {:code "(defn chunk [b]\n  (.chunk b))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2744 2745]},
                              :full-name "cljs.core/chunk",
                              :full-name-encode "cljs.core_chunk",
                              :history [["+" "0.0-1424"]]},
           "cljs.core/conj!" {:ns "cljs.core",
                              :name "conj!",
                              :signature ["[]"
                                          "[coll]"
                                          "[tcoll val]"
                                          "[tcoll val & vals]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core_conjBANG",
                              :source {:code "(defn conj!\n  ([] (transient []))\n  ([coll] coll)\n  ([tcoll val]\n    (-conj! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-conj! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2927 2938]},
                              :full-name "cljs.core/conj!",
                              :clj-symbol "clojure.core/conj!",
                              :docstring "Adds x to the transient collection, and return coll. The 'addition'\nmay happen at different 'places' depending on the concrete type."},
           "cljs.test/do-report" {:ns "cljs.test",
                                  :name "do-report",
                                  :signature ["[m]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test_do-report",
                                  :source {:code "(defn do-report [m]\n  (let [m (case (:type m)\n            :fail (merge (file-and-line (js/Error.) 4) m)\n            :error (merge (file-and-line (:actual m) 0) m)\n            m)]\n    (report m)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/test.cljs",
                                           :lines [389 394]},
                                  :full-name "cljs.test/do-report",
                                  :clj-symbol "clojure.test/do-report"},
           "cljs.core/print-map" {:ns "cljs.core",
                                  :name "print-map",
                                  :type "function",
                                  :signature ["[m print-one writer opts]"],
                                  :source {:code "(defn print-map [m print-one writer opts]\n  (pr-sequential-writer\n    writer\n    (fn [e w opts]\n      (do (print-one (key e) w opts)\n          (-write w \\space)\n          (print-one (val e) w opts)))\n    \"{\" \", \" \"}\"\n    opts (seq m)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8330 8338]},
                                  :full-name "cljs.core/print-map",
                                  :full-name-encode "cljs.core_print-map",
                                  :history [["+" "0.0-2120"]]},
           "cljs.core/js->clj" {:description "Recursively transforms JavaScript arrays into ClojureScript vectors, and\nJavaScript objects into ClojureScript maps.\n\nWith option `{:keywordize-keys true}` will convert object fields from strings to\nkeywords.\n\nNote that `js->clj` is not optimized for speed and the [transit.cljs] library is\nrecommended for parsing large amounts of JSON data.\n\n[transit.cljs]:http://swannodette.github.io/2014/07/26/transit--clojurescript/",
                                :ns "cljs.core",
                                :name "js->clj",
                                :signature ["[x]" "[x & opts]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/clj->js"],
                                :full-name-encode "cljs.core_js-GTclj",
                                :source {:code "(defn js->clj\n  ([x] (js->clj x {:keywordize-keys false}))\n  ([x & opts]\n    (let [{:keys [keywordize-keys]} opts\n          keyfn (if keywordize-keys keyword str)\n          f (fn thisfn [x]\n              (cond\n                (satisfies? IEncodeClojure x)\n                (-js->clj x (apply array-map opts))\n\n                (seq? x)\n                (doall (map thisfn x))\n\n                (coll? x)\n                (into (empty x) (map thisfn x))\n\n                (array? x)\n                (vec (map thisfn x))\n                 \n                (identical? (type x) js/Object)\n                (into {} (for [k (js-keys x)]\n                           [(keyfn k) (thisfn (aget x k))]))\n\n                :else x))]\n      (f x))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8676 8704]},
                                :examples [{:id "61d263",
                                            :content "Parse a JSON string:\n\n```clj\n(def json \"{\\\"foo\\\": 1, \\\"bar\\\": 2, \\\"baz\\\": [1,2,3]}\")\n(def a (.parse js/JSON json))\n;;=> #js {:foo 1, :bar 2, :baz #js [1 2 3]}\n```\n\nConvert JSON data `a` to ClojureScript data:\n\n```clj\n(js->clj a)\n;;=> {\"foo\" 1, \"bar\" 2, \"baz\" [1 2 3]}\n\n(js->clj a :keywordize-keys true)\n;;=> {:foo 1, :bar 2, :baz [1 2 3]}\n```"}],
                                :full-name "cljs.core/js->clj",
                                :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords."},
           "cljs.core/List" {:ns "cljs.core",
                             :name "List",
                             :signature ["[meta first rest count __hash]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_List",
                             :source {:code "(deftype List [meta first rest count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (List. meta first rest count __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll]\n    (if (== count 1)\n      ()\n      rest))\n\n  INext\n  (-next [coll]\n    (if (== count 1)\n      nil\n      rest))\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2274 2331]},
                             :full-name "cljs.core/List",
                             :clj-symbol "clojure.lang/PersistentList"},
           "cljs.core/identical?" {:description "Returns true if `x` and `y` are the same object, false otherwise.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "identical?",
                                   :signature ["[x y]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/="
                                             "cljs.core/=="],
                                   :full-name-encode "cljs.core_identicalQMARK",
                                   :source {:code "(defn ^boolean identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [84 87]},
                                   :extra-sources ({:code "(defmacro identical? [a b]\n  (bool-expr (core/list 'js* \"(~{} === ~{})\" a b)))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [319 320]}),
                                   :full-name "cljs.core/identical?",
                                   :clj-symbol "clojure.core/identical?",
                                   :docstring "Tests if 2 arguments are the same object"},
           "cljs.core/*main-cli-fn*" {:ns "cljs.core",
                                      :name "*main-cli-fn*",
                                      :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                      :type "var",
                                      :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [131 135]},
                                      :full-name "cljs.core/*main-cli-fn*",
                                      :full-name-encode "cljs.core_STARmain-cli-fnSTAR",
                                      :history [["+" "0.0-927"]]},
           "clojure.browser.dom/html->dom" {:ns "clojure.browser.dom",
                                            :name "html->dom",
                                            :type "function",
                                            :signature ["[s]"],
                                            :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [101 102]},
                                            :full-name "clojure.browser.dom/html->dom",
                                            :full-name-encode "clojure.browser.dom_html-GTdom",
                                            :history [["+" "0.0-927"]]},
           "cljs.repl.server/handlers" {:ns "cljs.repl.server",
                                        :name "handlers",
                                        :type "var",
                                        :source {:code "(defonce handlers (atom {}))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [43]},
                                        :full-name "cljs.repl.server/handlers",
                                        :full-name-encode "cljs.repl.server_handlers",
                                        :history [["+" "0.0-1503"]]},
           "cljs.repl.node/load-javascript" {:ns "cljs.repl.node",
                                             :name "load-javascript",
                                             :signature ["[repl-env provides url]"],
                                             :history [["+"
                                                        "0.0-2629"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.node_load-javascript",
                                             :source {:code "(defn load-javascript\n  [repl-env provides url]\n  (node-eval repl-env\n    (str \"goog.require('\" (comp/munge (first provides)) \"')\")))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/clj/cljs/repl/node.clj",
                                                      :lines [68 72]},
                                             :full-name "cljs.repl.node/load-javascript",
                                             :docstring "Load a Closure JavaScript file into the Node REPL process."},
           "cljs.core/LazyTransformer.create" {:ns "cljs.core",
                                               :name "LazyTransformer.create",
                                               :signature ["[xform coll]"],
                                               :history [["+"
                                                          "0.0-2301"]],
                                               :parent-type "LazyTransformer",
                                               :type "function",
                                               :full-name-encode "cljs.core_LazyTransformerDOTcreate",
                                               :source {:code "(set! (.-create LazyTransformer)\n  (fn [xform coll]\n    (LazyTransformer. (stepper xform (iter coll)) nil nil nil)))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [3264
                                                                3266]},
                                               :full-name "cljs.core/LazyTransformer.create"},
           "cljs.core/chunk-next" {:ns "cljs.core",
                                   :name "chunk-next",
                                   :type "function",
                                   :signature ["[s]"],
                                   :source {:code "(defn chunk-next [s]\n  (if (implements? IChunkedNext s)\n    (-chunked-next s)\n    (seq (-chunked-rest s))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2753 2756]},
                                   :full-name "cljs.core/chunk-next",
                                   :full-name-encode "cljs.core_chunk-next",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/enable-console-print!" {:ns "cljs.core",
                                              :name "enable-console-print!",
                                              :signature ["[]"],
                                              :history [["+"
                                                         "0.0-2060"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_enable-console-printBANG",
                                              :source {:code "(defn enable-console-print!\n  []\n  (set! *print-newline* false)\n  (set! *print-fn*\n    (fn [& args]\n      (.apply (.-log js/console) js/console (into-array args)))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [51 57]},
                                              :full-name "cljs.core/enable-console-print!",
                                              :docstring "Set *print-fn* to console.log"},
           "cljs.core/sorted?" {:description "Returns true if `coll` implements the `ISorted` protocol, false otherwise.\n\nSorted maps and sorted sets implement `ISorted`.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "sorted?",
                                :signature ["[coll]"],
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :related ["cljs.core/sorted-map"
                                          "cljs.core/sorted-set"],
                                :full-name-encode "cljs.core_sortedQMARK",
                                :source {:code "(defn ^boolean sorted?\n  [x] (satisfies? ISorted x))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1526 1528]},
                                :full-name "cljs.core/sorted?",
                                :clj-symbol "clojure.core/sorted?",
                                :docstring "Returns true if coll satisfies ISorted"},
           "cljs.core/some" {:description "Returns the first logical true value of `(pred x)` for any `x` in `coll`, else\nnil.\n\nA common idiom is to use a set as pred, for example this will return `:fred` if\n`:fred` is in the sequence, otherwise nil: `(some #{:fred} coll)`",
                             :ns "cljs.core",
                             :name "some",
                             :signature ["[pred coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/every?"
                                       "cljs.core/not-any?"
                                       "cljs.core/keep"
                                       "cljs.core/keep-indexed"
                                       "cljs.core/some-fn"],
                             :full-name-encode "cljs.core_some",
                             :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3309 3316]},
                             :full-name "cljs.core/some",
                             :clj-symbol "clojure.core/some",
                             :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
           "cljs.core/PersistentArrayMapSeq" {:ns "cljs.core",
                                              :name "PersistentArrayMapSeq",
                                              :type "type",
                                              :signature ["[arr i _meta]"],
                                              :source {:code "(deftype PersistentArrayMapSeq [arr i _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (PersistentArrayMapSeq. arr i new-meta))\n\n  ICounted\n  (-count [coll]\n    (/ (- (alength arr) i) 2))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n  \n  ISeq\n  (-first [coll]\n    [(aget arr i) (aget arr (inc i))])\n\n  (-rest [coll]\n    (if (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) _meta)\n      ()))\n\n  INext\n  (-next [coll]\n    (when (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) _meta)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [5263
                                                               5314]},
                                              :full-name "cljs.core/PersistentArrayMapSeq",
                                              :full-name-encode "cljs.core_PersistentArrayMapSeq",
                                              :history [["+"
                                                         "0.0-1820"]]},
           "cljs.reader/make-unicode-char" {:ns "cljs.reader",
                                            :name "make-unicode-char",
                                            :type "function",
                                            :signature ["[code-str]"],
                                            :source {:code "(defn make-unicode-char [code-str]\n    (let [code (js/parseInt code-str 16)]\n      (.fromCharCode js/String code)))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [189 191]},
                                            :full-name "cljs.reader/make-unicode-char",
                                            :full-name-encode "cljs.reader_make-unicode-char",
                                            :history [["+" "0.0-1424"]]},
           "clojure.core.reducers/Cat" {:ns "clojure.core.reducers",
                                        :name "Cat",
                                        :signature ["[cnt left right]"],
                                        :history [["+" "0.0-1236"]],
                                        :type "type",
                                        :full-name-encode "clojure.core.reducers_Cat",
                                        :source {:code "(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n\n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [193 211]},
                                        :full-name "clojure.core.reducers/Cat",
                                        :clj-symbol "clojure.core.reducers/Cat"},
           "cljs.core/write-all" {:ns "cljs.core",
                                  :name "write-all",
                                  :type "function",
                                  :signature ["[writer & ss]"],
                                  :source {:code "(defn write-all [writer & ss]\n  (doseq [s ss]\n    (-write writer s)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8133 8135]},
                                  :full-name "cljs.core/write-all",
                                  :full-name-encode "cljs.core_write-all",
                                  :history [["+" "0.0-1503"]]},
           "cljs.core/doall" {:description "Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.\n\n`doall` walks through the successive `next`s of the sequence, returning the head\nand causing the entire sequence to reside in memory at one time.",
                              :ns "cljs.core",
                              :name "doall",
                              :signature ["[coll]" "[n coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/dorun"
                                        "cljs.core/doseq"],
                              :full-name-encode "cljs.core_doall",
                              :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8046 8058]},
                              :full-name "cljs.core/doall",
                              :clj-symbol "clojure.core/doall",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
           "cljs.core/condp" {:description "Takes a binary predicate, an expression, and a set of clauses. There are two\nkinds of clauses:\n\nBinary clause: `test-expr` `result-expr`\n\nTernary clause: `test-expr` `:>>` `result-fn`<br />\n(Note: `:>>` is an ordinary keyword)\n\nFor each clause, `(pred test-expr expr)` is evaluated. If it returns logical\ntrue, the clause is a match.\n\nIf a binary clause matches, its `result-expr` is returned.\n\nIf a ternary clause matches, its `result-fn` is called with the result of the\npredicate and returned by `condp`. `result-fn` should take one argument.\n\nA single default expression can follow the clauses, and its value will be\nreturned if no clause matches.\n\nIf no default expression is provided and no clause matches, an Error is thrown.",
                              :ns "cljs.core",
                              :name "condp",
                              :signature ["[pred expr & clauses]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/cond" "special/if"],
                              :full-name-encode "cljs.core_condp",
                              :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (core/cond\n                  (= 0 n) `(throw (js/Error. (core/str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1139 1179]},
                              :full-name "cljs.core/condp",
                              :clj-symbol "clojure.core/condp",
                              :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
           "clojure.zip/down" {:ns "clojure.zip",
                               :name "down",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_down",
                               :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [98 109]},
                               :full-name "clojure.zip/down",
                               :clj-symbol "clojure.zip/down",
                               :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
           "cljs.core/IPending" {:ns "cljs.core",
                                 :name "IPending",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IPending",
                                 :source {:code "(defprotocol IPending\n  (^boolean -realized? [d]))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [369 370]},
                                 :methods [{:name "-realized?",
                                            :signature ["[d]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IPending",
                                 :clj-symbol "clojure.lang/IPending"},
           "cljs.core/count" {:description "Returns the number of items in `x`.\n\n`count` works on arrays, lists, maps, sets, strings, and vectors.\n\n`(count nil)` returns 0.",
                              :ns "cljs.core",
                              :name "count",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_count",
                              :source {:code "(defn count\n  [coll]\n  (if-not (nil? coll)\n    (cond\n      (implements? ICounted coll)\n      (-count ^not-native coll)\n\n      (array? coll)\n      (alength coll)\n    \n      (string? coll)\n      (alength coll)\n\n      (native-satisfies? ICounted coll)\n      (-count coll)\n\n      :else (accumulating-seq-count coll))\n    0))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1211 1230]},
                              :examples [{:id "96e470",
                                          :content "```clj\n(count [1 2 3])\n;;=> 3\n\n(count [])\n;;=> 0\n\n(count nil)\n;;=> 0\n\n(count #{:a :b})\n;;=> 2\n\n(count {:key \"value\" :key2 \"value2\"})\n;;=> 2\n```"}],
                              :full-name "cljs.core/count",
                              :clj-symbol "clojure.core/count",
                              :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
           "cljs.core/bit-test" {:description "Test bit at index `n`. Returns `true` if 1, and `false` if 0. Same as `(x & (1 << y)) != 0` in JavaScript.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "bit-test",
                                 :signature ["[x n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_bit-test",
                                 :source {:code "(defn ^boolean bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2130 2133]},
                                 :extra-sources ({:code "(defmacro bit-test [x n]\n  (bool-expr (core/list 'js* \"((~{} & (1 << ~{})) != 0)\" x n)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [523 524]}),
                                 :examples [{:id "f64664",
                                             :content "Bits can be entered using radix notation:\n\n```clj\n(bit-test 2r0100 2)\n;;=> true\n\n(bit-test 2r0100 1)\n;;=> false\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-test 4 2)\n;;=> true\n\n(bit-test 4 1)\n;;=> false\n```"}],
                                 :full-name "cljs.core/bit-test",
                                 :clj-symbol "clojure.core/bit-test",
                                 :docstring "Test bit at index n"},
           "cljs.core/js-mod" {:description "Returns the modulus of dividing numerator `n` by denominator `d`, with JavaScript's\noriginal behavior for negative numbers.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).\n\nEquivalent to `x % y` in JavaScript.",
                               :ns "cljs.core",
                               :name "js-mod",
                               :signature ["[n d]"],
                               :history [["+" "0.0-1552"]],
                               :type "function",
                               :related ["cljs.core/mod"],
                               :full-name-encode "cljs.core_js-mod",
                               :source {:code "(defn js-mod\n  [n d]\n  (cljs.core/js-mod n d))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2065 2068]},
                               :extra-sources ({:code "(defmacro ^::ana/numeric js-mod [num div]\n  (core/list 'js* \"(~{} % ~{})\" num div))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [487 488]}),
                               :examples [{:id "75fa6d",
                                           :content "```clj\n(js-mod -5 3)\n;;=> -2\n\n(js-mod 5 3)\n;;=> 2\n\n(js-mod 5 0)\n;;=> NaN\n```"}],
                               :full-name "cljs.core/js-mod",
                               :docstring "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"},
           "cljs.core/es6-set-entries-iterator" {:ns "cljs.core",
                                                 :name "es6-set-entries-iterator",
                                                 :type "function",
                                                 :signature ["[coll]"],
                                                 :source {:code "(defn es6-set-entries-iterator [coll]\n  (ES6SetEntriesIterator. (seq coll)))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [5183
                                                                  5184]},
                                                 :full-name "cljs.core/es6-set-entries-iterator",
                                                 :full-name-encode "cljs.core_es6-set-entries-iterator",
                                                 :history [["+"
                                                            "0.0-2371"]]},
           "cljs.test/set-env!" {:ns "cljs.test",
                                 :name "set-env!",
                                 :type "function",
                                 :signature ["[new-env]"],
                                 :source {:code "(defn set-env! [new-env]\n  (set! *current-env* new-env))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/test.cljs",
                                          :lines [267 268]},
                                 :full-name "cljs.test/set-env!",
                                 :full-name-encode "cljs.test_set-envBANG",
                                 :history [["+" "0.0-2496"]]},
           "cljs.core/SetEntriesIterator" {:ns "cljs.core",
                                           :name "SetEntriesIterator",
                                           :signature ["[s]"],
                                           :history [["+" "0.0-2268"]
                                                     ["-" "0.0-2371"]],
                                           :type "type",
                                           :full-name-encode "cljs.core_SetEntriesIterator",
                                           :source {:code "(deftype SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))",
                                                    :repo "clojurescript",
                                                    :tag "r2356",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [4887 4894]},
                                           :full-name "cljs.core/SetEntriesIterator",
                                           :removed {:in "0.0-2371",
                                                     :last-seen "0.0-2356"}},
           "cljs.core/loop" {:description "Evaluates the `body-exprs` in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs, just like a `let` form.\nActs as a `recur` target, which will allow tail-call optimization.",
                             :ns "cljs.core",
                             :name "loop",
                             :signature ["[[& bindings] & body-exprs]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["special/recur"],
                             :full-name-encode "cljs.core_loop",
                             :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (core/symbol? b) b (gensym))) bs)\n              bfs (reduce (fn [ret [b v g]]\n                            (if (core/symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map core/vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [159 181]},
                             :examples [{:id "60291e",
                                         :content "```clj\n(loop [x 0]\n  (when (< x 10)\n    (println x)\n    (recur (+ x 2))))\n;; Prints:\n;; 0\n;; 2\n;; 4\n;; 6\n;; 8\n;;\n;;=> nil\n```"}],
                             :full-name "cljs.core/loop",
                             :clj-symbol "clojure.core/loop",
                             :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
           "cljs.core/subvec" {:description "Returns a persistent vector of the items in `v` from `start` inclusive to `end`\nexclusive.\n\nIf `end` is not supplied, defaults to `(count v)`.\n\nThis operation is O(1) and very fast, as the resulting vector shares structure\nwith the original and no trimming is done.",
                               :ns "cljs.core",
                               :name "subvec",
                               :signature ["[v start]"
                                           "[v start end]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/vector"
                                         "cljs.core/vector?"],
                               :full-name-encode "cljs.core_subvec",
                               :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (build-subvec nil v start end nil)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4684 4693]},
                               :full-name "cljs.core/subvec",
                               :clj-symbol "clojure.core/subvec",
                               :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
           "cljs.core/bit-clear" {:description "Clear bit at index `n`.  Same as `x & ~(1 << y)` in JavaScript.",
                                  :ns "cljs.core",
                                  :name "bit-clear",
                                  :signature ["[x n]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/bit-set"
                                            "cljs.core/bit-flip"],
                                  :full-name-encode "cljs.core_bit-clear",
                                  :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2111 2114]},
                                  :extra-sources ({:code "(defmacro ^::ana/numeric bit-clear [x n]\n  (core/list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [517 518]}),
                                  :examples [{:id "0f6748",
                                              :content "Bits can be entered using radix notation:\n\n```clj\n(bit-clear 2r1111 2)\n;;=> 11\n;; 11 = 2r1011\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-clear 15 2)\n;;=> 11\n```"}],
                                  :full-name "cljs.core/bit-clear",
                                  :clj-symbol "clojure.core/bit-clear",
                                  :docstring "Clear bit at index n"},
           "cljs.core/gensym" {:ns "cljs.core",
                               :name "gensym",
                               :signature ["[]" "[prefix-string]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_gensym",
                               :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8516 8524]},
                               :full-name "cljs.core/gensym",
                               :clj-symbol "clojure.core/gensym",
                               :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
           "special/recur" {:ns "special",
                            :name "recur",
                            :type "special form",
                            :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs :as form] _ _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (when-not frame \n      (throw (error env \"Can't recur here\")))\n    (when-not (= (count exprs) (count (:params frame))) \n      (throw (error env \"recur argument count mismatch\")))\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children exprs)))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [998 1011]},
                            :full-name "special/recur",
                            :full-name-encode "special_recur",
                            :clj-symbol "clojure.core/recur",
                            :history [["+" "0.0-927"]]},
           "cljs.core/Symbol" {:ns "cljs.core",
                               :name "Symbol",
                               :signature ["[ns name str _hash _meta]"],
                               :history [["+" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core_Symbol",
                               :source {:code "(deftype Symbol [ns name str ^:mutable _hash _meta]\n  Object\n  (toString [_] str)\n  (equiv [this other] (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Symbol other)\n      (identical? str (.-str other))\n      false))\n\n  IFn\n  (-invoke [sym coll]\n    (-lookup coll sym nil))\n  (-invoke [sym coll not-found]\n    (-lookup coll sym not-found))\n\n  IMeta\n  (-meta [_] _meta)\n\n  IWithMeta\n  (-with-meta [_ new-meta] (Symbol. ns name str _hash new-meta))\n\n  IHash\n  (-hash [sym]\n    (caching-hash sym hash-symbol _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer str)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [596 628]},
                               :full-name "cljs.core/Symbol",
                               :clj-symbol "clojure.lang/Symbol"},
           "cljs.core/hash-string*" {:ns "cljs.core",
                                     :name "hash-string*",
                                     :type "function",
                                     :signature ["[s]"],
                                     :source {:code "(defn hash-string* [s]\n  (if-not (nil? s)\n    (let [len (alength s)]\n      (if (pos? len)\n        (loop [i 0 hash 0]\n          (if (< i len)\n            (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n            hash))\n        0))\n    0))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [517 526]},
                                     :full-name "cljs.core/hash-string*",
                                     :full-name-encode "cljs.core_hash-stringSTAR",
                                     :history [["+" "0.0-2261"]]},
           "cljs.core/shuffle" {:description "Returns a random permutation of `coll`.",
                                :ns "cljs.core",
                                :name "shuffle",
                                :signature ["[coll]"],
                                :history [["+" "0.0-1424"]],
                                :type "function",
                                :full-name-encode "cljs.core_shuffle",
                                :source {:code "(defn shuffle\n  [coll]\n  (let [a (to-array coll)]\n    (garray/shuffle a)\n    (vec a)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1752 1757]},
                                :full-name "cljs.core/shuffle",
                                :clj-symbol "clojure.core/shuffle",
                                :docstring "Return a random permutation of coll"},
           "cljs.core/+" {:description "Returns the sum of nums.\n\n`(+)` returns 0.",
                          :return-type number,
                          :ns "cljs.core",
                          :name "+",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/*" "cljs.core/-"],
                          :full-name-encode "cljs.core_PLUS",
                          :source {:code "(defn ^number +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more]\n    (reduce + (cljs.core/+ x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1842 1848]},
                          :extra-sources ({:code "(defmacro ^::ana/numeric +\n  ([] 0)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [355 359]}),
                          :examples [{:id "650668",
                                      :content "```clj\n(+)\n;;=> 0\n\n(+ 1)\n;;=> 1\n\n(+ -10)\n;;=> -10\n\n(+ 1 2)\n;;=> 3\n\n(+ 1 2 3)\n;;=> 6\n```"}],
                          :full-name "cljs.core/+",
                          :clj-symbol "clojure.core/+",
                          :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/clone" {:ns "cljs.core",
                              :name "clone",
                              :type "function",
                              :signature ["[value]"],
                              :source {:code "(defn clone [value]\n  (-clone value))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [700 701]},
                              :full-name "cljs.core/clone",
                              :full-name-encode "cljs.core_clone",
                              :history [["+" "0.0-2134"]]},
           "cljs.core/comp" {:description "Takes a set of functions and returns a function that is the composition\nof those functions.\n\nThe returned function takes a variable number of arguments, applies the\nrightmost of `fns` to the arguments, whose result is subsequently applied to\nthe next left function, and so on.\n\n`((comp a b c) x y)` = `(a (b (c x y)))`",
                             :ns "cljs.core",
                             :name "comp",
                             :signature ["[& fns]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/partial"
                                       "cljs.core/juxt"],
                             :full-name-encode "cljs.core_comp",
                             :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3347 3374]},
                             :examples [{:id "5d3250",
                                         :content "```clj\n(def f (comp str inc +))\n(f 1 2 3)\n;;=> \"7\"\n```"}],
                             :full-name "cljs.core/comp",
                             :clj-symbol "clojure.core/comp",
                             :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
           "cljs.core/ArrayIter" {:ns "cljs.core",
                                  :name "ArrayIter",
                                  :type "type",
                                  :signature ["[arr i]"],
                                  :source {:code "(deftype ArrayIter [arr ^:mutable i]\n  Object\n  (hasNext [_] (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3081 3088]},
                                  :full-name "cljs.core/ArrayIter",
                                  :full-name-encode "cljs.core_ArrayIter",
                                  :history [["+" "0.0-2301"]]},
           "cljs.reader/desugar-meta" {:ns "cljs.reader",
                                       :name "desugar-meta",
                                       :type "function",
                                       :signature ["[f]"],
                                       :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [353 359]},
                                       :full-name "cljs.reader/desugar-meta",
                                       :full-name-encode "cljs.reader_desugar-meta",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl/load-namespace" {:ns "cljs.repl",
                                       :name "load-namespace",
                                       :signature ["[repl-env sym]"
                                                   "[repl-env sym opts]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl_load-namespace",
                                       :source {:code "(defn load-namespace\n  ([repl-env sym] (load-namespace repl-env sym nil))\n  ([repl-env sym opts]\n   (let [sym      (if (and (seq? sym)\n                        (= (first sym) 'quote))\n                    (second sym)\n                    sym)\n         ;; TODO: add pre-condition to source-on-disk, the\n         ;; source must supply at least :url - David\n         sources  (cljsc/add-dependencies\n                    (merge (env->opts repl-env) opts)\n                    {:requires [(name sym)] :type :seed\n                     :url (:uri (cljsc/source-for-namespace\n                                  sym env/*compiler*))})\n         deps     (->> sources\n                    (remove (comp #{[\"goog\"]} :provides))\n                    (remove (comp #{:seed} :type))\n                    (map #(select-keys % [:provides :url])))]\n     (if (:output-dir opts)\n       ;; REPLs that read from :output-dir just need to add deps,\n       ;; environment will handle actual loading - David\n       (doseq [source (map #(cljsc/source-on-disk opts %) sources)]\n         (-evaluate repl-env \"<cljs repl>\" 1\n           (cljsc/add-dep-string opts source)))\n       ;; REPLs that stream must manually load each dep - David\n       (doseq [{:keys [url provides]} deps]\n         (-load repl-env provides url))))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [136 165]},
                                       :full-name "cljs.repl/load-namespace",
                                       :docstring "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once and\nonly once."},
           "cljs.core/pr" {:ns "cljs.core",
                           :name "pr",
                           :signature ["[& objs]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :full-name-encode "cljs.core_pr",
                           :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [8291 8297]},
                           :full-name "cljs.core/pr",
                           :clj-symbol "clojure.core/pr",
                           :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
           "cljs.test/run-tests" {:ns "cljs.test",
                                  :name "run-tests",
                                  :signature ["[]"
                                              "[env-or-ns]"
                                              "[env-or-ns & namespaces]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "macro",
                                  :full-name-encode "cljs.test_run-tests",
                                  :source {:code "(defmacro run-tests\n  ([] `(run-tests (cljs.test/empty-env) '~ana/*cljs-ns*))\n  ([env-or-ns]\n   (if (ns? env-or-ns)\n     `(run-tests (cljs.test/empty-env) ~env-or-ns)\n     `(run-tests ~env-or-ns '~ana/*cljs-ns*)))\n  ([env-or-ns & namespaces]\n   `(cljs.test/run-block (run-tests-block ~env-or-ns ~@namespaces))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/test.clj",
                                           :lines [281 290]},
                                  :full-name "cljs.test/run-tests",
                                  :clj-symbol "clojure.test/run-tests",
                                  :docstring "Runs all tests in the given namespaces; prints results.\nDefaults to current namespace if none given."},
           "clojure.string/upper-case" {:description "Converts string to all upper-case.",
                                        :ns "clojure.string",
                                        :name "upper-case",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_upper-case",
                                        :source {:code "(defn upper-case\n  [s]\n  (.toUpperCase s))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [68 71]},
                                        :full-name "clojure.string/upper-case",
                                        :clj-symbol "clojure.string/upper-case",
                                        :docstring "Converts string to all upper-case."},
           "cljs.core/chars" {:ns "cljs.core",
                              :name "chars",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core_chars",
                              :source {:code "(defn chars [x] x)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2058]},
                              :full-name "cljs.core/chars",
                              :clj-symbol "clojure.core/chars"},
           "cljs.analyzer.api/find-ns" {:ns "cljs.analyzer.api",
                                        :name "find-ns",
                                        :signature ["[sym]"],
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api_find-ns",
                                        :source {:code "(defn find-ns\n  [sym]\n  {:pre [(symbol? sym)]}\n  (get-in @env/*compiler* [::ana/namespaces sym]))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/analyzer/api.clj",
                                                 :lines [30 35]},
                                        :full-name "cljs.analyzer.api/find-ns",
                                        :clj-symbol "clojure.core/find-ns",
                                        :docstring "Given a namespace return the corresponding namespace analysis map. Analagous\nto clojure.core/find-ns."},
           "syntax/string" {:description "Signifies a string.  ClojureScript strings are the same as JavaScript strings.\n\nStrings may span multiple lines.\n\nStandard escape characters such as `\\\"` are supported, as well as unicode\nescape characters:\n\n| unicode characters  | constraints                                   |\n|---------------------|-----------------------------------------------|\n| `\\uXXXX`            | XXXX must have 4 digits outside 0xD7FF-0xE000 |\n| `\\oXXX`             | XXX is octal between 0 and 0377               |",
                            :ns "syntax",
                            :name "string",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/str"],
                            :full-name-encode "syntax_string",
                            :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                     :repo "tools.reader",
                                     :tag "tools.reader-0.8.10",
                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                     :lines [591 610]},
                            :extra-sources [{:code "(defn- read-string*\n  [reader _]\n  (loop [sb (StringBuilder.)\n         ch (read-char reader)]\n    (case ch\n      nil (reader-error reader \"EOF while reading string\")\n      \\\\ (recur (doto sb (.append (escape-char sb reader)))\n                (read-char reader))\n      \\\" (str sb)\n      (recur (doto sb (.append ch)) (read-char reader)))))",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [264 273]}],
                            :syntax-form "\"\"",
                            :examples [{:id "eb97ac",
                                        :content "```clj\n\"foo\"\n;;=> \"foo\"\n\n\"hello\n     world\"\n;;=> \"hello\\n     world\"\n```\n\nCharacters can be escaped:\n\n```clj\n(println \"foo\\nbar\")\n;; prints:\n;;   foo\n;;   bar\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#strings",
                            :full-name "syntax/string",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.event/expose" {:ns "clojure.browser.event",
                                           :name "expose",
                                           :type "function",
                                           :signature ["[e]"],
                                           :source {:code "(defn expose [e]\n  (events/expose e))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [81 82]},
                                           :full-name "clojure.browser.event/expose",
                                           :full-name-encode "clojure.browser.event_expose",
                                           :history [["+" "0.0-927"]]},
           "clojure.browser.event/listen-once" {:ns "clojure.browser.event",
                                                :name "listen-once",
                                                :type "function",
                                                :signature ["[src type fn]"
                                                            "[src type fn capture?]"],
                                                :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (events/listenOnce src\n                        (get (event-types src) type type)\n                        fn\n                        capture?)))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/clojure/browser/event.cljs",
                                                         :lines [55
                                                                 62]},
                                                :full-name "clojure.browser.event/listen-once",
                                                :full-name-encode "clojure.browser.event_listen-once",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/m3-C1" {:ns "cljs.core",
                              :name "m3-C1",
                              :type "var",
                              :source {:code "(def m3-C1 0xcc9e2d51)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [469]},
                              :full-name "cljs.core/m3-C1",
                              :full-name-encode "cljs.core_m3-C1",
                              :history [["+" "0.0-2261"]]},
           "cljs.core/empty?" {:description "Returns true if `coll` has no items - same as `(not (seq coll))`.\n\nPlease use the idiom `(seq x)` rather than `(not (empty? x))`.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "empty?",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/seq"],
                               :full-name-encode "cljs.core_emptyQMARK",
                               :source {:code "(defn ^boolean empty?\n  [coll] (or (nil? coll)\n             (not (seq coll))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1498 1502]},
                               :full-name "cljs.core/empty?",
                               :clj-symbol "clojure.core/empty?",
                               :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
           "cljs.core/m3-fmix" {:return-type number,
                                :ns "cljs.core",
                                :name "m3-fmix",
                                :signature ["[h1 len]"],
                                :history [["+" "0.0-2261"]],
                                :type "function",
                                :full-name-encode "cljs.core_m3-fmix",
                                :source {:code "(defn ^number m3-fmix [h1 len]\n  (as-> h1 h1\n    (bit-xor h1 len)\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))\n    (imul h1 0x85ebca6b)\n    (bit-xor h1 (unsigned-bit-shift-right h1 13))\n    (imul h1 0xc2b2ae35)\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [478 485]},
                                :full-name "cljs.core/m3-fmix"},
           "cljs.core/newline" {:ns "cljs.core",
                                :name "newline",
                                :signature ["[opts]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_newline",
                                :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8276 8279]},
                                :full-name "cljs.core/newline",
                                :clj-symbol "clojure.core/newline"},
           "cljs.core/PersistentHashMap" {:ns "cljs.core",
                                          :name "PersistentHashMap",
                                          :signature ["[meta cnt root has-nil? nil-val __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_PersistentHashMap",
                                          :source {:code "(deftype PersistentHashMap [meta cnt root ^boolean has-nil? nil-val ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k]\n    (-lookup coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if-not (nil? root) (.inode-seq root))]\n        (if has-nil?\n          (cons [nil nil-val] s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (.inode-lookup root 0 (hash k) k not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (Box. false)\n            new-root    (-> (if (nil? root)\n                              (.-EMPTY BitmapIndexedNode)\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if ^boolean (.-val added-leaf?) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-lookup root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (not (nil? root)) (.kv-reduce root f init)\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [6206 6331]},
                                          :full-name "cljs.core/PersistentHashMap",
                                          :clj-symbol "clojure.lang/PersistentHashMap"},
           "cljs.core/replace" {:description "Given a map of replacement pairs `smap` and a vector/collection `coll`, returns\na vector/seq with any elements `=` to a key in `smap` replaced with the\ncorresponding val in `smap`.\n\nReturns a transducer when `coll` is not provided.",
                                :ns "cljs.core",
                                :name "replace",
                                :signature ["[smap]" "[smap coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/map"
                                          "clojure.walk/prewalk-replace"
                                          "clojure.walk/postwalk-replace"],
                                :full-name-encode "cljs.core_replace",
                                :source {:code "(defn replace\n  ([smap]\n     (map #(if-let [e (find smap %)] (val e) %)))\n  ([smap coll]\n     (if (vector? coll)\n       (let [n (count coll)]\n         (reduce (fn [v i]\n                   (if-let [e (find smap (nth v i))]\n                     (assoc v i (second e))\n                     v))\n           coll (take n (iterate inc 0))))\n       (map #(if-let [e (find smap %)] (second e) %) coll))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7619 7634]},
                                :full-name "cljs.core/replace",
                                :clj-symbol "clojure.core/replace",
                                :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap.  Returns a transducer when no collection\nis provided."},
           "cljs.core/rand" {:description "Returns a random floating point number between 0 inclusive and `n` exclusive.\n\n`n` defaults to 1.",
                             :ns "cljs.core",
                             :name "rand",
                             :signature ["[]" "[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rand-int"
                                       "cljs.core/rand-nth"],
                             :full-name-encode "cljs.core_rand",
                             :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (* (Math/random) n)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [8737 8741]},
                             :full-name "cljs.core/rand",
                             :clj-symbol "clojure.core/rand",
                             :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
           "cljs.core/add-watch" {:description "Adds a watch function `f` to atom `a` that will execute when the value of `a`\nchanges.\n\nThe watch function takes 4 arguments: a key, the atom, its old state, and its\nnew state.\n\n`key` should be a keyword and can be used with `remove-watch` to remove the\nwatch function.",
                                  :ns "cljs.core",
                                  :name "add-watch",
                                  :signature ["[a key f]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/remove-watch"],
                                  :full-name-encode "cljs.core_add-watch",
                                  :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f)\n  iref)",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8479 8502]},
                                  :examples [{:id "2f2fe0",
                                              :content "```clj\n(def a (atom {}))\n\n(add-watch a :logger\n  (fn [_key _atom old-state new-state]\n    (println \"old:\" old-state)\n    (println \"new:\" new-state)))\n\n(swap! a assoc :foo \"bar\")\n;;=> will print the following:\n;; old: {}\n;; new: {:foo \"bar\"}\n```"}],
                                  :full-name "cljs.core/add-watch",
                                  :clj-symbol "clojure.core/add-watch",
                                  :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
           "cljs.repl.rhino/loaded-libs" {:ns "cljs.repl.rhino",
                                          :name "loaded-libs",
                                          :type "var",
                                          :source {:code "(def loaded-libs (atom #{}))",
                                                   :repo "clojurescript",
                                                   :tag "r1552",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [20]},
                                          :full-name "cljs.repl.rhino/loaded-libs",
                                          :full-name-encode "cljs.repl.rhino_loaded-libs",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1576"]],
                                          :removed {:in "0.0-1576",
                                                    :last-seen "0.0-1552"}},
           "cljs.core/cloneable?" {:ns "cljs.core",
                                   :name "cloneable?",
                                   :type "function",
                                   :signature ["[value]"],
                                   :source {:code "(defn cloneable? [value]\n  (satisfies? ICloneable value))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [703 704]},
                                   :full-name "cljs.core/cloneable?",
                                   :full-name-encode "cljs.core_cloneableQMARK",
                                   :history [["+" "0.0-2156"]]},
           "clojure.string/capitalize" {:description "Converts first character of the string to upper-case, all other characters to\nlower-case.",
                                        :ns "clojure.string",
                                        :name "capitalize",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_capitalize",
                                        :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [78 85]},
                                        :full-name "clojure.string/capitalize",
                                        :clj-symbol "clojure.string/capitalize",
                                        :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
           "cljs.core/short" {:return-type number,
                              :ns "cljs.core",
                              :name "short",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core_short",
                              :source {:code "(defn ^number short [x] x)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1949]},
                              :extra-sources ({:code "(defmacro short [x] x)",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [362]}),
                              :full-name "cljs.core/short",
                              :clj-symbol "clojure.core/short"},
           "cljs.core/replicate" {:ns "cljs.core",
                                  :name "replicate",
                                  :signature ["[n x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_replicate",
                                  :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3886 3888]},
                                  :full-name "cljs.core/replicate",
                                  :clj-symbol "clojure.core/replicate",
                                  :docstring "Returns a lazy seq of n xs."},
           "cljs.core/es6-entries-iterator" {:ns "cljs.core",
                                             :name "es6-entries-iterator",
                                             :type "function",
                                             :signature ["[coll]"],
                                             :source {:code "(defn es6-entries-iterator [coll]\n  (ES6EntriesIterator. (seq coll)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [5170
                                                              5171]},
                                             :full-name "cljs.core/es6-entries-iterator",
                                             :full-name-encode "cljs.core_es6-entries-iterator",
                                             :history [["+"
                                                        "0.0-2371"]]},
           "special/do" {:ns "special",
                         :name "do",
                         :type "special form",
                         :source {:code "(defmethod parse 'do\n  [op env [_ & exprs :as form] _ _]\n  (let [statements (disallowing-recur\n                     (seq (map #(analyze (assoc env :context :statement) %) (butlast exprs))))\n        ret (if (<= (count exprs) 1)\n              (analyze env (first exprs))\n              (analyze (assoc env :context (if (= :statement (:context env)) :statement :return)) (last exprs)))]\n    {:env env :op :do :form form\n     :statements statements :ret ret\n     :children (conj (vec statements) ret)}))",
                                  :repo "clojurescript",
                                  :tag "r2911",
                                  :filename "src/clj/cljs/analyzer.clj",
                                  :lines [922 931]},
                         :full-name "special/do",
                         :full-name-encode "special_do",
                         :clj-symbol "clojure.core/do",
                         :history [["+" "0.0-927"]]},
           "cljs.core/ArrayChunk" {:ns "cljs.core",
                                   :name "ArrayChunk",
                                   :signature ["[arr off end]"],
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core_ArrayChunk",
                                   :source {:code "(deftype ArrayChunk [arr off end]\n  ICounted\n  (-count [_] (- end off))\n\n  IIndexed\n  (-nth [coll i]\n    (aget arr (+ off i)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i (- end off)))\n      (aget arr (+ off i))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (== off end)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (ArrayChunk. arr (inc off) end)))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr off) (inc off)))\n  (-reduce [coll f start]\n    (array-reduce arr f start off)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2640 2662]},
                                   :full-name "cljs.core/ArrayChunk",
                                   :clj-symbol "clojure.lang/ArrayChunk"},
           "cljs.core/sequential?" {:description "Returns true if `coll` implements the `ISequential` protocol, false otherwise.\n\nLists and vectors are sequential.",
                                    :return-type boolean,
                                    :ns "cljs.core",
                                    :name "sequential?",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/seq?"
                                              "cljs.core/coll?"],
                                    :full-name-encode "cljs.core_sequentialQMARK",
                                    :source {:code "(defn ^boolean sequential?\n  [x] (satisfies? ISequential x))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1522 1524]},
                                    :full-name "cljs.core/sequential?",
                                    :clj-symbol "clojure.core/sequential?",
                                    :docstring "Returns true if coll satisfies ISequential"},
           "cljs.core/underive" {:ns "cljs.core",
                                 :name "underive",
                                 :signature ["[tag parent]"
                                             "[h tag parent]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_underive",
                                 :source {:code "(defn underive\n  ([tag parent]\n    (swap-global-hierarchy! underive tag parent)\n    nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8859 8878]},
                                 :full-name "cljs.core/underive",
                                 :clj-symbol "clojure.core/underive",
                                 :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "cljs.core/PersistentArrayMapIterator" {:ns "cljs.core",
                                                   :name "PersistentArrayMapIterator",
                                                   :type "type",
                                                   :signature ["[arr i cnt]"],
                                                   :source {:code "(deftype PersistentArrayMapIterator [arr ^:mutable i cnt]\n  Object\n  (hasNext [_]\n    (< i cnt))\n  (next [_]\n    (let [ret [(aget arr i) (aget arr (inc i))]]\n      (set! i (+ i 2))\n      ret)))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/cljs/cljs/core.cljs",
                                                            :lines [5324
                                                                    5331]},
                                                   :full-name "cljs.core/PersistentArrayMapIterator",
                                                   :full-name-encode "cljs.core_PersistentArrayMapIterator",
                                                   :history [["+"
                                                              "0.0-2371"]]},
           "cljs.core/get-method" {:ns "cljs.core",
                                   :name "get-method",
                                   :signature ["[multifn dispatch-val]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_get-method",
                                   :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [9149 9152]},
                                   :full-name "cljs.core/get-method",
                                   :clj-symbol "clojure.core/get-method",
                                   :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
           "cljs.core/=" {:description "Returns true if the value of `x` equals the value of `y`, false otherwise.\n\n`=` is a value comparison, not an identity comparison.\n\nAll collections can be tested for value, regardless of \"depth\".",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name "=",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/=="
                                    "cljs.core/not="
                                    "cljs.core/identical?"],
                          :full-name-encode "cljs.core_EQ",
                          :source {:code "(defn ^boolean =\n  ([x] true)\n  ([x y]\n    (if (nil? x)\n      (nil? y)\n      (or (identical? x y)\n        ^boolean (-equiv x y))))\n  ([x y & more]\n     (if (= x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (= y (first more)))\n       false)))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [762 778]},
                          :examples [{:id "edffb6",
                                      :content "```clj\n(= 1)\n;;=> true\n\n(= 1 1)\n;;=> true\n\n(= 1 2)\n;;=> false\n\n(= 1 1 1)\n;;=> true\n\n(= 1 1 2)\n;;=> false\n```"}
                                     {:id "a2d064",
                                      :content "Sequences are considered equal in value if they have the same elements:\n\n```clj\n(= '(1 2) [1 2])\n;;=> true\n```\n\nBut you cannot compare JavaScript arrays until you convert them to sequences:\n\n```clj\n(def a #js [1 2])\n(def b #js [1 2])\n(= a b)\n;;=> false\n\n(= (seq a) (seq b))\n;;=> true\n```"}
                                     {:id "6c8424",
                                      :content "It is natural to compare deeply nested collections since value equality checks\nare cheap in ClojureScript:\n\n```clj\n(def a {:foo {:bar \"baz\"}})\n(def b {:foo {:bar \"baz\"}})\n(= a b)\n;;=> true\n\n(= [a b] [a b])\n;=> true\n```\n\nJavaScript objects cannot be compared in this way until they are converted to\nClojureScript collections:\n\n```clj\n(def a #js {:foo #js {:bar \"baz\"}})\n(def b #js {:foo #js {:bar \"baz\"}})\n(= a b)\n;;=> false\n\n(= (js->clj a)\n   (js->clj b))\n;;=> true\n```"}],
                          :full-name "cljs.core/=",
                          :clj-symbol "clojure.core/=",
                          :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
           "cljs.repl.server/dispatch-on" {:ns "cljs.repl.server",
                                           :name "dispatch-on",
                                           :signature ["[method pred handler]"
                                                       "[method {:as m}]"],
                                           :history [["+" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.server_dispatch-on",
                                           :source {:code "(defn dispatch-on\n  ([method pred handler]\n    (dispatch-on method {:pred pred :handler handler}))\n  ([method {:as m}]\n    (swap! handlers\n      (fn [old]\n        (update-in old [method] #(conj (vec %) m))))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/repl/server.clj",
                                                    :lines [45 57]},
                                           :full-name "cljs.repl.server/dispatch-on",
                                           :docstring "Registers a handler to be dispatched based on a request method and a\npredicate.\n\npred should be a function that accepts an options map, a connection,\nand a request map and returns a boolean value based on whether or not\nthat request should be dispatched to the related handler."},
           "cljs.reader/deregister-default-tag-parser!" {:ns "cljs.reader",
                                                         :name "deregister-default-tag-parser!",
                                                         :type "function",
                                                         :signature ["[]"],
                                                         :source {:code "(defn deregister-default-tag-parser!\n  []\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] nil))\n    old-parser))",
                                                                  :repo "clojurescript",
                                                                  :tag "r2911",
                                                                  :filename "src/cljs/cljs/reader.cljs",
                                                                  :lines [608
                                                                          612]},
                                                         :full-name "cljs.reader/deregister-default-tag-parser!",
                                                         :full-name-encode "cljs.reader_deregister-default-tag-parserBANG",
                                                         :history [["+"
                                                                    "0.0-1576"]]},
           "syntax/comment" {:description "\"Comments out\" everything after `;` on the current line.",
                             :ns "syntax",
                             :name "comment",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/ignore"
                                       "cljs.core/comment"],
                             :full-name-encode "syntax_comment",
                             :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                      :repo "tools.reader",
                                      :tag "tools.reader-0.8.10",
                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                      :lines [591 610]},
                             :extra-sources [{:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [120 122]}],
                             :syntax-form ";",
                             :examples [{:id "ab62d2",
                                         :content "Add comments to code:\n\n```clj\n(def a 1) ; this is a comment\n```\n\nIt is common to use `;;` for comments that have their own line:\n\n```clj\n;; this is comment is on its own line\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#comments",
                             :full-name "syntax/comment",
                             :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/defn-" {:description "Same as `defn`, but adds `{:private true}` metadata to the definition.\n\nNote: `:private` metadata is not currently enforced by the ClojureScript\ncompiler.",
                              :ns "cljs.core",
                              :name "defn-",
                              :signature ["[name & decls]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/defn"],
                              :full-name-encode "cljs.core_defn-",
                              :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                       :repo "clojure",
                                       :tag "clojure-1.6.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [4529 4533]},
                              :full-name "cljs.core/defn-",
                              :clj-symbol "clojure.core/defn-",
                              :docstring "same as defn, yielding non-public def"},
           "cljs.reader/read-symbol" {:ns "cljs.reader",
                                      :name "read-symbol",
                                      :type "function",
                                      :signature ["[reader initch]"],
                                      :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (and (gstring/contains token \"/\")\n             (not (== (.-length token) 1)))\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\"))\n                (.-length token)))\n      (special-symbols token (symbol token)))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [327 335]},
                                      :full-name "cljs.reader/read-symbol",
                                      :full-name-encode "cljs.reader_read-symbol",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/push-back-reader" {:ns "cljs.reader",
                                           :name "push-back-reader",
                                           :type "function",
                                           :signature ["[s]"],
                                           :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (array) -1))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/reader.cljs",
                                                    :lines [29 31]},
                                           :full-name "cljs.reader/push-back-reader",
                                           :full-name-encode "cljs.reader_push-back-reader",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/deftype" {:ns "cljs.core",
                                :name "deftype",
                                :signature ["[t fields & impls]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_deftype",
                                :source {:code "(defmacro deftype [t fields & impls]\n  (let [env &env\n        r (:name (cljs.analyzer/resolve-var (dissoc env :locals) t))\n        [fpps pmasks] (prepare-protocol-masks env impls)\n        protocols (collect-protocols impls env)\n        t (vary-meta t assoc\n            :protocols protocols\n            :skip-protocol-flag fpps) ]\n    `(do\n       (deftype* ~t ~fields ~pmasks\n         ~(if (seq impls)\n            `(extend-type ~t ~@(dt->et t impls fields))))\n       (set! (.-cljs$lang$type ~t) true)\n       (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n       (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n\n       ~(build-positional-factory t r fields)\n       ~t)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [889 906]},
                                :full-name "cljs.core/deftype",
                                :clj-symbol "clojure.core/deftype"},
           "cljs.repl/print-doc" {:ns "cljs.repl",
                                  :name "print-doc",
                                  :type "function",
                                  :signature ["[m]"],
                                  :source {:code "(defn print-doc [m]\n  (println \"-------------------------\")\n  (println (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m)))\n  (cond\n    (:forms m) (doseq [f (:forms m)]\n                 (print \"  \")\n                 (prn f))\n    (:arglists m) (prn (:arglists m)))\n  (if (:special-form m)\n    (do\n      (println \"Special Form\")\n      (println \" \" (:doc m)) \n      (if (contains? m :url)\n        (when (:url m)\n          (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n        (println (str \"\\n  Please see http://clojure.org/special_forms#\"\n                   (:name m)))))\n    (do\n      (when (:macro m)\n        (println \"Macro\")) \n      (println \" \" (:doc m)))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/repl.cljs",
                                           :lines [12 32]},
                                  :full-name "cljs.repl/print-doc",
                                  :full-name-encode "cljs.repl_print-doc",
                                  :history [["+" "0.0-2496"]]},
           "cljs.core/longs" {:ns "cljs.core",
                              :name "longs",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core_longs",
                              :source {:code "(defn longs [x] x)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2063]},
                              :full-name "cljs.core/longs",
                              :clj-symbol "clojure.core/longs"},
           "cljs.core/Subvec" {:ns "cljs.core",
                               :name "Subvec",
                               :type "type",
                               :signature ["[meta v start end __hash]"],
                               :source {:code "(deftype Subvec [meta v start end ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (Subvec. meta v start end __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (build-subvec meta v start end __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (== start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (build-subvec meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (build-subvec meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (== i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  IReversible\n  (-rseq [coll]\n    (if-not (== start end)\n      (RSeq. coll (dec (- end start)) nil)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (if (or (neg? n) (<= end (+ start n)))\n      (vector-index-out-of-bounds n (- end start))\n      (-nth v (+ start n))))\n  (-nth [coll n not-found]\n    (if (or (neg? n) (<= end (+ start n)))\n      not-found\n      (-nth v (+ start n) not-found)))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (if (number? key)\n      (-assoc-n coll key val)\n      (throw (js/Error. \"Subvec's key for assoc must be a number.\"))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (let [v-pos (+ start n)]\n      (build-subvec meta (assoc v v-pos val) start (max end (inc v-pos)) nil)))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4577 4669]},
                               :full-name "cljs.core/Subvec",
                               :full-name-encode "cljs.core_Subvec",
                               :history [["+" "0.0-927"]]},
           "cljs.repl.browser/run-in-order" {:ns "cljs.repl.browser",
                                             :name "run-in-order",
                                             :type "function",
                                             :signature ["[{:keys [expecting fns]}]"],
                                             :source {:code "(defn run-in-order [{:keys [expecting fns]}]\n  (loop [order expecting fns fns]\n    (if-let [f (get fns order)]\n      (do\n        (f)\n        (recur (inc order) (dissoc fns order)))\n      {:expecting order :fns fns})))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [137 143]},
                                             :full-name "cljs.repl.browser/run-in-order",
                                             :full-name-encode "cljs.repl.browser_run-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.browser/compile-client-js" {:ns "cljs.repl.browser",
                                                  :name "compile-client-js",
                                                  :type "function",
                                                  :signature ["[opts]"],
                                                  :source {:code "(defn compile-client-js [opts]\n  (cljsc/build\n    '[(ns clojure.browser.repl.client\n        (:require [goog.events :as event]\n                  [clojure.browser.repl :as repl]))\n      (defn start [url]\n        (event/listen js/window\n          \"load\"\n          (fn []\n            (repl/start-evaluator url))))]\n    {:optimizations (:optimizations opts)\n     :output-dir (:working-dir opts)}))",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [213
                                                                   224]},
                                                  :full-name "cljs.repl.browser/compile-client-js",
                                                  :full-name-encode "cljs.repl.browser_compile-client-js",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/if-some" {:description "If `test` is not nil, evaluates `then` with `x` bound to the value of `test`. If\nnot, yields `else`.",
                                :ns "cljs.core",
                                :name "if-some",
                                :signature ["[[x test] then]"
                                            "[[x test] then else]"],
                                :history [["+" "0.0-2261"]],
                                :type "macro",
                                :related ["cljs.core/when-some"],
                                :full-name-encode "cljs.core_if-some",
                                :source {:code "(defmacro if-some\n  ([bindings then]\n   `(if-some ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if (nil? temp#)\n          ~else\n          (let [~form temp#]\n            ~then))))))",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [1756 1774]},
                                :full-name "cljs.core/if-some",
                                :clj-symbol "clojure.core/if-some",
                                :docstring "bindings => binding-form test\n\nIf test is not nil, evaluates then with binding-form bound to the\nvalue of test, if not, yields else"},
           "cljs.test/js-filename" {:ns "cljs.test",
                                    :name "js-filename",
                                    :type "function",
                                    :signature ["[stack-element]"],
                                    :source {:code "(defn js-filename [stack-element]\n  (first (.split (last (.split stack-element \"/out/\")) \":\")))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/test.cljs",
                                             :lines [353 354]},
                                    :full-name "cljs.test/js-filename",
                                    :full-name-encode "cljs.test_js-filename",
                                    :history [["+" "0.0-2496"]]},
           "special/ns" {:description "Sets the namespace of the file.\n\n`ns` must be the first form in a `.cljs` file and there can only be one `ns`\ndeclaration per file. Namespaces must match the file name of their respective\n`.cljs` files, with the exception that dashes in namespaces become underscores\nin filenames. Thus, `(ns foo.bar-biz.baz)` should be the first form in file\n`foo/bar_biz/baz.cljs`.\n\n`references` can be zero or more forms used to import other namespaces, symbols,\nand libraries into the current namespace.",
                         :ns "special",
                         :name "ns",
                         :signature ["[name & references]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :full-name-encode "special_ns",
                         :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args :as form] _ opts]\n  (when-not (symbol? name) \n    (throw (error env \"Namespaces must be named by a symbol.\")))\n  (when (= 1 (count (string/split (clojure.core/name name) #\"\\.\")))\n    (warning :single-segment-namespace env {:name name}))\n  (let [docstring (if (string? (first args)) (first args))\n        args      (if docstring (next args) args)\n        metadata  (if (map? (first args)) (first args))\n        form-meta (meta form)\n        args      (desugar-ns-specs (if metadata (next args) args))\n        name      (vary-meta name merge metadata)\n        excludes  (parse-ns-excludes env args)\n        deps      (atom #{})\n        aliases   (atom {:fns {} :macros {}})\n        spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                      :require-macros (partial parse-require-spec env true deps aliases)\n                      :use            (comp (partial parse-require-spec env false deps aliases)\n                                            (partial use->require env))\n                      :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                            (partial use->require env))\n                      :import         (partial parse-import-spec env deps)}\n        valid-forms (atom #{:use :use-macros :require :require-macros :import})\n        reload (atom {:use nil :require nil :use-macros nil :require-macros nil})\n        {uses :use requires :require use-macros :use-macros require-macros :require-macros imports :import :as params}\n        (reduce\n          (fn [m [k & libs]]\n            (when-not (#{:use :use-macros :require :require-macros :import} k)\n              (throw (error env \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")))\n            (when-not (@valid-forms k)\n              (throw (error env (str \"Only one \" k \" form is allowed per namespace definition\"))))\n            (swap! valid-forms disj k)\n            (when-not (= :import k)\n              (when (some #{:reload} libs)\n                (swap! reload assoc k :reload))\n              (when (some #{:reload-all} libs)\n                (swap! reload assoc k :reload-all)))\n            (apply merge-with merge m\n              (map (spec-parsers k)\n                (remove #{:reload :reload-all} libs))))\n          {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (when (and *analyze-deps* (seq @deps))\n      (analyze-deps name @deps env opts))\n    (when (and *analyze-deps* (seq uses))\n      (check-uses uses env))\n    (set! *cljs-ns* name)\n    (when *load-macros*\n      (load-core)\n      (doseq [nsym (vals use-macros)]\n        (if-let [k (:use-macros @reload)]\n          (clojure.core/require nsym k)\n          (clojure.core/require nsym)))\n      (doseq [nsym (vals require-macros)]\n        (if-let [k (:require-macros @reload)]\n          (clojure.core/require nsym k)\n          (clojure.core/require nsym)))\n      (when (seq use-macros)\n        (check-use-macros use-macros env)))\n    (let [ns-info\n          {:name name\n           :doc docstring\n           :excludes excludes\n           :use-macros use-macros\n           :require-macros require-macros\n           :uses uses\n           :requires requires\n           :imports imports}\n          ns-info\n          (if (:merge form-meta)\n            ;; for merging information in via require usage in REPLs\n            (let [ns-info' (get-in @env/*compiler* [::namespaces name])]\n              (if (pos? (count ns-info'))\n                (let [merge-keys\n                      [:use-macros :require-macros :uses :requires :imports]]\n                  (merge\n                    ns-info'\n                    (merge-with merge\n                      (select-keys ns-info' merge-keys)\n                      (select-keys ns-info merge-keys))))\n                ns-info))\n            ns-info)]\n      (swap! env/*compiler* assoc-in [::namespaces name] ns-info)\n      (merge {:env env :op :ns :form form}\n        (cond-> ns-info\n          (@reload :use)\n          (update-in [:uses]\n            (fn [m] (with-meta m {(@reload :use) true})))\n          (@reload :require)\n          (update-in [:requires]\n            (fn [m] (with-meta m {(@reload :require) true}))))))))",
                                  :repo "clojurescript",
                                  :tag "r2911",
                                  :filename "src/clj/cljs/analyzer.clj",
                                  :lines [1300 1389]},
                         :full-name "special/ns",
                         :clj-symbol "clojure.core/ns"},
           "cljs.core/IReversible" {:ns "cljs.core",
                                    :name "IReversible",
                                    :history [["+" "0.0-1211"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core_IReversible",
                                    :source {:code "(defprotocol IReversible\n  (^clj -rseq [coll]))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [348 349]},
                                    :methods [{:name "-rseq",
                                               :signature ["[coll]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IReversible",
                                    :clj-symbol "clojure.lang/Reversible"},
           "cljs.core/extend-protocol" {:ns "cljs.core",
                                        :name "extend-protocol",
                                        :signature ["[p & specs]"],
                                        :history [["+" "0.0-927"]],
                                        :type "macro",
                                        :full-name-encode "cljs.core_extend-protocol",
                                        :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                 :repo "clojure",
                                                 :tag "clojure-1.6.0",
                                                 :filename "src/clj/clojure/core_deftype.clj",
                                                 :lines [807 845]},
                                        :full-name "cljs.core/extend-protocol",
                                        :clj-symbol "clojure.core/extend-protocol",
                                        :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
           "cljs.reader/read" {:ns "cljs.reader",
                               :name "read",
                               :signature ["[reader eof-is-error sentinel is-recursive]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.reader_read",
                               :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF while reading\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [f (macros ch)\n                 res\n                 (cond\n                  f (f reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (identical? res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/reader.cljs",
                                        :lines [424 441]},
                               :full-name "cljs.reader/read",
                               :clj-symbol "clojure.core/read",
                               :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
           "cljs.core/EmptyList" {:ns "cljs.core",
                                  :name "EmptyList",
                                  :signature ["[meta]"],
                                  :history [["+" "0.0-927"]],
                                  :type "type",
                                  :full-name-encode "cljs.core_EmptyList",
                                  :source {:code "(deftype EmptyList [meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (EmptyList. meta))\n\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] ())\n\n  INext\n  (-next [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] (throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] empty-ordered-hash)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2335 2385]},
                                  :full-name "cljs.core/EmptyList",
                                  :clj-symbol "clojure.lang/EmptyList"},
           "cljs.core/specify!" {:ns "cljs.core",
                                 :name "specify!",
                                 :type "macro",
                                 :signature ["[expr & impls]"],
                                 :source {:code "(defmacro specify! [expr & impls]\n  (let [x (with-meta (gensym \"x\") {:extend :instance})]\n    `(let [~x ~expr]\n       (extend-type ~x ~@impls)\n       ~x)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [631 635]},
                                 :full-name "cljs.core/specify!",
                                 :full-name-encode "cljs.core_specifyBANG",
                                 :history [["+" "0.0-2156"]]},
           "cljs.core/cat" {:ns "cljs.core",
                            :name "cat",
                            :signature ["[rf]"],
                            :history [["+" "0.0-2341"]],
                            :type "function",
                            :full-name-encode "cljs.core_cat",
                            :source {:code "(defn cat\n  [rf]\n  (let [rf1 (preserving-reduced rf)]  \n    (fn\n      ([] (rf))\n      ([result] (rf result))\n      ([result input]\n         (reduce rf1 result input)))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [8568 8578]},
                            :full-name "cljs.core/cat",
                            :docstring "A transducer which concatenates the contents of each input, which must be a\ncollection, into the reduction."},
           "clojure.walk/postwalk" {:ns "clojure.walk",
                                    :name "postwalk",
                                    :signature ["[f form]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.walk_postwalk",
                                    :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/clojure/walk.cljs",
                                             :lines [50 56]},
                                    :full-name "clojure.walk/postwalk",
                                    :clj-symbol "clojure.walk/postwalk",
                                    :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP-THRESHOLD",
                                                             :type "var",
                                                             :parent-type "PersistentArrayMap",
                                                             :source {:code "(set! (.-HASHMAP-THRESHOLD PersistentArrayMap) 8)",
                                                                      :repo "clojurescript",
                                                                      :tag "r2911",
                                                                      :filename "src/cljs/cljs/core.cljs",
                                                                      :lines [5493]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD",
                                                             :full-name-encode "cljs.core_PersistentArrayMapDOTHASHMAP-THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-2301"]]},
           "clojure.zip/edit" {:ns "clojure.zip",
                               :name "edit",
                               :signature ["[loc f & args]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_edit",
                               :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [189 192]},
                               :full-name "clojure.zip/edit",
                               :clj-symbol "clojure.zip/edit",
                               :docstring "Replaces the node at this loc with the value of (f node args)"},
           "cljs.core/unreduced" {:ns "cljs.core",
                                  :name "unreduced",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-2411"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_unreduced",
                                  :source {:code "(defn unreduced\n  [x]\n  (if (reduced? x) (deref x) x))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [913 916]},
                                  :full-name "cljs.core/unreduced",
                                  :docstring "If x is reduced?, returns (deref x), else returns x"},
           "cljs.core/re-seq" {:description "Returns a lazy sequence of successive matches of regex `re` in string `s`.",
                               :ns "cljs.core",
                               :name "re-seq",
                               :signature ["[re s]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/re-find"
                                         "cljs.core/re-pattern"
                                         "cljs.core/re-matches"
                                         "cljs.core/subs"
                                         "clojure.string/split"],
                               :full-name-encode "cljs.core_re-seq",
                               :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (when (seq post-match) (re-seq re post-match)))))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8091 8098]},
                               :full-name "cljs.core/re-seq",
                               :clj-symbol "clojure.core/re-seq",
                               :docstring "Returns a lazy sequence of successive matches of re in s."},
           "cljs.reader/read-list" {:ns "cljs.reader",
                                    :name "read-list",
                                    :type "function",
                                    :signature ["[rdr _]"],
                                    :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [264 266]},
                                    :full-name "cljs.reader/read-list",
                                    :full-name-encode "cljs.reader_read-list",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/IKVReduce" {:ns "cljs.core",
                                  :name "IKVReduce",
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IKVReduce",
                                  :source {:code "(defprotocol IKVReduce\n  (-kv-reduce [coll f init]))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [327 328]},
                                  :methods [{:name "-kv-reduce",
                                             :signature ["[coll f init]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IKVReduce",
                                  :history [["+" "0.0-1211"]]},
           "cljs.core/Atom" {:ns "cljs.core",
                             :name "Atom",
                             :signature ["[state meta validator watches]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core_Atom",
                             :source {:code "(deftype Atom [state meta validator watches]\n  Object\n  (equiv [this other]\n    (-equiv this other))\n\n  IAtom\n  \n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f))\n    this)\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3491 3518]},
                             :full-name "cljs.core/Atom",
                             :clj-symbol "clojure.lang/Atom"},
           "clojure.core.reducers/foldcat" {:ns "clojure.core.reducers",
                                            :name "foldcat",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers_foldcat",
                                            :source {:code "(defn foldcat\n  [coll]\n  (fold cat append! coll))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [237 240]},
                                            :full-name "clojure.core.reducers/foldcat",
                                            :clj-symbol "clojure.core.reducers/foldcat",
                                            :docstring "Equivalent to (fold cat append! coll)"},
           "cljs.core/specify" {:ns "cljs.core",
                                :name "specify",
                                :type "macro",
                                :signature ["[expr & impls]"],
                                :source {:code "(defmacro specify [expr & impls]\n  `(cljs.core/specify! (cljs.core/clone ~expr)\n     ~@impls))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [637 639]},
                                :full-name "cljs.core/specify",
                                :full-name-encode "cljs.core_specify",
                                :history [["+" "0.0-2138"]]},
           "cljs.repl.server/start" {:ns "cljs.repl.server",
                                     :name "start",
                                     :signature ["[opts]"],
                                     :history [["+" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.repl.server_start",
                                     :source {:code "(defn start\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/repl/server.clj",
                                              :lines [168 173]},
                                     :full-name "cljs.repl.server/start",
                                     :docstring "Start the server on the specified port."},
           "cljs.core/IMap" {:ns "cljs.core",
                             :name "IMap",
                             :type "protocol",
                             :full-name-encode "cljs.core_IMap",
                             :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (^clj -dissoc [coll k]))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [294 296]},
                             :methods [{:name "-dissoc",
                                        :signature ["[coll k]"],
                                        :docstring nil}],
                             :full-name "cljs.core/IMap",
                             :history [["+" "0.0-927"]]},
           "cljs.core/pr-sequential-writer" {:ns "cljs.core",
                                             :name "pr-sequential-writer",
                                             :type "function",
                                             :signature ["[writer print-one begin sep end opts coll]"],
                                             :source {:code "(defn pr-sequential-writer [writer print-one begin sep end opts coll]\n  (binding [*print-level* (when-not (nil? *print-level*) (dec *print-level*))]\n    (if (and (not (nil? *print-level*)) (neg? *print-level*))\n      (-write writer \"#\")\n      (do\n        (-write writer begin)\n        (if (zero? (:print-length opts))\n          (when (seq coll)\n            (-write writer (or (:more-marker opts) \"...\")))\n          (do\n            (when (seq coll)\n              (print-one (first coll) writer opts))\n            (loop [coll (next coll) n (dec (:print-length opts))]\n              (if (and coll (or (nil? n) (not (zero? n))))\n                (do\n                  (-write writer sep)\n                  (print-one (first coll) writer opts)\n                  (recur (next coll) (dec n)))\n                (when (and (seq coll) (zero? n))\n                  (-write writer sep)\n                  (-write writer (or (:more-marker opts) \"...\")))))))\n        (-write writer end)))))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [8110
                                                              8131]},
                                             :full-name "cljs.core/pr-sequential-writer",
                                             :full-name-encode "cljs.core_pr-sequential-writer",
                                             :history [["+"
                                                        "0.0-1503"]]},
           "cljs.core/unchecked-multiply" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-multiply",
                                           :signature ["[]"
                                                       "[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :history [["+" "0.0-1798"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_unchecked-multiply",
                                           :source {:code "(defn ^number unchecked-multiply\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply x y))\n  ([x y & more] (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [1992 1997]},
                                           :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-multiply\n  ([& xs] `(* ~@xs)))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/clj/cljs/core.clj",
                                                            :lines [393
                                                                    394]}),
                                           :full-name "cljs.core/unchecked-multiply",
                                           :clj-symbol "clojure.core/unchecked-multiply",
                                           :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.reader/read-vector" {:ns "cljs.reader",
                                      :name "read-vector",
                                      :type "function",
                                      :signature ["[rdr _]"],
                                      :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [270 272]},
                                      :full-name "cljs.reader/read-vector",
                                      :full-name-encode "cljs.reader_read-vector",
                                      :history [["+" "0.0-927"]]},
           "clojure.set/join" {:ns "clojure.set",
                               :name "join",
                               :signature ["[xrel yrel]"
                                           "[xrel yrel km]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.set_join",
                               :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/set.cljs",
                                        :lines [101 129]},
                               :full-name "clojure.set/join",
                               :clj-symbol "clojure.set/join",
                               :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
           "cljs.core/HashMap" {:ns "cljs.core",
                                :name "HashMap",
                                :signature ["[meta count hashobj __hash]"],
                                :history [["+" "0.0-927"]
                                          ["-" "0.0-1798"]],
                                :type "type",
                                :full-name-encode "cljs.core_HashMap",
                                :source {:code "(deftype HashMap [meta count hashobj ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj nil))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj nil))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj nil)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (alength bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj nil)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                         :repo "clojurescript",
                                         :tag "r1586",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3737 3828]},
                                :full-name "cljs.core/HashMap",
                                :removed {:in "0.0-1798",
                                          :last-seen "0.0-1586"}},
           "cljs.repl.browser/handle-get" {:ns "cljs.repl.browser",
                                           :name "handle-get",
                                           :signature ["[opts conn request]"],
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.browser_handle-get",
                                           :source {:code "(defn handle-get [opts conn request]\n  (let [path (:path request)]\n    (cond\n     (.startsWith path \"/repl\") (send-repl-client-page opts conn request)\n     (:serve-static opts) (send-static opts conn request)\n     :else (send-404 conn (:path request)))))",
                                                    :repo "clojurescript",
                                                    :tag "r1450",
                                                    :filename "src/clj/cljs/repl/browser.clj",
                                                    :lines [199 204]},
                                           :full-name "cljs.repl.browser/handle-get",
                                           :removed {:in "0.0-1503",
                                                     :last-seen "0.0-1450"}},
           "cljs.core/es6-iterable" {:ns "cljs.core",
                                     :name "es6-iterable",
                                     :type "macro",
                                     :signature ["[ty]"],
                                     :source {:code "(defmacro es6-iterable [ty]\n  `(aset (.-prototype ~ty) cljs.core/ITER_SYMBOL\n     (fn []\n       (this-as this#\n         (cljs.core/es6-iterator this#)))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1670 1674]},
                                     :full-name "cljs.core/es6-iterable",
                                     :full-name-encode "cljs.core_es6-iterable",
                                     :history [["+" "0.0-2411"]]},
           "cljs.reader/int-pattern" {:ns "cljs.reader",
                                      :name "int-pattern",
                                      :type "var",
                                      :source {:code "(def int-pattern (re-pattern \"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+))(N)?$\"))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [98]},
                                      :full-name "cljs.reader/int-pattern",
                                      :full-name-encode "cljs.reader_int-pattern",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/swap!" {:description "Atomically swaps the value of atom to be: `(apply f current-value-of-atom\nargs)`\n\nNote that `f` may be called multiple times, and thus should be free of side\neffects.\n\nReturns the value that was swapped in.",
                              :ns "cljs.core",
                              :name "swap!",
                              :signature ["[a f]"
                                          "[a f x]"
                                          "[a f x y]"
                                          "[a f x y & more]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/atom"
                                        "cljs.core/reset!"],
                              :full-name-encode "cljs.core_swapBANG",
                              :source {:code "(defn swap!\n  ([a f]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a)))\n       (-swap! a f)))\n  ([a f x]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a) x))\n       (-swap! a f x)))\n  ([a f x y]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a) x y))\n       (-swap! a f x y)))\n  ([a f x y & more]\n     (if (instance? Atom a)\n       (reset! a (apply f (.-state a) x y more))\n       (-swap! a f x y more))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3554 3574]},
                              :full-name "cljs.core/swap!",
                              :clj-symbol "clojure.core/swap!",
                              :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
           "cljs.core/dec" {:description "Returns a number one less than `x`.",
                            :ns "cljs.core",
                            :name "dec",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/inc"],
                            :full-name-encode "cljs.core_dec",
                            :source {:code "(defn dec\n  [x] (- x 1))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1921 1923]},
                            :extra-sources ({:code "(defmacro ^::ana/numeric dec [x]\n  `(- ~x 1))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [460 461]}),
                            :full-name "cljs.core/dec",
                            :clj-symbol "clojure.core/dec",
                            :docstring "Returns a number one less than num."},
           "cljs.core/EntriesIterator" {:ns "cljs.core",
                                        :name "EntriesIterator",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-2268"]
                                                  ["-" "0.0-2371"]],
                                        :type "type",
                                        :full-name-encode "cljs.core_EntriesIterator",
                                        :source {:code "(deftype EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))",
                                                 :repo "clojurescript",
                                                 :tag "r2356",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4874 4881]},
                                        :full-name "cljs.core/EntriesIterator",
                                        :removed {:in "0.0-2371",
                                                  :last-seen "0.0-2356"}},
           "cljs.core/*clojurescript-version*" {:ns "cljs.core",
                                                :name "*clojurescript-version*",
                                                :type "var",
                                                :source {:code "(def *clojurescript-version*)",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [16]},
                                                :full-name "cljs.core/*clojurescript-version*",
                                                :full-name-encode "cljs.core_STARclojurescript-versionSTAR",
                                                :clj-symbol "clojure.core/*clojure-version*",
                                                :history [["+"
                                                           "0.0-2014"]]},
           "clojure.core.reducers/fold" {:ns "clojure.core.reducers",
                                         :name "fold",
                                         :signature ["[reducef coll]"
                                                     "[combinef reducef coll]"
                                                     "[n combinef reducef coll]"],
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers_fold",
                                         :source {:code "(defn fold\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [49 64]},
                                         :full-name "clojure.core.reducers/fold",
                                         :clj-symbol "clojure.core.reducers/fold",
                                         :docstring "Reduces a collection using a (potentially parallel) reduce-combine\nstrategy. The collection is partitioned into groups of approximately\nn (default 512), each of which is reduced with reducef (with a seed\nvalue obtained by calling (combinef) with no arguments). The results\nof these reductions are then reduced with combinef (default\nreducef). combinef must be associative, and, when called with no\narguments, (combinef) must produce its identity element. These\noperations may be performed in parallel, but the results will\npreserve order.\n\nNote: Performing operations in parallel is currently not implemented."},
           "cljs.core/StringBufferWriter" {:ns "cljs.core",
                                           :name "StringBufferWriter",
                                           :type "type",
                                           :signature ["[sb]"],
                                           :source {:code "(deftype StringBufferWriter [sb]\n  IWriter\n  (-write [_ s] (.append sb s))\n  (-flush [_] nil))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [430 433]},
                                           :full-name "cljs.core/StringBufferWriter",
                                           :full-name-encode "cljs.core_StringBufferWriter",
                                           :history [["+" "0.0-1503"]]},
           "cljs.repl.nashorn/eval-resource" {:ns "cljs.repl.nashorn",
                                              :name "eval-resource",
                                              :signature ["[engine path debug]"],
                                              :history [["+"
                                                         "0.0-2814"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.nashorn_eval-resource",
                                              :source {:code "(defn eval-resource \n  [engine path debug]\n  (let [r (io/resource path)]\n    (eval-str engine (slurp r))\n    (when debug (println \"loaded: \" path))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/repl/nashorn.clj",
                                                       :lines [78 83]},
                                              :full-name "cljs.repl.nashorn/eval-resource",
                                              :docstring "Evaluate a file on the classpath in the engine."},
           "clojure.browser.dom/remove-children" {:ns "clojure.browser.dom",
                                                  :name "remove-children",
                                                  :signature ["[id]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.dom_remove-children",
                                                  :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/cljs/clojure/browser/dom.cljs",
                                                           :lines [92
                                                                   96]},
                                                  :full-name "clojure.browser.dom/remove-children",
                                                  :docstring "Remove all children from the element with the passed id."},
           "cljs.core/BlackNode" {:ns "cljs.core",
                                  :name "BlackNode",
                                  :type "type",
                                  :signature ["[key val left right __hash]"],
                                  :source {:code "(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [6626 6726]},
                                  :full-name "cljs.core/BlackNode",
                                  :full-name-encode "cljs.core_BlackNode",
                                  :history [["+" "0.0-1211"]]},
           "syntax/Infinity" {:ns "syntax",
                              :name "Infinity",
                              :type "special symbol",
                              :full-name-encode "syntax_Infinity",
                              :source {:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                       :repo "tools.reader",
                                       :tag "tools.reader-0.8.10",
                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                       :lines [275 301]},
                              :syntax-form ["Infinity"
                                            "-Infinity"
                                            "+Infinity"],
                              :full-name "syntax/Infinity",
                              :history [["+" "0.0-1853"]]},
           "cljs.core/some->" {:description "When `expr` is not nil, threads it into the first form (via `->`), and when that\nresult is not nil, through the next, etc.",
                               :ns "cljs.core",
                               :name "some->",
                               :signature ["[expr & forms]"],
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :related ["cljs.core/->"
                                         "cljs.core/->>"
                                         "cljs.core/some->>"
                                         "cljs.core/some"],
                               :full-name-encode "cljs.core_some-GT",
                               :source {:code "(defmacro some->\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                        :repo "clojure",
                                        :tag "clojure-1.6.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [6923 6932]},
                               :full-name "cljs.core/some->",
                               :clj-symbol "clojure.core/some->",
                               :docstring "When expr is not nil, threads it into the first form (via ->),\nand when that result is not nil, through the next etc"},
           "cljs.core/get-validator" {:description "Returns the validator function for atom `a`.",
                                      :ns "cljs.core",
                                      :name "get-validator",
                                      :signature ["[a]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :related ["cljs.core/atom"
                                                "cljs.core/set-validator!"],
                                      :full-name-encode "cljs.core_get-validator",
                                      :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3595 3598]},
                                      :full-name "cljs.core/get-validator",
                                      :clj-symbol "clojure.core/get-validator",
                                      :docstring "Gets the validator-fn for a var/ref/agent/atom."},
           "cljs.core/coll?" {:description "Returns true if `x` is a collection, false otherwise.\n\nLists, maps, sets, and vectors are collections.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "coll?",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/seq?"
                                        "cljs.core/list?"
                                        "cljs.core/sequential?"],
                              :full-name-encode "cljs.core_collQMARK",
                              :source {:code "(defn ^boolean coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1504 1509]},
                              :examples [{:id "d30884",
                                          :content "```clj\n(coll? [1 2 3])\n;;=> true\n\n(coll? '(1 2 3))\n;;=> true\n\n(coll? #{1 2 3})\n;;=> true\n\n(coll? {:foo 1 :bar 2})\n;;=> true\n```\n\nNot collections:\n\n```clj\n(coll? \"foo\")\n;;=> false\n\n(coll? 123)\n;;=> false\n\n(coll? nil)\n;;=> false\n```"}],
                              :full-name "cljs.core/coll?",
                              :clj-symbol "clojure.core/coll?",
                              :docstring "Returns true if x satisfies ICollection"},
           "cljs.core/unchecked-negate-int" {:ns "cljs.core",
                                             :name "unchecked-negate-int",
                                             :signature ["[x]"],
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_unchecked-negate-int",
                                             :source {:code "(defn unchecked-negate-int [x]\n  (cljs.core/unchecked-negate-int x))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [2009
                                                              2010]},
                                             :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-negate-int\n  ([x] `(- ~x)))",
                                                              :repo "clojurescript",
                                                              :tag "r2911",
                                                              :filename "src/clj/cljs/core.clj",
                                                              :lines [402
                                                                      403]}),
                                             :full-name "cljs.core/unchecked-negate-int",
                                             :clj-symbol "clojure.core/unchecked-negate-int"},
           "cljs.core/bit-or" {:description "Bitwise \"or\". Same as `x | y` in JavaScript.",
                               :ns "cljs.core",
                               :name "bit-or",
                               :signature ["[x y]" "[x y & more]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/bit-and"
                                         "cljs.core/bit-xor"],
                               :full-name-encode "cljs.core_bit-or",
                               :source {:code "(defn bit-or\n  ([x y] (cljs.core/bit-or x y))\n  ([x y & more]\n     (reduce bit-or (cljs.core/bit-or x y) more)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2099 2103]},
                               :extra-sources ({:code "(defmacro ^::ana/numeric bit-or\n  ([x y] (core/list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [502 504]}),
                               :examples [{:id "ecea10",
                                           :content "Bits can be entered using radix notation:\n\n```clj\n(bit-or 2r1100 2r1010)\n;;=> 14\n;; 14 = 2r1110\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-or 12 10)\n;;=> 14\n```"}],
                               :full-name "cljs.core/bit-or",
                               :clj-symbol "clojure.core/bit-or",
                               :docstring "Bitwise or"},
           "cljs.core/nfirst" {:description "Same as `(next (first coll))`.",
                               :ns "cljs.core",
                               :name "nfirst",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/next"],
                               :full-name-encode "cljs.core_nfirst",
                               :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1157 1160]},
                               :examples [{:id "60b8a4",
                                           :content "```clj\n(nfirst [[1 2 3] [4 5]])\n;;=> (2 3)\n\n(nfirst [[1 2] [3 4]])\n;;=> (2)\n\n(nfirst [[1] [2 3]])\n;;=> nil\n\n(nfirst [[] [1 2]])\n;;=> nil\n```"}],
                               :full-name "cljs.core/nfirst",
                               :clj-symbol "clojure.core/nfirst",
                               :docstring "Same as (next (first x))"},
           "cljs.core/keep" {:description "Returns a lazy sequence of the non-nil results of `(f item)`. Note, this means\nfalse return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "keep",
                             :signature ["[f]" "[f coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/keep-indexed"
                                       "cljs.core/map"
                                       "cljs.core/filter"],
                             :full-name-encode "cljs.core_keep",
                             :source {:code "(defn keep\n  ([f]\n   (fn [rf]\n     (fn\n       ([] (rf))\n       ([result] (rf result))\n       ([result input]\n          (let [v (f input)]\n            (if (nil? v)\n              result\n              (rf result v)))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (-nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3457 3486]},
                             :full-name "cljs.core/keep",
                             :clj-symbol "clojure.core/keep",
                             :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects.  Returns a transducer when no collection is provided."},
           "cljs.core/take" {:description "Returns a lazy sequence of the first `n` items in `coll`. Returns all the items\nif there are fewer than `n`.\n\nReturns a stateful transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "take",
                             :signature ["[n]" "[n coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/drop"
                                       "cljs.core/take-while"
                                       "cljs.core/take-last"
                                       "cljs.core/take-nth"],
                             :full-name-encode "cljs.core_take",
                             :source {:code "(defn take\n  ([n]\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na\n                    nn (vswap! na dec)\n                    result (if (pos? n)\n                             (rf result input)\n                             result)]\n                (if (not (pos? nn))\n                  (ensure-reduced result)\n                  result)))))))\n  ([n coll]\n     (lazy-seq\n       (when (pos? n)\n         (when-let [s (seq coll)]\n           (cons (first s) (take (dec n) (rest s))))))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3783 3806]},
                             :full-name "cljs.core/take",
                             :clj-symbol "clojure.core/take",
                             :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n.  Returns a stateful transducer when\nno collection is provided."},
           "cljs.core/PersistentHashSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentHashSet",
                                                :type "var",
                                                :full-name-encode "cljs.core_PersistentHashSetDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentHashSet)\n  (PersistentHashSet. nil (.-EMPTY PersistentArrayMap) empty-unordered-hash))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [7429
                                                                 7430]},
                                                :full-name "cljs.core/PersistentHashSet.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentHashSet.EMPTY"},
           "cljs.core/cond" {:description "`clauses` must be an even number of forms, ie: `(cond t1 e1, t2 e2, t3 e3)`.\nEach test `t` is evaluated one at a time. If a test returns logical true, `cond`\nevaluates and returns the corresponding expression `e` and does not evaluate any\nof the other tests or expressions.\n\nIt is idiomatic to provide a default case as the last test pair using the\nkeyword `:else` (a keyword always evaluates to logical true).\n\n`(cond)` returns nil.",
                             :ns "cljs.core",
                             :name "cond",
                             :signature ["[& clauses]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/condp"
                                       "cljs.core/case"
                                       "special/if"],
                             :full-name-encode "cljs.core_cond",
                             :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [558 571]},
                             :full-name "cljs.core/cond",
                             :clj-symbol "clojure.core/cond",
                             :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
           "cljs.core/bit-and" {:description "Bitwise \"and\".  Same as `x & y` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-and",
                                :signature ["[x y]" "[x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-or"],
                                :full-name-encode "cljs.core_bit-and",
                                :source {:code "(defn bit-and\n  ([x y] (cljs.core/bit-and x y))\n  ([x y & more]\n     (reduce bit-and (cljs.core/bit-and x y) more)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2093 2097]},
                                :extra-sources ({:code "(defmacro ^::ana/numeric bit-and\n  ([x y] (core/list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [493 495]}),
                                :examples [{:id "3c0470",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-and 2r1100 2r1010)\n;;=> 8\n;; 8 = 2r1000\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-and 12 10)\n;;=> 8\n```"}],
                                :full-name "cljs.core/bit-and",
                                :clj-symbol "clojure.core/bit-and",
                                :docstring "Bitwise and"},
           "cljs.core/MetaFn" {:ns "cljs.core",
                               :name "MetaFn",
                               :type "type",
                               :signature ["[afn meta]"],
                               :source {:code "(deftype MetaFn [afn meta]\n  IMeta\n  (-meta [_] meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (MetaFn. afn new-meta))\n  Fn\n  IFn\n  (-invoke [_]\n    (afn))\n  (-invoke [_ a]\n    (afn a))\n  (-invoke [_ a b]\n    (afn a b))\n  (-invoke [_ a b c]\n    (afn a b c))\n  (-invoke [_ a b c d]\n    (afn a b c d))\n  (-invoke [_ a b c d e]\n    (afn a b c d e))\n  (-invoke [_ a b c d e f]\n    (afn a b c d e f))\n  (-invoke [_ a b c d e f g]\n    (afn a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    (afn a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    (afn a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    (afn a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    (afn a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    (afn a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    (afn a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    (afn a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    (afn a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    (afn a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    (afn a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    (afn a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    (afn a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    (afn a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply afn a b c d e f g h i j k l m n o p q r s t rest)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1400 1451]},
                               :full-name "cljs.core/MetaFn",
                               :full-name-encode "cljs.core_MetaFn",
                               :history [["+" "0.0-2234"]]},
           "cljs.core/ObjMap.fromObject" {:ns "cljs.core",
                                          :name "ObjMap.fromObject",
                                          :signature ["[ks obj]"],
                                          :history [["+" "0.0-927"]],
                                          :parent-type "ObjMap",
                                          :type "function",
                                          :full-name-encode "cljs.core_ObjMapDOTfromObject",
                                          :source {:code "(set! (.-fromObject ObjMap) (fn [ks obj] (ObjMap. nil ks obj 0 nil)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5158]},
                                          :full-name "cljs.core/ObjMap.fromObject"},
           "cljs.core/PersistentArrayMap" {:ns "cljs.core",
                                           :name "PersistentArrayMap",
                                           :signature ["[meta cnt arr __hash]"],
                                           :history [["+" "0.0-1211"]],
                                           :type "type",
                                           :full-name-encode "cljs.core_PersistentArrayMap",
                                           :source {:code "(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k]\n    (-lookup coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentArrayMap. meta cnt arr __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentArrayMap. meta cnt arr __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentArrayMap) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (if (implements? IMap other)\n      (let [alen (alength arr)\n            ^not-native other other]\n        (if (== cnt (-count other))\n          (loop [i 0]\n            (if (< i alen)\n              (let [v (-lookup other (aget arr i) lookup-sentinel)]\n                (if-not (identical? v lookup-sentinel)\n                  (if (= (aget arr (inc i)) v)\n                    (recur (+ i 2))\n                    false)\n                  false))\n              true))\n          false))\n      (equiv-map coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  IIterable\n  (-iterator [this]\n    (PersistentArrayMapIterator. arr 0 (* cnt 2)))\n  \n  ISeqable\n  (-seq [coll]\n    (persistent-array-map-seq arr 0 nil))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (== idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (== idx -1)\n        (if (< cnt (.-HASHMAP-THRESHOLD PersistentArrayMap))\n          (let [arr (array-map-extend-kv coll k v)]\n            (PersistentArrayMap. meta (inc cnt) arr nil))\n          (-> (into (.-EMPTY PersistentHashMap) coll)\n            (-assoc k v)\n            (-with-meta meta)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (let [arr (doto (aclone arr)\n                    (aset (inc idx) v))]\n          (PersistentArrayMap. meta cnt arr nil)))))\n\n  (-contains-key? [coll k]\n    (not (== (array-map-index-of coll k) -1)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (>= idx 0)\n        (let [len     (alength arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (>= s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (= k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength arr)]\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))\n          init))))\n  \n  IReduce\n  (-reduce [coll f]\n    (seq-reduce f coll))\n  (-reduce [coll f start]\n    (seq-reduce f start coll))\n  \n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (alength arr) (aclone arr))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [5333 5489]},
                                           :full-name "cljs.core/PersistentArrayMap",
                                           :clj-symbol "clojure.lang/PersistentArrayMap"},
           "clojure.browser.event/unique-event-id" {:ns "clojure.browser.event",
                                                    :name "unique-event-id",
                                                    :type "function",
                                                    :signature ["[event-type]"],
                                                    :source {:code "(defn unique-event-id [event-type])",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [94]},
                                                    :full-name "clojure.browser.event/unique-event-id",
                                                    :full-name-encode "clojure.browser.event_unique-event-id",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/vswap!" {:ns "cljs.core",
                               :name "vswap!",
                               :signature ["[vol f & args]"],
                               :history [["+" "0.0-2496"]],
                               :type "macro",
                               :full-name-encode "cljs.core_vswapBANG",
                               :source {:code "(defmacro vswap!\n  [vol f & args]\n  `(-vreset! ~vol (~f (-deref ~vol) ~@args)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [1687 1692]},
                               :full-name "cljs.core/vswap!",
                               :docstring "Non-atomically swaps the value of the volatile as if:\n(apply f current-value-of-vol args). Returns the value that\nwas swapped in."},
           "cljs.core/ObjMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                 :name "ObjMap.HASHMAP_THRESHOLD",
                                                 :type "var",
                                                 :parent-type "ObjMap",
                                                 :source {:code "(set! (.-HASHMAP_THRESHOLD ObjMap) 8)",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [5156]},
                                                 :full-name "cljs.core/ObjMap.HASHMAP_THRESHOLD",
                                                 :full-name-encode "cljs.core_ObjMapDOTHASHMAP_THRESHOLD",
                                                 :history [["+"
                                                            "0.0-1211"]]},
           "clojure.set/project" {:ns "clojure.set",
                                  :name "project",
                                  :signature ["[xrel ks]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set_project",
                                  :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [67 70]},
                                  :full-name "clojure.set/project",
                                  :clj-symbol "clojure.set/project",
                                  :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
           "cljs.core/int" {:description "Coerces `x` to an integer by stripping decimal places.",
                            :ns "cljs.core",
                            :name "int",
                            :signature ["[x]"],
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :related ["cljs.core/char"
                                      "cljs.core/integer?"],
                            :full-name-encode "cljs.core_int",
                            :source {:code "(defn int\n  [x]\n  (bit-or x 0))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2036 2039]},
                            :extra-sources ({:code "(defmacro ^::ana/numeric int [x]\n  `(bit-or ~x 0))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [506 507]}),
                            :full-name "cljs.core/int",
                            :clj-symbol "clojure.core/int",
                            :docstring "Coerce to int by stripping decimal places."},
           "cljs.repl/js-src->cljs-src" {:return-type File,
                                         :ns "cljs.repl",
                                         :name "js-src->cljs-src",
                                         :signature ["[f]"],
                                         :history [["+" "0.0-2814"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl_js-src-GTcljs-src",
                                         :source {:code "(defn ^File js-src->cljs-src\n  [f]\n  (let [f (io/file f)\n        dir (.getParentFile f)\n        name (.getName f)]\n    (io/file dir (string/replace name \".js\" \".cljs\"))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl.clj",
                                                  :lines [180 187]},
                                         :full-name "cljs.repl/js-src->cljs-src",
                                         :docstring "Map a JavaScript output file back to the original ClojureScript source\nfile."},
           "special/js*" {:ns "special",
                          :name "js*",
                          :type "special form",
                          :source {:code "(defmethod parse 'js*\n  [op env [_ jsform & args :as form] _ _]\n  (when-not (string? jsform)\n    (throw (error env \"Invalid js* form\")))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (lazy-seq\n                         (cons (subs s 0 idx)\n                           (seg (subs s (inc end)))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       (when (-> form meta :numeric)\n         (let [types (map #(infer-tag env %) argexprs)]\n           (when-not (every?\n                       (fn [t]\n                         (or (nil? t)\n                             (and (symbol? t) ('#{any number} t))\n                             ;; TODO: type inference is not strong enough to detect that\n                             ;; when functions like first won't return nil, so variadic\n                             ;; numeric functions like cljs.core/< would produce a spurious\n                             ;; warning without this - David\n                             (and (set? t) (or (contains? t 'number) (contains? t 'any)))))\n                       types)\n             (warning :invalid-arithmetic env\n               {:js-op (-> form meta :js-op)\n                :types (into [] types)}))))\n       {:env env :op :js :segs (seg jsform) :args argexprs\n        :tag (or (-> form meta :tag)\n                 (and (-> form meta :numeric) 'number)\n                 nil)\n        :form form :children argexprs\n        :js-op (-> form meta :js-op)\n        :numeric (-> form meta :numeric)}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (lazy-seq\n                           (cons (subs s 0 idx)\n                             (cons inner\n                               (interp (subs s (inc end))))))))))]\n      {:env env :op :js :form form :code (apply str (interp jsform))\n       :tag (or (-> form meta :tag)\n                (and (-> form meta :numeric) 'number)\n                nil)\n       :js-op (-> form meta :js-op)\n       :numeric (-> form meta :numeric)})))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/clj/cljs/analyzer.clj",
                                   :lines [1505 1558]},
                          :full-name "special/js*",
                          :full-name-encode "special_jsSTAR",
                          :history [["+" "0.0-927"]]},
           "clojure.reflect/macroexpand" {:ns "clojure.reflect",
                                          :name "macroexpand",
                                          :signature ["[form]"],
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "clojure.reflect_macroexpand",
                                          :source {:code "(defn macroexpand\n  [form]\n  (query-reflection (str \"macroform=\" (js/encodeURIComponent (str form))) println))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/clojure/reflect.cljs",
                                                   :lines [32 36]},
                                          :full-name "clojure.reflect/macroexpand",
                                          :docstring "Queries the reflection api with a quoted macro form, then calls the\ncallback function with the macroexpanded form, as a string."},
           "syntax/quote" {:description "Prevent the evaluation of the following form.\n\n`'foo` = `(quote foo)`",
                           :ns "syntax",
                           :name "quote",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["special/quote"],
                           :full-name-encode "syntax_quote",
                           :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                    :repo "tools.reader",
                                    :tag "tools.reader-0.8.10",
                                    :filename "src/main/clojure/clojure/tools/reader.clj",
                                    :lines [591 610]},
                           :extra-sources [{:code "(defn- wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.10",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [335 338]}],
                           :syntax-form "'",
                           :examples [{:id "0d2c26",
                                       :content "```clj\n'foo\n;;=> foo\n\n'(a b c)\n;;=> (a b c)\n\n'[a b c]\n;;=> [a b c]\n\n'(a b (c d))\n;;=> (a b (c d))\n```"}],
                           :full-name "syntax/quote",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.string/trim-newline" {:description "Removes all trailing newline `\\n` or return `\\r` characters from string.\n\nSimilar to Perl's chomp.",
                                          :ns "clojure.string",
                                          :name "trim-newline",
                                          :signature ["[s]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.string_trim-newline",
                                          :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/clojure/string.cljs",
                                                   :lines [162 172]},
                                          :full-name "clojure.string/trim-newline",
                                          :clj-symbol "clojure.string/trim-newline",
                                          :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
           "cljs.repl.reflect/parse-param" {:ns "cljs.repl.reflect",
                                            :name "parse-param",
                                            :signature ["[path]"],
                                            :history [["+" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.reflect_parse-param",
                                            :source {:code "(defn parse-param\n  [path]\n  (-> (str/split path #\"\\?\")\n      (last)\n      (str/split #\"=\")))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/repl/reflect.clj",
                                                     :lines [44 50]},
                                            :full-name "cljs.repl.reflect/parse-param",
                                            :docstring "Parses the query parameter of a path of the form \"/reflect?var=foo\"\ninto the vector [\"var\" \"foo\"]."},
           "cljs.repl/print-mapped-stacktrace" {:ns "cljs.repl",
                                                :name "print-mapped-stacktrace",
                                                :signature ["[stacktrace]"
                                                            "[stacktrace opts]"],
                                                :history [["+"
                                                           "0.0-2814"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl_print-mapped-stacktrace",
                                                :source {:code "(defn print-mapped-stacktrace\n  ([stacktrace] (print-mapped-stacktrace stacktrace *repl-opts*))\n  ([stacktrace opts]\n    (doseq [{:keys [function file line column]}\n            (mapped-stacktrace stacktrace opts)]\n      ((:print opts) \"\\t\" (str function \" (\" file \":\" line \":\" column \")\")))))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/clj/cljs/repl.clj",
                                                         :lines [262
                                                                 269]},
                                                :full-name "cljs.repl/print-mapped-stacktrace",
                                                :docstring "Given a vector representing the canonicalized JavaScript stacktrace\nprint the ClojureScript stacktrace. See mapped-stacktrace."},
           "specialrepl/in-ns" {:description "Only usable from a REPL.\n\nChanges to the namespace `name`, creating it if needed.\n\nSets `*cljs-ns*` to the namespace `name`.",
                                :ns "specialrepl",
                                :name "in-ns",
                                :signature ["[name]"],
                                :history [["+" "0.0-927"]],
                                :type "special form (repl)",
                                :full-name-encode "specialrepl_in-ns",
                                :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n        (when-not (and (= quote 'quote) (symbol? ns-name))\n          (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n        (when-not (ana/get-namespace ns-name)\n          (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n          (-evaluate repl-env \"<cljs repl>\" 1\n            (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n        (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (let [is-self-require? (self-require? specs)\n              [target-ns restore-ns]\n              (if-not is-self-require?\n                [ana/*cljs-ns* nil]\n                ['cljs.user ana/*cljs-ns*])]\n          (evaluate-form repl-env env \"<cljs repl>\"\n            (with-meta\n              `(~'ns ~target-ns\n                 (:require\n                   ~@(map\n                       (fn [quoted-spec-or-kw]\n                         (if (keyword? quoted-spec-or-kw)\n                           quoted-spec-or-kw\n                           (second quoted-spec-or-kw)))\n                       specs)))\n              {:merge true :line 1 :column 1})\n            identity opts)\n          (when is-self-require?\n            (set! ana/*cljs-ns* restore-ns)))))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (evaluate-form repl-env env \"<cljs repl>\"\n          (with-meta\n            `(~'ns ~ana/*cljs-ns*\n               (:require-macros\n                 ~@(map\n                     (fn [quoted-spec-or-kw]\n                       (if (keyword? quoted-spec-or-kw)\n                         quoted-spec-or-kw\n                         (second quoted-spec-or-kw)))\n                     specs)))\n            {:merge true :line 1 :column 1})\n          identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n        (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n        (load-namespace repl-env ns opts)))}))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/repl.clj",
                                         :lines [475 543]},
                                :examples [{:id "e81eb3",
                                            :content "```clj\n(in-ns 'foo.core)\n```"}],
                                :full-name "specialrepl/in-ns",
                                :clj-symbol "clojure.core/in-ns"},
           "special/let*" {:ns "special",
                           :name "let*",
                           :type "special form",
                           :source {:code "(defmethod parse 'let*\n  [op encl-env form _ _]\n  (analyze-let encl-env form false))",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [990 992]},
                           :full-name "special/let*",
                           :full-name-encode "special_letSTAR",
                           :history [["+" "0.0-927"]]},
           "cljs.core/pr-seq-writer" {:ns "cljs.core",
                                      :name "pr-seq-writer",
                                      :type "function",
                                      :signature ["[objs writer opts]"],
                                      :source {:code "(defn pr-seq-writer [objs writer opts]\n  (pr-writer (first objs) writer opts)\n  (doseq [obj (next objs)]\n    (-write writer \" \")\n    (pr-writer obj writer opts)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [8240 8244]},
                                      :full-name "cljs.core/pr-seq-writer",
                                      :full-name-encode "cljs.core_pr-seq-writer",
                                      :history [["+" "0.0-1503"]]},
           "cljs.repl/analyze-source" {:ns "cljs.repl",
                                       :name "analyze-source",
                                       :signature ["[src-dir]"
                                                   "[src-dir opts]"],
                                       :history [["+" "0.0-1503"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl_analyze-source",
                                       :source {:code "(defn analyze-source\n  ([src-dir] (analyze-source src-dir nil))\n  ([src-dir opts]\n    (if-let [src-dir (and (not (empty? src-dir))\n                       (File. src-dir))]\n      (doseq [file (comp/cljs-files-in src-dir)]\n        (ana/analyze-file (str \"file://\" (.getAbsolutePath file)) opts)))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [545 553]},
                                       :full-name "cljs.repl/analyze-source",
                                       :docstring "Given a source directory, analyzes all .cljs files. Used to populate\n(:cljs.analyzer/namespaces compiler-env) so as to support code reflection."},
           "cljs.repl.browser/stop-server" {:ns "cljs.repl.browser",
                                            :name "stop-server",
                                            :signature ["[]"],
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser_stop-server",
                                            :source {:code "(defn stop-server\n  []\n  (.close (:socket @server-state)))",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [272 274]},
                                            :full-name "cljs.repl.browser/stop-server",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "special/throw" {:description "`expr` is evaluated and thrown, hopefully to be caught by a `try` expression.\n\n`(throw (js/Error. \"Oops!\"))`",
                            :ns "special",
                            :name "throw",
                            :signature ["[expr]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :related ["special/try"
                                      "special/catch"
                                      "special/finally"],
                            :full-name-encode "special_throw",
                            :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name _]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [599 604]},
                            :full-name "special/throw",
                            :clj-symbol "clojure.core/throw"},
           "cljs.core/chunk-cons" {:ns "cljs.core",
                                   :name "chunk-cons",
                                   :type "function",
                                   :signature ["[chunk rest]"],
                                   :source {:code "(defn chunk-cons [chunk rest]\n  (if (zero? (-count chunk))\n    rest\n    (ChunkedCons. chunk rest nil nil)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2736 2739]},
                                   :full-name "cljs.core/chunk-cons",
                                   :full-name-encode "cljs.core_chunk-cons",
                                   :history [["+" "0.0-1424"]]},
           "clojure.zip/insert-left" {:ns "clojure.zip",
                                      :name "insert-left",
                                      :signature ["[loc item]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.zip_insert-left",
                                      :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/clojure/zip.cljs",
                                               :lines [165 172]},
                                      :full-name "clojure.zip/insert-left",
                                      :clj-symbol "clojure.zip/insert-left",
                                      :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
           "cljs.core/*print-level*" {:ns "cljs.core",
                                      :name "*print-level*",
                                      :type "dynamic var",
                                      :source {:code "(def ^:dynamic *print-level* nil)",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [38]},
                                      :full-name "cljs.core/*print-level*",
                                      :full-name-encode "cljs.core_STARprint-levelSTAR",
                                      :clj-symbol "clojure.core/*print-level*",
                                      :history [["+" "0.0-2120"]]},
           "cljs.repl/*repl-opts*" {:ns "cljs.repl",
                                    :name "*repl-opts*",
                                    :type "dynamic var",
                                    :source {:code "(def ^:dynamic *repl-opts* nil)",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [31]},
                                    :full-name "cljs.repl/*repl-opts*",
                                    :full-name-encode "cljs.repl_STARrepl-optsSTAR",
                                    :history [["+" "0.0-2911"]]},
           "cljs.core/true?" {:description "Returns true if `x` is the value true, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "true?",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/false?"],
                              :full-name-encode "cljs.core_trueQMARK",
                              :source {:code "(defn ^boolean true?\n  [x] (cljs.core/true? x))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1589 1591]},
                              :extra-sources ({:code "(defmacro true? [x]\n  (bool-expr (core/list 'js* \"~{} === true\" x)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [296 297]}),
                              :full-name "cljs.core/true?",
                              :clj-symbol "clojure.core/true?",
                              :docstring "Returns true if x is the value true, false otherwise."},
           "cljs.core/unchecked-substract-int" {:return-type number,
                                                :ns "cljs.core",
                                                :name "unchecked-substract-int",
                                                :signature ["[x]"
                                                            "[x y]"
                                                            "[x y & more]"],
                                                :history [["+"
                                                           "0.0-1798"]
                                                          ["-"
                                                           "0.0-2277"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_unchecked-substract-int",
                                                :source {:code "(defn ^number unchecked-substract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-substract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                         :repo "clojurescript",
                                                         :tag "r2268",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1812
                                                                 1817]},
                                                :full-name "cljs.core/unchecked-substract-int",
                                                :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                                :removed {:in "0.0-2277",
                                                          :last-seen "0.0-2268"}},
           "clojure.browser.net/xpc-connection" {:ns "clojure.browser.net",
                                                 :name "xpc-connection",
                                                 :signature ["[]"
                                                             "[config]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net_xpc-connection",
                                                 :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (CrossPageChannel.\n      (reduce (fn [sum [k v]]\n                (if-let [field (get xpc-config-fields k)]\n                  (doto sum (aset field v))\n                  sum))\n              (js-obj)\n              config))))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [116
                                                                  138]},
                                                 :full-name "clojure.browser.net/xpc-connection",
                                                 :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API."},
           "cljs.core/ES6EntriesIterator" {:ns "cljs.core",
                                           :name "ES6EntriesIterator",
                                           :type "type",
                                           :signature ["[s]"],
                                           :source {:code "(deftype ES6EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [5161 5168]},
                                           :full-name "cljs.core/ES6EntriesIterator",
                                           :full-name-encode "cljs.core_ES6EntriesIterator",
                                           :history [["+" "0.0-2371"]]},
           "cljs.core/not" {:description "Returns true if `x` is logical false, false otherwise.",
                            :return-type boolean,
                            :ns "cljs.core",
                            :name "not",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/complement"
                                      "cljs.core/false?"],
                            :full-name-encode "cljs.core_not",
                            :source {:code "(defn ^boolean not\n  [x] (if x false true))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [100 102]},
                            :full-name "cljs.core/not",
                            :clj-symbol "clojure.core/not",
                            :docstring "Returns true if x is logical false, false otherwise."},
           "cljs.core/js-obj" {:description "Returns a new JavaScript object using the supplied mappings.\n\n`keyvals` must be an even number of forms.",
                               :ns "cljs.core",
                               :name "js-obj",
                               :signature ["[& keyvals]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/array"],
                               :full-name-encode "cljs.core_js-obj",
                               :source {:code "(defn js-obj\n  ([]\n     (cljs.core/js-obj))\n  ([& keyvals]\n     (apply gobject/create keyvals)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1551 1555]},
                               :extra-sources ({:code "(defmacro js-obj [& rest]\n  (let [sym-or-str? (fn [x] (core/or (core/symbol? x) (core/string? x)))\n        filter-on-keys (fn [f coll]\n                         (->> coll\n                              (filter (fn [[k _]] (f k)))\n                              (into {})))\n        kvs (into {} (map vec (partition 2 rest)))\n        sym-pairs (filter-on-keys core/symbol? kvs)\n        expr->local (zipmap\n                     (filter (complement sym-or-str?) (keys kvs))\n                     (repeatedly gensym))\n        obj (gensym \"obj\")]\n    `(let [~@(apply concat (clojure.set/map-invert expr->local))\n           ~obj ~(js-obj* (filter-on-keys core/string? kvs))]\n       ~@(map (fn [[k v]] `(aset ~obj ~k ~v)) sym-pairs)\n       ~@(map (fn [[k v]] `(aset ~obj ~v ~(core/get kvs k))) expr->local)\n       ~obj)))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [1473 1489]}),
                               :examples [{:id "657cd7",
                                           :content "```clj\n(js-obj \"foo\" 1 \"bar\" 2)\n;;=> #js {:foo 1, :bar 2}\n```"}],
                               :full-name "cljs.core/js-obj"},
           "cljs.core/complement" {:description "Takes a function `f` and returns a function that takes the same arguments as\n`f`, has the same effects, if any, and returns the opposite truth value.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "complement",
                                   :signature ["[f]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/not"],
                                   :full-name-encode "cljs.core_complement",
                                   :source {:code "(defn ^boolean complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3333 3341]},
                                   :full-name "cljs.core/complement",
                                   :clj-symbol "clojure.core/complement",
                                   :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
           "cljs.core/spread" {:ns "cljs.core",
                               :name "spread",
                               :type "function",
                               :signature ["[arglist]"],
                               :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2869 2875]},
                               :full-name "cljs.core/spread",
                               :full-name-encode "cljs.core_spread",
                               :history [["+" "0.0-927"]]},
           "cljs.core/unchecked-double" {:return-type number,
                                         :ns "cljs.core",
                                         :name "unchecked-double",
                                         :signature ["[x]"],
                                         :history [["+" "0.0-1798"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_unchecked-double",
                                         :source {:code "(defn ^number unchecked-double [x] x)",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [1957]},
                                         :extra-sources ({:code "(defmacro unchecked-double [x] x)",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/clj/cljs/core.clj",
                                                          :lines [370]}),
                                         :full-name "cljs.core/unchecked-double",
                                         :clj-symbol "clojure.core/unchecked-double"},
           "cljs.core/keyword" {:ns "cljs.core",
                                :name "keyword",
                                :signature ["[name]" "[ns name]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_keyword",
                                :source {:code "(defn keyword\n  ([name] (cond\n            (keyword? name) name\n            (symbol? name) (Keyword.\n                             (cljs.core/namespace name)\n                             (cljs.core/name name) (.-str name) nil)\n            (string? name) (let [parts (.split name \"/\")]\n                             (if (== (alength parts) 2)\n                               (Keyword. (aget parts 0) (aget parts 1) name nil)\n                               (Keyword. nil (aget parts 0) name nil)))))\n  ([ns name] (Keyword. ns name (str (when ns (str ns \"/\")) name) nil)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2540 2552]},
                                :full-name "cljs.core/keyword",
                                :clj-symbol "clojure.core/keyword",
                                :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
           "syntax/keyword-qualify" {:ns "syntax",
                                     :name "keyword-qualify",
                                     :history [["+" "0.0-927"]],
                                     :type "syntax",
                                     :full-name-encode "syntax_keyword-qualify",
                                     :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [591 610]},
                                     :extra-sources [{:code "(defn- read-keyword\n  [reader initch]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-ns (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (reader-error reader \"Invalid token: :\" token)))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (reader-error reader \"Invalid token: :\" token)))\n      (reader-error reader \"Invalid token: :\"))))",
                                                      :repo "tools.reader",
                                                      :tag "tools.reader-0.8.10",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [315 333]}],
                                     :syntax-form "::",
                                     :full-name "syntax/keyword-qualify",
                                     :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/sort" {:description "Returns a sorted sequence of the items in `coll`.\n\n`comp` can be a boolean-valued comparison funcion, or a -/0/+ valued comparator.\n\n`comp` defaults to `compare`.",
                             :ns "cljs.core",
                             :name "sort",
                             :signature ["[coll]" "[comp coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/sort-by"],
                             :full-name-encode "cljs.core_sort",
                             :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1711 1723]},
                             :full-name "cljs.core/sort",
                             :clj-symbol "clojure.core/sort",
                             :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison function, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "clojure.string/trim" {:description "Removes whitespace from both ends of string.",
                                  :ns "clojure.string",
                                  :name "trim",
                                  :signature ["[s]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string_trim",
                                  :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [147 150]},
                                  :full-name "clojure.string/trim",
                                  :clj-symbol "clojure.string/trim",
                                  :docstring "Removes whitespace from both ends of string."},
           "cljs.core/meta" {:ns "cljs.core",
                             :name "meta",
                             :signature ["[o]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_meta",
                             :source {:code "(defn meta\n  [o]\n  (when (and (not (nil? o))\n             (satisfies? IMeta o))\n    (-meta o)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1462 1467]},
                             :full-name "cljs.core/meta",
                             :clj-symbol "clojure.core/meta",
                             :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
           "clojure.core.reducers/monoid" {:ns "clojure.core.reducers",
                                           :name "monoid",
                                           :signature ["[op ctor]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers_monoid",
                                           :source {:code "(defn monoid\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [242 249]},
                                           :full-name "clojure.core.reducers/monoid",
                                           :clj-symbol "clojure.core.reducers/monoid",
                                           :docstring "Builds a combining fn out of the supplied operator and identity\nconstructor. op must be associative and ctor called with no args\nmust return an identity value for it."},
           "cljs.core/time" {:ns "cljs.core",
                             :name "time",
                             :signature ["[expr]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core_time",
                             :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.))\n         ret# ~expr]\n     (prn (core/str \"Elapsed time: \" (- (.getTime (js/Date.)) start#) \" msecs\"))\n     ret#))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1595 1601]},
                             :full-name "cljs.core/time",
                             :clj-symbol "clojure.core/time",
                             :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
           "cljs.core/boolean" {:description "Return `false` if `x` is false or nil.  Otherwise return `true`.  This is the\ntruthiness condition used by `if` expressions.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "boolean",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["special/if"],
                                :full-name-encode "cljs.core_boolean",
                                :source {:code "(defn ^boolean boolean [x]\n  (if x true false))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1608 1609]},
                                :examples [{:id "9edf3a",
                                            :content "```clj\n(boolean 1)\n;;=> true\n\n(boolean 0)\n;;=> true\n\n(boolean nil)\n;;=> false\n```"}],
                                :full-name "cljs.core/boolean",
                                :clj-symbol "clojure.core/boolean"},
           "cljs.reader/read-token" {:ns "cljs.reader",
                                     :name "read-token",
                                     :type "function",
                                     :signature ["[rdr initch]"],
                                     :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (.toString sb))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [79 87]},
                                     :full-name "cljs.reader/read-token",
                                     :full-name-encode "cljs.reader_read-token",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/update-in" {:description "\"Updates\" a value in a nested associative structure, where `ks` is a sequence of\nkeys and `f` is a function that will take the old value and any supplied\narguments and return the new value. Returns a new nested structure.\n\nIf any levels do not exist, hash-maps will be created.",
                                  :ns "cljs.core",
                                  :name "update-in",
                                  :signature ["[m [k & ks] f]"
                                              "[m [k & ks] f a]"
                                              "[m [k & ks] f a b]"
                                              "[m [k & ks] f a b c]"
                                              "[m [k & ks] f a b c & args]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/assoc-in"
                                            "cljs.core/get-in"],
                                  :full-name-encode "cljs.core_update-in",
                                  :source {:code "(defn update-in\n  ([m [k & ks] f]\n   (if ks\n     (assoc m k (update-in (get m k) ks f))\n     (assoc m k (f (get m k)))))\n  ([m [k & ks] f a]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a))\n     (assoc m k (f (get m k) a))))\n  ([m [k & ks] f a b]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b))\n     (assoc m k (f (get m k) a b))))\n  ([m [k & ks] f a b c]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b c))\n     (assoc m k (f (get m k) a b c))))\n  ([m [k & ks] f a b c & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f a b c args))\n     (assoc m k (apply f (get m k) a b c args)))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [4112 4137]},
                                  :full-name "cljs.core/update-in",
                                  :clj-symbol "clojure.core/update-in",
                                  :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
           "cljs.core/map-indexed" {:description "Returns a lazy sequence consisting of the result of applying `f` to 0 and the\nfirst item of `coll`, followed by applying `f` to 1 and the second item in\n`coll`, etc, until `coll` is exhausted.\n\nFunction `f` should accept 2 arguments, index and item.",
                                    :ns "cljs.core",
                                    :name "map-indexed",
                                    :signature ["[f coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/map"
                                              "cljs.core/keep-indexed"],
                                    :full-name-encode "cljs.core_map-indexed",
                                    :source {:code "(defn map-indexed\n  ([f]\n    (fn [rf]\n      (let [i (volatile! -1)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (rf result (f (vswap! i inc) input)))))))\n  ([f coll]\n    (letfn [(mapi [idx coll]\n              (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (chunk-append b (f (+ idx i) (-nth c i))))\n                      (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                    (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n      (mapi 0 coll))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3430 3455]},
                                    :full-name "cljs.core/map-indexed",
                                    :clj-symbol "clojure.core/map-indexed",
                                    :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
           "cljs.core/IVolatile" {:ns "cljs.core",
                                  :name "IVolatile",
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IVolatile",
                                  :source {:code "(defprotocol IVolatile\n  (-vreset! [o new-value]))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [422 423]},
                                  :methods [{:name "-vreset!",
                                             :signature ["[o new-value]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IVolatile",
                                  :history [["+" "0.0-2496"]]},
           "cljs.core/printf" {:ns "cljs.core",
                               :name "printf",
                               :signature ["[fmt & args]"],
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core_printf",
                               :source {:code "(defn printf\n  [fmt & args]\n  (print (apply format fmt args)))",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6758 6761]},
                               :full-name "cljs.core/printf",
                               :clj-symbol "clojure.core/printf",
                               :docstring "Prints formatted output, as per format",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "clojure.core.reducers/map" {:ns "clojure.core.reducers",
                                        :name "map",
                                        :signature ["[f]" "[f coll]"],
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers_map",
                                        :source {:code "(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [96 104]},
                                        :full-name "clojure.core.reducers/map",
                                        :clj-symbol "clojure.core.reducers/map",
                                        :docstring "Applies f to every value in the reduction of coll. Foldable."},
           "cljs.core/IStack" {:ns "cljs.core",
                               :name "IStack",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core_IStack",
                               :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (^clj -pop [coll]))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [305 307]},
                               :methods [{:name "-peek",
                                          :signature ["[coll]"],
                                          :docstring nil}
                                         {:name "-pop",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IStack",
                               :clj-symbol "clojure.lang/IPersistentStack"},
           "cljs.reader/parse-and-validate-timestamp" {:ns "cljs.reader",
                                                       :name "parse-and-validate-timestamp",
                                                       :type "function",
                                                       :signature ["[s]"],
                                                       :source {:code "(defn parse-and-validate-timestamp [s]\n  (let [[_ years months days hours minutes seconds fraction offset-sign offset-hours offset-minutes :as v] \n        (re-matches timestamp-regex s)]\n    (if-not v\n      (reader-error nil (str \"Unrecognized date/time syntax: \" s))\n      (let [years (parse-int years)\n            months (or (parse-int months) 1)\n            days (or (parse-int days) 1)\n            hours (or (parse-int hours) 0)\n            minutes (or (parse-int minutes) 0)\n            seconds (or (parse-int seconds) 0)\n            fraction (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n            offset-sign (if (= offset-sign \"-\") -1 1)\n            offset-hours (or (parse-int offset-hours) 0)\n            offset-minutes (or (parse-int offset-minutes) 0)\n            offset (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n        [years\n         (check 1 months 12 \"timestamp month field must be in range 1..12\")\n         (check 1 days (days-in-month months (leap-year? years)) \"timestamp day field must be in range 1..last day in month\")\n         (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n         (check 0 minutes 59 \"timestamp minute field must be in range 0..59\")\n         (check 0 seconds (if (= minutes 59) 60 59) \"timestamp second field must be in range 0..60\")\n         (check 0 fraction 999 \"timestamp millisecond field must be in range 0..999\")\n         offset]))))",
                                                                :repo "clojurescript",
                                                                :tag "r2911",
                                                                :filename "src/cljs/cljs/reader.cljs",
                                                                :lines [492
                                                                        515]},
                                                       :full-name "cljs.reader/parse-and-validate-timestamp",
                                                       :full-name-encode "cljs.reader_parse-and-validate-timestamp",
                                                       :history [["+"
                                                                  "0.0-1853"]]},
           "cljs.core/ISorted" {:ns "cljs.core",
                                :name "ISorted",
                                :history [["+" "0.0-1211"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_ISorted",
                                :source {:code "(defprotocol ISorted\n  (^clj -sorted-seq [coll ascending?])\n  (^clj -sorted-seq-from [coll k ascending?])\n  (-entry-key [coll entry])\n  (-comparator [coll]))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [351 355]},
                                :methods [{:name "-sorted-seq",
                                           :signature ["[coll ascending?]"],
                                           :docstring nil}
                                          {:name "-sorted-seq-from",
                                           :signature ["[coll k ascending?]"],
                                           :docstring nil}
                                          {:name "-entry-key",
                                           :signature ["[coll entry]"],
                                           :docstring nil}
                                          {:name "-comparator",
                                           :signature ["[coll]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ISorted",
                                :clj-symbol "clojure.lang/Sorted"},
           "cljs.test/file-and-line" {:ns "cljs.test",
                                      :name "file-and-line",
                                      :type "function",
                                      :signature ["[exception depth]"],
                                      :source {:code "(defn file-and-line [exception depth]\n  (let [stack (.-stack exception)]\n      (if (and stack (string? stack))\n        ;; TODO: flesh out\n        (let [stacktrace\n              (vec (map string/trim\n                     (string/split stack #\"\\n\")))\n              stack-element (nth stacktrace depth)\n              fname (js-filename stack-element)\n              [line column] (js-line-and-column stack-element)\n              [fname line column] (mapped-line-and-column fname line column)]\n          {:file fname :line line :column column})\n        {:file (.-fileName exception)\n         :line (.-lineNumber exception)}))  )",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/test.cljs",
                                               :lines [374 387]},
                                      :full-name "cljs.test/file-and-line",
                                      :full-name-encode "cljs.test_file-and-line",
                                      :history [["+" "0.0-2496"]]},
           "cljs.core/IIndexed" {:ns "cljs.core",
                                 :name "IIndexed",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IIndexed",
                                 :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [274 275]},
                                 :methods [{:name "-nth",
                                            :signature ["[coll n]"
                                                        "[coll n not-found]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IIndexed",
                                 :clj-symbol "clojure.lang/Indexed"},
           "clojure.browser.repl/repl-print" {:ns "clojure.browser.repl",
                                              :name "repl-print",
                                              :type "function",
                                              :signature ["[data]"],
                                              :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [28 30]},
                                              :full-name "clojure.browser.repl/repl-print",
                                              :full-name-encode "clojure.browser.repl_repl-print",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.browser.net/xpc-config-fields" {:ns "clojure.browser.net",
                                                    :name "xpc-config-fields",
                                                    :type "var",
                                                    :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (.toLowerCase k))\n            v])\n         (js->clj CfgFields))))",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [73
                                                                     79]},
                                                    :full-name "clojure.browser.net/xpc-config-fields",
                                                    :full-name-encode "clojure.browser.net_xpc-config-fields",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/ISwap" {:ns "cljs.core",
                              :name "ISwap",
                              :type "protocol",
                              :full-name-encode "cljs.core_ISwap",
                              :source {:code "(defprotocol ISwap\n  (-swap! [o f] [o f a] [o f a b] [o f a b xs]))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [419 420]},
                              :methods [{:name "-swap!",
                                         :signature ["[o f]"
                                                     "[o f a]"
                                                     "[o f a b]"
                                                     "[o f a b xs]"],
                                         :docstring nil}],
                              :full-name "cljs.core/ISwap",
                              :history [["+" "0.0-2173"]]},
           "cljs.core/nnext" {:description "Same as `(next (next coll))`.",
                              :ns "cljs.core",
                              :name "nnext",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/next"],
                              :full-name-encode "cljs.core_nnext",
                              :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1167 1170]},
                              :full-name "cljs.core/nnext",
                              :clj-symbol "clojure.core/nnext",
                              :docstring "Same as (next (next x))"},
           "cljs.core/*print-meta*" {:ns "cljs.core",
                                     :name "*print-meta*",
                                     :type "dynamic var",
                                     :source {:code "(def ^:dynamic *print-meta* false)",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [35]},
                                     :full-name "cljs.core/*print-meta*",
                                     :full-name-encode "cljs.core_STARprint-metaSTAR",
                                     :clj-symbol "clojure.core/*print-meta*",
                                     :history [["+" "0.0-927"]]},
           "cljs.reader/read-dispatch" {:ns "cljs.reader",
                                        :name "read-dispatch",
                                        :type "function",
                                        :signature ["[rdr _]"],
                                        :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (if-let [obj (maybe-read-tagged-type rdr ch)]\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [250 258]},
                                        :full-name "cljs.reader/read-dispatch",
                                        :full-name-encode "cljs.reader_read-dispatch",
                                        :history [["+" "0.0-927"]]},
           "cljs.test/run-block" {:ns "cljs.test",
                                  :name "run-block",
                                  :signature ["[fns]"],
                                  :history [["+" "0.0-2814"]],
                                  :type "function",
                                  :full-name-encode "cljs.test_run-block",
                                  :source {:code "(defn run-block\n  [fns]\n  (when-first [f fns]\n    (let [obj (f)]\n      (if (async? obj)\n        (obj (let [d (delay (run-block (rest fns)))]\n               (fn []\n                 (if (realized? d)\n                   (println \"WARNING: Async test called done more than one time.\")\n                   @d))))\n        (recur (cond->> (rest fns)\n                 (::block? (meta obj)) (concat obj)))))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/test.cljs",
                                           :lines [408 425]},
                                  :full-name "cljs.test/run-block",
                                  :docstring "Invoke all functions in fns with no arguments. A fn can optionally\nreturn\n\nan async test - is invoked with a continuation running left fns\n\na seq of fns tagged per block - are invoked immediately after fn"},
           "cljs.core/distinct" {:description "Returns a lazy sequence of the elements of `coll` with duplicates removed.",
                                 :ns "cljs.core",
                                 :name "distinct",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/distinct?"],
                                 :full-name-encode "cljs.core_distinct",
                                 :source {:code "(defn distinct\n  ([]\n    (fn [rf]\n      (let [seen (volatile! #{})]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if (contains? @seen input)\n              result\n              (do (vswap! seen conj input)\n                  (rf result input))))))))\n  ([coll]\n    (let [step (fn step [xs seen]\n                 (lazy-seq\n                   ((fn [[f :as xs] seen]\n                      (when-let [s (seq xs)]\n                        (if (contains? seen f)\n                          (recur (rest s) seen)\n                          (cons f (step (rest s) (conj seen f))))))\n                     xs seen)))]\n      (step coll #{}))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7636 7658]},
                                 :full-name "cljs.core/distinct",
                                 :clj-symbol "clojure.core/distinct",
                                 :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
           "cljs.reader/wrapping-reader" {:ns "cljs.reader",
                                          :name "wrapping-reader",
                                          :type "function",
                                          :signature ["[sym]"],
                                          :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [361 364]},
                                          :full-name "cljs.reader/wrapping-reader",
                                          :full-name-encode "cljs.reader_wrapping-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/LazyTransformer" {:ns "cljs.core",
                                        :name "LazyTransformer",
                                        :type "type",
                                        :signature ["[stepper first rest meta]"],
                                        :source {:code "(deftype LazyTransformer [^:mutable stepper ^:mutable first ^:mutable rest meta]\n  IWithMeta\n  (-with-meta [this new-meta]\n    (LazyTransformer. stepper first rest new-meta))\n\n  ICollection\n  (-conj [this o]\n    (cons o (-seq this)))\n\n  IEmptyableCollection\n  (-empty [this]\n    ())\n\n  ISequential\n  IEquiv\n  (-equiv [this other]\n    (let [s (-seq this)]\n      (if-not (nil? s)\n        (equiv-sequential this other)\n        (and (sequential? other)\n             (nil? (seq other))))))\n\n  IHash\n  (-hash [this]\n    (hash-ordered-coll this))\n\n  ISeqable\n  (-seq [this]\n    (when-not (nil? stepper)\n      (.step stepper this))\n    (if (nil? rest)\n      nil\n      this))\n\n  ISeq\n  (-first [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      nil\n      first))\n\n  (-rest [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      ()\n      rest))\n\n  INext\n  (-next [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      nil\n      (-seq rest))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [3205 3260]},
                                        :full-name "cljs.core/LazyTransformer",
                                        :full-name-encode "cljs.core_LazyTransformer",
                                        :history [["+" "0.0-2301"]]},
           "cljs.core/double-array" {:ns "cljs.core",
                                     :name "double-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :history [["+" "0.0-1211"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_double-array",
                                     :source {:code "(defn double-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (double-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2821 2839]},
                                     :full-name "cljs.core/double-array",
                                     :clj-symbol "clojure.core/double-array"},
           "cljs.core/prn" {:ns "cljs.core",
                            :name "prn",
                            :signature ["[& objs]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core_prn",
                            :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [8323 8328]},
                            :full-name "cljs.core/prn",
                            :clj-symbol "clojure.core/prn",
                            :docstring "Same as pr followed by (newline)."},
           "cljs.core/chunked-seq" {:ns "cljs.core",
                                    :name "chunked-seq",
                                    :type "function",
                                    :signature ["[vec i off]"
                                                "[vec node i off]"
                                                "[vec node i off meta]"],
                                    :source {:code "(defn chunked-seq\n  ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n  ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (ChunkedSeq. vec node i off meta nil)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [4569 4573]},
                                    :full-name "cljs.core/chunked-seq",
                                    :full-name-encode "cljs.core_chunked-seq",
                                    :history [["+" "0.0-1424"]]},
           "clojure.zip/leftmost" {:ns "clojure.zip",
                                   :name "leftmost",
                                   :signature ["[loc]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip_leftmost",
                                   :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [157 163]},
                                   :full-name "clojure.zip/leftmost",
                                   :clj-symbol "clojure.zip/leftmost",
                                   :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
           "cljs.core/nthrest" {:description "Returns the `nth` rest of `coll`.\n\nReturns `coll` when `n` is 0.",
                                :ns "cljs.core",
                                :name "nthrest",
                                :signature ["[coll n]"],
                                :history [["+" "0.0-2411"]],
                                :type "function",
                                :related ["cljs.core/drop"
                                          "cljs.core/nthnext"
                                          "cljs.core/nth"],
                                :full-name-encode "cljs.core_nthrest",
                                :source {:code "(defn nthrest\n  [coll n]\n    (loop [n n xs coll]\n      (if (and (pos? n) (seq xs))\n        (recur (dec n) (rest xs))\n        xs)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1316 1322]},
                                :full-name "cljs.core/nthrest",
                                :clj-symbol "clojure.core/nthrest",
                                :docstring "Returns the nth rest of coll, coll when n is 0."},
           "cljs.core/js-in" {:description "Determines if property `key` is in JavaScript object `obj`.\n\nEquivalent to `key in obj` in JavaScript.",
                              :ns "cljs.core",
                              :name "js-in",
                              :signature ["[key obj]"],
                              :history [["+" "0.0-2411"]],
                              :type "macro",
                              :related ["cljs.core/contains?"],
                              :full-name-encode "cljs.core_js-in",
                              :source {:code "(defmacro js-in [key obj]\n  (core/list 'js* \"~{} in ~{}\" key obj))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [290 291]},
                              :examples [{:id "a45b18",
                                          :content "```clj\n(def a #js {:foo 1 :bar 2})\n\n(js-in \"foo\" a)\n;;=> true\n\n(js-in \"hello\" a)\n;;=> false\n```\n\nProperties inherited from prototype chain are also detected:\n\n```clj\n(js-in \"toString\" a)\n;;=> true\n```"}],
                              :full-name "cljs.core/js-in"},
           "cljs.test/function?" {:ns "cljs.test",
                                  :name "function?",
                                  :signature ["[menv x]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test_functionQMARK",
                                  :source {:code "(defn function?\n  [menv x]\n  (and (symbol? x) (:fn-var (ana-api/resolve menv x))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/test.clj",
                                           :lines [18 22]},
                                  :full-name "cljs.test/function?",
                                  :clj-symbol "clojure.test/function?",
                                  :docstring "Returns true if argument is a function or a symbol that resolves to\na function (not a macro)."},
           "cljs.core/>=" {:description "Returns true if each successive number argument is less than or equal to the\nprevious one, false otherwise.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name ">=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/>"],
                           :full-name-encode "cljs.core_GTEQ",
                           :source {:code "(defn ^boolean >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1909 1919]},
                           :extra-sources ({:code "(defmacro ^::ana/numeric >=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [450 453]}),
                           :examples [{:id "de73d7",
                                       :content "```clj\n(>= 2 1)\n;;=> true\n\n(>= 2 2)\n;;=> true\n\n(>= 1 2)\n;;=> false\n\n(>= 6 5 4 3 2)\n;;=> true\n```"}],
                           :full-name "cljs.core/>=",
                           :clj-symbol "clojure.core/>=",
                           :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
           "clojure.browser.net/websocket-connection" {:ns "clojure.browser.net",
                                                       :name "websocket-connection",
                                                       :type "function",
                                                       :signature ["[]"
                                                                   "[auto-reconnect?]"
                                                                   "[auto-reconnect? next-reconnect-fn]"],
                                                       :source {:code "(defn websocket-connection\n  ([]\n     (websocket-connection nil nil))\n  ([auto-reconnect?]\n     (websocket-connection auto-reconnect? nil))\n  ([auto-reconnect? next-reconnect-fn]\n     (WebSocket. auto-reconnect? next-reconnect-fn)))",
                                                                :repo "clojurescript",
                                                                :tag "r2911",
                                                                :filename "src/cljs/clojure/browser/net.cljs",
                                                                :lines [174
                                                                        180]},
                                                       :full-name "clojure.browser.net/websocket-connection",
                                                       :full-name-encode "clojure.browser.net_websocket-connection",
                                                       :history [["+"
                                                                  "0.0-2911"]]},
           "cljs.repl.browser/read-request" {:ns "cljs.repl.browser",
                                             :name "read-request",
                                             :signature ["[rdr]"],
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser_read-request",
                                             :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [161 165]},
                                             :full-name "cljs.repl.browser/read-request",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.reader/macros" {:ns "cljs.reader",
                                 :name "macros",
                                 :type "function",
                                 :signature ["[c]"],
                                 :source {:code "(defn macros [c]\n  (cond\n   (identical? c \\\") read-string*\n   (identical? c \\:) read-keyword\n   (identical? c \\;) read-comment\n   (identical? c \\') (wrapping-reader 'quote)\n   (identical? c \\@) (wrapping-reader 'deref)\n   (identical? c \\^) read-meta\n   (identical? c \\`) not-implemented\n   (identical? c \\~) not-implemented\n   (identical? c \\() read-list\n   (identical? c \\)) read-unmatched-delimiter\n   (identical? c \\[) read-vector\n   (identical? c \\]) read-unmatched-delimiter\n   (identical? c \\{) read-map\n   (identical? c \\}) read-unmatched-delimiter\n   (identical? c \\\\) read-char\n   (identical? c \\#) read-dispatch\n   :else nil))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/reader.cljs",
                                          :lines [394 412]},
                                 :full-name "cljs.reader/macros",
                                 :full-name-encode "cljs.reader_macros",
                                 :history [["+" "0.0-927"]]},
           "cljs.build.api/target-file-for-cljs-ns" {:return-type File,
                                                     :ns "cljs.build.api",
                                                     :name "target-file-for-cljs-ns",
                                                     :signature ["[ns-sym]"
                                                                 "[ns-sym output-dir]"],
                                                     :history [["+"
                                                                "0.0-2496"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.build.api_target-file-for-cljs-ns",
                                                     :source {:code "(defn ^File target-file-for-cljs-ns\n  ([ns-sym] (target-file-for-cljs-ns ns-sym nil))\n  ([ns-sym output-dir]\n    (util/to-target-file\n      (util/output-directory {:output-dir output-dir})\n      {:ns ns-sym})))",
                                                              :repo "clojurescript",
                                                              :tag "r2911",
                                                              :filename "src/clj/cljs/build/api.clj",
                                                              :lines [24
                                                                      35]},
                                                     :full-name "cljs.build.api/target-file-for-cljs-ns",
                                                     :docstring "Given an output directory and a clojurescript namespace return the\ncompilation target file for that namespace.\n\nFor example:\n(target-file-from-cljs-ns \"resources/out\" 'example.core) ->\n<File: \"resources/out/example/core.js\">"},
           "cljs.core/doseq" {:description "Repeatedly executes `body` (presumably for side-effects) with bindings and\nfiltering as provided by `for`. Does not retain the head of the sequence.\n\nReturns nil.",
                              :ns "cljs.core",
                              :name "doseq",
                              :signature ["[seq-exprs & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/doall"
                                        "cljs.core/dorun"
                                        "cljs.core/for"
                                        "cljs.core/dotimes"],
                              :full-name-encode "cljs.core_doseq",
                              :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [err (fn [& msg] (throw (ex-info (apply core/str msg) {})))\n        step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n\n                       seqsym (gensym \"seq__\")\n                       recform (if (core/keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (core/cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     (core/keyword? k) (err \"Invalid 'doseq' keyword\" k)\n                     :else (let [chunksym (with-meta (gensym \"chunk__\")\n                                            {:tag 'not-native})\n                                 countsym (gensym \"count__\")\n                                 isym     (gensym \"i__\")\n                                 recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                 steppair-chunk (step recform-chunk (nnext exprs))\n                                 subform-chunk  (steppair-chunk 1)]\n                             [true `(loop [~seqsym   (seq ~v)\n                                           ~chunksym nil\n                                           ~countsym 0\n                                           ~isym     0]\n                                      (if (coercive-boolean (< ~isym ~countsym))\n                                        (let [~k (-nth ~chunksym ~isym)]\n                                          ~subform-chunk\n                                          ~@(when needrec [recform-chunk]))\n                                        (when-let [~seqsym (seq ~seqsym)]\n                                          (if (chunked-seq? ~seqsym)\n                                            (let [c# (chunk-first ~seqsym)]\n                                              (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                            (let [~k (first ~seqsym)]\n                                              ~subform\n                                              ~@(when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1341 1395]},
                              :full-name "cljs.core/doseq",
                              :clj-symbol "clojure.core/doseq",
                              :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
           "cljs.core/*" {:description "Returns the product of nums.\n\n`(*)` returns 1.",
                          :return-type number,
                          :ns "cljs.core",
                          :name "*",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/+" "cljs.core//"],
                          :full-name-encode "cljs.core_STAR",
                          :source {:code "(defn ^number *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1857 1862]},
                          :extra-sources ({:code "(defmacro ^::ana/numeric *\n  ([] 1)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [419 423]}),
                          :examples [{:id "bc4a1f",
                                      :content "```clj\n;; there is an implicit 1\n(*)\n;;=> 1\n\n;; the implicit 1 comes into play\n(* 6)\n;;=> 6\n\n(* 2 3)\n;;=> 6\n\n(* 2 3 4)\n;;=> 24\n```"}],
                          :full-name "cljs.core/*",
                          :clj-symbol "clojure.core/*",
                          :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/into" {:description "Returns a new collection consisting of `to` with all of the items of `from`\n\"added\" using `conj`.\n\nA transducer may be supplied as `xform`.",
                             :ns "cljs.core",
                             :name "into",
                             :signature ["[to from]"
                                         "[to xform from]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/conj"],
                             :full-name-encode "cljs.core_into",
                             :source {:code "(defn into\n  ([to from]\n     (if-not (nil? to)\n       (if (implements? IEditableCollection to)\n         (with-meta (persistent! (reduce -conj! (transient to) from)) (meta to))\n         (reduce -conj to from))\n       (reduce conj () from)))\n  ([to xform from]\n     (if (implements? IEditableCollection to)\n       (with-meta (persistent! (transduce xform conj! (transient to) from)) (meta to))\n       (transduce xform conj to from))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [4021 4033]},
                             :full-name "cljs.core/into",
                             :clj-symbol "clojure.core/into",
                             :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined. A transducer may be supplied."},
           "cljs.repl.server/state" {:ns "cljs.repl.server",
                                     :name "state",
                                     :type "var",
                                     :source {:code "(defonce state\n  (atom\n    {:socket nil\n     :connection nil\n     :promised-conn nil}))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/repl/server.clj",
                                              :lines [8 12]},
                                     :full-name "cljs.repl.server/state",
                                     :full-name-encode "cljs.repl.server_state",
                                     :history [["+" "0.0-1503"]]},
           "cljs.core/defmethod" {:ns "cljs.core",
                                  :name "defmethod",
                                  :signature ["[multifn dispatch-val & fn-tail]"],
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core_defmethod",
                                  :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [1590 1593]},
                                  :full-name "cljs.core/defmethod",
                                  :clj-symbol "clojure.core/defmethod",
                                  :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
           "cljs.core/rest" {:description "Returns a possibly empty sequence of the items after the first item.\n\nCalls `seq` on its argument.",
                             :return-type seq,
                             :ns "cljs.core",
                             :name "rest",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/next"
                                       "cljs.core/first"
                                       "cljs.core/drop"
                                       "cljs.core/pop"],
                             :full-name-encode "cljs.core_rest",
                             :source {:code "(defn ^seq rest\n  [coll]\n  (if-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-rest ^not-native coll)\n      (let [s (seq coll)]\n        (if s\n          (-rest ^not-native s)\n          ())))\n    ()))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [740 751]},
                             :examples [{:id "0869af",
                                         :content "```clj\n(rest [1 2 3])\n;;=> (2 3)\n\n(rest [1 2])\n;;=> (2)\n\n(rest [1])\n;;=> ()\n\n(rest [])\n;;=> ()\n```"}],
                             :full-name "cljs.core/rest",
                             :clj-symbol "clojure.core/rest",
                             :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
           "cljs.reader/unicode-4-pattern" {:ns "cljs.reader",
                                            :name "unicode-4-pattern",
                                            :type "var",
                                            :source {:code "(def unicode-4-pattern (re-pattern \"^[0-9A-Fa-f]{4}$\"))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [182]},
                                            :full-name "cljs.reader/unicode-4-pattern",
                                            :full-name-encode "cljs.reader_unicode-4-pattern",
                                            :history [["+" "0.0-1424"]]},
           "cljs.core/dotimes" {:description "Repeatedly executes `body` (presumably for side-effects) with `name` bound to\nintegers from 0 through `n`-1.",
                                :ns "cljs.core",
                                :name "dotimes",
                                :signature ["[[name n] & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/repeat"
                                          "cljs.core/for"
                                          "cljs.core/doseq"],
                                :full-name-encode "cljs.core_dotimes",
                                :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1522 1534]},
                                :full-name "cljs.core/dotimes",
                                :clj-symbol "clojure.core/dotimes",
                                :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
           "cljs.core/dedupe" {:ns "cljs.core",
                               :name "dedupe",
                               :signature ["[]" "[coll]"],
                               :history [["+" "0.0-2301"]],
                               :type "function",
                               :full-name-encode "cljs.core_dedupe",
                               :source {:code "(defn dedupe\n  ([]\n   (fn [rf]\n     (let [pa (volatile! ::none)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [prior @pa]\n              (vreset! pa input)\n              (if (= prior input)\n                result\n                (rf result input))))))))\n  ([coll] (sequence (dedupe) coll)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8580 8595]},
                               :full-name "cljs.core/dedupe",
                               :docstring "Returns a lazy sequence removing consecutive duplicates in coll.\nReturns a transducer when no collection is provided."},
           "clojure.zip/lefts" {:ns "clojure.zip",
                                :name "lefts",
                                :signature ["[loc]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip_lefts",
                                :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [87 90]},
                                :full-name "clojure.zip/lefts",
                                :clj-symbol "clojure.zip/lefts",
                                :docstring "Returns a seq of the left siblings of this loc"},
           "clojure.browser.dom/ensure-element" {:ns "clojure.browser.dom",
                                                 :name "ensure-element",
                                                 :signature ["[e]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom_ensure-element",
                                                 :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [107
                                                                  112]},
                                                 :full-name "clojure.browser.dom/ensure-element",
                                                 :docstring "Coerce the argument to a dom element if possible."},
           "cljs.core/defmacro" {:ns "cljs.core",
                                 :name "defmacro",
                                 :signature ["[name doc-string? attr-map? [params*] body]"
                                             "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core_defmacro",
                                 :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                          :repo "clojure",
                                          :tag "clojure-1.6.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [422 466]},
                                 :full-name "cljs.core/defmacro",
                                 :clj-symbol "clojure.core/defmacro",
                                 :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
           "cljs.core/remove" {:description "Returns a lazy sequence of the items in `coll` for which `(pred item)` returns\nfalse.\n\n`pred` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                               :ns "cljs.core",
                               :name "remove",
                               :signature ["[pred]" "[pred coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/filter"],
                               :full-name-encode "cljs.core_remove",
                               :source {:code "(defn remove\n  ([pred] (filter (complement pred)))\n  ([pred coll]\n     (filter (complement pred) coll)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3990 3996]},
                               :full-name "cljs.core/remove",
                               :clj-symbol "clojure.core/remove",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "cljs.test/test-all-vars" {:ns "cljs.test",
                                      :name "test-all-vars",
                                      :signature ["[[quote ns :as form]]"],
                                      :history [["+" "0.0-2496"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test_test-all-vars",
                                      :source {:code "(defmacro test-all-vars\n  [[quote ns :as form]]\n  `(cljs.test/run-block (test-all-vars-block ~form)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/test.clj",
                                               :lines [329 333]},
                                      :full-name "cljs.test/test-all-vars",
                                      :clj-symbol "clojure.test/test-all-vars",
                                      :docstring "Calls test-vars on every var with :test metadata interned in the\nnamespace, with fixtures."},
           "cljs.core/set-print-fn!" {:ns "cljs.core",
                                      :name "set-print-fn!",
                                      :signature ["[f]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_set-print-fnBANG",
                                      :source {:code "(defn set-print-fn!\n  [f] (set! *print-fn* f))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [28 30]},
                                      :full-name "cljs.core/set-print-fn!",
                                      :docstring "Set *print-fn* to f."},
           "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-1211"]
                                                                       ["-"
                                                                        "0.0-2301"]],
                                                             :parent-type "PersistentArrayMap",
                                                             :type "var",
                                                             :full-name-encode "cljs.core_PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :source {:code "(set! cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD 8)",
                                                                      :repo "clojurescript",
                                                                      :tag "r2280",
                                                                      :filename "src/cljs/cljs/core.cljs",
                                                                      :lines [4672]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :removed {:in "0.0-2301",
                                                                       :last-seen "0.0-2280"}},
           "cljs.core/if-not" {:description "If `test` is false or nil, evaluates and returns `then`. Otherwise, evaluates\nand returns `else`. `else` defaults to nil if not provided.",
                               :ns "cljs.core",
                               :name "if-not",
                               :signature ["[test then]"
                                           "[test then else]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :related ["special/if"
                                         "cljs.core/when-not"],
                               :full-name-encode "cljs.core_if-not",
                               :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                        :repo "clojure",
                                        :tag "clojure-1.6.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [726 732]},
                               :full-name "cljs.core/if-not",
                               :clj-symbol "clojure.core/if-not",
                               :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
           "cljs.repl.reflect/macroexpand" {:ns "cljs.repl.reflect",
                                            :name "macroexpand",
                                            :type "function",
                                            :signature ["[form]"],
                                            :source {:code "(defn macroexpand [form]\n  \"Fully expands a cljs macro form.\"\n  (let [mform (analyzer/macroexpand-1 {} form)]\n    (if (identical? form mform)\n      mform\n      (macroexpand mform))))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/repl/reflect.clj",
                                                     :lines [32 37]},
                                            :full-name "cljs.repl.reflect/macroexpand",
                                            :full-name-encode "cljs.repl.reflect_macroexpand",
                                            :history [["+" "0.0-1503"]]},
           "cljs.core/string-iter" {:ns "cljs.core",
                                    :name "string-iter",
                                    :type "function",
                                    :signature ["[x]"],
                                    :source {:code "(defn string-iter [x]\n  (StringIter. x 0))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3078 3079]},
                                    :full-name "cljs.core/string-iter",
                                    :full-name-encode "cljs.core_string-iter",
                                    :history [["+" "0.0-2301"]]},
           "cljs.test/assert-any" {:ns "cljs.test",
                                   :name "assert-any",
                                   :signature ["[msg form]"],
                                   :history [["+" "0.0-2496"]],
                                   :type "function",
                                   :full-name-encode "cljs.test_assert-any",
                                   :source {:code "(defn assert-any\n  [msg form]\n  `(let [value# ~form]\n     (if value#\n       (cljs.test/do-report\n         {:type :pass, :message ~msg,\n          :expected '~form, :actual value#})\n       (cljs.test/do-report\n         {:type :fail, :message ~msg,\n          :expected '~form, :actual value#}))\n     value#))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/test.clj",
                                            :lines [44 56]},
                                   :full-name "cljs.test/assert-any",
                                   :clj-symbol "clojure.test/assert-any",
                                   :docstring "Returns generic assertion code for any test, including macros, Java\nmethod calls, or isolated symbols."},
           "specialrepl/require" {:description "Only usable from a REPL.\n\nLoads libs, skipping any that are already loaded. Each argument is\neither a libspec that identifies a lib or a flag that modifies how all the identified\nlibs are loaded.\n\n## Libspecs\n\nA libspec is a lib name or a vector containing a lib name followed by\noptions expressed as sequential keywords and arguments.\n\nRecognized options:\n\n- `:as` takes a symbol as its argument and makes that symbol an alias to the\n  lib's namespace in the current namespace.\n- `:refer` takes a list of symbols to refer from the namespace..\n- `:refer-macros` takes a list of macro symbols to refer from the namespace.\n- `:include-macros` takes a list of macro symbols to refer from the namespace.\n\n## Flags\n\nA flag is a keyword. Recognized flags:\n\n- `:reload` forces loading of all the identified libs even if they are\n  already loaded\n- `:reload-all` implies :reload and also forces loading of all libs that the\n  identified libs directly or indirectly load via require or use\n- `:verbose` triggers printing information about each load, alias, and refer",
                                  :ns "specialrepl",
                                  :name "require",
                                  :history [["+" "0.0-2629"]],
                                  :type "special form (repl)",
                                  :related ["specialrepl/require-macros"],
                                  :full-name-encode "specialrepl_require",
                                  :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n        (when-not (and (= quote 'quote) (symbol? ns-name))\n          (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n        (when-not (ana/get-namespace ns-name)\n          (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n          (-evaluate repl-env \"<cljs repl>\" 1\n            (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n        (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (let [is-self-require? (self-require? specs)\n              [target-ns restore-ns]\n              (if-not is-self-require?\n                [ana/*cljs-ns* nil]\n                ['cljs.user ana/*cljs-ns*])]\n          (evaluate-form repl-env env \"<cljs repl>\"\n            (with-meta\n              `(~'ns ~target-ns\n                 (:require\n                   ~@(map\n                       (fn [quoted-spec-or-kw]\n                         (if (keyword? quoted-spec-or-kw)\n                           quoted-spec-or-kw\n                           (second quoted-spec-or-kw)))\n                       specs)))\n              {:merge true :line 1 :column 1})\n            identity opts)\n          (when is-self-require?\n            (set! ana/*cljs-ns* restore-ns)))))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (evaluate-form repl-env env \"<cljs repl>\"\n          (with-meta\n            `(~'ns ~ana/*cljs-ns*\n               (:require-macros\n                 ~@(map\n                     (fn [quoted-spec-or-kw]\n                       (if (keyword? quoted-spec-or-kw)\n                         quoted-spec-or-kw\n                         (second quoted-spec-or-kw)))\n                     specs)))\n            {:merge true :line 1 :column 1})\n          identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n        (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n        (load-namespace repl-env ns opts)))}))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [475 543]},
                                  :examples [{:id "ab0355",
                                              :content "```clj\n(require '[clojure/string :as string])\n```"}],
                                  :full-name "specialrepl/require",
                                  :clj-symbol "clojure.core/require"},
           "clojure.zip/path" {:ns "clojure.zip",
                               :name "path",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_path",
                               :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [82 85]},
                               :full-name "clojure.zip/path",
                               :clj-symbol "clojure.zip/path",
                               :docstring "Returns a seq of nodes leading to this loc"},
           "cljs.core/mapcat" {:description "Returns the result of applying `concat` to the result of applying `map` to `f`\nand `colls`.\n\nFunction `f` should return a collection.\n\nReturns a transducer when no collections are provided.",
                               :ns "cljs.core",
                               :name "mapcat",
                               :signature ["[f]" "[f & colls]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/map"
                                         "cljs.core/concat"],
                               :full-name-encode "cljs.core_mapcat",
                               :source {:code "(defn mapcat\n  ([f] (comp (map f) cat))\n  ([f & colls]\n     (apply concat (apply map f colls))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3951 3959]},
                               :full-name "cljs.core/mapcat",
                               :clj-symbol "clojure.core/mapcat",
                               :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection. Returns\na transducer when no collections are provided"},
           "cljs.repl.node/platform-path" {:ns "cljs.repl.node",
                                           :name "platform-path",
                                           :type "function",
                                           :signature ["[v]"],
                                           :source {:code "(defn platform-path [v]\n  (str \"path.join.apply(null, \" (seq->js-array v) \")\"))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/repl/node.clj",
                                                    :lines [77 78]},
                                           :full-name "cljs.repl.node/platform-path",
                                           :full-name-encode "cljs.repl.node_platform-path",
                                           :history [["+" "0.0-2814"]]},
           "cljs.core/m3-mix-H1" {:return-type number,
                                  :ns "cljs.core",
                                  :name "m3-mix-H1",
                                  :signature ["[h1 k1]"],
                                  :history [["+" "0.0-2261"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_m3-mix-H1",
                                  :source {:code "(defn ^number m3-mix-H1 [h1 k1]\n  (-> h1 (bit-xor k1) (int-rotate-left 13) (imul 5) (+ 0xe6546b64)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [475 476]},
                                  :full-name "cljs.core/m3-mix-H1"},
           "cljs.core/IWatchable" {:ns "cljs.core",
                                   :name "IWatchable",
                                   :type "protocol",
                                   :full-name-encode "cljs.core_IWatchable",
                                   :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [372 375]},
                                   :methods [{:name "-notify-watches",
                                              :signature ["[this oldval newval]"],
                                              :docstring nil}
                                             {:name "-add-watch",
                                              :signature ["[this key f]"],
                                              :docstring nil}
                                             {:name "-remove-watch",
                                              :signature ["[this key]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IWatchable",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashMap.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashMap.fromArray",
                                                    :signature ["[arr no-clone]"],
                                                    :history [["+"
                                                               "0.0-2719"]],
                                                    :parent-type "PersistentHashMap",
                                                    :type "function",
                                                    :full-name-encode "cljs.core_PersistentHashMapDOTfromArray",
                                                    :source {:code "(set! (.-fromArray PersistentHashMap)\n  (fn [arr ^boolean no-clone]\n    (let [arr (if no-clone arr (aclone arr))\n          len (alength arr)]\n      (loop [i 0 ret (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (+ i 2)\n            (-assoc! ret (aget arr i) (aget arr (inc i))))\n          (-persistent! ret))))))",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [6335
                                                                     6343]},
                                                    :full-name "cljs.core/PersistentHashMap.fromArray"},
           "cljs.core/run!" {:ns "cljs.core",
                             :name "run!",
                             :signature ["[proc coll]"],
                             :history [["+" "0.0-2301"]],
                             :type "function",
                             :full-name-encode "cljs.core_runBANG",
                             :source {:code "(defn run!\n  [proc coll]\n  (reduce #(proc %2) nil coll))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [8629 8633]},
                             :full-name "cljs.core/run!",
                             :docstring "Runs the supplied procedure (via reduce), for purposes of side\neffects, on successive items in the collection. Returns nil"},
           "cljs.core/IndexedSeqIterator" {:ns "cljs.core",
                                           :name "IndexedSeqIterator",
                                           :type "type",
                                           :signature ["[arr i]"],
                                           :source {:code "(deftype IndexedSeqIterator [arr ^:mutable i]\n  Object\n  (hasNext [_]\n    (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret)))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [998 1005]},
                                           :full-name "cljs.core/IndexedSeqIterator",
                                           :full-name-encode "cljs.core_IndexedSeqIterator",
                                           :history [["+" "0.0-2371"]]},
           "cljs.core/unchecked-inc-int" {:ns "cljs.core",
                                          :name "unchecked-inc-int",
                                          :signature ["[x]"],
                                          :history [["+" "0.0-1798"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_unchecked-inc-int",
                                          :source {:code "(defn unchecked-inc-int [x]\n  (cljs.core/unchecked-inc-int x))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1989 1990]},
                                          :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-inc-int\n  ([x] `(inc ~x)))",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [390
                                                                   391]}),
                                          :full-name "cljs.core/unchecked-inc-int",
                                          :clj-symbol "clojure.core/unchecked-inc-int"},
           "cljs.test/testing-vars-str" {:ns "cljs.test",
                                         :name "testing-vars-str",
                                         :signature ["[m]"],
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test_testing-vars-str",
                                         :source {:code "(defn testing-vars-str\n  [m]\n  (let [{:keys [file line]} m]\n    (str\n      (reverse (map #(:name (meta %)) (:testing-vars (get-current-env))))\n      \" (\" file \":\" line \")\")))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/test.cljs",
                                                  :lines [279 287]},
                                         :full-name "cljs.test/testing-vars-str",
                                         :clj-symbol "clojure.test/testing-vars-str",
                                         :docstring "Returns a string representation of the current test.  Renders names\nin *testing-vars* as a list, then the source file and line of\ncurrent assertion."},
           "clojure.zip/rightmost" {:ns "clojure.zip",
                                    :name "rightmost",
                                    :signature ["[loc]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip_rightmost",
                                    :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [142 148]},
                                    :full-name "clojure.zip/rightmost",
                                    :clj-symbol "clojure.zip/rightmost",
                                    :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
           "cljs.core/PersistentArrayMap.EMPTY" {:ns "cljs.core",
                                                 :name "PersistentArrayMap.EMPTY",
                                                 :history [["+"
                                                            "0.0-1211"]],
                                                 :parent-type "PersistentArrayMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core_PersistentArrayMapDOTEMPTY",
                                                 :source {:code "(set! (.-EMPTY PersistentArrayMap) (PersistentArrayMap. nil 0 (array) empty-unordered-hash))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [5491]},
                                                 :full-name "cljs.core/PersistentArrayMap.EMPTY",
                                                 :clj-symbol "clojure.lang/PersistentArrayMap.EMPTY"},
           "cljs.core/m3-C2" {:ns "cljs.core",
                              :name "m3-C2",
                              :type "var",
                              :source {:code "(def m3-C2 0x1b873593)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [470]},
                              :full-name "cljs.core/m3-C2",
                              :full-name-encode "cljs.core_m3-C2",
                              :history [["+" "0.0-2261"]]},
           "cljs.repl.server/read-request" {:ns "cljs.repl.server",
                                            :name "read-request",
                                            :type "function",
                                            :signature ["[rdr]"],
                                            :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond\n      (.startsWith line \"POST\") (read-post line rdr)\n      (.startsWith line \"GET\") (read-get line rdr)\n      :else {:method :unknown :content line})))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/repl/server.clj",
                                                     :lines [96 101]},
                                            :full-name "cljs.repl.server/read-request",
                                            :full-name-encode "cljs.repl.server_read-request",
                                            :history [["+" "0.0-1503"]]},
           "cljs.test/compose-fixtures" {:ns "cljs.test",
                                         :name "compose-fixtures",
                                         :signature ["[f1 f2]"],
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test_compose-fixtures",
                                         :source {:code "(defn compose-fixtures\n  [f1 f2]\n  (fn [g] (f1 (fn [] (f2 g)))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/test.cljs",
                                                  :lines [474 480]},
                                         :full-name "cljs.test/compose-fixtures",
                                         :clj-symbol "clojure.test/compose-fixtures",
                                         :docstring "Composes two fixture functions, creating a new fixture function\nthat combines their behavior.\n\nNOTE: Incompatible with map fixtures."},
           "cljs.repl/load-file" {:ns "cljs.repl",
                                  :name "load-file",
                                  :type "function",
                                  :signature ["[repl-env f]"
                                              "[repl-env f opts]"],
                                  :source {:code "(defn load-file\n  ([repl-env f] (load-file repl-env f nil))\n  ([repl-env f opts]\n    (if (:output-dir opts)\n      (let [src (if (util/url? f) f (io/resource f))\n            compiled (cljsc/compile src\n                       (assoc opts\n                         :output-file\n                         (cljsc/src-file->target-file src)))]\n        (-evaluate repl-env f 1 (cljsc/add-dep-string opts compiled))\n        (-evaluate repl-env f 1 (cljsc/src-file->goog-require src)))\n      (binding [ana/*cljs-ns* 'cljs.user]\n        (let [res (if (= File/separatorChar (first f)) f (io/resource f))]\n          (assert res (str \"Can't find \" f \" in classpath\"))\n          (load-stream repl-env f res))))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [402 416]},
                                  :full-name "cljs.repl/load-file",
                                  :full-name-encode "cljs.repl_load-file",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/unchecked-subtract" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-subtract",
                                           :signature ["[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :history [["+" "0.0-1798"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_unchecked-subtract",
                                           :source {:code "(defn ^number unchecked-subtract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2017 2022]},
                                           :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-subtract\n  ([& xs] `(- ~@xs)))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/clj/cljs/core.clj",
                                                            :lines [408
                                                                    409]}),
                                           :full-name "cljs.core/unchecked-subtract",
                                           :clj-symbol "clojure.core/unchecked-subtract",
                                           :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.repl.nashorn/eval-str" {:ns "cljs.repl.nashorn",
                                         :name "eval-str",
                                         :type "function",
                                         :signature ["[engine s]"],
                                         :source {:code "(defn eval-str [^ScriptEngine engine ^String s]\n  (.eval engine s))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl/nashorn.clj",
                                                  :lines [75 76]},
                                         :full-name "cljs.repl.nashorn/eval-str",
                                         :full-name-encode "cljs.repl.nashorn_eval-str",
                                         :history [["+" "0.0-2814"]]},
           "cljs.core/->" {:description "The thread-first macro \"threads\" an expression through several forms as the\nsecond item in a list.\n\nInserts `x` as the second item in the first form, making a list of it if it is\nnot a list already. If there are more forms, inserts the first form as the\nsecond item in second form, etc.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(-> x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x (d (a x b c)) y z)</pre></td></tr></tbody></table>",
                           :ns "cljs.core",
                           :name "->",
                           :signature ["[x & forms]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/->>"],
                           :full-name-encode "cljs.core_-GT",
                           :source {:code "(defmacro ->\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n                       (list form x))]\n        (recur threaded (next forms)))\n      x)))",
                                    :repo "clojure",
                                    :tag "clojure-1.6.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1558 1572]},
                           :examples [{:id "19b460",
                                       :content "The first is arguably a bit more cumbersome to read than the second:\n\n```clj\n(first (.split (.replace (.toUpperCase \"a b c d\") \"A\" \"X\") \" \"))\n;;=> \"X\"\n\n(-> \"a b c d\"\n    .toUpperCase\n    (.replace \"A\" \"X\")\n    (.split \" \")\n    first)\n;;=> \"X\"\n```"}
                                      {:id "78ad8f",
                                       :content "It can also be useful for pulling values out of deeply-nested\ndata structures:\n\n```clj\n(def person\n  {:name \"Mark Volkmann\"\n   :address {:street \"644 Glen Summit\"\n             :city \"St. Charles\"\n             :state \"Missouri\"\n             :zip 63304}\n   :employer {:name \"Object Computing, Inc.\"\n              :address {:street \"12140 Woodcrest Dr.\"\n                        :city \"Creve Coeur\"\n                        :state \"Missouri\"\n                        :zip 63141}}})\n\n(-> person :employer :address :city)\n;;=> \"Creve Coeur\"\n```\n\nSame as above, but with more nesting:\n\n```clj\n(:city (:address (:employer person)))\n;;=> \"Creve Coeur\"\n```"}
                                      {:id "5fe621",
                                       :content "It can also help with arithmetic:\n\n```clj\n(def c 5)\n(-> c (+ 3) (/ 2) (- 1))\n;;=> 3\n```\n\nSame as above, but with more nesting:\n\n```clj\n(- (/ (+ c 3) 2) 1)\n;;=> 3\n```"}],
                           :full-name "cljs.core/->",
                           :clj-symbol "clojure.core/->",
                           :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
           "cljs.core/remove-all-methods" {:ns "cljs.core",
                                           :name "remove-all-methods",
                                           :signature ["[multifn]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_remove-all-methods",
                                           :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [9129 9132]},
                                           :full-name "cljs.core/remove-all-methods",
                                           :clj-symbol "clojure.core/remove-all-methods",
                                           :docstring "Removes all of the methods of multimethod."},
           "cljs.core/unchecked-add-int" {:return-type number,
                                          :ns "cljs.core",
                                          :name "unchecked-add-int",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :history [["+" "0.0-1798"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_unchecked-add-int",
                                          :source {:code "(defn ^number unchecked-add-int\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add-int x y))\n  ([x y & more] (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1966 1971]},
                                          :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-add-int\n  ([& xs] `(+ ~@xs)))",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [375
                                                                   376]}),
                                          :full-name "cljs.core/unchecked-add-int",
                                          :clj-symbol "clojure.core/unchecked-add-int",
                                          :docstring "Returns the sum of nums. (+) returns 0."},
           "clojure.string/replace-first" {:description "Replaces the first instance of `match` with `replacement` in `s`.\n\nThe options for match / replacement are:\n\n| match  | replacement |\n|--------|-------------|\n| string | string      |\n| regex  | string      |\n| regex  | function    |",
                                           :ns "clojure.string",
                                           :name "replace-first",
                                           :signature ["[s match replacement]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.string_replace-first",
                                           :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/string.cljs",
                                                    :lines [40 47]},
                                           :full-name "clojure.string/replace-first",
                                           :clj-symbol "clojure.string/replace-first",
                                           :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/reduced?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "reduced?",
                                 :signature ["[r]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_reducedQMARK",
                                 :source {:code "(defn ^boolean reduced?\n  [r]\n  (instance? Reduced r))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [903 906]},
                                 :full-name "cljs.core/reduced?",
                                 :clj-symbol "clojure.core/reduced?",
                                 :docstring "Returns true if x is the result of a call to reduced"},
           "clojure.browser.dom/get-value" {:ns "clojure.browser.dom",
                                            :name "get-value",
                                            :signature ["[e]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom_get-value",
                                            :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [131 134]},
                                            :full-name "clojure.browser.dom/get-value",
                                            :docstring "Get the value of an element."},
           "clojure.core.reducers/CollFold" {:ns "clojure.core.reducers",
                                             :name "CollFold",
                                             :type "protocol",
                                             :full-name-encode "clojure.core.reducers_CollFold",
                                             :source {:code "(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/clojure/core/reducers.cljs",
                                                      :lines [46 47]},
                                             :methods [{:name "coll-fold",
                                                        :signature ["[coll n combinef reducef]"],
                                                        :docstring nil}],
                                             :full-name "clojure.core.reducers/CollFold",
                                             :history [["+"
                                                        "0.0-2120"]]},
           "cljs.nodejs/process" {:ns "cljs.nodejs",
                                  :name "process",
                                  :type "var",
                                  :source {:code "(def process (js* \"process\"))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [16]},
                                  :full-name "cljs.nodejs/process",
                                  :full-name-encode "cljs.nodejs_process",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/some->>" {:description "When `expr` is not nil, threads it into the first form (via `->>`), and when\nthat result is not nil, through the next, etc.",
                                :ns "cljs.core",
                                :name "some->>",
                                :signature ["[expr & forms]"],
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :related ["cljs.core/->"
                                          "cljs.core/->>"
                                          "cljs.core/some->"
                                          "cljs.core/some"],
                                :full-name-encode "cljs.core_some-GTGT",
                                :source {:code "(defmacro some->>\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [6934 6943]},
                                :full-name "cljs.core/some->>",
                                :clj-symbol "clojure.core/some->>",
                                :docstring "When expr is not nil, threads it into the first form (via ->>),\nand when that result is not nil, through the next etc"},
           "cljs.core/unchecked-inc" {:ns "cljs.core",
                                      :name "unchecked-inc",
                                      :signature ["[x]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_unchecked-inc",
                                      :source {:code "(defn unchecked-inc [x]\n  (cljs.core/unchecked-inc x))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1986 1987]},
                                      :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-inc\n  ([x] `(inc ~x)))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [387
                                                               388]}),
                                      :full-name "cljs.core/unchecked-inc",
                                      :clj-symbol "clojure.core/unchecked-inc"},
           "cljs.core/not=" {:description "Returns the opposite of `=`.\n\nSame as `(not (= x y))`",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "not=",
                             :signature ["[x]" "[x y]" "[x y & more]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/=" "cljs.core/not"],
                             :full-name-encode "cljs.core_notEQ",
                             :source {:code "(defn ^boolean not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3051 3056]},
                             :full-name "cljs.core/not=",
                             :clj-symbol "clojure.core/not=",
                             :docstring "Same as (not (= obj1 obj2))"},
           "cljs.core/unchecked-subtract-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-subtract-int",
                                               :signature ["[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_unchecked-subtract-int",
                                               :source {:code "(defn ^number unchecked-subtract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-subtract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [2024
                                                                2029]},
                                               :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-subtract-int\n  ([& xs] `(- ~@xs)))",
                                                                :repo "clojurescript",
                                                                :tag "r2911",
                                                                :filename "src/clj/cljs/core.clj",
                                                                :lines [411
                                                                        412]}),
                                               :full-name "cljs.core/unchecked-subtract-int",
                                               :clj-symbol "clojure.core/unchecked-subtract-int",
                                               :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/ex-data" {:ns "cljs.core",
                                :name "ex-data",
                                :signature ["[ex]"],
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core_ex-data",
                                :source {:code "(defn ex-data\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-data ex)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [9214 9220]},
                                :full-name "cljs.core/ex-data",
                                :clj-symbol "clojure.core/ex-data",
                                :docstring "Alpha - subject to change.\nReturns exception data (a map) if ex is an ExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/PersistentTreeMapSeq" {:ns "cljs.core",
                                             :name "PersistentTreeMapSeq",
                                             :type "type",
                                             :signature ["[meta stack ascending? cnt __hash]"],
                                             :source {:code "(deftype PersistentTreeMapSeq [meta stack ^boolean ascending? cnt ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n  (-rest [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (if-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil)\n        ())))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta]\n    (PersistentTreeMapSeq. meta stack ascending? cnt __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [6467
                                                              6516]},
                                             :full-name "cljs.core/PersistentTreeMapSeq",
                                             :full-name-encode "cljs.core_PersistentTreeMapSeq",
                                             :history [["+"
                                                        "0.0-1211"]]},
           "cljs.core/js-keys" {:description "Returns the keys for the JavaScript object `obj`.",
                                :ns "cljs.core",
                                :name "js-keys",
                                :signature ["[obj]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/keys"],
                                :full-name-encode "cljs.core_js-keys",
                                :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1557 1560]},
                                :examples [{:id "5dd933",
                                            :content "```clj\n(js-keys #js {:foo 1 :bar 2})\n;;=> #js [\"foo\" \"bar\"]\n```"}],
                                :full-name "cljs.core/js-keys"},
           "cljs.repl.browser/browser-eval" {:ns "cljs.repl.browser",
                                             :name "browser-eval",
                                             :signature ["[form]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser_browser-eval",
                                             :source {:code "(defn browser-eval\n  [form]\n  (let [return-value (promise)]\n    (send-for-eval form\n      (fn [val] (deliver return-value val)))\n    (let [ret @return-value]\n      (try\n        (read-string ret)\n        (catch Exception e\n          {:status :error\n           :value (str \"Could not read return value: \" ret)})))))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [165 181]},
                                             :full-name "cljs.repl.browser/browser-eval",
                                             :docstring "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured."},
           "clojure.zip/seq-zip" {:ns "clojure.zip",
                                  :name "seq-zip",
                                  :signature ["[root]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_seq-zip",
                                  :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [34 40]},
                                  :full-name "clojure.zip/seq-zip",
                                  :clj-symbol "clojure.zip/seq-zip",
                                  :docstring "Returns a zipper for nested sequences, given a root sequence"},
           "cljs.core/lazy-transformer" {:ns "cljs.core",
                                         :name "lazy-transformer",
                                         :type "function",
                                         :signature ["[stepper]"],
                                         :source {:code "(defn lazy-transformer [stepper]\n  (LazyTransformer. stepper nil nil nil))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3128 3129]},
                                         :full-name "cljs.core/lazy-transformer",
                                         :full-name-encode "cljs.core_lazy-transformer",
                                         :history [["+" "0.0-2301"]]},
           "cljs.repl.browser/server-state" {:ns "cljs.repl.browser",
                                             :name "server-state",
                                             :type "var",
                                             :source {:code "(defonce server-state (atom {:socket nil\n                             :connection nil\n                             :promised-conn nil\n                             :return-value-fn nil\n                             :client-js nil}))",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [24 28]},
                                             :full-name "cljs.repl.browser/server-state",
                                             :full-name-encode "cljs.repl.browser_server-state",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.core/random-sample" {:ns "cljs.core",
                                      :name "random-sample",
                                      :signature ["[prob]"
                                                  "[prob coll]"],
                                      :history [["+" "0.0-2301"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_random-sample",
                                      :source {:code "(defn random-sample\n  ([prob]\n     (filter (fn [_] (< (rand) prob))))\n  ([prob coll]\n     (filter (fn [_] (< (rand) prob)) coll)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [8599 8605]},
                                      :full-name "cljs.core/random-sample",
                                      :docstring "Returns items from coll with random probability of prob (0.0 -\n1.0).  Returns a transducer when no collection is provided."},
           "cljs.core/IVector" {:ns "cljs.core",
                                :name "IVector",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IVector",
                                :source {:code "(defprotocol IVector\n  (^clj -assoc-n [coll n val]))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [309 310]},
                                :methods [{:name "-assoc-n",
                                           :signature ["[coll n val]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IVector",
                                :clj-symbol "clojure.lang/IPersistentVector"},
           "cljs.core/iter" {:ns "cljs.core",
                             :name "iter",
                             :type "function",
                             :signature ["[coll]"],
                             :source {:code "(defn iter [coll]\n  (cond\n    (nil? coll) (nil-iter)\n    (string? coll) (string-iter coll)\n    (array? coll) (array-iter coll)\n    (iterable? coll) (-iterator coll)\n    (seqable? coll) (seq-iter coll)\n    :else (throw (js/Error. (str \"Cannot create iterator from \" coll)))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3117 3124]},
                             :full-name "cljs.core/iter",
                             :full-name-encode "cljs.core_iter",
                             :history [["+" "0.0-2301"]]},
           "cljs.core/persistent!" {:ns "cljs.core",
                                    :name "persistent!",
                                    :signature ["[tcoll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_persistentBANG",
                                    :source {:code "(defn persistent!\n  [tcoll]\n  (-persistent! tcoll))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2920 2925]},
                                    :full-name "cljs.core/persistent!",
                                    :clj-symbol "clojure.core/persistent!",
                                    :docstring "Returns a new, persistent version of the transient collection, in\nconstant time. The transient collection cannot be used after this\ncall, any such use will throw an exception."},
           "cljs.core/empty" {:description "Returns an empty collection of the same category as `coll`.\n\nReturns nil if `coll` is nil.",
                              :ns "cljs.core",
                              :name "empty",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/not-empty"],
                              :full-name-encode "cljs.core_empty",
                              :source {:code "(defn empty\n  [coll]\n  (when-not (nil? coll)\n    (-empty coll)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1199 1203]},
                              :full-name "cljs.core/empty",
                              :clj-symbol "clojure.core/empty",
                              :docstring "Returns an empty collection of the same category as coll, or nil"},
           "cljs.core/re-matches" {:description "Returns the result of `(re-find re s)` if `re` fully matches `s`.",
                                   :ns "cljs.core",
                                   :name "re-matches",
                                   :signature ["[re s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_re-matches",
                                   :source {:code "(defn re-matches\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when (= (first matches) s)\n        (if (== (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. \"re-matches must match against a string.\"))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [8065 8074]},
                                   :full-name "cljs.core/re-matches",
                                   :clj-symbol "clojure.core/re-matches",
                                   :docstring "Returns the result of (re-find re s) if re fully matches s."},
           "syntax/meta" {:description "Attaches metadata to the following form.\n\nMetadata is a map.  It can be attached to a collection or symbol.\n\nIf the provided metadata is a keyword, the resulting metadata will be a map\ncontaining that keyword with an associated value `true`.\n\nIf the provided metadata is a string or symbol, the resulting metadata will be\na map associating `:tag` with the value of the string or evaluated symbol.",
                          :ns "syntax",
                          :name "meta",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :related ["cljs.core/meta"
                                    "cljs.core/with-meta"
                                    "cljs.core/vary-meta"
                                    "cljs.core/alter-meta!"],
                          :full-name-encode "syntax_meta",
                          :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                   :repo "tools.reader",
                                   :tag "tools.reader-0.8.10",
                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                   :lines [591 610]},
                          :extra-sources [{:code "(defn- read-meta\n  [rdr _]\n  (log-source rdr\n    (let [[line column] (when (indexing-reader? rdr)\n                          [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n          m (desugar-meta (read rdr true nil true))]\n      (when-not (map? m)\n        (reader-error rdr \"Metadata must be Symbol, Keyword, String or Map\"))\n      (let [o (read rdr true nil true)]\n        (if (instance? IMeta o)\n          (let [m (if (and line (seq? o))\n                    (assoc m :line line :column column)\n                    m)]\n            (if (instance? IObj o)\n              (with-meta o (merge (meta o) m))\n              (reset-meta! o m)))\n          (reader-error rdr \"Metadata can only be applied to IMetas\"))))))",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [340 356]}],
                          :syntax-form "^",
                          :examples [{:id "5b8fec",
                                      :content "Attach metadata to a collection:\n\n```clj\n^:foo [1 2 3]\n;;=> [1 2 3]\n```\n\nView the resulting metadata:\n\n```clj\n(meta ^:foo [1 2 3])\n;;=> {:foo true}\n\n(meta ^{:foo \"bar\"} [1 2 3])\n;;=> {:foo \"bar\"}\n\n(meta ^\"foo\" [1 2 3])\n;;=> {:tag \"foo\"}\n\n(def foo 1)\n(meta ^foo [1 2 3])\n;;=> {:tag 1}\n```\n\nChain metadata:\n\n```clj\n(meta ^:foo ^\"foo\" [1 2 3])\n;;=> {:foo true, :tag \"foo\"}\n```"}],
                          :full-name "syntax/meta",
                          :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                             :name "DOMBuilder",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.dom_DOMBuilder",
                                             :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/clojure/browser/dom.cljs",
                                                      :lines [17 18]},
                                             :methods [{:name "-element",
                                                        :signature ["[this]"
                                                                    "[this attrs-or-children]"
                                                                    "[this attrs children]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.dom/DOMBuilder",
                                             :history [["+" "0.0-927"]]},
           "syntax/regex" {:description "Signifies a regular expression. Represented as JavaScript regular expressions.\n\nAn inline modifier can be included at the beginning of the regex:\n\n|  modifier          | ClojureScript | JavaScript |\n|--------------------|---------------|------------|\n|  global match      | N/A           | `/foo/g`   |\n|  case-insensitive  | `#\"(?i)foo\"`  | `/foo/i`   |\n|  multi-line        | `#\"(?m)f.*o\"` | `/f.*o/m`  |\n\nGlobal matches (i.e. multiple matches per line) can be achieved using `re-seq`.",
                           :ns "syntax",
                           :name "regex",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["cljs.core/re-pattern"
                                     "cljs.core/re-find"
                                     "cljs.core/re-seq"
                                     "cljs.core/re-matches"],
                           :full-name-encode "syntax_regex",
                           :source {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                    :repo "tools.reader",
                                    :tag "tools.reader-0.8.10",
                                    :filename "src/main/clojure/clojure/tools/reader.clj",
                                    :lines [612 623]},
                           :extra-sources [{:code "(defn read-regex\n  [rdr ch]\n  (let [sb (StringBuilder.)]\n    (loop [ch (read-char rdr)]\n      (if (identical? \\\" ch)\n        (Pattern/compile (str sb))\n        (if (nil? ch)\n          (reader-error rdr \"EOF while reading regex\")\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (read-char rdr)]\n                (if (nil? ch)\n                  (reader-error rdr \"EOF while reading regex\"))\n                (.append sb ch)))\n            (recur (read-char rdr))))))))",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.10",
                                            :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                            :lines [129 144]}],
                           :syntax-form "#\"\"",
                           :examples [{:id "dacf80",
                                       :content "```clj\n#\"foo\"\n;;=> #\"foo\"\n\n(re-seq #\"foo\" \"FOO BAR foo bar\")\n;;=> (\"foo\")\n```\n\nCase-insensitive matching:\n\n```clj\n#\"(?i)foo\"\n;;=> #\"foo\"\n\n(re-seq #\"(?i)foo\" \"FOO BAR foo bar\")\n;;=> (\"FOO\" \"foo\")\n```"}],
                           :full-name "syntax/regex",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/extend-type" {:ns "cljs.core",
                                    :name "extend-type",
                                    :signature ["[type-sym & impls]"],
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_extend-type",
                                    :source {:code "(defmacro extend-type [type-sym & impls]\n  (let [env &env\n        _ (validate-impls env impls)\n        resolve (partial resolve-var env)\n        impl-map (->impl-map impls)\n        [type assign-impls] (if-let [type (base-type type-sym)]\n                              [type base-assign-impls]\n                              [(resolve type-sym) proto-assign-impls])]\n    (when (core/and (:extending-base-js-type cljs.analyzer/*cljs-warnings*)\n                    (js-base-type type-sym))\n      (cljs.analyzer/warning :extending-base-js-type env\n          {:current-symbol type-sym :suggested-symbol (js-base-type type-sym)}))\n    `(do ~@(mapcat #(assign-impls env resolve type-sym type %) impl-map))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [816 828]},
                                    :full-name "cljs.core/extend-type",
                                    :clj-symbol "clojure.core/extend-type"},
           "cljs.core/ISeqable" {:ns "cljs.core",
                                 :name "ISeqable",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_ISeqable",
                                 :source {:code "(defprotocol ISeqable\n  (^clj-or-nil -seq [o]))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [336 337]},
                                 :methods [{:name "-seq",
                                            :signature ["[o]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/ISeqable",
                                 :clj-symbol "clojure.lang/Seqable"},
           "cljs.core/assoc" {:description "assoc(iate)\n\nWhen applied to a map, returns a new map that contains the mapping of key(s) to\nval(s).\n\nHas no effect on the map type (hashed/sorted).\n\nWhen applied to a vector, returns a new vector that contains value `v` at index\n`k`.",
                              :ns "cljs.core",
                              :name "assoc",
                              :signature ["[coll k v]"
                                          "[coll k v & kvs]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/assoc-in"
                                        "cljs.core/dissoc"
                                        "cljs.core/merge"],
                              :full-name-encode "cljs.core_assoc",
                              :source {:code "(defn assoc\n  ([coll k v]\n    (if-not (nil? coll)\n      (-assoc coll k v)\n      (hash-map k v)))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1368 1381]},
                              :examples [{:id "2fa7e0",
                                          :content "```clj\n(def my-map {:foo 1})\n\n(assoc my-map :foo 2)\n;;=> {:foo 2}\n\n(assoc my-map :bar 2)\n;;=> {:foo 1 :bar 2}\n\n(assoc my-map :a 3 :b 4 :c 5 :d 6)\n;;=> {:foo 1 :a 3 :b 4 :c 5 :d 6}\n\n;; you must pass a value for every key\n(assoc my-map :foo)\n;;=> WARNING: Wrong number of args (2) passed to cljs.core/assoc\n```"}
                                         {:id "c06eac",
                                          :content "```clj\n(def my-vec [1 2 3])\n\n(assoc my-vec 0 \"foo\")\n;;=> [\"foo\" 2 3]\n\n(assoc my-vec 3 \"foo\")\n;;=> Error: Index 3 out of bounds  [0,0]\n```"}],
                              :full-name "cljs.core/assoc",
                              :clj-symbol "clojure.core/assoc",
                              :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
           "clojure.browser.repl/xpc-connection" {:ns "clojure.browser.repl",
                                                  :name "xpc-connection",
                                                  :type "var",
                                                  :source {:code "(def xpc-connection (atom nil))",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/cljs/clojure/browser/repl.cljs",
                                                           :lines [26]},
                                                  :full-name "clojure.browser.repl/xpc-connection",
                                                  :full-name-encode "clojure.browser.repl_xpc-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                          :name "IDerefWithTimeout",
                                          :type "protocol",
                                          :full-name-encode "cljs.core_IDerefWithTimeout",
                                          :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [315 316]},
                                          :methods [{:name "-deref-with-timeout",
                                                     :signature ["[o msec timeout-val]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IDerefWithTimeout",
                                          :history [["+" "0.0-927"]]},
           "syntax/eval" {:ns "syntax",
                          :name "eval",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :full-name-encode "syntax_eval",
                          :source {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                   :repo "tools.reader",
                                   :tag "tools.reader-0.8.10",
                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                   :lines [612 623]},
                          :extra-sources [{:code "(defn- read-eval\n  [rdr _]\n  (when-not *read-eval*\n    (reader-error rdr \"#= not allowed when *read-eval* is false\"))\n  (eval (read rdr true nil true)))",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [439 443]}],
                          :syntax-form "#=",
                          :full-name "syntax/eval",
                          :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L113"},
           "cljs.core/multi-stepper" {:ns "cljs.core",
                                      :name "multi-stepper",
                                      :type "function",
                                      :signature ["[xform iters]"
                                                  "[xform iters nexts]"],
                                      :source {:code "(defn multi-stepper\n  ([xform iters]\n     (multi-stepper xform iters\n       (make-array (alength iters))))\n  ([xform iters nexts]\n     (letfn [(stepfn\n               ([result]\n                  (let [lt (if (reduced? result)\n                             @result\n                             result)]\n                    (set! (.-stepper lt) nil)\n                    lt))\n               ([result input]\n                  (let [lt result]\n                    (set! (.-first lt) input)\n                    (set! (.-rest lt) (lazy-transformer (.-stepper lt)))\n                    (set! (.-stepper lt) nil)\n                    (.-rest lt))))]\n       (MultiStepper. (xform stepfn) iters nexts))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3185 3203]},
                                      :full-name "cljs.core/multi-stepper",
                                      :full-name-encode "cljs.core_multi-stepper",
                                      :history [["+" "0.0-2301"]]},
           "clojure.core.reducers/cat" {:ns "clojure.core.reducers",
                                        :name "cat",
                                        :signature ["[]"
                                                    "[ctor]"
                                                    "[left right]"],
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers_cat",
                                        :source {:code "(defn cat\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [213 230]},
                                        :full-name "clojure.core.reducers/cat",
                                        :clj-symbol "clojure.core.reducers/cat",
                                        :docstring "A high-performance combining fn that yields the catenation of the\nreduced values. The result is reducible, foldable, seqable and\ncounted, providing the identity collections are reducible, seqable\nand counted. The single argument version will build a combining fn\nwith the supplied identity constructor. Tests for identity\nwith (zero? (count x)). See also foldcat."},
           "cljs.core/unchecked-substract" {:return-type number,
                                            :ns "cljs.core",
                                            :name "unchecked-substract",
                                            :signature ["[x]"
                                                        "[x y]"
                                                        "[x y & more]"],
                                            :history [["+" "0.0-1798"]
                                                      ["-" "0.0-2277"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_unchecked-substract",
                                            :source {:code "(defn ^number unchecked-substract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-substract (cljs.core/unchecked-subtract x y) more)))",
                                                     :repo "clojurescript",
                                                     :tag "r2268",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [1805
                                                             1810]},
                                            :full-name "cljs.core/unchecked-substract",
                                            :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                            :removed {:in "0.0-2277",
                                                      :last-seen "0.0-2268"}},
           "cljs.core/Iteration" {:ns "cljs.core",
                                  :name "Iteration",
                                  :signature ["[xform coll]"],
                                  :history [["+" "0.0-2301"]
                                            ["-" "0.0-2371"]],
                                  :type "type",
                                  :full-name-encode "cljs.core_Iteration",
                                  :source {:code "(deftype Iteration [xform coll]\n   ISequential\n   \n   ISeqable\n   (-seq [_] (seq (sequence xform coll)))\n\n   IReduce\n   (-reduce [_ f init] (transduce xform f init coll))\n\n   IPrintWithWriter\n   (-pr-writer [coll writer opts]\n     (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))",
                                           :repo "clojurescript",
                                           :tag "r2356",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8192 8203]},
                                  :full-name "cljs.core/Iteration",
                                  :removed {:in "0.0-2371",
                                            :last-seen "0.0-2356"}},
           "clojure.browser.repl/start-evaluator" {:ns "clojure.browser.repl",
                                                   :name "start-evaluator",
                                                   :signature ["[url]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.repl_start-evaluator",
                                                   :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText (.-currentTarget e)\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/cljs/clojure/browser/repl.cljs",
                                                            :lines [65
                                                                    93]},
                                                   :full-name "clojure.browser.repl/start-evaluator",
                                                   :docstring "Start the REPL server connection."},
           "cljs.repl.browser/send-for-eval" {:ns "cljs.repl.browser",
                                              :name "send-for-eval",
                                              :signature ["[form return-value-fn]"
                                                          "[conn form return-value-fn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser_send-for-eval",
                                              :source {:code "(defn send-for-eval\n  ([form return-value-fn]\n    (send-for-eval @(server/connection) form return-value-fn))\n  ([conn form return-value-fn]\n    (set-return-value-fn return-value-fn)\n    (server/send-and-close conn 200 form \"text/javascript\")))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [35 43]},
                                              :full-name "cljs.repl.browser/send-for-eval",
                                              :docstring "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received."},
           "clojure.browser.event/unlisten" {:ns "clojure.browser.event",
                                             :name "unlisten",
                                             :type "function",
                                             :signature ["[src type fn]"
                                                         "[src type fn capture?]"],
                                             :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (events/unlisten src\n                      (get (event-types src) type type)\n                      fn\n                      capture?)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/clojure/browser/event.cljs",
                                                      :lines [64 71]},
                                             :full-name "clojure.browser.event/unlisten",
                                             :full-name-encode "clojure.browser.event_unlisten",
                                             :history [["+" "0.0-927"]]},
           "cljs.test/is" {:ns "cljs.test",
                           :name "is",
                           :signature ["[form]" "[form msg]"],
                           :history [["+" "0.0-2496"]],
                           :type "macro",
                           :full-name-encode "cljs.test_is",
                           :source {:code "(defmacro is\n  ([form] `(cljs.test/is ~form nil))\n  ([form msg]\n   `(cljs.test/try-expr ~msg ~form)))",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/clj/cljs/test.clj",
                                    :lines [149 165]},
                           :full-name "cljs.test/is",
                           :clj-symbol "clojure.test/is",
                           :docstring "Generic assertion macro.  'form' is any predicate test.\n'msg' is an optional message to attach to the assertion.\n\nExample: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\nSpecial forms:\n\n(is (thrown? c body)) checks that an instance of c is thrown from\nbody, fails if not; then returns the thing thrown.\n\n(is (thrown-with-msg? c re body)) checks that an instance of c is\nthrown AND that the message on the exception matches (with\nre-find) the regular expression re."},
           "cljs.test/use-fixtures" {:ns "cljs.test",
                                     :name "use-fixtures",
                                     :signature ["[type & fns]"],
                                     :history [["+" "0.0-2498"]],
                                     :type "macro",
                                     :full-name-encode "cljs.test_use-fixtures",
                                     :source {:code "(defmacro use-fixtures [type & fns]\n  (condp = type\n    :once\n    `(def ~'cljs-test-once-fixtures\n       [~@fns])\n    :each\n    `(def ~'cljs-test-each-fixtures\n       [~@fns])\n    :else\n    (throw\n      (Exception. \"First argument to cljs.test/use-fixtures must be :once or :each\"))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/test.clj",
                                              :lines [369 379]},
                                     :full-name "cljs.test/use-fixtures",
                                     :clj-symbol "clojure.test/use-fixtures"},
           "cljs.core/PersistentHashMap.fromArrays" {:ns "cljs.core",
                                                     :name "PersistentHashMap.fromArrays",
                                                     :signature ["[ks vs]"],
                                                     :history [["+"
                                                                "0.0-1211"]],
                                                     :parent-type "PersistentHashMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core_PersistentHashMapDOTfromArrays",
                                                     :source {:code "(set! (.-fromArrays PersistentHashMap)\n  (fn [ks vs]\n    (let [len (alength ks)]\n      (loop [i 0 ^not-native out (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (inc i) (-assoc! out (aget ks i) (aget vs i)))\n          (persistent! out))))))",
                                                              :repo "clojurescript",
                                                              :tag "r2911",
                                                              :filename "src/cljs/cljs/core.cljs",
                                                              :lines [6345
                                                                      6351]},
                                                     :full-name "cljs.core/PersistentHashMap.fromArrays"},
           "cljs.core/special-symbol?" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name "special-symbol?",
                                        :signature ["[x]"],
                                        :history [["+" "0.0-1803"]],
                                        :type "function",
                                        :full-name-encode "cljs.core_special-symbolQMARK",
                                        :source {:code "(defn ^boolean special-symbol? [x]\n  (contains?\n    '#{if def fn* do let* loop* letfn* throw try\n       recur new set! ns deftype* defrecord* . js* & quote}\n    x))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [9245 9249]},
                                        :full-name "cljs.core/special-symbol?",
                                        :clj-symbol "clojure.core/special-symbol?"},
           "cljs.repl.browser/constrain-order" {:ns "cljs.repl.browser",
                                                :name "constrain-order",
                                                :signature ["[order f]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser_constrain-order",
                                                :source {:code "(defn constrain-order\n  [order f]\n  (send-off ordering add-in-order order f)\n  (send-off ordering run-in-order))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [145
                                                                 150]},
                                                :full-name "cljs.repl.browser/constrain-order",
                                                :docstring "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order."},
           "cljs.core/js-debugger" {:description "Creates breakpoint that will stop the debugger if the browser's devtools are\nopen.  Equivalent to `debugger;` in JavaScript.",
                                    :ns "cljs.core",
                                    :name "js-debugger",
                                    :signature ["[]"],
                                    :history [["+" "0.0-2496"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_js-debugger",
                                    :source {:code "(defmacro js-debugger []\n  (core/list 'js* \"debugger;\"))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [293 294]},
                                    :examples [{:id "87f2fa",
                                                :content "```clj\n(defn foo []\n  (println \"HI\")\n  (js-debugger)\n  (println \"WORLD\"))\n\n(foo)\n;; will print \"HI\" then pause JS inside this function\n;; if browser devtools are open.\n```"}],
                                    :full-name "cljs.core/js-debugger"},
           "cljs.repl/default-special-fns" {:ns "cljs.repl",
                                            :name "default-special-fns",
                                            :type "var",
                                            :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n        (when-not (and (= quote 'quote) (symbol? ns-name))\n          (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n        (when-not (ana/get-namespace ns-name)\n          (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n          (-evaluate repl-env \"<cljs repl>\" 1\n            (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n        (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (let [is-self-require? (self-require? specs)\n              [target-ns restore-ns]\n              (if-not is-self-require?\n                [ana/*cljs-ns* nil]\n                ['cljs.user ana/*cljs-ns*])]\n          (evaluate-form repl-env env \"<cljs repl>\"\n            (with-meta\n              `(~'ns ~target-ns\n                 (:require\n                   ~@(map\n                       (fn [quoted-spec-or-kw]\n                         (if (keyword? quoted-spec-or-kw)\n                           quoted-spec-or-kw\n                           (second quoted-spec-or-kw)))\n                       specs)))\n              {:merge true :line 1 :column 1})\n            identity opts)\n          (when is-self-require?\n            (set! ana/*cljs-ns* restore-ns)))))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (evaluate-form repl-env env \"<cljs repl>\"\n          (with-meta\n            `(~'ns ~ana/*cljs-ns*\n               (:require-macros\n                 ~@(map\n                     (fn [quoted-spec-or-kw]\n                       (if (keyword? quoted-spec-or-kw)\n                         quoted-spec-or-kw\n                         (second quoted-spec-or-kw)))\n                     specs)))\n            {:merge true :line 1 :column 1})\n          identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n        (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n        (load-namespace repl-env ns opts)))}))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [475 543]},
                                            :full-name "cljs.repl/default-special-fns",
                                            :full-name-encode "cljs.repl_default-special-fns",
                                            :history [["+" "0.0-993"]]},
           "cljs.core/format" {:ns "cljs.core",
                               :name "format",
                               :signature ["[fmt & args]"],
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core_format",
                               :source {:code "(defn format\n  [fmt & args]\n  (apply gstring/format fmt args))",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1771 1774]},
                               :full-name "cljs.core/format",
                               :clj-symbol "clojure.core/format",
                               :docstring "Formats a string using goog.string.format.",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "cljs.core/sorted-set" {:description "Returns a new sorted set with supplied `keys`.",
                                   :ns "cljs.core",
                                   :name "sorted-set",
                                   :signature ["[& keys]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/sorted-set-by"
                                             "cljs.core/subseq"
                                             "cljs.core/rsubseq"
                                             "cljs.core/sorted-map"],
                                   :full-name-encode "cljs.core_sorted-set",
                                   :source {:code "(defn sorted-set\n  ([& keys]\n   (reduce -conj (.-EMPTY PersistentTreeSet) keys)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7607 7610]},
                                   :full-name "cljs.core/sorted-set",
                                   :clj-symbol "clojure.core/sorted-set",
                                   :docstring "Returns a new sorted set with supplied keys."},
           "cljs.core/fnil" {:description "Takes a function `f`, and returns a function that calls `f`, replacing a nil\nfirst argument to `f` with the supplied value `x`. Higher arity versions can\nreplace arguments in the second and third positions (`y`, `z`).\n\nNote that the function `f` can take any number of arguments, not just the one(s)\nbeing nil-patched.",
                             :ns "cljs.core",
                             :name "fnil",
                             :signature ["[f x]"
                                         "[f x y]"
                                         "[f x y z]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_fnil",
                             :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3405 3426]},
                             :full-name "cljs.core/fnil",
                             :clj-symbol "clojure.core/fnil",
                             :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
           "cljs.core/update" {:ns "cljs.core",
                               :name "update",
                               :signature ["[m k f]"
                                           "[m k f x]"
                                           "[m k f x y]"
                                           "[m k f x y z]"
                                           "[m k f x y z & more]"],
                               :history [["+" "0.0-2411"]],
                               :type "function",
                               :full-name-encode "cljs.core_update",
                               :source {:code "(defn update\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z & more]\n   (assoc m k (apply f (get m k) x y z more))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4139 4153]},
                               :full-name "cljs.core/update",
                               :docstring "'Updates' a value in an associative structure, where k is a\nkey and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nstructure.  If the key does not exist, nil is passed as the old value."},
           "cljs.core/this-as" {:ns "cljs.core",
                                :name "this-as",
                                :signature ["[name & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_this-as",
                                :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (js-this)]\n     ~@body))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [644 648]},
                                :full-name "cljs.core/this-as",
                                :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."},
           "cljs.repl.rhino/rhino-eval" {:ns "cljs.repl.rhino",
                                         :name "rhino-eval",
                                         :type "function",
                                         :signature ["[repl-env filename line js]"],
                                         :source {:code "(defn rhino-eval\n  [repl-env filename line js]\n  (try\n    (let [linenum (or line Integer/MIN_VALUE)]\n      {:status :success\n       :value (eval-result (-eval js repl-env filename linenum))})\n    (catch Throwable ex\n      {:status :exception\n       :value (.toString ex)\n       :stacktrace (stacktrace ex)})))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [67 76]},
                                         :full-name "cljs.repl.rhino/rhino-eval",
                                         :full-name-encode "cljs.repl.rhino_rhino-eval",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueueSeq" {:ns "cljs.core",
                                           :name "PersistentQueueSeq",
                                           :type "type",
                                           :signature ["[meta front rear __hash]"],
                                           :source {:code "(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [4883 4919]},
                                           :full-name "cljs.core/PersistentQueueSeq",
                                           :full-name-encode "cljs.core_PersistentQueueSeq",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/counted?" {:description "Returns true if `x` executes `count` in constant time, false otherwise.\n\nLists, maps, sets, strings, and vectors can be counted in constant time.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "counted?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_countedQMARK",
                                 :source {:code "(defn ^boolean counted?\n  [x] (satisfies? ICounted x))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [990 992]},
                                 :full-name "cljs.core/counted?",
                                 :clj-symbol "clojure.core/counted?",
                                 :docstring "Returns true if coll implements count in constant time"},
           "cljs.repl.browser/read-headers" {:ns "cljs.repl.browser",
                                             :name "read-headers",
                                             :signature ["[rdr]"],
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser_read-headers",
                                             :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [136 141]},
                                             :full-name "cljs.repl.browser/read-headers",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "clojure.string/trimr" {:description "Removes whitespace from the right side of string.",
                                   :ns "clojure.string",
                                   :name "trimr",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string_trimr",
                                   :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [157 160]},
                                   :full-name "clojure.string/trimr",
                                   :clj-symbol "clojure.string/trimr",
                                   :docstring "Removes whitespace from the right side of string."},
           "clojure.core.reducers/take" {:ns "clojure.core.reducers",
                                         :name "take",
                                         :signature ["[n]" "[n coll]"],
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers_take",
                                         :source {:code "(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [164 176]},
                                         :full-name "clojure.core.reducers/take",
                                         :clj-symbol "clojure.core.reducers/take",
                                         :docstring "Ends the reduction of coll after consuming n values."},
           "cljs.repl/IReplEnvOptions" {:ns "cljs.repl",
                                        :name "IReplEnvOptions",
                                        :type "protocol",
                                        :full-name-encode "cljs.repl_IReplEnvOptions",
                                        :source {:code "(defprotocol IReplEnvOptions\n  (-repl-options [repl-env] \"Return default REPL options for a REPL Env\"))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [95 96]},
                                        :methods [{:name "-repl-options",
                                                   :signature ["[repl-env]"],
                                                   :docstring "Return default REPL options for a REPL Env"}],
                                        :full-name "cljs.repl/IReplEnvOptions",
                                        :history [["+" "0.0-2719"]]},
           "cljs.core/force" {:ns "cljs.core",
                              :name "force",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_force",
                              :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8549 8554]},
                              :full-name "cljs.core/force",
                              :clj-symbol "clojure.core/force",
                              :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
           "cljs.core/compare-and-set!" {:description "Atomically sets the value of atom `a` to `newval` if and only if the current\nvalue of the atom is identical to `oldval`.\n\nReturns true if set happened, false otherwise.",
                                         :ns "cljs.core",
                                         :name "compare-and-set!",
                                         :signature ["[a oldval newval]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :related ["cljs.core/atom"
                                                   "cljs.core/reset!"
                                                   "cljs.core/swap!"],
                                         :full-name-encode "cljs.core_compare-and-setBANG",
                                         :source {:code "(defn compare-and-set!\n  [^not-native a oldval newval]\n  (if (= (-deref a) oldval)\n    (do (reset! a newval) true)\n    false))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3576 3583]},
                                         :full-name "cljs.core/compare-and-set!",
                                         :clj-symbol "clojure.core/compare-and-set!",
                                         :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is equal to oldval. Returns true if\nset happened, else false."},
           "cljs.core/set?" {:description "Returns true if `x` is a set, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "set?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/set"],
                             :full-name-encode "cljs.core_setQMARK",
                             :source {:code "(defn ^boolean set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1511 1516]},
                             :full-name "cljs.core/set?",
                             :clj-symbol "clojure.core/set?",
                             :docstring "Returns true if x satisfies ISet"},
           "cljs.core/hash-string" {:ns "cljs.core",
                                    :name "hash-string",
                                    :type "function",
                                    :signature ["[k]"],
                                    :source {:code "(defn hash-string [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [534 541]},
                                    :full-name "cljs.core/hash-string",
                                    :full-name-encode "cljs.core_hash-string",
                                    :history [["+" "0.0-2261"]]},
           "cljs.repl.server/set-connection" {:ns "cljs.repl.server",
                                              :name "set-connection",
                                              :signature ["[conn]"],
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server_set-connection",
                                              :source {:code "(defn set-connection\n  [conn]\n  (if-let [promised-conn (:promised-conn @state)]\n    (do\n      (swap! state\n        (fn [old]\n          (-> old\n            (assoc :connection nil)\n            (assoc :promised-conn nil))))\n      (deliver promised-conn conn))\n    (swap! state (fn [old] (assoc old :connection conn)))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/repl/server.clj",
                                                       :lines [28 41]},
                                              :full-name "cljs.repl.server/set-connection",
                                              :docstring "Given a new available connection, either use it to deliver the\nconnection which was promised or store the connection for later\nuse."},
           "syntax/unquote-splicing" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nIntended for use inside a syntax-quote.\n\nForces evaluation of the following form and expands its children into the\nparent form.",
                                      :ns "syntax",
                                      :name "unquote-splicing",
                                      :history [["+" "0.0-927"]],
                                      :type "syntax",
                                      :related ["syntax/syntax-quote"
                                                "syntax/unquote"],
                                      :full-name-encode "syntax_unquote-splicing",
                                      :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.10",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [591 610]},
                                      :extra-sources [{:code "(defn- read-unquote\n  [rdr comma]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~))))",
                                                       :repo "tools.reader",
                                                       :tag "tools.reader-0.8.10",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [447
                                                               452]}],
                                      :syntax-form "~@",
                                      :examples [{:id "e6f73d",
                                                  :content "```clj\n(def foo '[a b c])\n`(~@foo)\n;;=> (a b c)\n```"}],
                                      :full-name "syntax/unquote-splicing",
                                      :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/unchecked-dec" {:ns "cljs.core",
                                      :name "unchecked-dec",
                                      :signature ["[x]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_unchecked-dec",
                                      :source {:code "(defn unchecked-dec [x]\n  (cljs.core/unchecked-dec x))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1973 1974]},
                                      :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-dec\n  ([x] `(dec ~x)))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [378
                                                               379]}),
                                      :full-name "cljs.core/unchecked-dec",
                                      :clj-symbol "clojure.core/unchecked-dec"},
           "cljs.core/PersistentVector.EMPTY-NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY-NODE",
                                                    :type "var",
                                                    :parent-type "PersistentVector",
                                                    :source {:code "(set! (.-EMPTY-NODE PersistentVector) (VectorNode. nil (make-array 32)))",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [4458]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY-NODE",
                                                    :full-name-encode "cljs.core_PersistentVectorDOTEMPTY-NODE",
                                                    :history [["+"
                                                               "0.0-2301"]]},
           "clojure.string/escape" {:description "Return a new string, using `cmap` to escape each character `ch` from `s` as follows:\n\nIf `(cmap ch)` is nil, append ch to the new string.\n\nIf `(cmap ch)` is non-nil, append `(str (cmap ch))` instead.",
                                    :ns "clojure.string",
                                    :name "escape",
                                    :signature ["[s cmap]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string_escape",
                                    :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [179 195]},
                                    :full-name "clojure.string/escape",
                                    :clj-symbol "clojure.string/escape",
                                    :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
           "cljs.core/remove-watch" {:description "Removes a watch function identified by `key` from atom `a`.  The function must\nhave originally been set by `add-watch`.",
                                     :ns "cljs.core",
                                     :name "remove-watch",
                                     :signature ["[a key]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/add-watch"],
                                     :full-name-encode "cljs.core_remove-watch",
                                     :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key)\n  iref)",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [8504 8510]},
                                     :examples [{:id "70044a",
                                                 :content "```clj\n(def a (atom {}))\n\n(add-watch a :logger\n  (fn [_key _atom old-state new-state]\n    (println \"old:\" old-state)\n    (println \"new:\" new-state)))\n\n(swap! a assoc :foo \"bar\")\n;;=> will print the following:\n;; old: {}\n;; new: {:foo \"bar\"}\n\n(remove-watch a :logger)\n\n(swap! a assoc :foo 3)\n;;=> nothing will be printed...\n```"}],
                                     :full-name "cljs.core/remove-watch",
                                     :clj-symbol "clojure.core/remove-watch",
                                     :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
           "cljs.core/m3-hash-unencoded-chars" {:return-type number,
                                                :ns "cljs.core",
                                                :name "m3-hash-unencoded-chars",
                                                :signature ["[in]"],
                                                :history [["+"
                                                           "0.0-2261"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_m3-hash-unencoded-chars",
                                                :source {:code "(defn ^number m3-hash-unencoded-chars [in]\n  (let [h1 (loop [i 1 h1 m3-seed]\n             (if (< i (alength in))\n               (recur (+ i 2)\n                 (m3-mix-H1 h1\n                   (m3-mix-K1\n                     (bit-or (.charCodeAt in (dec i))\n                       (bit-shift-left (.charCodeAt in i) 16)))))\n               h1))\n        h1 (if (== (bit-and (alength in) 1) 1)\n             (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (alength in)))))\n             h1)]\n    (m3-fmix h1 (imul 2 (alength in)))))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [494
                                                                 506]},
                                                :full-name "cljs.core/m3-hash-unencoded-chars"},
           "cljs.core/es6-iterator-seq" {:ns "cljs.core",
                                         :name "es6-iterator-seq",
                                         :type "function",
                                         :signature ["[iter]"],
                                         :source {:code "(defn es6-iterator-seq [iter]\n  (let [v (.next iter)]\n    (if (.-done v)\n      ()\n      (ES6IteratorSeq. (.-value v) iter nil))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [805 809]},
                                         :full-name "cljs.core/es6-iterator-seq",
                                         :full-name-encode "cljs.core_es6-iterator-seq",
                                         :history [["+" "0.0-2411"]]},
           "cljs.core/IMultiFn" {:ns "cljs.core",
                                 :name "IMultiFn",
                                 :type "protocol",
                                 :full-name-encode "cljs.core_IMultiFn",
                                 :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf]))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8932 8939]},
                                 :methods [{:name "-reset",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-add-method",
                                            :signature ["[mf dispatch-val method]"],
                                            :docstring nil}
                                           {:name "-remove-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-prefer-method",
                                            :signature ["[mf dispatch-val dispatch-val-y]"],
                                            :docstring nil}
                                           {:name "-get-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-methods",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-prefers",
                                            :signature ["[mf]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IMultiFn",
                                 :history [["+" "0.0-927"]]},
           "clojure.browser.event/IEventType" {:ns "clojure.browser.event",
                                               :name "IEventType",
                                               :type "protocol",
                                               :full-name-encode "clojure.browser.event_IEventType",
                                               :source {:code "(defprotocol IEventType\n  (event-types [this]))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/clojure/browser/event.cljs",
                                                        :lines [16 17]},
                                               :methods [{:name "event-types",
                                                          :signature ["[this]"],
                                                          :docstring nil}],
                                               :full-name "clojure.browser.event/IEventType",
                                               :history [["+"
                                                          "0.0-2301"]]},
           "clojure.zip/end?" {:ns "clojure.zip",
                               :name "end?",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_endQMARK",
                               :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [232 235]},
                               :full-name "clojure.zip/end?",
                               :clj-symbol "clojure.zip/end?",
                               :docstring "Returns true if loc represents the end of a depth-first walk"},
           "cljs.test/clear-env!" {:ns "cljs.test",
                                   :name "clear-env!",
                                   :type "function",
                                   :signature ["[]"],
                                   :source {:code "(defn clear-env! []\n  (set! *current-env* nil))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/test.cljs",
                                            :lines [270 271]},
                                   :full-name "cljs.test/clear-env!",
                                   :full-name-encode "cljs.test_clear-envBANG",
                                   :history [["+" "0.0-2496"]]},
           "cljs.analyzer.api/ns-resolve" {:ns "cljs.analyzer.api",
                                           :name "ns-resolve",
                                           :signature ["[ns sym]"],
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api_ns-resolve",
                                           :source {:code "(defn ns-resolve\n  [ns sym]\n  {:pre [(symbol? ns) (symbol? sym)]}\n  (get-in @env/*compiler* [::ana/namespaces ns :defs sym]))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/analyzer/api.clj",
                                                    :lines [44 49]},
                                           :full-name "cljs.analyzer.api/ns-resolve",
                                           :clj-symbol "clojure.core/ns-resolve",
                                           :docstring "Given a namespace and a symbol return the corresponding var analysis map.\nAnalagous to clojure.core/ns-resolve but returns var analysis map not Var."},
           "special/try" {:description "The expressions (`expr*`) are evaluated and, if no exceptions occur, the value\nof the last is returned.\n\nIf an exception occurs and catch clauses (`catch-clause*`) are provided, each is\nexamined in turn and the first for which the thrown exception is an instance of\nthe named class is considered a matching catch clause. If there is a matching\ncatch clause, its expressions are evaluated in a context in which name is bound\nto the thrown exception, and the value of the last is the return value of the\nfunction.\n\nIf there is no matching catch clause, the exception propagates out of the\nfunction. Before returning, normally or abnormally, any `finally-clause?`\nexpressions will be evaluated for their side effects.\n\n`try` is one of ClojureScript's [special forms](http://clojure.org/special_forms).",
                          :ns "special",
                          :name "try",
                          :signature ["[expr* catch-clause* finally-clause?]"],
                          :history [["+" "0.0-1933"]],
                          :type "special form",
                          :related ["special/catch"
                                    "special/finally"
                                    "special/throw"],
                          :full-name-encode "special_try",
                          :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/clj/cljs/analyzer.clj",
                                   :lines [606 665]},
                          :full-name "special/try",
                          :clj-symbol "clojure.core/try"},
           "cljs.repl/update-require-spec" {:ns "cljs.repl",
                                            :name "update-require-spec",
                                            :signature ["[specs & additions]"],
                                            :history [["+" "0.0-2629"]
                                                      ["-" "0.0-2655"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl_update-require-spec",
                                            :source {:code "(defn update-require-spec\n  [specs & additions]\n  (let [[before [requires & other-specs]]\n        (split-with\n          (fn [[x _]] (not= :require x))\n          specs)\n        requires'\n        `(:require\n           ~@(reduce\n               (fn [requires spec]\n                 (merge-require requires spec))\n               (rest requires)\n               additions))]\n    (concat before [requires'] other-specs)))",
                                                     :repo "clojurescript",
                                                     :tag "r2644",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [226 241]},
                                            :full-name "cljs.repl/update-require-spec",
                                            :docstring "Given the specification portion of a ns form and require spec additions\nreturn an updated specification.",
                                            :removed {:in "0.0-2655",
                                                      :last-seen "0.0-2644"}},
           "cljs.test/test-all-vars-block" {:ns "cljs.test",
                                            :name "test-all-vars-block",
                                            :type "macro",
                                            :signature ["[[quote ns]]"],
                                            :source {:code "(defmacro test-all-vars-block\n  ([[quote ns]]\n   `(let [env# (cljs.test/get-current-env)]\n      (concat\n       [(fn []\n          (when (nil? env#)\n            (cljs.test/set-env! (cljs.test/empty-env)))\n          ~(when (ana-api/ns-resolve ns 'cljs-test-once-fixtures)\n             `(cljs.test/update-current-env! [:once-fixtures] assoc '~ns\n                                             ~(symbol (name ns) \"cljs-test-once-fixtures\")))\n          ~(when (ana-api/ns-resolve ns 'cljs-test-each-fixtures)\n             `(cljs.test/update-current-env! [:each-fixtures] assoc '~ns\n                                             ~(symbol (name ns) \"cljs-test-each-fixtures\"))))]\n       (cljs.test/test-vars-block\n        [~@(map\n            (fn [[k _]]\n              `(var ~(symbol (name ns) (name k))))\n            (filter\n             (fn [[_ v]] (:test v))\n             (ana-api/ns-interns ns)))])\n       [(fn []\n          (when (nil? env#)\n            (cljs.test/clear-env!)))]))))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/test.clj",
                                                     :lines [305 327]},
                                            :full-name "cljs.test/test-all-vars-block",
                                            :full-name-encode "cljs.test_test-all-vars-block",
                                            :history [["+" "0.0-2814"]]},
           "clojure.set/superset?" {:description "Returns true if `a` is a superset of `b`, false otherwise.\n\nIn other words, returns true if `a` contains all the elements of `b`.",
                                    :ns "clojure.set",
                                    :name "superset?",
                                    :signature ["[a b]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/set"
                                              "cljs.core/set?"
                                              "clojure.set/subset?"],
                                    :full-name-encode "clojure.set_supersetQMARK",
                                    :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/clojure/set.cljs",
                                             :lines [137 141]},
                                    :full-name "clojure.set/superset?",
                                    :clj-symbol "clojure.set/superset?",
                                    :docstring "Is set1 a superset of set2?"},
           "cljs.repl/repl" {:ns "cljs.repl",
                             :name "repl",
                             :signature ["[repl-env & {:as opts}]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.repl_repl",
                             :source {:code "(defn repl\n  [repl-env & {:as opts}]\n  (repl* repl-env opts))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/clj/cljs/repl.clj",
                                      :lines [698 766]},
                             :full-name "cljs.repl/repl",
                             :docstring "Generic, reusable, read-eval-print loop. By default, reads from *in* using\na c.t.r.reader-types/source-logging-push-back-reader,\nwrites to *out*, and prints exception summaries to *err*. If you use the\ndefault :read hook, *in* must either be an instance of\nc.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\nunread and collapsing CR, LF, and CRLF into a single \\newline. Options\nare sequential keyword-value pairs. The first argument is the JavaScript\nevaluation environment, the second argument is an extended version of the\nstandard ClojureScript compiler options. In addition to ClojureScript compiler\nbuild options it also take a set of options similar to clojure.main/repl with\nadjustments for ClojureScript evalution and compilation model:\n\nAvailable clojure.main/repl style options and their defaults:\n\n   - :init, function of no arguments, initialization hook called with\n     bindings for set!-able vars in place.\n     default: #()\n\n   - :need-prompt, function of no arguments, called before each\n     read-eval-print except the first, the user will be prompted if it\n     returns true.\n     default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                 (== (c.t.r.reader-types/get-column-number *in*) 1)\n                 (identity true))\n\n   - :prompt, function of no arguments, prompts for more input.\n     default: repl-prompt\n\n   - :flush, function of no arguments, flushes output\n     default: flush\n\n   - :read, function of two arguments, reads from *in*:\n       - returns its first argument to request a fresh prompt\n         - depending on need-prompt, this may cause the repl to prompt\n           before reading again\n       - returns its second argument to request an exit from the repl\n       - else returns the next object read from the input stream\n     default: repl-read\n\n   - :eval, function of one argument, returns the evaluation of its\n     argument. The eval function must take repl-env, the JavaScript evaluation\n     environment, env, the ClojureScript analysis environment, the form\n     and opts, the standard ClojureScript REPL/compiler options.\n     default: eval\n\n   - :print, function of one argument, prints its argument to the output\n     default: println\n\n   - :caught, function of three arguments, a throwable, called when\n     read, eval, or print throws an exception or error default. The second\n     argument is the JavaScript evaluation environment this permits context\n     sensitive handling if necessary. The third argument is opts, the standard\n     ClojureScript REPL/compiler options. In the case of errors or exception\n     in the JavaScript target, these will be thrown as\n     clojure.lang.IExceptionInfo instances.\n     default: repl-caught\n\n   - :reader, the c.t.r reader to use.\n     default: c.t.r.reader-types/source-logging-push-back-reader\n\n   - :print-no-newline, print without a newline.\n     default: print\n\n   - :source-map-inline, whether inline source maps should be enabled. Most\n     useful in browser context. Implies using a fresh reader for each form.\n     default: true"},
           "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                              :name "IConnection",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.net_IConnection",
                                              :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [30 42]},
                                              :methods [{:name "connect",
                                                         :signature ["[this]"
                                                                     "[this opt1]"
                                                                     "[this opt1 opt2]"
                                                                     "[this opt1 opt2 opt3]"],
                                                         :docstring nil}
                                                        {:name "transmit",
                                                         :signature ["[this opt]"
                                                                     "[this opt opt2]"
                                                                     "[this opt opt2 opt3]"
                                                                     "[this opt opt2 opt3 opt4]"
                                                                     "[this opt opt2 opt3 opt4 opt5]"],
                                                         :docstring nil}
                                                        {:name "close",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.net/IConnection",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/let" {:description "Binds expressions to symbols and makes those symbols available only within\n`body`.\n\n`bindings` should be a vector with an even number of forms, ie: `[a1 b1, a2 b2,\na3 b3]`. The first item in a pair (the `a`s) should be a symbol that is assigned\nthe evaluation of the second item (the `b`s). These symbols (the `a`s) are then\navailable within `body` (and not outside of `body`).\n\nAnother way to think about this is that the binding symbols in `let` are like\nlocal `def`s that are only available within `let`'s scope.\n\nIn addition to direct symbol binding, `let` supports a destructuring syntax to\n\"break apart\" collections into multiple symbols. This destructuring syntax is\nlike it's own [mini-language] and allows for succinct code.\n\n`let` is a wrapper over one of ClojureScript's [special forms] and is a\nfundamental building block of the language. Many macros rely on `let`s binding\nsyntax and scope rules.\n\n[mini-language]:http://blog.jayfields.com/2010/07/clojure-destructuring.html\n[special forms]:http://clojure.org/special_forms",
                            :ns "cljs.core",
                            :name "let",
                            :signature ["[bindings & body]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/letfn"
                                      "cljs.core/if-let"],
                            :full-name-encode "cljs.core_let",
                            :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [147 157]},
                            :full-name "cljs.core/let",
                            :clj-symbol "clojure.core/let",
                            :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
           "cljs.core/unchecked-divide-int" {:return-type number,
                                             :ns "cljs.core",
                                             :name "unchecked-divide-int",
                                             :signature ["[x]"
                                                         "[x y]"
                                                         "[x y & more]"],
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_unchecked-divide-int",
                                             :source {:code "(defn ^number unchecked-divide-int\n  ([x] (unchecked-divide-int 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce unchecked-divide-int (unchecked-divide-int x y) more)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [1979
                                                              1984]},
                                             :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-divide-int\n  ([& xs] `(/ ~@xs)))",
                                                              :repo "clojurescript",
                                                              :tag "r2911",
                                                              :filename "src/clj/cljs/core.clj",
                                                              :lines [384
                                                                      385]}),
                                             :full-name "cljs.core/unchecked-divide-int",
                                             :clj-symbol "clojure.core/unchecked-divide-int",
                                             :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.repl.nashorn/create-engine" {:ns "cljs.repl.nashorn",
                                              :name "create-engine",
                                              :type "function",
                                              :signature ["[]"],
                                              :source {:code "(defn create-engine []\n  (if-let [engine (.getEngineByName (ScriptEngineManager.) \"nashorn\")]\n    (let [context (.getContext engine)]\n      (.setWriter context *out*)\n      (.setErrorWriter context *err*)\n      engine)\n    (throw (IllegalArgumentException.\n            \"Cannot find the Nashorn script engine, use a JDK version 8 or higher.\"))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/repl/nashorn.clj",
                                                       :lines [66 73]},
                                              :full-name "cljs.repl.nashorn/create-engine",
                                              :full-name-encode "cljs.repl.nashorn_create-engine",
                                              :history [["+"
                                                         "0.0-2814"]]},
           "cljs.core/dorun" {:description "Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.\n\n`dorun` walks through the successive `next`s of the sequence and returns nil.",
                              :ns "cljs.core",
                              :name "dorun",
                              :signature ["[coll]" "[n coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/doall"],
                              :full-name-encode "cljs.core_dorun",
                              :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8033 8044]},
                              :full-name "cljs.core/dorun",
                              :clj-symbol "clojure.core/dorun",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
           "cljs.core/with-redefs" {:ns "cljs.core",
                                    :name "with-redefs",
                                    :signature ["[bindings & body]"],
                                    :history [["+" "0.0-1806"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_with-redefs",
                                    :source {:code "(defmacro with-redefs\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map core/vector names vals)\n        resets (reverse (map core/vector names tempnames))\n        bind-value (fn [[k v]] (core/list 'set! k v))]\n    `(let [~@(interleave tempnames names)]\n       ~@(map bind-value binds)\n       (try\n         ~@body\n        (finally\n          ~@(map bind-value resets))))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [1104 1124]},
                                    :full-name "cljs.core/with-redefs",
                                    :clj-symbol "clojure.core/with-redefs",
                                    :docstring "binding => var-symbol temp-value-expr\n\nTemporarily redefines vars while executing the body.  The\ntemp-value-exprs will be evaluated and each resulting value will\nreplace in parallel the root value of its var.  After the body is\nexecuted, the root values of all the vars will be set back to their\nold values. Useful for mocking out functions during testing."},
           "cljs.core/SeqIter" {:ns "cljs.core",
                                :name "SeqIter",
                                :signature ["[_seq _next]"],
                                :history [["+" "0.0-2301"]],
                                :type "type",
                                :full-name-encode "cljs.core_SeqIter",
                                :source {:code "(deftype SeqIter [^:mutable _seq ^:mutable _next]\n  Object\n  (hasNext [_]\n    (if (identical? _seq INIT)\n      (do\n        (set! _seq START)\n        (set! _next (seq _next)))\n      (if (identical? _seq _next)\n        (set! _next (next _seq))))\n    (not (nil? _next)))\n  (next [this]\n    (if-not (.hasNext this)\n      (throw (js/Error. \"No such element\"))\n      (do\n        (set! _seq _next)\n        (first _next))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3096 3112]},
                                :full-name "cljs.core/SeqIter",
                                :clj-symbol "clojure.lang/SeqIterator"},
           "cljs.core/unsigned-bit-shift-right" {:description "Bitwise shift right with zero fill",
                                                 :ns "cljs.core",
                                                 :name "unsigned-bit-shift-right",
                                                 :signature ["[x n]"],
                                                 :history [["+"
                                                            "0.0-2080"]],
                                                 :type "function",
                                                 :related ["cljs.core/bit-shift-right"],
                                                 :full-name-encode "cljs.core_unsigned-bit-shift-right",
                                                 :source {:code "(defn unsigned-bit-shift-right\n  [x n] (cljs.core/unsigned-bit-shift-right x n))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [2147
                                                                  2149]},
                                                 :extra-sources ({:code "(defmacro ^::ana/numeric unsigned-bit-shift-right [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                  :repo "clojurescript",
                                                                  :tag "r2911",
                                                                  :filename "src/clj/cljs/core.clj",
                                                                  :lines [535
                                                                          536]}),
                                                 :full-name "cljs.core/unsigned-bit-shift-right",
                                                 :clj-symbol "clojure.core/unsigned-bit-shift-right",
                                                 :docstring "Bitwise shift right with zero fill"},
           "cljs.core/iterable?" {:ns "cljs.core",
                                  :name "iterable?",
                                  :type "function",
                                  :signature ["[x]"],
                                  :source {:code "(defn iterable? [x]\n  (satisfies? IIterable x))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [697 698]},
                                  :full-name "cljs.core/iterable?",
                                  :full-name-encode "cljs.core_iterableQMARK",
                                  :history [["+" "0.0-2356"]]},
           "cljs.core/pr-str" {:ns "cljs.core",
                               :name "pr-str",
                               :signature ["[& objs]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_pr-str",
                               :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8281 8284]},
                               :full-name "cljs.core/pr-str",
                               :clj-symbol "clojure.core/pr-str",
                               :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."},
           "cljs.core/IPrintable" {:ns "cljs.core",
                                   :name "IPrintable",
                                   :history [["+" "0.0-927"]
                                             ["-" "0.0-1798"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core_IPrintable",
                                   :source {:code "(defprotocol ^:deprecated IPrintable\n  \"Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.\"\n  (-pr-seq [o opts]))",
                                            :repo "clojurescript",
                                            :tag "r1586",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [253 257]},
                                   :methods [{:name "-pr-seq",
                                              :signature ["[o opts]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IPrintable",
                                   :docstring "Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.",
                                   :removed {:in "0.0-1798",
                                             :last-seen "0.0-1586"}},
           "cljs.build.api/src-file->target-file" {:return-type File,
                                                   :ns "cljs.build.api",
                                                   :name "src-file->target-file",
                                                   :signature ["[src]"
                                                               "[src opts]"],
                                                   :history [["+"
                                                              "0.0-2629"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.build.api_src-file-GTtarget-file",
                                                   :source {:code "(defn ^File src-file->target-file\n  ([src] (closure/src-file->target-file src))\n  ([src opts] (closure/src-file->target-file src opts)))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/clj/cljs/build/api.clj",
                                                            :lines [80
                                                                    84]},
                                                   :full-name "cljs.build.api/src-file->target-file",
                                                   :docstring "Given a ClojureScript source file return the target file. May optionally\nprovide build options with :output-dir specified."},
           "cljs.core/defprotocol" {:ns "cljs.core",
                                    :name "defprotocol",
                                    :signature ["[psym & doc+methods]"],
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_defprotocol",
                                    :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.analyzer/resolve-var (dissoc &env :locals) psym))\n        psym (vary-meta psym assoc :protocol-symbol true)\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (core/str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (core/string? (first doc+methods)) (next doc+methods) doc+methods)\n        _ (core/doseq [[mname & arities] methods]\n            (when (some #{0} (map count (filter vector? arities)))\n              (throw (Exception. (core/str \"Invalid protocol, \" psym \" defines method \" mname \" with arity 0\")))))\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (core/str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         (let [x# (if (nil? ~(first sig)) nil ~(first sig))]\n                           ((or\n                             (aget ~(fqn fname) (goog/typeOf x#))\n                             (aget ~(fqn fname) \"_\")\n                             (throw (missing-protocol\n                                     ~(core/str psym \".\" fname) ~(first sig))))\n                            ~@sig)))))\n        psym   (vary-meta psym assoc-in [:protocol-info :methods]\n                 (into {}\n                   (map\n                     (fn [[fname & sigs]]\n                       (let [sigs (take-while vector? sigs)]\n                         [fname (vec sigs)]))\n                     methods)))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (core/str prefix (name fname)))\n                       fname (vary-meta fname assoc :protocol p)]\n                   `(defn ~fname ~@(map (fn [sig]\n                                          (expand-sig fname\n                                                      (symbol (core/str slot \"$arity$\" (count sig)))\n                                                      sig))\n                                        sigs))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (js-obj))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [1009 1050]},
                                    :full-name "cljs.core/defprotocol",
                                    :clj-symbol "clojure.core/defprotocol"},
           "cljs.core/ints" {:ns "cljs.core",
                             :name "ints",
                             :signature ["[x]"],
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core_ints",
                             :source {:code "(defn ints [x] x)",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2060]},
                             :full-name "cljs.core/ints",
                             :clj-symbol "clojure.core/ints"},
           "cljs.core/assert" {:description "Evaluates expression `expr` and throws an exception if it does not evaluate to\nlogical true.  Exception will include `message` if given.\n\nReturns `nil`.",
                               :ns "cljs.core",
                               :name "assert",
                               :signature ["[expr]" "[expr message]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core_assert",
                               :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [1240 1252]},
                               :extra-sources ({:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" (pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x))))))))",
                                                :repo "clojure",
                                                :tag "clojure-1.6.0",
                                                :filename "src/clj/clojure/core.clj",
                                                :lines [4420 4431]}),
                               :examples [{:id "1dc16f",
                                           :content "```clj\n(assert true)\n;;=> nil\n\n(assert false)\n;;=> Uncaught Error: Assert failed: false\n\n(assert (= 1 2) \"1 is not 2\")\n;;=> Uncaught Error: Assert failed: 1 is not 2\n;;   (= 1 2)\n```"}],
                               :full-name "cljs.core/assert",
                               :clj-symbol "clojure.core/assert",
                               :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
           "cljs.core/declare" {:description "Uses `def` to establish symbols of `names` with no bindings.\n\nUseful for making forward declarations.",
                                :ns "cljs.core",
                                :name "declare",
                                :signature ["[& names]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["special/def"],
                                :full-name-encode "cljs.core_declare",
                                :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [2795 2798]},
                                :examples [{:id "5a2dc2",
                                            :content "```clj\na\n;; WARNING: Use of undeclared Var\n\n(declare a)\na\n;;=> nil\n```"}],
                                :full-name "cljs.core/declare",
                                :clj-symbol "clojure.core/declare",
                                :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
           "cljs.core/PersistentTreeMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentTreeMap",
                                                :type "var",
                                                :full-name-encode "cljs.core_PersistentTreeMapDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentTreeMap) (PersistentTreeMap. compare nil 0 nil empty-unordered-hash))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [7126]},
                                                :full-name "cljs.core/PersistentTreeMap.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentTreeMap.EMPTY"},
           "cljs.core/fn?" {:description "Returns true if `f` is a function, false otherwise.",
                            :return-type boolean,
                            :ns "cljs.core",
                            :name "fn?",
                            :signature ["[f]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/ifn?"],
                            :full-name-encode "cljs.core_fnQMARK",
                            :source {:code "(defn ^boolean fn? [f]\n  (or ^boolean (goog/isFunction f) (satisfies? Fn f)))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1397 1398]},
                            :full-name "cljs.core/fn?",
                            :clj-symbol "clojure.core/fn?"},
           "cljs.core/associative?" {:description "Returns true if `coll` implements the `IAssociative` protocol, false otherwise.\n\nMaps and vectors are associative.",
                                     :return-type boolean,
                                     :ns "cljs.core",
                                     :name "associative?",
                                     :signature ["[coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_associativeQMARK",
                                     :source {:code "(defn ^boolean associative?\n  [x] (satisfies? IAssociative x))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1518 1520]},
                                     :examples [{:id "29a37f",
                                                 :content "```clj\n(associative? [1 2 3])\n;;=> true\n\n(associative? {:a 1 :b 2})\n;;=> true\n\n(associative? #{1 2 3})\n;;=> false\n\n(associative? '(1 2 3))\n;;=> false\n```"}],
                                     :full-name "cljs.core/associative?",
                                     :clj-symbol "clojure.core/associative?",
                                     :docstring "Returns true if coll implements Associative"},
           "cljs.repl.rhino/load-javascript" {:ns "cljs.repl.rhino",
                                              :name "load-javascript",
                                              :type "function",
                                              :signature ["[repl-env ns url]"],
                                              :source {:code "(defn load-javascript [repl-env ns url]\n  (try\n    (with-open [reader (io/reader url)]\n      (-eval reader repl-env (.toString url) 1))\n    ;; TODO: don't show errors for goog/base.js line number 105\n    (catch Throwable ex (println (.getMessage ex)))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/repl/rhino.clj",
                                                       :lines [111
                                                               116]},
                                              :full-name "cljs.repl.rhino/load-javascript",
                                              :full-name-encode "cljs.repl.rhino_load-javascript",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/IList" {:ns "cljs.core",
                              :name "IList",
                              :history [["+" "0.0-1211"]],
                              :type "protocol",
                              :full-name-encode "cljs.core_IList",
                              :source {:code "(defprotocol IList\n  \"Marker interface indicating a persistent list\")",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [342 343]},
                              :full-name "cljs.core/IList",
                              :clj-symbol "clojure.lang/IPersistentList",
                              :docstring "Marker interface indicating a persistent list"},
           "cljs.core/list*" {:description "Creates a new list containing the items prepended to the rest, the last of which\nwill be treated as a sequence.",
                              :ns "cljs.core",
                              :name "list*",
                              :signature ["[args]"
                                          "[a args]"
                                          "[a b args]"
                                          "[a b c args]"
                                          "[a b c d & more]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/list"],
                              :full-name-encode "cljs.core_listSTAR",
                              :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2902 2910]},
                              :full-name "cljs.core/list*",
                              :clj-symbol "clojure.core/list*",
                              :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
           "cljs.core/PersistentArrayMap.fromArray" {:ns "cljs.core",
                                                     :name "PersistentArrayMap.fromArray",
                                                     :signature ["[arr no-clone no-check]"],
                                                     :history [["+"
                                                                "0.0-1798"]],
                                                     :parent-type "PersistentArrayMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core_PersistentArrayMapDOTfromArray",
                                                     :source {:code "(set! (.-fromArray PersistentArrayMap)\n  (fn [arr ^boolean no-clone ^boolean no-check]\n    (let [arr (if no-clone arr (aclone arr))]\n      (if no-check\n        (let [cnt (/ (alength arr) 2)]\n          (PersistentArrayMap. nil cnt arr nil))\n        (let [len (alength arr)]\n          (loop [i 0\n                 ret (transient (.-EMPTY PersistentArrayMap))]\n            (if (< i len)\n              (recur (+ i 2)\n                (-assoc! ret (aget arr i) (aget arr (inc i))))\n              (-persistent! ret))))))))",
                                                              :repo "clojurescript",
                                                              :tag "r2911",
                                                              :filename "src/cljs/cljs/core.cljs",
                                                              :lines [5495
                                                                      5507]},
                                                     :full-name "cljs.core/PersistentArrayMap.fromArray"},
           "cljs.core/reduce" {:description "`f` should be a function of 2 arguments. If `val` is not supplied, returns the\nresult of applying `f` to the first 2 items in `coll`, then applying `f` to that\nresult and the 3rd item, etc.\n\nIf `coll` contains no items, `f` must accept no arguments as well, and `reduce`\nreturns the result of calling `f` with no arguments.\n\nIf `coll` has only 1 item, it is returned and `f` is not called.\n\nIf `val` is supplied, returns the result of applying `f` to `val` and the first\nitem in `coll`, then applying `f` to that result and the 2nd item, etc.\n\nIf `coll` contains no items, returns `val` and `f` is not called.",
                               :ns "cljs.core",
                               :name "reduce",
                               :signature ["[f coll]" "[f val coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/reductions"
                                         "cljs.core/apply"
                                         "cljs.core/frequencies"],
                               :full-name-encode "cljs.core_reduce",
                               :source {:code "(defn reduce\n  ([f coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce ^not-native coll f)\n\n       (array? coll)\n       (array-reduce coll f)\n\n       (string? coll)\n       (array-reduce coll f)\n       \n       (native-satisfies? IReduce coll)\n       (-reduce coll f)\n\n       :else\n       (seq-reduce f coll)))\n  ([f val coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce ^not-native coll f val)\n\n       (array? coll)\n       (array-reduce coll f val)\n      \n       (string? coll)\n       (array-reduce coll f val)\n       \n       (native-satisfies? IReduce coll)\n       (-reduce coll f val)\n\n       :else\n       (seq-reduce f val coll))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1759 1800]},
                               :full-name "cljs.core/reduce",
                               :clj-symbol "clojure.core/reduce",
                               :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
           "cljs.repl/merge-require" {:ns "cljs.repl",
                                      :name "merge-require",
                                      :signature ["[requires [lib :as spec]]"],
                                      :history [["+" "0.0-2629"]
                                                ["-" "0.0-2655"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl_merge-require",
                                      :source {:code "(defn merge-require [requires [lib :as spec]]\n  (let [[before [match & after]]\n        (split-with\n          (fn [[lib' & _]]\n            (not= lib lib'))\n          requires)]\n    (if (nil? match)\n      ;; no match, append to end\n      (concat requires [spec])\n      (if (= match spec)\n        ;; dupe\n        requires\n        ;; merge\n        (concat before [(merge-spec match spec)] after)))))",
                                               :repo "clojurescript",
                                               :tag "r2644",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [211 224]},
                                      :full-name "cljs.repl/merge-require",
                                      :removed {:in "0.0-2655",
                                                :last-seen "0.0-2644"}},
           "clojure.browser.event/has-listener" {:ns "clojure.browser.event",
                                                 :name "has-listener",
                                                 :type "function",
                                                 :signature ["[obj opt_type opt_capture]"],
                                                 :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [96]},
                                                 :full-name "clojure.browser.event/has-listener",
                                                 :full-name-encode "clojure.browser.event_has-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/unchecked-dec-int" {:ns "cljs.core",
                                          :name "unchecked-dec-int",
                                          :signature ["[x]"],
                                          :history [["+" "0.0-1798"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_unchecked-dec-int",
                                          :source {:code "(defn unchecked-dec-int [x]\n  (cljs.core/unchecked-dec-int x))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1976 1977]},
                                          :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-dec-int\n  ([x] `(dec ~x)))",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [381
                                                                   382]}),
                                          :full-name "cljs.core/unchecked-dec-int",
                                          :clj-symbol "clojure.core/unchecked-dec-int"},
           "cljs.core/PersistentHashMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentHashMap",
                                                :type "var",
                                                :full-name-encode "cljs.core_PersistentHashMapDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentHashMap) (PersistentHashMap. nil 0 nil false nil empty-unordered-hash))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [6333]},
                                                :full-name "cljs.core/PersistentHashMap.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentHashMap.EMPTY"},
           "cljs.core/compare" {:description "Comparator.\n\nReturns a negative number, zero, or a positive number when `x` is logically\n\"less than\", \"equal to\", or \"greater than\" `y`.\n\nUses `IComparable` if available and `google.array.defaultCompare` for objects of\nthe same type. nil is treated as a special case and is always less than any\nother object.",
                                :return-type number,
                                :ns "cljs.core",
                                :name "compare",
                                :signature ["[x y]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/sort-by"
                                          "cljs.core/sorted-set-by"
                                          "cljs.core/sorted-map-by"],
                                :full-name-encode "cljs.core_compare",
                                :source {:code "(defn ^number compare\n  [x y]\n  (cond\n   (identical? x y) 0\n\n   (nil? x) -1\n\n   (nil? y) 1\n\n   (identical? (type x) (type y))\n   (if (implements? IComparable x)\n     (-compare ^not-native x y)\n     (garray/defaultCompare x y))\n\n   :else\n   (throw (js/Error. \"compare on non-nil objects of different types\"))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1659 1678]},
                                :examples [{:id "e13fa0",
                                            :content "```clj\n(compare 10 12)\n;;=> -1\n\n(compare 12 10)\n;;=> 1\n\n(compare 10 10)\n;;=> 0\n\n(compare 10 nil)\n;;=>  1\n\n(compare 10 (list 1 2 3))\n;; Error: compare on non-nil objects of different types\n```"}],
                                :full-name "cljs.core/compare",
                                :clj-symbol "clojure.core/compare",
                                :docstring "Comparator. Returns a negative number, zero, or a positive number\n when x is logically 'less than', 'equal to', or 'greater than'\n y. Uses IComparable if available and google.array.defaultCompare for objects\nof the same type and special-cases nil to be less than any other object."},
           "cljs.core/contains?" {:description "Returns true if `k` is present in `coll`, otherwise returns false.\n\nNote that for numerically indexed collections like vectors and arrays, this\ntests if the numeric key is within the range of indexes.\n\n`contains?` operates in constant or logarithmic time; it will not perform a\nlinear search for a value.",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "contains?",
                                  :signature ["[coll k]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/some"
                                            "cljs.core/get"],
                                  :full-name-encode "cljs.core_containsQMARK",
                                  :source {:code "(defn ^boolean contains?\n  [coll v]\n  (if (identical? (get coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1622 1631]},
                                  :full-name "cljs.core/contains?",
                                  :clj-symbol "clojure.core/contains?",
                                  :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
           "cljs.core/Stepper" {:ns "cljs.core",
                                :name "Stepper",
                                :type "type",
                                :signature ["[xform iter]"],
                                :source {:code "(deftype Stepper [xform iter]\n  Object\n  (step [this lt]\n    (loop []\n      (if (and (not (nil? (.-stepper lt)))\n               (.hasNext iter))\n        (if (reduced? (xform lt (.next iter)))\n          (when-not (nil? (.-rest lt))\n            (set! (.. lt -rest -stepper) nil))\n          (recur))))\n    (when-not (nil? (.-stepper lt))\n      (xform lt))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3131 3142]},
                                :full-name "cljs.core/Stepper",
                                :full-name-encode "cljs.core_Stepper",
                                :history [["+" "0.0-2301"]]},
           "cljs.core/prefer-method" {:ns "cljs.core",
                                      :name "prefer-method",
                                      :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_prefer-method",
                                      :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [9139 9143]},
                                      :full-name "cljs.core/prefer-method",
                                      :clj-symbol "clojure.core/prefer-method",
                                      :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
           "cljs.core/array-seq" {:description "Creates a `seq` from a JavaScript array, starting at index `i` if given.",
                                  :ns "cljs.core",
                                  :name "array-seq",
                                  :signature ["[array]" "[array i]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_array-seq",
                                  :source {:code "(defn array-seq\n  ([array]\n     (prim-seq array 0))\n  ([array i]\n     (prim-seq array i)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1084 1088]},
                                  :examples [{:id "9ef6de",
                                              :content "```clj\n(array-seq #js [1 2 3])\n;;=> (1 2 3)\n\n(array-seq #js [1 2 3] 1)\n;;=> (2 3)\n```"}],
                                  :full-name "cljs.core/array-seq"},
           "cljs.core/to-array-2d" {:description "Returns a (potentially-ragged) 2-dimensional JavaScript array containing the\ncontents of `coll`.",
                                    :ns "cljs.core",
                                    :name "to-array-2d",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :related ["cljs.core/to-array"],
                                    :full-name-encode "cljs.core_to-array-2d",
                                    :source {:code "(defn to-array-2d\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when xs\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2770 2779]},
                                    :full-name "cljs.core/to-array-2d",
                                    :clj-symbol "clojure.core/to-array-2d",
                                    :docstring "Returns a (potentially-ragged) 2-dimensional array\ncontaining the contents of coll."},
           "cljs.repl.nashorn/load-ns" {:ns "cljs.repl.nashorn",
                                        :name "load-ns",
                                        :type "function",
                                        :signature ["[engine ns]"],
                                        :source {:code "(defn load-ns [engine ns]\n  (eval-str engine\n    (format \"goog.require(\\\"%s\\\");\" (comp/munge (first ns)))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/repl/nashorn.clj",
                                                 :lines [126 128]},
                                        :full-name "cljs.repl.nashorn/load-ns",
                                        :full-name-encode "cljs.repl.nashorn_load-ns",
                                        :history [["+" "0.0-2814"]]},
           "cljs.core/ICloneable" {:ns "cljs.core",
                                   :name "ICloneable",
                                   :type "protocol",
                                   :full-name-encode "cljs.core_ICloneable",
                                   :source {:code "(defprotocol ICloneable\n  (^clj -clone [value]))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [259 260]},
                                   :methods [{:name "-clone",
                                              :signature ["[value]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/ICloneable",
                                   :history [["+" "0.0-2134"]]},
           "cljs.repl.browser/create-client-js-file" {:ns "cljs.repl.browser",
                                                      :name "create-client-js-file",
                                                      :type "function",
                                                      :signature ["[opts file-path]"],
                                                      :source {:code "(defn create-client-js-file [opts file-path]\n  (let [file (io/file file-path)]\n    (when (not (.exists file))\n      (spit file (compile-client-js opts)))\n    file))",
                                                               :repo "clojurescript",
                                                               :tag "r2911",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [226
                                                                       230]},
                                                      :full-name "cljs.repl.browser/create-client-js-file",
                                                      :full-name-encode "cljs.repl.browser_create-client-js-file",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "cljs.core/*print-length*" {:ns "cljs.core",
                                       :name "*print-length*",
                                       :type "dynamic var",
                                       :source {:code "(def ^:dynamic *print-length* nil)",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [37]},
                                       :full-name "cljs.core/*print-length*",
                                       :full-name-encode "cljs.core_STARprint-lengthSTAR",
                                       :clj-symbol "clojure.core/*print-length*",
                                       :history [["+" "0.0-2060"]]},
           "cljs.repl/*cljs-verbose*" {:ns "cljs.repl",
                                       :name "*cljs-verbose*",
                                       :type "dynamic var",
                                       :source {:code "(def ^:dynamic *cljs-verbose* false)",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [30]},
                                       :full-name "cljs.repl/*cljs-verbose*",
                                       :full-name-encode "cljs.repl_STARcljs-verboseSTAR",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue" {:ns "cljs.core",
                                        :name "PersistentQueue",
                                        :signature ["[meta count front rear __hash]"],
                                        :history [["+" "0.0-927"]],
                                        :type "type",
                                        :full-name-encode "cljs.core_PersistentQueue",
                                        :source {:code "(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [coll] (PersistentQueue. meta count front rear __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentQueue) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil))))\n\n  ICounted\n  (-count [coll] count))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4923 4975]},
                                        :full-name "cljs.core/PersistentQueue",
                                        :clj-symbol "clojure.lang/PersistentQueue"},
           "cljs.repl.server/read-post" {:ns "cljs.repl.server",
                                         :name "read-post",
                                         :type "function",
                                         :signature ["[line rdr]"],
                                         :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n      {:method :post\n       :path path\n       :headers headers\n       :content (String. content)})))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl/server.clj",
                                                  :lines [78 87]},
                                         :full-name "cljs.repl.server/read-post",
                                         :full-name-encode "cljs.repl.server_read-post",
                                         :history [["+" "0.0-1503"]]},
           "cljs.core/drop-last" {:description "Return a lazy sequence of all but the last `n` items in `s`.\n\n`n` defaults to 1.",
                                  :ns "cljs.core",
                                  :name "drop-last",
                                  :signature ["[s]" "[n s]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/drop"
                                            "cljs.core/drop-while"],
                                  :full-name-encode "cljs.core_drop-last",
                                  :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3831 3834]},
                                  :full-name "cljs.core/drop-last",
                                  :clj-symbol "clojure.core/drop-last",
                                  :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
           "cljs.core/array?" {:description "Returns true if `x` is a JavaScript array, false otherwise.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "array?",
                               :signature ["[x]"],
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :related ["cljs.core/object?"],
                               :full-name-encode "cljs.core_arrayQMARK",
                               :source {:code "(defn ^boolean array? [x]\n  (cljs.core/array? x))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [94 95]},
                               :extra-sources ({:code "(defmacro array? [x]\n  (if (= :nodejs (-> @env/*compiler* :options :target))\n    (bool-expr `(.isArray js/Array ~x))\n    (bool-expr (core/list 'js* \"~{} instanceof Array\" x))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [302 305]}),
                               :examples [{:id "39913c",
                                           :content "```clj\n(array? #js [1 2 3])\n;;=> true\n\n(array? [1 2 3])\n;;=> false\n\n(array? \"hi\")\n;;=> false\n```"}],
                               :full-name "cljs.core/array?"},
           "cljs.core/PersistentVector.fromArray" {:ns "cljs.core",
                                                   :name "PersistentVector.fromArray",
                                                   :signature ["[xs no-clone]"],
                                                   :history [["+"
                                                              "0.0-1006"]],
                                                   :parent-type "PersistentVector",
                                                   :type "function",
                                                   :full-name-encode "cljs.core_PersistentVectorDOTfromArray",
                                                   :source {:code "(set! (.-fromArray PersistentVector)\n  (fn [xs ^boolean no-clone]\n    (let [l (alength xs)\n          xs (if no-clone xs (aclone xs))]\n      (if (< l 32)\n        (PersistentVector. nil l 5 (.-EMPTY-NODE PersistentVector) xs nil)\n        (let [node (.slice xs 0 32)\n              v (PersistentVector. nil 32 5 (.-EMPTY-NODE PersistentVector) node nil)]\n          (loop [i 32 out (-as-transient v)]\n            (if (< i l)\n              (recur (inc i) (conj! out (aget xs i)))\n              (persistent! out))))))))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/cljs/cljs/core.cljs",
                                                            :lines [4463
                                                                    4474]},
                                                   :full-name "cljs.core/PersistentVector.fromArray"},
           "cljs.core/filterv" {:description "Returns a vector of the items in `coll` for which `(pred item)` returns true.\n\n`pred` must be free of side-effects.",
                                :ns "cljs.core",
                                :name "filterv",
                                :signature ["[pred coll]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core_filterv",
                                :source {:code "(defn filterv\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [4051 4058]},
                                :full-name "cljs.core/filterv",
                                :clj-symbol "clojure.core/filterv",
                                :docstring "Returns a vector of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "cljs.core/IComparable" {:ns "cljs.core",
                                    :name "IComparable",
                                    :type "protocol",
                                    :full-name-encode "cljs.core_IComparable",
                                    :source {:code "(defprotocol IComparable\n  (^number -compare [x y]))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [397 398]},
                                    :methods [{:name "-compare",
                                               :signature ["[x y]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IComparable",
                                    :history [["+" "0.0-1424"]]},
           "cljs.reader/read-string" {:ns "cljs.reader",
                                      :name "read-string",
                                      :signature ["[s]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader_read-string",
                                      :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r false nil false)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [443 447]},
                                      :full-name "cljs.reader/read-string",
                                      :clj-symbol "clojure.core/read-string",
                                      :docstring "Reads one object from the string s"},
           "cljs.reader/unicode-2-pattern" {:ns "cljs.reader",
                                            :name "unicode-2-pattern",
                                            :type "var",
                                            :source {:code "(def unicode-2-pattern (re-pattern \"^[0-9A-Fa-f]{2}$\"))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [181]},
                                            :full-name "cljs.reader/unicode-2-pattern",
                                            :full-name-encode "cljs.reader_unicode-2-pattern",
                                            :history [["+" "0.0-1424"]]},
           "cljs.core/Volatile" {:ns "cljs.core",
                                 :name "Volatile",
                                 :type "type",
                                 :signature ["[state]"],
                                 :source {:code "(deftype Volatile [^:mutable state]\n  IVolatile\n  (-vreset! [_ new-state]\n    (set! state new-state))\n\n  IDeref\n  (-deref [_] state))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3600 3606]},
                                 :full-name "cljs.core/Volatile",
                                 :full-name-encode "cljs.core_Volatile",
                                 :history [["+" "0.0-2496"]]},
           "cljs.core/check-string-hash-cache" {:ns "cljs.core",
                                                :name "check-string-hash-cache",
                                                :signature ["[k]"],
                                                :history [["+"
                                                           "0.0-1424"]
                                                          ["-"
                                                           "0.0-2261"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_check-string-hash-cache",
                                                :source {:code "(defn check-string-hash-cache [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                                         :repo "clojurescript",
                                                         :tag "r2234",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1147
                                                                 1154]},
                                                :full-name "cljs.core/check-string-hash-cache",
                                                :removed {:in "0.0-2261",
                                                          :last-seen "0.0-2234"}},
           "cljs.core/vector?" {:description "Returns true if `x` is a vector, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "vector?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/vector"
                                          "cljs.core/vec"],
                                :full-name-encode "cljs.core_vectorQMARK",
                                :source {:code "(defn ^boolean vector?\n  [x] (satisfies? IVector x))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1541 1543]},
                                :full-name "cljs.core/vector?",
                                :clj-symbol "clojure.core/vector?",
                                :docstring "Return true if x satisfies IVector"},
           "cljs.core/defmulti" {:ns "cljs.core",
                                 :name "defmulti",
                                 :signature ["[mm-name & options]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core_defmulti",
                                 :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (core/string? (first options))\n                      (first options)\n                      nil)\n        options     (if (core/string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)\n        mm-ns (-> &env :ns :name core/str)] \n    (when (= (count options) 1)\n      (throw (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")))\n    (let [options   (apply core/hash-map options)\n          default   (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (get ~options :hierarchy (cljs.core/get-global-hierarchy))]\n           (cljs.core/MultiFn. (cljs.core/symbol ~mm-ns ~(name mm-name)) ~dispatch-fn ~default hierarchy#\n                               method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1546 1588]},
                                 :full-name "cljs.core/defmulti",
                                 :clj-symbol "clojure.core/defmulti",
                                 :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
           "cljs.core/Keyword" {:ns "cljs.core",
                                :name "Keyword",
                                :signature ["[ns name fqn _hash]"],
                                :history [["+" "0.0-1424"]],
                                :type "type",
                                :full-name-encode "cljs.core_Keyword",
                                :source {:code "(deftype Keyword [ns name fqn ^:mutable _hash]\n  Object\n  (toString [_] (str \":\" fqn))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Keyword other)\n      (identical? fqn (.-fqn other))\n      false))\n  IFn\n  (-invoke [kw coll]\n    (get coll kw))\n  (-invoke [kw coll not-found]\n    (get coll kw not-found))\n\n  IHash\n  (-hash [this]\n    (caching-hash this hash-keyword _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer (str \":\" fqn))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2494 2520]},
                                :full-name "cljs.core/Keyword",
                                :clj-symbol "clojure.lang/Keyword"},
           "cljs.core/List.EMPTY" {:ns "cljs.core",
                                   :name "List.EMPTY",
                                   :history [["+" "0.0-927"]],
                                   :parent-type "List",
                                   :type "var",
                                   :full-name-encode "cljs.core_ListDOTEMPTY",
                                   :source {:code "(set! (.-EMPTY List) (EmptyList. nil))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2387]},
                                   :full-name "cljs.core/List.EMPTY",
                                   :clj-symbol "clojure.lang/PersistentList.EMPTY"},
           "clojure.browser.event/dispatch-event" {:ns "clojure.browser.event",
                                                   :name "dispatch-event",
                                                   :type "function",
                                                   :signature ["[src event]"],
                                                   :source {:code "(defn dispatch-event\n  [src event]\n  (events/dispatchEvent src event))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [77
                                                                    79]},
                                                   :full-name "clojure.browser.event/dispatch-event",
                                                   :full-name-encode "clojure.browser.event_dispatch-event",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/ns-interns" {:ns "cljs.core",
                                   :name "ns-interns",
                                   :signature ["[[quote ns]]"],
                                   :history [["+" "0.0-2496"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core_ns-interns",
                                   :source {:code "(defmacro ns-interns\n  [[quote ns]]\n  (core/assert (core/and (= quote 'quote) (core/symbol? ns))\n    \"Argument to ns-interns must be a quoted symbol\")\n  `(into {}\n     [~@(map\n          (fn [[sym _]]\n            `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n          (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs]))]))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [1676 1685]},
                                   :full-name "cljs.core/ns-interns",
                                   :clj-symbol "clojure.core/ns-interns",
                                   :docstring "Returns a map of the intern mappings for the namespace."},
           "clojure.string/split-lines" {:description "Splits `s` on `\\n` or `\\r\\n`.",
                                         :ns "clojure.string",
                                         :name "split-lines",
                                         :signature ["[s]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :related ["clojure.string/split"],
                                         :full-name-encode "clojure.string_split-lines",
                                         :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/clojure/string.cljs",
                                                  :lines [142 145]},
                                         :full-name "clojure.string/split-lines",
                                         :clj-symbol "clojure.string/split-lines",
                                         :docstring "Splits s on \n or \r\n."},
           "cljs.test/mapped-line-and-column" {:ns "cljs.test",
                                               :name "mapped-line-and-column",
                                               :type "function",
                                               :signature ["[filename line column]"],
                                               :source {:code "(defn mapped-line-and-column [filename line column]\n  (let [default [filename line column]]\n    (if-let [source-map (:source-map (get-current-env))]\n      ;; source maps are 0 indexed for lines\n      (if-let [columns (get-in source-map [filename (dec line)])]\n        (vec\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; just take first\n            (first\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:source :line :col]))\n        default)\n      default)))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/cljs/test.cljs",
                                                        :lines [356
                                                                372]},
                                               :full-name "cljs.test/mapped-line-and-column",
                                               :full-name-encode "cljs.test_mapped-line-and-column",
                                               :history [["+"
                                                          "0.0-2496"]]},
           "cljs.repl.browser/loaded-libs" {:ns "cljs.repl.browser",
                                            :name "loaded-libs",
                                            :type "var",
                                            :source {:code "(def loaded-libs (atom #{}))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [25]},
                                            :full-name "cljs.repl.browser/loaded-libs",
                                            :full-name-encode "cljs.repl.browser_loaded-libs",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/areduce" {:description "For quickly reducing an expression `expr` across a JavaScript array `a`.  The\nexpression can use `ret` as the current result, which is initialized to `init`.\nIt can also use `idx` to get the current index.",
                                :ns "cljs.core",
                                :name "areduce",
                                :signature ["[a idx ret init expr]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/reduce"],
                                :full-name-encode "cljs.core_areduce",
                                :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1511 1520]},
                                :examples [{:id "20a389",
                                            :content "```clj\n(def a #js [1 2 3])\n(areduce a i ret 0 (+ ret (aget a i)))\n;;=> 6\n```"}],
                                :full-name "cljs.core/areduce",
                                :clj-symbol "clojure.core/areduce",
                                :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the\nevaluation of expr at each step, returning ret."},
           "cljs.core/disj" {:description "disj(oin). Returns a new set of the same (hashed/sorted) type, that does not\ncontain key(s).",
                             :ns "cljs.core",
                             :name "disj",
                             :signature ["[coll]"
                                         "[coll k]"
                                         "[coll k & ks]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/dissoc"
                                       "cljs.core/disj!"
                                       "clojure.set/difference"],
                             :full-name-encode "cljs.core_disj",
                             :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-disjoin coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (disj coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1484 1496]},
                             :full-name "cljs.core/disj",
                             :clj-symbol "clojure.core/disj",
                             :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.core/IEditableCollection" {:ns "cljs.core",
                                            :name "IEditableCollection",
                                            :history [["+" "0.0-1211"]],
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IEditableCollection",
                                            :source {:code "(defprotocol IEditableCollection\n  (^clj -as-transient [coll]))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [377 378]},
                                            :methods [{:name "-as-transient",
                                                       :signature ["[coll]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IEditableCollection",
                                            :clj-symbol "clojure.lang/IEditableCollection"},
           "cljs.core/unchecked-char" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-char",
                                       :signature ["[x]"],
                                       :history [["+" "0.0-1798"]],
                                       :type "function",
                                       :full-name-encode "cljs.core_unchecked-char",
                                       :source {:code "(defn ^number unchecked-char [x] x)",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1954]},
                                       :extra-sources ({:code "(defmacro unchecked-char [x] x)",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [367]}),
                                       :full-name "cljs.core/unchecked-char",
                                       :clj-symbol "clojure.core/unchecked-char"},
           "cljs.core/keyword-identical?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "keyword-identical?",
                                           :signature ["[x y]"],
                                           :history [["+" "0.0-1877"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_keyword-identicalQMARK",
                                           :source {:code "(defn ^boolean keyword-identical? [x y]\n  (if (identical? x y)\n    true\n    (if (and (keyword? x)\n             (keyword? y))\n      (identical? (.-fqn x) (.-fqn y))\n      false)))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2525 2531]},
                                           :full-name "cljs.core/keyword-identical?"},
           "clojure.browser.net/event-types" {:ns "clojure.browser.net",
                                              :name "event-types",
                                              :type "var",
                                              :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (.toLowerCase k))\n            v])\n         (merge\n          (js->clj EventType)))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [21 28]},
                                              :full-name "clojure.browser.net/event-types",
                                              :full-name-encode "clojure.browser.net_event-types",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.string/lower-case" {:description "Converts string to all lower-case.",
                                        :ns "clojure.string",
                                        :name "lower-case",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string_lower-case",
                                        :source {:code "(defn lower-case\n  [s]\n  (.toLowerCase s))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [73 76]},
                                        :full-name "clojure.string/lower-case",
                                        :clj-symbol "clojure.string/lower-case",
                                        :docstring "Converts string to all lower-case."},
           "cljs.core/*print-fn*" {:ns "cljs.core",
                                   :name "*print-fn*",
                                   :docstring "Each runtime environment provides a different way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                   :type "dynamic var",
                                   :source {:code "(defonce\n  ^{:doc \"Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\" :dynamic true}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [20 26]},
                                   :full-name "cljs.core/*print-fn*",
                                   :full-name-encode "cljs.core_STARprint-fnSTAR",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/str" {:description "`(str)` and `(str nil)` return the empty string.\n\n`(str x)` returns `x.toString()`.\n\nWith more than one argument, returns the concatenation of the `str` values of\nthe arguments.",
                            :ns "cljs.core",
                            :name "str",
                            :signature ["[]" "[x]" "[x & ys]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core_str",
                            :source {:code "(defn str\n  ([] \"\")\n  ([x] (if (nil? x)\n         \"\"\n         (gstring/buildString x)))\n  ([x & ys]\n    (loop [sb (StringBuffer. (str x)) more ys]\n      (if more\n        (recur (. sb  (append (str (first more)))) (next more))\n        (.toString sb)))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2194 2206]},
                            :extra-sources ({:code "(defmacro str [& xs]\n  (let [strs (->> (repeat (count xs) \"cljs.core.str(~{})\")\n               (interpose \",\")\n               (apply core/str))]\n    (list* 'js* (core/str \"[\" strs \"].join('')\") xs)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [208 212]}),
                            :full-name "cljs.core/str",
                            :clj-symbol "clojure.core/str",
                            :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
           "cljs.core/ISequential" {:ns "cljs.core",
                                    :name "ISequential",
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core_ISequential",
                                    :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [339 340]},
                                    :full-name "cljs.core/ISequential",
                                    :clj-symbol "clojure.lang/Sequential",
                                    :docstring "Marker interface indicating a persistent collection of sequential items"},
           "cljs.core/key-test" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "key-test",
                                 :signature ["[key other]"],
                                 :history [["+" "0.0-1424"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_key-test",
                                 :source {:code "(defn ^boolean key-test [key other]\n  (cond\n    (identical? key other) true\n    (keyword-identical? key other) true\n    :else (= key other)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [5596 5600]},
                                 :full-name "cljs.core/key-test"},
           "cljs.core/set" {:description "Returns a set of the distinct elements of `coll`.",
                            :ns "cljs.core",
                            :name "set",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/hash-set"
                                      "cljs.core/sorted-set"
                                      "cljs.core/conj"
                                      "cljs.core/disj"
                                      "cljs.core/distinct"
                                      "clojure.set/join"
                                      "clojure.set/select"
                                      "clojure.set/difference"
                                      "clojure.set/intersection"
                                      "clojure.set/union"
                                      "clojure.set/index"
                                      "clojure.set/project"
                                      "clojure.set/rename"
                                      "clojure.set/rename-keys"
                                      "clojure.set/map-invert"],
                            :full-name-encode "cljs.core_set",
                            :source {:code "(defn set\n  [coll]\n  (let [^not-native in (seq coll)]\n    (cond\n      (nil? in) #{}\n\n      (and (instance? IndexedSeq in) (zero? (.-i in)))\n      (set-from-indexed-seq in)\n\n      :else\n      (loop [in in\n              ^not-native out (-as-transient #{})]\n        (if-not (nil? in)\n          (recur (-next in) (-conj! out (-first in)))\n          (-persistent! out))))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [7586 7601]},
                            :full-name "cljs.core/set",
                            :clj-symbol "clojure.core/set",
                            :docstring "Returns a set of the distinct elements of coll."},
           "cljs.repl.nashorn/load-js-file" {:ns "cljs.repl.nashorn",
                                             :name "load-js-file",
                                             :type "function",
                                             :signature ["[engine file]"],
                                             :source {:code "(defn load-js-file [engine file]\n  (eval-str engine (format \"nashorn_load(\\\"%s\\\");\" file)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/clj/cljs/repl/nashorn.clj",
                                                      :lines [105 106]},
                                             :full-name "cljs.repl.nashorn/load-js-file",
                                             :full-name-encode "cljs.repl.nashorn_load-js-file",
                                             :history [["+"
                                                        "0.0-2814"]]},
           "cljs.core/obj-map" {:ns "cljs.core",
                                :name "obj-map",
                                :signature ["[& keyvals]"],
                                :history [["+" "0.0-1443"]],
                                :type "function",
                                :full-name-encode "cljs.core_obj-map",
                                :source {:code "(defn obj-map\n  [& keyvals]\n  (let [ks  (array)\n        obj (js-obj)]\n    (loop [kvs (seq keyvals)]\n      (if kvs\n        (do (.push ks (first kvs))\n            (aset obj (first kvs) (second kvs))\n            (recur (nnext kvs)))\n        (.fromObject ObjMap ks obj)))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7145 7156]},
                                :full-name "cljs.core/obj-map",
                                :docstring "keyval => key val\nReturns a new object map with supplied mappings."},
           "special/def" {:description "Creates a global variable with the name of `symbol` and a namespace of the\ncurrent namespace.\n\nIf `init` is supplied, it is evaluated and the result is assigned to `symbol`.\n\n`doc-string` is an optional documentation string.\n\n`def` is one of ClojureScript's [special forms](http://clojure.org/special_forms)\nand is used by many macros to define common elements (ie: `defn`, `defmacro`,\netc).",
                          :ns "special",
                          :name "def",
                          :signature ["[symbol]"
                                      "[symbol init]"
                                      "[symbol doc-string init]"],
                          :history [["+" "0.0-927"]],
                          :type "special form",
                          :related ["cljs.core/defn"
                                    "cljs.core/fn"
                                    "cljs.core/defmacro"
                                    "cljs.core/defmulti"],
                          :full-name-encode "special_def",
                          :source {:code "(defmethod parse 'def\n  [op env form name _]\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        sym-meta (meta sym)\n        tag (-> sym meta :tag)\n        protocol (-> sym meta :protocol)\n        dynamic (-> sym meta :dynamic)\n        ns-name (-> env :ns :name)\n        locals (:locals env)]\n    (when (namespace sym)\n      (throw (error env \"Can't def ns-qualified name\")))\n    (when-let [doc (:doc args)]\n      (when-not (string? doc)\n        (throw (error env \"Too many arguments to def\"))))\n    (when-let [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n      (when (and (not *allow-redef*)\n                 (not (:declared v))\n                 (not (:declared sym-meta))\n                 *file-defs*\n                 (get @*file-defs* sym))\n        (warning :redef-in-file env {:sym sym :line (:line v)})))\n    (when *file-defs*\n      (swap! *file-defs* conj sym))\n    (let [env (if (or (and (not= ns-name 'cljs.core)\n                           (core-name? env sym))\n                      (get-in @env/*compiler* [::namespaces ns-name :uses sym]))\n                (let [ev (resolve-existing-var (dissoc env :locals) sym)]\n                  (warning :redef env {:sym sym :ns (:ns ev) :ns-name ns-name})\n                  (swap! env/*compiler* update-in [::namespaces ns-name :excludes] conj sym)\n                  (update-in env [:ns :excludes] conj sym))\n                env)\n          var-name (:name (resolve-var (dissoc env :locals) sym))\n          init-expr (when (contains? args :init)\n                      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n                        (merge\n                          {:name var-name}\n                          sym-meta\n                          (when dynamic {:dynamic true})\n                          (source-info var-name env)))\n                      (disallowing-recur\n                        (analyze (assoc env :context :expr) (:init args) sym)))\n          fn-var? (and init-expr (= (:op init-expr) :fn))\n          tag (if fn-var?\n                (or (:ret-tag init-expr) tag)\n                tag)\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) var-name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (when-let [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n        (when (and (not (-> sym meta :declared))\n                   (and (:fn-var v) (not fn-var?)))\n          (warning :fn-var env {:ns-name ns-name :sym sym})))\n      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n        (merge \n          {:name var-name}\n          ;; elide test metadata, as it includes non-valid EDN - David\n          (cond-> sym-meta\n            :test (-> (dissoc :test) (assoc :test true)))\n          {:meta (dissoc sym-meta :test)}\n          (when doc {:doc doc})\n          (when dynamic {:dynamic true})\n          (source-info var-name env)\n          ;; the protocol a protocol fn belongs to\n          (when protocol\n            {:protocol protocol})\n          ;; symbol for reified protocol\n          (when-let [protocol-symbol (-> sym meta :protocol-symbol)]\n            {:protocol-symbol protocol-symbol\n             :info (-> protocol-symbol meta :protocol-info)\n             :impls #{}})\n          (when fn-var?\n            (let [params (map #(vec (map :name (:params %))) (:methods init-expr))]\n              {:fn-var true\n               ;; protocol implementation context\n               :protocol-impl (:protocol-impl init-expr)\n               ;; inline protocol implementation context\n               :protocol-inline (:protocol-inline init-expr)\n               :variadic (:variadic init-expr)\n               :max-fixed-arity (:max-fixed-arity init-expr)\n               :method-params params\n               :arglists (:arglists sym-meta)\n               :arglists-meta (doall (map meta (:arglists sym-meta)))\n               :methods (map (fn [method]\n                               (let [tag (infer-tag env (assoc method :op :method))]\n                                 (cond-> (select-keys method\n                                           [:max-fixed-arity :variadic])\n                                   tag (assoc :tag tag))))\n                          (:methods init-expr))}) )\n          (when (and fn-var? tag)\n            {:ret-tag tag})))\n      (merge {:env env :op :def :form form\n              :name var-name\n              :var (assoc\n                     (analyze\n                       (-> env (dissoc :locals)\n                         (assoc :context :expr)\n                         (assoc :def-var true))\n                       sym)\n                     :op :var)\n              :doc doc :init init-expr}\n        (when-let [test (:test sym-meta)]\n          {:test (analyze (assoc env :context :expr) test)})\n        (when tag\n          (if fn-var?\n            {:ret-tag tag}\n            {:tag tag}))\n        (when dynamic {:dynamic true})\n        (when export-as {:export export-as})\n        (when init-expr {:children [init-expr]})))))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/clj/cljs/analyzer.clj",
                                   :lines [669 782]},
                          :examples [{:id "a5f898",
                                      :content "```clj\n(def a)\na\n;;=> nil\n\n(def b 42)\nb\n;;=> 42\n\n(def c \"an optional docstring\" 42)\nc\n;;=> 42\n```"}],
                          :full-name "special/def",
                          :clj-symbol "clojure.core/def"},
           "cljs.core/print" {:ns "cljs.core",
                              :name "print",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_print",
                              :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8299 8304]},
                              :full-name "cljs.core/print",
                              :clj-symbol "clojure.core/print",
                              :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption."},
           "cljs.core/ArrayNode" {:ns "cljs.core",
                                  :name "ArrayNode",
                                  :signature ["[edit cnt arr]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "type",
                                  :full-name-encode "cljs.core_ArrayNode",
                                  :source {:code "(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-lookup node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (alength arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [node (aget arr i)]\n            (if-not (nil? node)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  @init\n                  (recur (inc i) init)))\n              (recur (inc i) init)))\n          init)))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [5866 5961]},
                                  :full-name "cljs.core/ArrayNode",
                                  :clj-symbol "clojure.lang/ArrayNode"},
           "cljs.core/type" {:ns "cljs.core",
                             :name "type",
                             :signature ["[x]"],
                             :history [["+" "0.0-971"]],
                             :type "function",
                             :full-name-encode "cljs.core_type",
                             :source {:code "(defn type [x]\n  (when-not (nil? x)\n    (.-constructor x)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [137 139]},
                             :full-name "cljs.core/type",
                             :clj-symbol "clojure.core/type"},
           "clojure.string/blank?" {:description "True if `s` is nil, empty, or contains only whitespace.",
                                    :ns "clojure.string",
                                    :name "blank?",
                                    :signature ["[s]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string_blankQMARK",
                                    :source {:code "(defn blank?\n  [s]\n  (gstring/isEmptySafe s))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [174 177]},
                                    :full-name "clojure.string/blank?",
                                    :clj-symbol "clojure.string/blank?",
                                    :docstring "True is s is nil, empty, or contains only whitespace."},
           "syntax/keyword" {:description "Signifies a keyword, a string-like datatype often used as keys for maps.\nKeywords should not start with a number.\n\nKeywords can have an optional namespace. For example, `:foo/bar`. This is useful\nfor functions in a namespace to prevent key collisions on a globally accessible\nmap.\n\nPreceding a keyword with `::` will prepend the given keyword with the current\nnamespace.  For example, in the user namespace, `::foo` is read as `:user/foo`.\n\nIf a keyword is prefixed by `::` and is namespace-qualified, the namespace part is properly resolved.\nFor example, if `foo` is an alias of `cljs.core`, then `::foo/bar` evaluates to `:cljs.core/bar`.\nA reader exception is thrown if `foo` is not a namespace.",
                             :ns "syntax",
                             :name "keyword",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["cljs.core/keyword"
                                       "cljs.core/keyword?"],
                             :full-name-encode "syntax_keyword",
                             :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                      :repo "tools.reader",
                                      :tag "tools.reader-0.8.10",
                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                      :lines [591 610]},
                             :extra-sources [{:code "(defn- read-keyword\n  [reader initch]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-ns (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (reader-error reader \"Invalid token: :\" token)))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (reader-error reader \"Invalid token: :\" token)))\n      (reader-error reader \"Invalid token: :\"))))",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [315 333]}],
                             :syntax-form ":",
                             :examples [{:id "e5fdbe",
                                         :content "```clj\n:foo\n;;=> :foo\n\n::foo\n;;=> :user/foo\n\n:a/foo\n;;=> :a/foo\n```"}
                                        {:id "9765fe",
                                         :content "A keyword is also callable for retrieving values from a map:\n\n```clj\n(def m {:foo 1})\n(:foo m)\n;;=> 1\n\n(def things [{:foo 1 :bar 2}\n             {:foo 3 :bar 4}\n             {:foo 5 :bar 6}])\n(map :foo things)\n;;=> (1 3 5)\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#keywords",
                             :full-name "syntax/keyword",
                             :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.reader/maybe-read-tagged-type" {:ns "cljs.reader",
                                                 :name "maybe-read-tagged-type",
                                                 :type "function",
                                                 :signature ["[rdr initch]"],
                                                 :source {:code "(defn maybe-read-tagged-type\n  [rdr initch]\n  (let [tag (read-symbol rdr initch)\n        pfn (get @*tag-table* (str tag))\n        dfn @*default-data-reader-fn*]\n    (cond\n     pfn (pfn (read rdr true nil false))\n     dfn (dfn tag (read rdr true nil false))\n     :else (reader-error rdr\n                         \"Could not find tag parser for \" (str tag)\n                         \" in \" (pr-str (keys @*tag-table*))))))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/cljs/reader.cljs",
                                                          :lines [576
                                                                  586]},
                                                 :full-name "cljs.reader/maybe-read-tagged-type",
                                                 :full-name-encode "cljs.reader_maybe-read-tagged-type",
                                                 :history [["+"
                                                            "0.0-1236"]]},
           "cljs.core/IChunkedSeq" {:ns "cljs.core",
                                    :name "IChunkedSeq",
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core_IChunkedSeq",
                                    :source {:code "(defprotocol IChunkedSeq\n  (-chunked-first [coll])\n  (-chunked-rest [coll]))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [403 405]},
                                    :methods [{:name "-chunked-first",
                                               :signature ["[coll]"],
                                               :docstring nil}
                                              {:name "-chunked-rest",
                                               :signature ["[coll]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IChunkedSeq",
                                    :clj-symbol "clojure.lang/IChunkedSeq"},
           "clojure.browser.dom/append" {:ns "clojure.browser.dom",
                                         :name "append",
                                         :type "function",
                                         :signature ["[parent & children]"],
                                         :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/clojure/browser/dom.cljs",
                                                  :lines [13 15]},
                                         :full-name "clojure.browser.dom/append",
                                         :full-name-encode "clojure.browser.dom_append",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/take-last" {:description "Returns a sequence of the last `n` items in `coll`.\n\nDepending on the type of collection, `take-last` may be no faster than linear\ntime. For vectors, please use `subvec`.",
                                  :ns "cljs.core",
                                  :name "take-last",
                                  :signature ["[n coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/last"
                                            "cljs.core/butlast"
                                            "cljs.core/drop-last"],
                                  :full-name-encode "cljs.core_take-last",
                                  :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3836 3843]},
                                  :full-name "cljs.core/take-last",
                                  :clj-symbol "clojure.core/take-last",
                                  :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
           "cljs.core/key->js" {:ns "cljs.core",
                                :name "key->js",
                                :type "function",
                                :signature ["[k]"],
                                :source {:code "(defn key->js [k]\n  (if (satisfies? IEncodeJS k)\n    (-clj->js k)\n    (if (or (string? k)\n            (number? k)\n            (keyword? k)\n            (symbol? k))\n      (clj->js k)\n      (pr-str k))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8642 8650]},
                                :full-name "cljs.core/key->js",
                                :full-name-encode "cljs.core_key-GTjs",
                                :history [["+" "0.0-1798"]]},
           "cljs.repl.browser/setup" {:ns "cljs.repl.browser",
                                      :name "setup",
                                      :type "function",
                                      :signature ["[repl-env opts]"],
                                      :source {:code "(defn setup [repl-env opts]\n  (when (:src repl-env)\n    (repl/analyze-source (:src repl-env)))\n  (comp/with-core-cljs nil\n    (fn [] (server/start repl-env))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/repl/browser.clj",
                                               :lines [195 199]},
                                      :full-name "cljs.repl.browser/setup",
                                      :full-name-encode "cljs.repl.browser_setup",
                                      :history [["+" "0.0-2665"]]},
           "cljs.core/TransientHashMap" {:ns "cljs.core",
                                         :name "TransientHashMap",
                                         :signature ["[edit root count has-nil? nil-val]"],
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core_TransientHashMap",
                                         :source {:code "(deftype TransientHashMap [^:mutable ^boolean edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable ^boolean has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (if (satisfies? IMapEntry o)\n        (.assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent\"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (Box. false)\n              node        (-> (if (nil? root)\n                                (.-EMPTY BitmapIndexedNode)\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if ^boolean (.-val added-leaf?)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (Box. false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if (aget removed-leaf? 0)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (.inode-lookup root 0 (hash k) k))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (.inode-lookup root 0 (hash k) k not-found))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [6355 6456]},
                                         :full-name "cljs.core/TransientHashMap",
                                         :clj-symbol "clojure.lang/TransientHashMap"},
           "clojure.set/intersection" {:description "Return a set that is the intersection of the input sets.",
                                       :ns "clojure.set",
                                       :name "intersection",
                                       :signature ["[s1]"
                                                   "[s1 s2]"
                                                   "[s1 s2 & sets]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["clojure.set/union"
                                                 "clojure.set/difference"
                                                 "clojure.set/superset?"
                                                 "clojure.set/project"],
                                       :full-name-encode "clojure.set_intersection",
                                       :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/clojure/set.cljs",
                                                :lines [31 44]},
                                       :full-name "clojure.set/intersection",
                                       :clj-symbol "clojure.set/intersection",
                                       :docstring "Return a set that is the intersection of the input sets"},
           "cljs.test/async?" {:ns "cljs.test",
                               :name "async?",
                               :signature ["[x]"],
                               :history [["+" "0.0-2814"]],
                               :type "function",
                               :full-name-encode "cljs.test_asyncQMARK",
                               :source {:code "(defn async?\n  [x]\n  (satisfies? IAsyncTest x))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/test.cljs",
                                        :lines [403 406]},
                               :full-name "cljs.test/async?",
                               :docstring "Returns whether x implements IAsyncTest."},
           "cljs.core/fnext" {:description "Same as `(first (next coll))`",
                              :ns "cljs.core",
                              :name "fnext",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/ffirst"
                                        "cljs.core/second"],
                              :full-name-encode "cljs.core_fnext",
                              :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1162 1165]},
                              :examples [{:id "92383f",
                                          :content "```clj\n(fnext [1 2 3])\n;;=> 2\n\n(fnext [1 2])\n;;=> 2\n\n(fnext [1])\n;;=> nil\n\n(fnext [])\n;;=> nil\n```"}],
                              :full-name "cljs.core/fnext",
                              :clj-symbol "clojure.core/fnext",
                              :docstring "Same as (first (next x))"},
           "cljs.core/apply" {:description "Applies function `f` to the argument list formed by prepending intervening\narguments to `args`.",
                              :ns "cljs.core",
                              :name "apply",
                              :signature ["[f args]"
                                          "[f x args]"
                                          "[f x y args]"
                                          "[f x y z args]"
                                          "[f a b c d & args]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/map"],
                              :full-name-encode "cljs.core_apply",
                              :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count args (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc args)\n            (.cljs$lang$applyTo f args)))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist))))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2986 3032]},
                              :examples [{:id "174052",
                                          :content "```clj\n(max 1 2 3)\n;;=> 3\n\n(apply max [1 2 3])\n;;=> 3\n\n(apply max 1 [2 3])\n;;=> 3\n```"}],
                              :full-name "cljs.core/apply",
                              :clj-symbol "clojure.core/apply",
                              :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
           "clojure.walk/prewalk" {:ns "clojure.walk",
                                   :name "prewalk",
                                   :signature ["[f form]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.walk_prewalk",
                                   :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/clojure/walk.cljs",
                                            :lines [58 62]},
                                   :full-name "clojure.walk/prewalk",
                                   :clj-symbol "clojure.walk/prewalk",
                                   :docstring "Like postwalk, but does pre-order traversal."},
           "cljs.core/flatten" {:description "Takes any nested combination of sequential things (lists, vectors, etc.) and\nreturns their contents as a single, flat sequence.\n\n`(flatten nil)` returns nil.",
                                :ns "cljs.core",
                                :name "flatten",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_flatten",
                                :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [4013 4019]},
                                :full-name "cljs.core/flatten",
                                :clj-symbol "clojure.core/flatten",
                                :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
           "cljs.core/get" {:description "Returns the value mapped to key `k`.\n\nReturns `not-found` or nil if `k` is not present in `o`.",
                            :ns "cljs.core",
                            :name "get",
                            :signature ["[o k]" "[o k not-found]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/get-in"],
                            :full-name-encode "cljs.core_get",
                            :source {:code "(defn get\n  ([o k]\n    (when-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup ^not-native o k)\n\n        (array? o)\n        (when (< k (.-length o))\n          (aget o k))\n        \n        (string? o)\n        (when (< k (.-length o))\n          (aget o k))\n\n        (native-satisfies? ILookup o)\n        (-lookup o k)\n        \n        :else nil)))\n  ([o k not-found]\n    (if-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup ^not-native o k not-found)\n\n        (array? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n        \n        (string? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n\n        (native-satisfies? ILookup o)\n        (-lookup o k not-found)\n\n        :else not-found)\n      not-found)))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1324 1364]},
                            :full-name "cljs.core/get",
                            :clj-symbol "clojure.core/get",
                            :docstring "Returns the value mapped to key, not-found or nil if key not present."},
           "cljs.repl/skip-whitespace" {:ns "cljs.repl",
                                        :name "skip-whitespace",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-2719"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl_skip-whitespace",
                                        :source {:code "(defn skip-whitespace\n  [s]\n  (loop [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      \\; (do (readers/read-line s) :line-start)\n      (if (or (Character/isWhitespace c) (identical? c \\,))\n        (recur (readers/read-char s))\n        (do (readers/unread s c) :body)))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [50 67]},
                                        :full-name "cljs.repl/skip-whitespace",
                                        :docstring "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\nor :body to indicate the relative location of the next character on s.\nInterprets comma as whitespace and semicolon as comment to end of line.\nDoes not interpret #! as comment to end of line because only one\ncharacter of lookahead is available. The stream must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF to a single\n\\newline."},
           "cljs.core/char" {:description "Converts a number `x` to a character using `String.fromCharCode(x)` from\nJavaScript.",
                             :ns "cljs.core",
                             :name "char",
                             :signature ["[x]"],
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core_char",
                             :source {:code "(defn char\n  [x]\n  (cond\n    (number? x) (.fromCharCode js/String x)\n    (and (string? x) (== (.-length x) 1)) x\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1941 1947]},
                             :examples [{:id "4e1a56",
                                         :content "```clj\n(char 81)\n;;=> \"Q\"\n\n(char \"Q\")\n;;=> \"Q\"\n\n(char \"foo\")\n;; Error: Argument to char must be a character or number\n```"}],
                             :full-name "cljs.core/char",
                             :clj-symbol "clojure.core/char",
                             :docstring "Coerce to char"},
           "cljs.core/.." {:description "For interop, the `..` macro allows method/property chaining on the given JavaScript object `o`.\n\nIt essentially combines the thread-first `->` macro with the `.` operator.",
                           :ns "cljs.core",
                           :name "..",
                           :signature ["[o form]" "[o form & more]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["special/."
                                     "cljs.core/->"
                                     "cljs.core/doto"],
                           :full-name-encode "cljs.core_DOTDOT",
                           :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                    :repo "clojure",
                                    :tag "clojure-1.6.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1540 1556]},
                           :examples [{:id "500658",
                                       :content "```js\n// JavaScript\n\"a b c d\".toUpperCase().replace(\"A\", \"X\")\n//=> \"X B C D\"\n```\n\n```clj\n;; ClojureScript\n(.. \"a b c d\"\n    toUpperCase\n    (replace \"A\" \"X\"))\n;;=> \"X B C D\"\n```\n\nThis is expanded to:\n\n```clj\n(. (. \"a b c d\" toUpperCase) (replace \"A\" \"X\"))\n```\n\n\nwhich is equivalent to:\n\n```clj\n(.replace (.toUpperCase \"a b c d\") \"A\" \"X\")\n;;=> \"X B C D\"\n```\n\nCompare to the equivalent form using the thread-first `->` macro:\n\n```clj\n(-> \"a b c d\"\n    .toUpperCase\n    (.replace \"A\" \"X\"))\n;;=> \"X B C D\"\n```"}],
                           :full-name "cljs.core/..",
                           :clj-symbol "clojure.core/..",
                           :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
           "cljs.core/floats" {:ns "cljs.core",
                               :name "floats",
                               :signature ["[x]"],
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :full-name-encode "cljs.core_floats",
                               :source {:code "(defn floats [x] x)",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2061]},
                               :full-name "cljs.core/floats",
                               :clj-symbol "clojure.core/floats"},
           "specialrepl/require-macros" {:description "Only usable from a REPL.\n\nThis is a way for ClojureScript to load macros from Clojure files.\nThe usage is similar to the `require` form.\n\nThere is a nicer alternative if the Clojure macros file has the same name as a\nClojureScript file in the same directory, which is a common pattern.  In this\ncase, you can just use the `:include-macros` or `:refer-macros` flag of the\n`require` form.",
                                         :ns "specialrepl",
                                         :name "require-macros",
                                         :history [["+" "0.0-2657"]],
                                         :type "special form (repl)",
                                         :related ["specialrepl/require"],
                                         :full-name-encode "specialrepl_require-macros",
                                         :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n        (when-not (and (= quote 'quote) (symbol? ns-name))\n          (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n        (when-not (ana/get-namespace ns-name)\n          (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n          (-evaluate repl-env \"<cljs repl>\" 1\n            (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n        (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (let [is-self-require? (self-require? specs)\n              [target-ns restore-ns]\n              (if-not is-self-require?\n                [ana/*cljs-ns* nil]\n                ['cljs.user ana/*cljs-ns*])]\n          (evaluate-form repl-env env \"<cljs repl>\"\n            (with-meta\n              `(~'ns ~target-ns\n                 (:require\n                   ~@(map\n                       (fn [quoted-spec-or-kw]\n                         (if (keyword? quoted-spec-or-kw)\n                           quoted-spec-or-kw\n                           (second quoted-spec-or-kw)))\n                       specs)))\n              {:merge true :line 1 :column 1})\n            identity opts)\n          (when is-self-require?\n            (set! ana/*cljs-ns* restore-ns)))))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (evaluate-form repl-env env \"<cljs repl>\"\n          (with-meta\n            `(~'ns ~ana/*cljs-ns*\n               (:require-macros\n                 ~@(map\n                     (fn [quoted-spec-or-kw]\n                       (if (keyword? quoted-spec-or-kw)\n                         quoted-spec-or-kw\n                         (second quoted-spec-or-kw)))\n                     specs)))\n            {:merge true :line 1 :column 1})\n          identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n        (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n        (load-namespace repl-env ns opts)))}))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl.clj",
                                                  :lines [475 543]},
                                         :examples [{:id "e34cf4",
                                                     :content "```clj\n(require-macros '[cljs.core.async.macros :refer [go]])\n```"}],
                                         :full-name "specialrepl/require-macros"},
           "cljs.core/Range" {:ns "cljs.core",
                              :name "Range",
                              :signature ["[meta start end step __hash]"],
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core_Range",
                              :source {:code "(deftype Range [meta start end step ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (Range. meta start end step __hash))\n\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step __hash))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng]\n    (if (pos? step)\n      (when (< start end)\n        rng)\n      (when (> start end)\n        rng)))\n\n  ISeq\n  (-first [rng]\n    (when-not (nil? (-seq rng)) start))\n  (-rest [rng]\n    (if-not (nil? (-seq rng))\n      (Range. meta (+ start step) end step nil)\n      ()))\n\n  IIterable\n  (-iterator [_]\n    (RangeIterator. start end step))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (< (+ start step) end)\n        (Range. meta (+ start step) end step nil))\n      (when (> (+ start step) end)\n        (Range. meta (+ start step) end step nil))))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-ordered-coll __hash))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (Math/ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        not-found)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f init]\n    (loop [i start ret init]\n      (if (if (pos? step) (< i end) (> i end))\n        (let [ret (f ret i)]\n          (if (reduced? ret)\n            @ret\n            (recur (+ i step) ret)))\n        ret))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7810 7896]},
                              :full-name "cljs.core/Range",
                              :clj-symbol "clojure.lang/Range"},
           "cljs.core/zero?" {:description "Returns true if `n` is 0, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "zero?",
                              :signature ["[n]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/pos?"
                                        "cljs.core/neg?"],
                              :full-name-encode "cljs.core_zeroQMARK",
                              :source {:code "(defn ^boolean zero? [n]\n  (cljs.core/zero? n))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2175 2176]},
                              :extra-sources ({:code "(defmacro ^::ana/numeric zero? [x]\n  `(== ~x 0))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [466 467]}),
                              :full-name "cljs.core/zero?",
                              :clj-symbol "clojure.core/zero?"},
           "cljs.core/identity" {:description "Returns its argument.",
                                 :ns "cljs.core",
                                 :name "identity",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/nil?"],
                                 :full-name-encode "cljs.core_identity",
                                 :source {:code "(defn identity [x] x)",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1814]},
                                 :full-name "cljs.core/identity",
                                 :clj-symbol "clojure.core/identity"},
           "cljs.core/first" {:description "Returns the first item in `coll` and calls `seq` on its argument.\n\nReturns nil when `coll` is nil.",
                              :ns "cljs.core",
                              :name "first",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/rest"
                                        "cljs.core/next"
                                        "cljs.core/nth"
                                        "cljs.core/second"
                                        "cljs.core/take"
                                        "cljs.core/ffirst"],
                              :full-name-encode "cljs.core_first",
                              :source {:code "(defn first\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-first ^not-native coll)\n      (let [s (seq coll)]\n        (when-not (nil? s)\n          (-first s))))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [729 738]},
                              :examples [{:id "40e413",
                                          :content "```clj\n(first [1 2 3])\n;;=> 1\n\n(first [])\n;;=> nil\n```"}],
                              :full-name "cljs.core/first",
                              :clj-symbol "clojure.core/first",
                              :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
           "cljs.reader/ratio-pattern" {:ns "cljs.reader",
                                        :name "ratio-pattern",
                                        :type "var",
                                        :source {:code "(def ratio-pattern (re-pattern \"^([-+]?[0-9]+)/([0-9]+)$\"))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [99]},
                                        :full-name "cljs.reader/ratio-pattern",
                                        :full-name-encode "cljs.reader_ratio-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/println-str" {:ns "cljs.core",
                                    :name "println-str",
                                    :signature ["[& objs]"],
                                    :history [["+" "0.0-1011"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_println-str",
                                    :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [8318 8321]},
                                    :full-name "cljs.core/println-str",
                                    :clj-symbol "clojure.core/println-str",
                                    :docstring "println to a string, returning it"},
           "cljs.core/>" {:description "Returns true if each successive number argument is less than the previous\none, false otherwise.",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name ">",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/>="],
                          :full-name-encode "cljs.core_GT",
                          :source {:code "(defn ^boolean >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1897 1907]},
                          :extra-sources ({:code "(defmacro ^::ana/numeric >\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [445 448]}),
                          :examples [{:id "67180c",
                                      :content "```clj\n(> 1 2)\n;;=> false\n\n(> 2 1)\n;;=> true\n\n(> 2 2)\n;;=> false\n\n(> 6 5 4 3 2)\n;;=> true\n```"}],
                          :full-name "cljs.core/>",
                          :clj-symbol "clojure.core/>",
                          :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
           "cljs.repl/IPrintStacktrace" {:ns "cljs.repl",
                                         :name "IPrintStacktrace",
                                         :type "protocol",
                                         :full-name-encode "cljs.repl_IPrintStacktrace",
                                         :source {:code "(defprotocol IPrintStacktrace\n  (-print-stacktrace [repl-env stacktrace error build-options]\n    \"Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.\"))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl.clj",
                                                  :lines [122 125]},
                                         :methods [{:name "-print-stacktrace",
                                                    :signature ["[repl-env stacktrace error build-options]"],
                                                    :docstring "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing."}],
                                         :full-name "cljs.repl/IPrintStacktrace",
                                         :history [["+" "0.0-2843"]]},
           "cljs.core/juxt" {:description "Takes a set of functions and returns a function that is the juxtaposition of\nthose functions.\n\nThe returned function takes a variable number of arguments, and returns a vector\ncontaining the result of applying each function to the arguments (left-to-\nright).\n\n`((juxt a b c) x)` => `[(a x) (b x) (c x)]`",
                             :ns "cljs.core",
                             :name "juxt",
                             :signature ["[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f g h & fs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/partial"
                                       "cljs.core/comp"],
                             :full-name-encode "cljs.core_juxt",
                             :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7997 8031]},
                             :full-name "cljs.core/juxt",
                             :clj-symbol "clojure.core/juxt",
                             :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
           "cljs.core/max" {:description "Returns the greatest number argument.",
                            :return-type number,
                            :ns "cljs.core",
                            :name "max",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/min"
                                      "cljs.core/max-key"],
                            :full-name-encode "cljs.core_max",
                            :source {:code "(defn ^number max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1925 1930]},
                            :extra-sources ({:code "(defmacro ^::ana/numeric max\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} > ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [475 479]}),
                            :full-name "cljs.core/max",
                            :clj-symbol "clojure.core/max",
                            :docstring "Returns the greatest of the nums."},
           "cljs.core/completing" {:ns "cljs.core",
                                   :name "completing",
                                   :type "function",
                                   :signature ["[f]" "[f cf]"],
                                   :source {:code "(defn completing\n  ([f] (completing f identity))\n  ([f cf]\n    (fn\n      ([] (f))\n      ([x] (cf x))\n      ([x y] (f x y)))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1816 1822]},
                                   :full-name "cljs.core/completing",
                                   :full-name-encode "cljs.core_completing",
                                   :history [["+" "0.0-2341"]]},
           "cljs.core/transduce" {:ns "cljs.core",
                                  :name "transduce",
                                  :signature ["[xform f coll]"
                                              "[xform f init coll]"],
                                  :history [["+" "0.0-2301"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_transduce",
                                  :source {:code "(defn transduce\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n     (let [f (xform f)\n           ret (reduce f init coll)]\n       (f ret))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1824 1837]},
                                  :full-name "cljs.core/transduce",
                                  :docstring "reduce with a transformation of f (xf). If init is not\nsupplied, (f) will be called to produce it. f should be a reducing\nstep function that accepts both 1 and 2 arguments, if it accepts\nonly 2 you can add the arity-1 with 'completing'. Returns the result\nof applying (the transformed) xf to init and the first item in coll,\nthen applying xf to that result and the 2nd item, etc. If coll\ncontains no items, returns init and f is not called. Note that\ncertain transforms may inject or skip items."},
           "cljs.test/test-var" {:ns "cljs.test",
                                 :name "test-var",
                                 :signature ["[v]"],
                                 :history [["+" "0.0-2496"]],
                                 :type "function",
                                 :full-name-encode "cljs.test_test-var",
                                 :source {:code "(defn test-var\n  [v]\n  (run-block (test-var-block v)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/test.cljs",
                                          :lines [461 465]},
                                 :full-name "cljs.test/test-var",
                                 :clj-symbol "clojure.test/test-var",
                                 :docstring "If v has a function in its :test metadata, calls that function,\nadd v to :testing-vars property of env."},
           "cljs.core/with-out-str" {:ns "cljs.core",
                                     :name "with-out-str",
                                     :signature ["[& body]"],
                                     :history [["+" "0.0-1535"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core_with-out-str",
                                     :source {:code "(defmacro with-out-str\n  [& body]\n  `(let [sb# (goog.string.StringBuffer.)]\n     (binding [cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1648 1656]},
                                     :full-name "cljs.core/with-out-str",
                                     :clj-symbol "clojure.core/with-out-str",
                                     :docstring "Evaluates exprs in a context in which *print-fn* is bound to .append\non a fresh StringBuffer.  Returns the string created by any nested\nprinting calls."},
           "cljs.core/*3" {:description "Only usable from a REPL.\n\nHolds the result of the third to last expression.",
                           :ns "cljs.core",
                           :name "*3",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*2"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR3",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [67 69]},
                           :examples [{:id "d7a6e9",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n(+ 4 8)\n;;=> 12\n\n(+ 1 2)\n;;=> 3\n\n*3\n;;=> 10\n\n(inc *3)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*3",
                           :clj-symbol "clojure.core/*3",
                           :docstring "bound in a repl thread to the third most recent value printed"},
           "cljs.core/memfn" {:ns "cljs.core",
                              :name "memfn",
                              :signature ["[name & args]"],
                              :history [["+" "0.0-1443"]],
                              :type "macro",
                              :full-name-encode "cljs.core_memfn",
                              :source {:code "(defmacro memfn\n  [name & args]\n  (let [t (with-meta (gensym \"target\")\n            (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))",
                                       :repo "clojure",
                                       :tag "clojure-1.6.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [3550 3561]},
                              :full-name "cljs.core/memfn",
                              :clj-symbol "clojure.core/memfn",
                              :docstring "Expands into code that creates a fn that expects to be passed an\nobject and any args and calls the named instance method on the\nobject passing the args. Use when you want to treat a Java method as\na first-class fn. name may be type-hinted with the method receiver's\ntype in order to avoid reflective calls."},
           "cljs.core/IEncodeClojure" {:ns "cljs.core",
                                       :name "IEncodeClojure",
                                       :type "protocol",
                                       :full-name-encode "cljs.core_IEncodeClojure",
                                       :source {:code "(defprotocol IEncodeClojure\n  (-js->clj [x options] \"Transforms JavaScript values to Clojure\"))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [8673 8674]},
                                       :methods [{:name "-js->clj",
                                                  :signature ["[x options]"],
                                                  :docstring "Transforms JavaScript values to Clojure"}],
                                       :full-name "cljs.core/IEncodeClojure",
                                       :history [["+" "0.0-1552"]]},
           "cljs.core/TransientArrayMap" {:ns "cljs.core",
                                          :name "TransientArrayMap",
                                          :signature ["[editable? len arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_TransientArrayMap",
                                          :source {:code "(deftype TransientArrayMap [^:mutable editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (== idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. \"lookup after persistent!\"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (if (satisfies? IMapEntry o)\n        (-assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (== idx -1)\n          (if (<= (+ len 2) (* 2 (.-HASHMAP-THRESHOLD PersistentArrayMap)))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array->transient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (>= idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. \"dissoc! after persistent!\")))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5513 5579]},
                                          :full-name "cljs.core/TransientArrayMap",
                                          :clj-symbol "clojure.lang/TransientArrayMap"},
           "cljs.core/cond->>" {:description "Takes an expression and a set of test/form pairs. Threads `expr` (via `->>`)\nthrough each form for which the corresponding test expression is true.\n\nNote that, unlike `cond` branching, `cond->>` threading does not short circuit\nafter the first true test expression.",
                                :ns "cljs.core",
                                :name "cond->>",
                                :signature ["[expr & clauses]"],
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :related ["cljs.core/->"
                                          "cljs.core/->>"
                                          "cljs.core/cond->"
                                          "cljs.core/cond"],
                                :full-name-encode "cljs.core_cond-GTGT",
                                :source {:code "(defmacro cond->>\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (->> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [6899 6911]},
                                :full-name "cljs.core/cond->>",
                                :clj-symbol "clojure.core/cond->>",
                                :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\nthrough each form for which the corresponding test expression\nis true.  Note that, unlike cond branching, cond->> threading does not short circuit\nafter the first true test expression."},
           "cljs.core/number?" {:description "Returns true if `n` is a number, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "number?",
                                :signature ["[n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/integer?"],
                                :full-name-encode "cljs.core_numberQMARK",
                                :source {:code "(defn ^boolean number? [n]\n  (cljs.core/number? n))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [97 98]},
                                :extra-sources ({:code "(defmacro number? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'number'\" x)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [331 332]}),
                                :full-name "cljs.core/number?",
                                :clj-symbol "clojure.core/number?"},
           "cljs.core/array" {:description "Creates a JavaScript array containing `args`.\n\nThe tagged literal `#js [1 2 3]` is equivalent to `(array 1 2 3)`",
                              :return-type array,
                              :ns "cljs.core",
                              :name "array",
                              :signature ["[& args]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/aclone"
                                        "cljs.core/make-array"
                                        "cljs.core/clj->js"],
                              :full-name-encode "cljs.core_array",
                              :source {:code "(defn ^array array\n  [var-args]            ;; [& items]\n  (let [a (js/Array. (alength (cljs.core/js-arguments)))]\n    (loop [i 0]\n      (if (< i (alength a))\n        (do\n          (aset a i (aget (cljs.core/js-arguments) i))\n          (recur (inc i)))\n        a))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [182 192]},
                              :extra-sources ({:code "(defmacro array [& rest]\n  (let [xs-str (->> (repeat \"~{}\")\n                    (take (count rest))\n                    (interpose \",\")\n                    (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"[\" xs-str \"]\") rest)\n      assoc :tag 'array)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [1397 1404]}),
                              :examples [{:id "3a546d",
                                          :content "```clj\n(array 1 2 3)\n;;=> #js [1 2 3]\n\n(apply array [1 2 3])\n;;=> #js [1 2 3]\n\n#js [1 2 3]\n;;=> #js [1 2 3]\n```"}
                                         {:id "cca945",
                                          :content "When creating nested JavaScript arrays, you can opt to use `clj->js` instead:\n\n```clj\n(array 1 2 (array 3 4))\n;;=> #js [1 2 #js [3 4]]\n\n(clj->js [1 2 [3 4]])\n;;=> #js [1 2 #js [3 4]]\n```"}],
                              :full-name "cljs.core/array",
                              :docstring "Creates a new javascript array.\n@param {...*} var_args"},
           "cljs.core/nthnext" {:description "Returns the `n`th `next` of `coll`.\n\nReturns `(seq coll)` when `n` is 0.",
                                :ns "cljs.core",
                                :name "nthnext",
                                :signature ["[coll n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/nth"
                                          "cljs.core/drop"
                                          "cljs.core/nthrest"],
                                :full-name-encode "cljs.core_nthnext",
                                :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2184 2190]},
                                :full-name "cljs.core/nthnext",
                                :clj-symbol "clojure.core/nthnext",
                                :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
           "cljs.core/re-pattern" {:description "Returns an instance of RegExp which has compiled the provided string.",
                                   :ns "cljs.core",
                                   :name "re-pattern",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_re-pattern",
                                   :source {:code "(defn re-pattern\n  [s]\n  (if (instance? js/RegExp s)\n    s\n    (let [[_ flags pattern] (re-find #\"^(?:\\(\\?([idmsux]*)\\))?(.*)\" s)]\n      (js/RegExp. pattern flags))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [8100 8106]},
                                   :full-name "cljs.core/re-pattern",
                                   :clj-symbol "clojure.core/re-pattern",
                                   :docstring "Returns an instance of RegExp which has compiled the provided string."},
           "cljs.core/missing-protocol" {:ns "cljs.core",
                                         :name "missing-protocol",
                                         :type "function",
                                         :signature ["[proto obj]"],
                                         :source {:code "(defn missing-protocol [proto obj]\n  (let [ty (type obj)\n        ty (if (and ty (.-cljs$lang$type ty))\n             (.-cljs$lang$ctorStr ty)\n             (goog/typeOf obj))]\n   (js/Error.\n     (.join (array \"No protocol method \" proto\n                   \" defined for type \" ty \": \" obj) \"\"))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [141 148]},
                                         :full-name "cljs.core/missing-protocol",
                                         :full-name-encode "cljs.core_missing-protocol",
                                         :history [["+" "0.0-927"]]},
           "clojure.browser.dom/set-text" {:ns "clojure.browser.dom",
                                           :name "set-text",
                                           :signature ["[e s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.dom_set-text",
                                           :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/browser/dom.cljs",
                                                    :lines [124 129]},
                                           :full-name "clojure.browser.dom/set-text",
                                           :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned."},
           "cljs.test/js-line-and-column" {:ns "cljs.test",
                                           :name "js-line-and-column",
                                           :type "function",
                                           :signature ["[stack-element]"],
                                           :source {:code "(defn js-line-and-column [stack-element]\n  (let [parts (.split stack-element \":\")\n        cnt   (count parts)]\n    [(js/parseInt (nth parts (- cnt 2)))\n     (js/parseInt (nth parts (dec cnt)))]))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/test.cljs",
                                                    :lines [347 351]},
                                           :full-name "cljs.test/js-line-and-column",
                                           :full-name-encode "cljs.test_js-line-and-column",
                                           :history [["+" "0.0-2496"]]},
           "clojure.zip/up" {:ns "clojure.zip",
                             :name "up",
                             :signature ["[loc]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "clojure.zip_up",
                             :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [111 122]},
                             :full-name "clojure.zip/up",
                             :clj-symbol "clojure.zip/up",
                             :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
           "cljs.core/IWithMeta" {:ns "cljs.core",
                                  :name "IWithMeta",
                                  :type "protocol",
                                  :full-name-encode "cljs.core_IWithMeta",
                                  :source {:code "(defprotocol IWithMeta\n  (^clj -with-meta [o meta]))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [321 322]},
                                  :methods [{:name "-with-meta",
                                             :signature ["[o meta]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IWithMeta",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/bit-and-not" {:description "Bitwise \"and\" `x` with bitwise \"not\" `y`.  Same as `x & ~y` in JavaScript.",
                                    :ns "cljs.core",
                                    :name "bit-and-not",
                                    :signature ["[x y]"
                                                "[x y & more]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/bit-and"
                                              "cljs.core/bit-not"],
                                    :full-name-encode "cljs.core_bit-and-not",
                                    :source {:code "(defn bit-and-not\n  ([x y] (cljs.core/bit-and-not x y))\n  ([x y & more]\n     (reduce bit-and-not (cljs.core/bit-and-not x y) more)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2105 2109]},
                                    :extra-sources ({:code "(defmacro ^::ana/numeric bit-and-not\n  ([x y] (core/list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/core.clj",
                                                     :lines [513 515]}),
                                    :examples [{:id "16f35d",
                                                :content "Bits can be entered using radix notation:\n\n```clj\n(bit-and-not 2r1100 2r1010)\n;;=> 4\n;; 4 = 2r0100\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-and-not 12 10)\n;;=> 4\n```\n\nSame result using `bit-and` and `bit-not`:\n\n```clj\n(bit-and 12 (bit-not 10))\n;;=> 4\n```"}],
                                    :full-name "cljs.core/bit-and-not",
                                    :clj-symbol "clojure.core/bit-and-not",
                                    :docstring "Bitwise and"},
           "clojure.string/triml" {:description "Removes whitespace from the left side of string.",
                                   :ns "clojure.string",
                                   :name "triml",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string_triml",
                                   :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [152 155]},
                                   :full-name "clojure.string/triml",
                                   :clj-symbol "clojure.string/triml",
                                   :docstring "Removes whitespace from the left side of string."},
           "cljs.core/chunk-append" {:ns "cljs.core",
                                     :name "chunk-append",
                                     :type "function",
                                     :signature ["[b x]"],
                                     :source {:code "(defn chunk-append [b x]\n  (.add b x))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2741 2742]},
                                     :full-name "cljs.core/chunk-append",
                                     :full-name-encode "cljs.core_chunk-append",
                                     :history [["+" "0.0-1424"]]},
           "syntax/character" {:description "Signifies a single character string.  Carried over from Clojure for\ncompatibility.  They are represented as single character JavaScript strings.\n\n`\\c` = `\"c\"`\n\n| unicode characters  | constraints                                   |\n|---------------------|-----------------------------------------------|\n| `\\uXXXX`            | XXXX must have 4 digits outside 0xD7FF-0xE000 |\n| `\\oXXX`             | XXX is octal between 0 and 0377               |\n\n| special characters  | result   |\n|---------------------|----------|\n| `\\newline`          | `\"\\n\"`   |\n| `\\space`            | `\" \"`    |\n| `\\tab`              | `\"\\t\"`   |\n| `\\formfeed`         | `\"\\f\"`   |\n| `\\backspace`        | `\"\\b\"`   |\n| `\\return`           | `\"\\r\"`   |",
                               :ns "syntax",
                               :name "character",
                               :history [["+" "0.0-927"]],
                               :type "syntax",
                               :related ["syntax/string"
                                         "cljs.core/str"],
                               :full-name-encode "syntax_character",
                               :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                        :repo "tools.reader",
                                        :tag "tools.reader-0.8.10",
                                        :filename "src/main/clojure/clojure/tools/reader.clj",
                                        :lines [591 610]},
                               :extra-sources [{:code "(defn- read-char*\n  [rdr backslash]\n  (let [ch (read-char rdr)]\n    (if-not (nil? ch)\n      (let [token (if (or (macro-terminating? ch)\n                          (whitespace? ch))\n                    (str ch)\n                    (read-token rdr ch))\n            token-len (count token)]\n        (cond\n\n         (== 1 token-len)  (Character/valueOf (nth token 0))\n\n         (= token \"newline\") \\newline\n         (= token \"space\") \\space\n         (= token \"tab\") \\tab\n         (= token \"backspace\") \\backspace\n         (= token \"formfeed\") \\formfeed\n         (= token \"return\") \\return\n\n         (.startsWith token \"u\")\n         (let [c (read-unicode-char token 1 4 16)\n               ic (int c)]\n           (if (and (> ic upper-limit)\n                    (< ic lower-limit))\n             (reader-error rdr \"Invalid character constant: \\\\u\" (Integer/toString ic 16))\n             c))\n\n         (.startsWith token \"x\")\n         (read-unicode-char token 1 2 16)\n\n         (.startsWith token \"o\")\n         (let [len (dec token-len)]\n           (if (> len 3)\n             (reader-error rdr \"Invalid octal escape sequence length: \" len)\n             (let [uc (read-unicode-char token 1 len 8)]\n               (if (> (int uc) 0377)\n                 (reader-error rdr \"Octal escape sequence must be in range [0, 377]\")\n                 uc))))\n\n         :else (reader-error rdr \"Unsupported character: \\\\\" token)))\n      (reader-error rdr \"EOF while reading character\"))))",
                                                :repo "tools.reader",
                                                :tag "tools.reader-0.8.10",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [107 148]}],
                               :syntax-form "\\",
                               :examples [{:id "495a47",
                                           :content "```clj\n\\c\n;;=> \"c\"\n\n\\A\n;;=> \"A\"\n\n\\newline\n;;=> \"\\n\"\n\n\\u00a1\n;;=> \"¡\"\n\n\\o256\n;;=> \"®\"\n```"}],
                               :edn-doc "https://github.com/edn-format/edn#characters",
                               :full-name "syntax/character",
                               :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/unreadable" {:ns "syntax",
                                :name "unreadable",
                                :history [["+" "0.0-927"]],
                                :type "syntax",
                                :full-name-encode "syntax_unreadable",
                                :source {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                         :repo "tools.reader",
                                         :tag "tools.reader-0.8.10",
                                         :filename "src/main/clojure/clojure/tools/reader.clj",
                                         :lines [612 623]},
                                :syntax-form "#<>",
                                :full-name "syntax/unreadable",
                                :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L115"},
           "cljs.core/regexp?" {:ns "cljs.core",
                                :name "regexp?",
                                :type "function",
                                :signature ["[o]"],
                                :source {:code "(defn regexp? [o]\n  (instance? js/RegExp o))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8062 8063]},
                                :full-name "cljs.core/regexp?",
                                :full-name-encode "cljs.core_regexpQMARK",
                                :history [["+" "0.0-1424"]]},
           "clojure.string/split" {:description "Splits string on a regular expression. Optional argument limit is the maximum\nnumber of splits. Not lazy. Returns vector of the splits.",
                                   :ns "clojure.string",
                                   :name "split",
                                   :signature ["[s re]"
                                               "[s re limit]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/subs"
                                             "clojure.string/replace"
                                             "clojure.string/split-lines"],
                                   :full-name-encode "clojure.string_split",
                                   :source {:code "(defn split\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (= (str re) \"/(?:)/\")\n         (split-with-empty-regex s limit)\n         (if (< limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (= limit 1)\n               (conj parts s)\n               (if-let [m (re-find re s)]\n                 (let [index (.indexOf s m)]\n                   (recur (.substring s (+ index (count m)))\n                          (dec limit)\n                          (conj parts (.substring s 0 index))))\n                 (conj parts s)))))))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [119 140]},
                                   :full-name "clojure.string/split",
                                   :clj-symbol "clojure.string/split",
                                   :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
           "cljs.reader/read-4-chars" {:ns "cljs.reader",
                                       :name "read-4-chars",
                                       :type "function",
                                       :signature ["[reader]"],
                                       :source {:code "(defn read-4-chars [reader]\n  (.toString\n    (StringBuffer.\n      (read-char reader)\n      (read-char reader)\n      (read-char reader)\n      (read-char reader))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [173 179]},
                                       :full-name "cljs.reader/read-4-chars",
                                       :full-name-encode "cljs.reader_read-4-chars",
                                       :history [["+" "0.0-1424"]]},
           "cljs.core/iteration" {:ns "cljs.core",
                                  :name "iteration",
                                  :signature ["[xform coll]"],
                                  :history [["+" "0.0-2301"]
                                            ["-" "0.0-2371"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_iteration",
                                  :source {:code "(defn iteration\n  [xform coll]\n  (Iteration. xform coll))",
                                           :repo "clojurescript",
                                           :tag "r2356",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8205 8210]},
                                  :full-name "cljs.core/iteration",
                                  :docstring "Returns an iterable/seqable/reducible sequence of applications of\nthe transducer to the items in coll. Note that these applications\nwill be performed every time iterator/seq/reduce is called.",
                                  :removed {:in "0.0-2371",
                                            :last-seen "0.0-2356"}},
           "cljs.core/hash-map" {:description "Returns a new hash map with supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                 :ns "cljs.core",
                                 :name "hash-map",
                                 :signature ["[& keyvals]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/array-map"
                                           "cljs.core/sorted-map"],
                                 :full-name-encode "cljs.core_hash-map",
                                 :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out (transient (.-EMPTY PersistentHashMap))]\n    (if in\n      (recur (nnext in) (assoc! out (first in) (second in)))\n      (persistent! out))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7130 7137]},
                                 :extra-sources ({:code "(defmacro hash-map\n  ([] `(.-EMPTY cljs.core/PersistentHashMap))\n  ([& kvs]\n    (let [pairs (partition 2 kvs)\n          ks    (map first pairs)\n          vs    (map second pairs)]\n      (vary-meta\n        `(.fromArrays cljs.core/PersistentHashMap (array ~@ks) (array ~@vs))\n        assoc :tag 'cljs.core/PersistentHashMap))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1440 1448]}),
                                 :full-name "cljs.core/hash-map",
                                 :clj-symbol "clojure.core/hash-map",
                                 :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
           "cljs.core/mapv" {:description "Returns a vector consisting of the result of applying `f` to the set of first\nitems of each coll, followed by applying `f` to the set of second items in each\ncoll, until any one of the colls is exhausted. Any remaining items in other\ncolls are ignored.\n\nFunction `f` should accept number-of-colls arguments.",
                             :ns "cljs.core",
                             :name "mapv",
                             :signature ["[f coll]"
                                         "[f c1 c2]"
                                         "[f c1 c2 c3]"
                                         "[f c1 c2 c3 & colls]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/map"],
                             :full-name-encode "cljs.core_mapv",
                             :source {:code "(defn mapv\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [4035 4049]},
                             :full-name "cljs.core/mapv",
                             :clj-symbol "clojure.core/mapv",
                             :docstring "Returns a vector consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "cljs.core/rem" {:description "Returns the remainder of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).",
                            :ns "cljs.core",
                            :name "rem",
                            :signature ["[n d]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/quot"
                                      "cljs.core/mod"],
                            :full-name-encode "cljs.core_rem",
                            :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (- n (* d q))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2081 2085]},
                            :full-name "cljs.core/rem",
                            :clj-symbol "clojure.core/rem",
                            :docstring "remainder of dividing numerator by denominator."},
           "cljs.core/IRecord" {:ns "cljs.core",
                                :name "IRecord",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IRecord",
                                :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [345 346]},
                                :full-name "cljs.core/IRecord",
                                :clj-symbol "clojure.lang/IRecord",
                                :docstring "Marker interface indicating a record object"},
           "cljs.core/RangedIterator" {:ns "cljs.core",
                                       :name "RangedIterator",
                                       :type "type",
                                       :signature ["[i base arr v start end]"],
                                       :source {:code "(deftype RangedIterator [^:mutable i ^:mutable base ^:mutable arr v start end]\n  Object\n  (hasNext [this]\n    (< i end))\n  (next [this]\n    (when (== (- i base) 32)\n      (set! arr (unchecked-array-for v i))\n      (set! base (+ base 32)))\n    (let [ret (aget arr (bit-and i 0x01f))]\n      (set! i (inc i))\n      ret)))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [4254 4264]},
                                       :full-name "cljs.core/RangedIterator",
                                       :full-name-encode "cljs.core_RangedIterator",
                                       :history [["+" "0.0-2371"]]},
           "cljs.core/volatile!" {:ns "cljs.core",
                                  :name "volatile!",
                                  :signature ["[val]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_volatileBANG",
                                  :source {:code "(defn volatile!\n  [val]\n  (Volatile. val))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3608 3611]},
                                  :full-name "cljs.core/volatile!",
                                  :docstring "Creates and returns a Volatile with an initial value of val."},
           "cljs.core/constantly" {:description "Returns a function that takes any number of arguments and always returns `x`.",
                                   :ns "cljs.core",
                                   :name "constantly",
                                   :signature ["[x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/repeatedly"],
                                   :full-name-encode "cljs.core_constantly",
                                   :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3343 3345]},
                                   :full-name "cljs.core/constantly",
                                   :clj-symbol "clojure.core/constantly",
                                   :docstring "Returns a function that takes any number of arguments and returns x."},
           "cljs.test/*current-env*" {:ns "cljs.test",
                                      :name "*current-env*",
                                      :type "dynamic var",
                                      :source {:code "(def ^:dynamic *current-env* nil)",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/test.cljs",
                                               :lines [259]},
                                      :full-name "cljs.test/*current-env*",
                                      :full-name-encode "cljs.test_STARcurrent-envSTAR",
                                      :history [["+" "0.0-2496"]]},
           "clojure.browser.dom/get-element" {:ns "clojure.browser.dom",
                                              :name "get-element",
                                              :type "function",
                                              :signature ["[id]"],
                                              :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/clojure/browser/dom.cljs",
                                                       :lines [98 99]},
                                              :full-name "clojure.browser.dom/get-element",
                                              :full-name-encode "clojure.browser.dom_get-element",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/UUID" {:ns "cljs.core",
                             :name "UUID",
                             :type "type",
                             :signature ["[uuid]"],
                             :source {:code "(deftype UUID [uuid]\n  Object\n  (toString [_] uuid)\n  (equiv [this other]\n    (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (and (instance? UUID other) (identical? uuid (.-uuid other))))\n\n  IPrintWithWriter\n  (-pr-writer [_ writer _]\n    (-write writer (str \"#uuid \\\"\" uuid \"\\\"\")))\n\n  IHash\n  (-hash [this]\n    (goog.string/hashCode (pr-str this))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [9160 9176]},
                             :full-name "cljs.core/UUID",
                             :full-name-encode "cljs.core_UUID",
                             :history [["+" "0.0-1424"]]},
           "clojure.core.reducers/reduce" {:ns "clojure.core.reducers",
                                           :name "reduce",
                                           :signature ["[f coll]"
                                                       "[f init coll]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers_reduce",
                                           :source {:code "(defn reduce\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (cond\n         (nil? coll) init\n         (array? coll) (array-reduce coll f init)\n         :else (-reduce coll f init)))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [33 44]},
                                           :full-name "clojure.core.reducers/reduce",
                                           :clj-symbol "clojure.core.reducers/reduce",
                                           :docstring "Like core/reduce except:\n  When init is not provided, (f) is used.\n  Maps are reduced with reduce-kv"},
           "cljs.core/and" {:description "Evaluates arguments one at a time from left to right. If an argument returns\nlogical false (nil or false), `and` returns that value and doesn't evaluate any\nof the other arguments, otherwise it returns the value of the last argument.\n\n`(and)` returns true.",
                            :ns "cljs.core",
                            :name "and",
                            :signature ["[]" "[x]" "[x & next]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/or" "special/if"],
                            :full-name-encode "cljs.core_and",
                            :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n    (let [forms (concat [x] next)]\n      (if (every? #(simple-test-expr? &env %)\n            (map #(cljs.analyzer/analyze &env %) forms))\n        (let [and-str (->> (repeat (count forms) \"(~{})\")\n                        (interpose \" && \")\n                        (apply core/str))]\n          (bool-expr `(~'js* ~and-str ~@forms)))\n        `(let [and# ~x]\n           (if and# (and ~@next) and#))))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [222 238]},
                            :examples [{:id "a39a73",
                                        :content "```clj\n(and)\n;;=> true\n\n(and false)\n;;=> false\n\n(and true)\n;;=> true\n\n(and true true)\n;;=> true\n\n(and true false)\n;;=> false\n\n(and false false)\n;;=> false\n```"}
                                       {:id "766638",
                                        :content "`nil` and `false` are the only falsy values and everything else is truthy:\n\n```clj\n(and \"foo\" \"bar\")\n;;=> \"bar\"\n\n(and \"foo\" nil)\n;;=> nil\n\n(and \"foo\" false)\n;;=> false\n\n(and nil \"foo\")\n;;=> nil\n\n(and false \"foo\")\n;;=> false\n```"}],
                            :full-name "cljs.core/and",
                            :clj-symbol "clojure.core/and",
                            :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
           "clojure.browser.repl/wrap-message" {:ns "clojure.browser.repl",
                                                :name "wrap-message",
                                                :type "function",
                                                :signature ["[t data]"],
                                                :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/clojure/browser/repl.cljs",
                                                         :lines [62
                                                                 63]},
                                                :full-name "clojure.browser.repl/wrap-message",
                                                :full-name-encode "clojure.browser.repl_wrap-message",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.reader/deregister-tag-parser!" {:ns "cljs.reader",
                                                 :name "deregister-tag-parser!",
                                                 :type "function",
                                                 :signature ["[tag]"],
                                                 :source {:code "(defn deregister-tag-parser!\n  [tag]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* dissoc tag)\n    old-parser))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/cljs/reader.cljs",
                                                          :lines [595
                                                                  600]},
                                                 :full-name "cljs.reader/deregister-tag-parser!",
                                                 :full-name-encode "cljs.reader_deregister-tag-parserBANG",
                                                 :history [["+"
                                                            "0.0-1424"]]},
           "clojure.reflect/print-doc" {:ns "clojure.reflect",
                                        :name "print-doc",
                                        :type "function",
                                        :signature ["[{:keys [name method-params doc]}]"],
                                        :source {:code "(defn print-doc [{:keys [name method-params doc]}]\n  (when-not (empty? name)\n    (println name)\n    (println method-params)\n    (println doc)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/clojure/reflect.cljs",
                                                 :lines [38 42]},
                                        :full-name "clojure.reflect/print-doc",
                                        :full-name-encode "clojure.reflect_print-doc",
                                        :history [["+" "0.0-1503"]]},
           "clojure.browser.event/unlisten-by-key" {:ns "clojure.browser.event",
                                                    :name "unlisten-by-key",
                                                    :type "function",
                                                    :signature ["[key]"],
                                                    :source {:code "(defn unlisten-by-key\n  [key]\n  (events/unlistenByKey key))",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [73
                                                                     75]},
                                                    :full-name "clojure.browser.event/unlisten-by-key",
                                                    :full-name-encode "clojure.browser.event_unlisten-by-key",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/try" {:ns "cljs.core",
                            :name "try",
                            :signature ["[& forms]"],
                            :history [["+" "0.0-927"]
                                      ["-" "0.0-1933"]],
                            :type "macro",
                            :full-name-encode "cljs.core_try",
                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (seq? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                     :repo "clojurescript",
                                     :tag "r1913",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [1004 1032]},
                            :full-name "cljs.core/try",
                            :clj-symbol "clojure.core/try",
                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions.",
                            :removed {:in "0.0-1933",
                                      :last-seen "0.0-1913"}},
           "cljs.repl.nashorn/init-engine" {:ns "cljs.repl.nashorn",
                                            :name "init-engine",
                                            :type "function",
                                            :signature ["[engine output-dir debug]"],
                                            :source {:code "(defn init-engine [engine output-dir debug]\n  (eval-resource engine \"goog/base.js\" debug)\n  (eval-resource engine \"goog/deps.js\" debug)\n  (eval-str engine \"var global = this\") ; required by React\n  (eval-str engine\n    (format\n      (str \"var nashorn_load = function(path) {\"\n           \"  var outputPath = \\\"%s\\\" + \\\"/\\\" + path;\"\n           (when debug \"  print(\\\"loading: \\\" + outputPath) ; \")\n           \"  load(outputPath);\"\n           \"};\")\n      output-dir))\n  (eval-str engine\n    (str \"goog.global.CLOSURE_IMPORT_SCRIPT = function(path) {\"\n         \" nashorn_load(\\\"goog/\\\" + path);\"\n         \" return true;\"\n         \"};\"))\n  (eval-str engine \"goog.global.isProvided_ = function(name) { return false; };\")\n  engine)",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/repl/nashorn.clj",
                                                     :lines [85 103]},
                                            :full-name "cljs.repl.nashorn/init-engine",
                                            :full-name-encode "cljs.repl.nashorn_init-engine",
                                            :history [["+" "0.0-2814"]]},
           "cljs.core/iterate" {:description "Returns a lazy sequence of `x`, `(f x)`, `(f (f x))` etc.\n\n`f` must be free of side-effects.",
                                :ns "cljs.core",
                                :name "iterate",
                                :signature ["[f x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/cycle"
                                          "cljs.core/repeatedly"
                                          "cljs.core/repeat"],
                                :full-name-encode "cljs.core_iterate",
                                :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3897 3900]},
                                :full-name "cljs.core/iterate",
                                :clj-symbol "clojure.core/iterate",
                                :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
           "cljs.core/lazy-seq" {:description "Returns a new lazy sequence.",
                                 :ns "cljs.core",
                                 :name "lazy-seq",
                                 :signature ["[& body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/lazy-cat"
                                           "cljs.core/realized?"
                                           "cljs.core/doall"
                                           "cljs.core/iterate"],
                                 :full-name-encode "cljs.core_lazy-seq",
                                 :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core/LazySeq nil (fn [] ~@body) nil nil))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1094 1095]},
                                 :full-name "cljs.core/lazy-seq",
                                 :clj-symbol "clojure.core/lazy-seq"},
           "cljs.test/update-current-env!" {:ns "cljs.test",
                                            :name "update-current-env!",
                                            :type "function",
                                            :signature ["[ks f & args]"],
                                            :source {:code "(defn update-current-env! [ks f & args]\n  (set! *current-env* (apply update-in (get-current-env) ks f args)))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/cljs/test.cljs",
                                                     :lines [264 265]},
                                            :full-name "cljs.test/update-current-env!",
                                            :full-name-encode "cljs.test_update-current-envBANG",
                                            :history [["+" "0.0-2496"]]},
           "specialrepl/load-file" {:description "Only usable from a REPL.\n\nLoad file at `filename`, then compiles and evaluates its code.",
                                    :ns "specialrepl",
                                    :name "load-file",
                                    :signature ["[filename]"],
                                    :history [["+" "0.0-927"]],
                                    :type "special form (repl)",
                                    :full-name-encode "specialrepl_load-file",
                                    :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n        (when-not (and (= quote 'quote) (symbol? ns-name))\n          (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n        (when-not (ana/get-namespace ns-name)\n          (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n          (-evaluate repl-env \"<cljs repl>\" 1\n            (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n        (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (let [is-self-require? (self-require? specs)\n              [target-ns restore-ns]\n              (if-not is-self-require?\n                [ana/*cljs-ns* nil]\n                ['cljs.user ana/*cljs-ns*])]\n          (evaluate-form repl-env env \"<cljs repl>\"\n            (with-meta\n              `(~'ns ~target-ns\n                 (:require\n                   ~@(map\n                       (fn [quoted-spec-or-kw]\n                         (if (keyword? quoted-spec-or-kw)\n                           quoted-spec-or-kw\n                           (second quoted-spec-or-kw)))\n                       specs)))\n              {:merge true :line 1 :column 1})\n            identity opts)\n          (when is-self-require?\n            (set! ana/*cljs-ns* restore-ns)))))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (evaluate-form repl-env env \"<cljs repl>\"\n          (with-meta\n            `(~'ns ~ana/*cljs-ns*\n               (:require-macros\n                 ~@(map\n                     (fn [quoted-spec-or-kw]\n                       (if (keyword? quoted-spec-or-kw)\n                         quoted-spec-or-kw\n                         (second quoted-spec-or-kw)))\n                     specs)))\n            {:merge true :line 1 :column 1})\n          identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n        (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n        (load-namespace repl-env ns opts)))}))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [475 543]},
                                    :examples [{:id "0903c5",
                                                :content "```clj\n(load-file \"path/to/foo.cljs\")\n```"}],
                                    :full-name "specialrepl/load-file",
                                    :clj-symbol "clojure.core/load-file"},
           "cljs.core/IndexedSeq" {:ns "cljs.core",
                                   :name "IndexedSeq",
                                   :signature ["[arr i]"],
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core_IndexedSeq",
                                   :source {:code "(deftype IndexedSeq [arr i]\n  Object\n  (toString [coll]\n   (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (IndexedSeq. arr i))\n\n  ISeqable\n  (-seq [this] this)\n\n  ASeq\n  ISeq\n  (-first [_] (aget arr i))\n  (-rest [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               (list)))\n\n  INext\n  (-next [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               nil))\n\n  ICounted\n  (-count [_] (- (alength arr) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (alength arr))\n        (aget arr i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (alength arr))\n        (aget arr i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IIterable\n  (-iterator [coll]\n    (IndexedSeqIterator. arr i))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr i) (inc i)))\n  (-reduce [coll f start]\n    (array-reduce arr f start i))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReversible\n  (-rseq [coll]\n    (let [c (-count coll)]\n      (if (pos? c)\n        (RSeq. coll (dec c) nil)))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1007 1073]},
                                   :full-name "cljs.core/IndexedSeq",
                                   :clj-symbol "clojure.lang/IndexedSeq"},
           "cljs.repl.server/parse-headers" {:ns "cljs.repl.server",
                                             :name "parse-headers",
                                             :signature ["[header-lines]"],
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.server_parse-headers",
                                             :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n    (mapcat\n      (fn [line]\n        (let [[k v] (str/split line #\":\" 2)]\n          [(keyword (str/lower-case k)) (str/triml v)]))\n      header-lines)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/clj/cljs/repl/server.clj",
                                                      :lines [60 68]},
                                             :full-name "cljs.repl.server/parse-headers",
                                             :docstring "Parse the headers of an HTTP POST request."},
           "cljs.core/KeySeq" {:ns "cljs.core",
                               :name "KeySeq",
                               :signature ["[mseq _meta]"],
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core_KeySeq",
                               :source {:code "(deftype KeySeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta] (KeySeq. mseq new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n  \n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-key me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (KeySeq. nseq _meta)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (KeySeq. nseq _meta))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7177 7230]},
                               :full-name "cljs.core/KeySeq",
                               :clj-symbol "clojure.lang/KeySeq"},
           "cljs.core/next" {:description "Returns a sequence of the items after the first and calls `seq` on its argument.\n\nReturns nil if `coll` is empty.",
                             :return-type seq,
                             :ns "cljs.core",
                             :name "next",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rest"
                                       "cljs.core/first"
                                       "cljs.core/fnext"],
                             :full-name-encode "cljs.core_next",
                             :source {:code "(defn ^seq next\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? INext coll)\n      (-next ^not-native coll)\n      (seq (rest coll)))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [753 760]},
                             :examples [{:id "7db59a",
                                         :content "```clj\n(next [1 2 3])\n;;=> (2 3)\n\n(next [1 2])\n;;=> (2)\n\n(next [1])\n;;=> nil\n\n(next [])\n;;=> nil\n```"}],
                             :full-name "cljs.core/next",
                             :clj-symbol "clojure.core/next",
                             :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
           "cljs.core/*print-readably*" {:ns "cljs.core",
                                         :name "*print-readably*",
                                         :type "dynamic var",
                                         :source {:code "(def ^:dynamic *print-readably* true)",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [34]},
                                         :full-name "cljs.core/*print-readably*",
                                         :full-name-encode "cljs.core_STARprint-readablySTAR",
                                         :clj-symbol "clojure.core/*print-readably*",
                                         :history [["+" "0.0-927"]]},
           "cljs.repl.node/read-response" {:ns "cljs.repl.node",
                                           :name "read-response",
                                           :type "function",
                                           :signature ["[in]"],
                                           :source {:code "(defn read-response [^BufferedReader in]\n  (let [sb (StringBuilder.)]\n    (loop [sb sb c (.read in)]\n      (cond\n       (= c 1) (let [ret (str sb)]\n                 (print ret)\n                 (recur (StringBuilder.) (.read in)))\n       (= c 0) (str sb)\n       :else (do\n               (.append sb (char c))\n               (recur sb (.read in)))))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/repl/node.clj",
                                                    :lines [39 49]},
                                           :full-name "cljs.repl.node/read-response",
                                           :full-name-encode "cljs.repl.node_read-response",
                                           :history [["+" "0.0-2629"]]},
           "cljs.repl.browser/repl-client-js" {:ns "cljs.repl.browser",
                                               :name "repl-client-js",
                                               :type "function",
                                               :signature ["[]"],
                                               :source {:code "(defn repl-client-js []\n  (slurp (:client-js @browser-state)))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [51 52]},
                                               :full-name "cljs.repl.browser/repl-client-js",
                                               :full-name-encode "cljs.repl.browser_repl-client-js",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/booleans" {:ns "cljs.core",
                                 :name "booleans",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-1798"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_booleans",
                                 :source {:code "(defn booleans [x] x)",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2056]},
                                 :full-name "cljs.core/booleans",
                                 :clj-symbol "clojure.core/booleans"},
           "cljs.core/not-native" {:ns "cljs.core",
                                   :name "not-native",
                                   :type "var",
                                   :source {:code "(def not-native nil)",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [80]},
                                   :full-name "cljs.core/not-native",
                                   :full-name-encode "cljs.core_not-native",
                                   :history [["+" "0.0-1798"]]},
           "cljs.repl.browser/parse-headers" {:ns "cljs.repl.browser",
                                              :name "parse-headers",
                                              :signature ["[header-lines]"],
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser_parse-headers",
                                              :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                       :repo "clojurescript",
                                                       :tag "r1450",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [116
                                                               124]},
                                              :full-name "cljs.repl.browser/parse-headers",
                                              :docstring "Parse the headers of an HTTP POST request.",
                                              :removed {:in "0.0-1503",
                                                        :last-seen "0.0-1450"}},
           "cljs.core/last" {:description "Returns the last item in `coll` in linear time.\n\n`peek` is much faster than `last` for a vector.",
                             :ns "cljs.core",
                             :name "last",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/first"
                                       "cljs.core/next"
                                       "cljs.core/rest"
                                       "cljs.core/butlast"
                                       "cljs.core/take-last"],
                             :full-name-encode "cljs.core_last",
                             :source {:code "(defn last\n  [s]\n  (let [sn (next s)]\n    (if-not (nil? sn)\n      (recur sn)\n      (first s))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1172 1178]},
                             :examples [{:id "eb0836",
                                         :content "```clj\n(last [1 2 3])\n;;=> 3\n\n(last [1 2])\n;;=> 2\n\n(last [1])\n;;=> 1\n\n(last [])\n;;=> nil\n```"}],
                             :full-name "cljs.core/last",
                             :clj-symbol "clojure.core/last",
                             :docstring "Return the last item in coll, in linear time"},
           "cljs.core/pr-str*" {:ns "cljs.core",
                                :name "pr-str*",
                                :signature ["[obj]"],
                                :history [["+" "0.0-1806"]],
                                :type "function",
                                :full-name-encode "cljs.core_pr-strSTAR",
                                :source {:code "(defn pr-str*\n  [^not-native obj]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (-pr-writer obj writer (pr-opts))\n    (-flush writer)\n    (str sb)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [435 443]},
                                :full-name "cljs.core/pr-str*",
                                :docstring "Support so that collections can implement toString without\nloading all the printing machinery."},
           "cljs.core/bit-shift-left" {:description "Bitwise shift left `n` bits.  Same as `x << n` in JavaScript.",
                                       :ns "cljs.core",
                                       :name "bit-shift-left",
                                       :signature ["[x n]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["cljs.core/bit-shift-right"],
                                       :full-name-encode "cljs.core_bit-shift-left",
                                       :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [2135 2137]},
                                       :extra-sources ({:code "(defmacro ^::ana/numeric bit-shift-left [x n]\n  (core/list 'js* \"(~{} << ~{})\" x n))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [526
                                                                527]}),
                                       :examples [{:id "67c34a",
                                                   :content "Bits can be entered using radix notation:\n\n```clj\n(bit-shift-left 2r0101 1)\n;;=> 10\n;; 10 = 2r1010\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-shift-left 5 1)\n;;=> 10\n```"}],
                                       :full-name "cljs.core/bit-shift-left",
                                       :clj-symbol "clojure.core/bit-shift-left",
                                       :docstring "Bitwise shift left"},
           "clojure.string/reverse" {:description "Returns `s` with its characters reversed.",
                                     :ns "clojure.string",
                                     :name "reverse",
                                     :signature ["[s]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string_reverse",
                                     :source {:code "(defn reverse\n  [s]\n  (-> (.replace s re-surrogate-pair \"$2$1\")\n      (.. (split \"\") (reverse) (join \"\"))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [21 25]},
                                     :full-name "clojure.string/reverse",
                                     :clj-symbol "clojure.string/reverse",
                                     :docstring "Returns s with its characters reversed."},
           "cljs.core/min" {:description "Returns the least number argument.",
                            :return-type number,
                            :ns "cljs.core",
                            :name "min",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/max"
                                      "cljs.core/min-key"],
                            :full-name-encode "cljs.core_min",
                            :source {:code "(defn ^number min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1932 1937]},
                            :extra-sources ({:code "(defmacro ^::ana/numeric min\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} < ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [481 485]}),
                            :examples [{:id "ab2de5",
                                        :content "```clj\n(min 1 2 3 4)\n;; => 1\n```\n\nApply it to a collection:\n\n```clj\n(apply min [1 2 3 4])\n;; => 1\n```"}],
                            :full-name "cljs.core/min",
                            :clj-symbol "clojure.core/min",
                            :docstring "Returns the least of the nums."},
           "cljs.reader/escape-char" {:ns "cljs.reader",
                                      :name "escape-char",
                                      :type "function",
                                      :signature ["[buffer reader]"],
                                      :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (cond\n        (identical? ch \\x)\n        (->> (read-2-chars reader)\n          (validate-unicode-escape unicode-2-pattern reader ch)\n          (make-unicode-char))\n\n        (identical? ch \\u)\n        (->> (read-4-chars reader)\n          (validate-unicode-escape unicode-4-pattern reader ch)\n          (make-unicode-char))\n\n        (numeric? ch)\n        (.fromCharCode js/String ch)\n\n        :else\n        (reader-error reader \"Unexpected unicode escape \\\\\" ch )))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [193 214]},
                                      :full-name "cljs.reader/escape-char",
                                      :full-name-encode "cljs.reader_escape-char",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/read-raw-string*" {:ns "cljs.reader",
                                           :name "read-raw-string*",
                                           :type "function",
                                           :signature ["[reader _]"],
                                           :source {:code "(defn read-raw-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n      (nil? ch) (reader-error reader \"EOF while reading\")\n      (identical? \"\\\\\" ch) (do (.append buffer ch)\n                             (let [nch (read-char reader)]\n                               (if (nil? nch)\n                                 (reader-error reader \"EOF while reading\")\n                                 (recur (doto buffer (.append nch))\n                                        (read-char reader)))))\n      (identical? \"\\\"\" ch) (.toString buffer)\n      :else (recur (doto buffer (.append ch)) (read-char reader)))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/reader.cljs",
                                                    :lines [304 317]},
                                           :full-name "cljs.reader/read-raw-string*",
                                           :full-name-encode "cljs.reader_read-raw-stringSTAR",
                                           :history [["+" "0.0-2261"]]},
           "cljs.core/INext" {:ns "cljs.core",
                              :name "INext",
                              :type "protocol",
                              :full-name-encode "cljs.core_INext",
                              :source {:code "(defprotocol INext\n  (^clj-or-nil -next [coll]))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [283 284]},
                              :methods [{:name "-next",
                                         :signature ["[coll]"],
                                         :docstring nil}],
                              :full-name "cljs.core/INext",
                              :history [["+" "0.0-1424"]]},
           "cljs.reader/read-map" {:ns "cljs.reader",
                                   :name "read-map",
                                   :type "function",
                                   :signature ["[rdr _]"],
                                   :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [274 279]},
                                   :full-name "cljs.reader/read-map",
                                   :full-name-encode "cljs.reader_read-map",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/seq" {:description "Returns a sequence on the collection. If the collection is empty, returns nil.\n\n`(seq nil)` returns nil.\n\n`seq` also works on strings.",
                            :return-type seq,
                            :ns "cljs.core",
                            :name "seq",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/seq?"
                                      "cljs.core/empty?"],
                            :full-name-encode "cljs.core_seq",
                            :source {:code "(defn ^seq seq\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? ISeqable coll)\n      (-seq ^not-native coll)\n\n      (array? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0))\n\n      (string? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0))\n\n      (native-satisfies? ISeqable coll)\n      (-seq coll)\n\n      :else (throw (js/Error. (str coll \" is not ISeqable\"))))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [706 727]},
                            :full-name "cljs.core/seq",
                            :clj-symbol "clojure.core/seq",
                            :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
           "cljs.core/*print-newline*" {:ns "cljs.core",
                                        :name "*print-newline*",
                                        :type "dynamic var",
                                        :source {:code "(def ^:dynamic *print-newline* true)",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [33]},
                                        :full-name "cljs.core/*print-newline*",
                                        :full-name-encode "cljs.core_STARprint-newlineSTAR",
                                        :history [["+" "0.0-2060"]]},
           "cljs.core/long" {:ns "cljs.core",
                             :name "long",
                             :signature ["[x]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core_long",
                             :source {:code "(defn long\n  [x]\n  (fix x))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2046 2049]},
                             :full-name "cljs.core/long",
                             :clj-symbol "clojure.core/long",
                             :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.core/es6-iterator" {:ns "cljs.core",
                                     :name "es6-iterator",
                                     :type "function",
                                     :signature ["[coll]"],
                                     :source {:code "(defn es6-iterator [coll]\n  (ES6Iterator. (seq coll)))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [790 791]},
                                     :full-name "cljs.core/es6-iterator",
                                     :full-name-encode "cljs.core_es6-iterator",
                                     :history [["+" "0.0-2371"]]},
           "cljs.core/not-empty" {:description "Returns nil if `coll` is empty, else returns `coll`.",
                                  :ns "cljs.core",
                                  :name "not-empty",
                                  :signature ["[coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/empty"],
                                  :full-name-encode "cljs.core_not-empty",
                                  :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3058 3060]},
                                  :full-name "cljs.core/not-empty",
                                  :clj-symbol "clojure.core/not-empty",
                                  :docstring "If coll is empty, returns nil, else coll"},
           "syntax/hashbang" {:ns "syntax",
                              :name "hashbang",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :full-name-encode "syntax_hashbang",
                              :source {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                       :repo "tools.reader",
                                       :tag "tools.reader-0.8.10",
                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                       :lines [612 623]},
                              :extra-sources [{:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.10",
                                               :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                               :lines [120 122]}],
                              :syntax-form "#!",
                              :full-name "syntax/hashbang",
                              :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L114"},
           "cljs.core/println" {:ns "cljs.core",
                                :name "println",
                                :signature ["[& objs]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_println",
                                :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8311 8316]},
                                :full-name "cljs.core/println",
                                :clj-symbol "clojure.core/println",
                                :docstring "Same as print followed by (newline)"},
           "clojure.browser.repl/connect" {:ns "clojure.browser.repl",
                                           :name "connect",
                                           :signature ["[repl-server-url]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.repl_connect",
                                           :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection\n        (net/xpc-connection\n          {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n      :evaluate-javascript\n      (fn [js]\n        (net/transmit\n          repl-connection\n          :send-result\n          (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n      (constantly nil)\n      (fn [iframe]\n        (set! (.-display (.-style iframe))\n          \"none\")))\n    ;; Monkey-patch goog.require if running under optimizations :none - David\n    (when-not js/COMPILED\n      (set! *loaded-libs*\n        (let [gntp (.. js/goog -dependencies_ -nameToPath)]\n          (into #{}\n            (filter\n              (fn [name]\n                (aget (.. js/goog -dependencies_ -visited) (aget gntp name)))\n              (js-keys gntp)))))\n      (set! (.-isProvided_ js/goog) (fn [_] false))\n      (set! (.-require js/goog)\n        (fn [name reload]\n          (when (or (not (contains? *loaded-libs* name)) reload)\n            (set! *loaded-libs* (conj (or *loaded-libs* #{}) name))\n            (.appendChild js/document.body\n              (let [script (.createElement js/document \"script\")]\n                (set! (.-type script) \"text/javascript\")\n                (set! (.-src script)\n                  (str \"goog/\"\n                    (aget (.. js/goog -dependencies_ -nameToPath) name)))\n                script))))))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/browser/repl.cljs",
                                                    :lines [95 136]},
                                           :full-name "clojure.browser.repl/connect",
                                           :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function."},
           "cljs.core/bytes" {:ns "cljs.core",
                              :name "bytes",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core_bytes",
                              :source {:code "(defn bytes [x] x)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2057]},
                              :full-name "cljs.core/bytes",
                              :clj-symbol "clojure.core/bytes"},
           "cljs.core/unchecked-byte" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-byte",
                                       :signature ["[x]"],
                                       :history [["+" "0.0-1798"]],
                                       :type "function",
                                       :full-name-encode "cljs.core_unchecked-byte",
                                       :source {:code "(defn ^number unchecked-byte [x] x)",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1953]},
                                       :extra-sources ({:code "(defmacro unchecked-byte [x] x)",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [366]}),
                                       :full-name "cljs.core/unchecked-byte",
                                       :clj-symbol "clojure.core/unchecked-byte"},
           "clojure.browser.dom/insert-at" {:ns "clojure.browser.dom",
                                            :name "insert-at",
                                            :type "function",
                                            :signature ["[parent child index]"],
                                            :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [104 105]},
                                            :full-name "clojure.browser.dom/insert-at",
                                            :full-name-encode "clojure.browser.dom_insert-at",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/quot" {:description "Returns the quotient of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).",
                             :ns "cljs.core",
                             :name "quot",
                             :signature ["[n d]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rem"
                                       "cljs.core/mod"],
                             :full-name-encode "cljs.core_quot",
                             :source {:code "(defn quot\n  [n d]\n  (let [rem (js-mod n d)]\n    (fix (/ (- n rem) d))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2075 2079]},
                             :full-name "cljs.core/quot",
                             :clj-symbol "clojure.core/quot",
                             :docstring "quot[ient] of dividing numerator by denominator."},
           "clojure.browser.event/get-listener" {:ns "clojure.browser.event",
                                                 :name "get-listener",
                                                 :type "function",
                                                 :signature ["[src type listener opt_capt opt_handler]"],
                                                 :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [91]},
                                                 :full-name "clojure.browser.event/get-listener",
                                                 :full-name-encode "clojure.browser.event_get-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/filter" {:description "Returns a lazy sequence of the non-nil results of `(f item)`. Note, this means\nfalse return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                               :ns "cljs.core",
                               :name "filter",
                               :signature ["[f]" "[f coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/remove"
                                         "cljs.core/keep"],
                               :full-name-encode "cljs.core_filter",
                               :source {:code "(defn filter\n  ([pred]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (if (pred input)\n             (rf result input)\n             result)))))\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (-nth c i))\n                (chunk-append b (-nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3961 3988]},
                               :full-name "cljs.core/filter",
                               :clj-symbol "clojure.core/filter",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "cljs.core/RSeq" {:ns "cljs.core",
                             :name "RSeq",
                             :signature ["[ci i meta]"],
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :full-name-encode "cljs.core_RSeq",
                             :source {:code "(deftype RSeq [ci i meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (RSeq. ci i meta))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (RSeq. ci i new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeq\n  (-first [coll]\n    (-nth ci i))\n  (-rest [coll]\n    (if (pos? i)\n      (RSeq. ci (dec i) nil)\n      ()))\n  \n  INext\n  (-next [coll]\n    (when (pos? i)\n      (RSeq. ci (dec i) nil)))\n\n  ICounted\n  (-count [coll] (inc i))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReduce\n  (-reduce [col f] (seq-reduce f col))\n  (-reduce [col f start] (seq-reduce f start col)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1092 1143]},
                             :full-name "cljs.core/RSeq",
                             :clj-symbol "clojure.lang/RSeq"},
           "clojure.zip/branch?" {:ns "clojure.zip",
                                  :name "branch?",
                                  :signature ["[loc]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_branchQMARK",
                                  :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [64 67]},
                                  :full-name "clojure.zip/branch?",
                                  :clj-symbol "clojure.zip/branch?",
                                  :docstring "Returns true if the node at loc is a branch"},
           "special/if" {:description "If `test` is not false or nil, `then` is evaluated and returned. Otherwise,\n`else?` is evaluated and returned. `else?` defaults to nil if not provided.\n\n`if` is one of ClojureScript's [special forms](http://clojure.org/special_forms)\nand is a fundamental building block of the language. All other conditionals in\nClojureScript are based on `if`s notion of truthiness (ie: anything other than\nfalse or nil).",
                         :ns "special",
                         :name "if",
                         :signature ["[test then else?]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :related ["cljs.core/cond"
                                   "cljs.core/when"
                                   "cljs.core/if-let"
                                   "cljs.core/if-not"],
                         :full-name-encode "special_if",
                         :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name _]\n  (when (< (count form) 3)\n    (throw (error env \"Too few arguments to if\")))\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (allowing-redef (analyze env then))\n        else-expr (allowing-redef (analyze env else))]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked @*unchecked-if*\n     :children [test-expr then-expr else-expr]}))",
                                  :repo "clojurescript",
                                  :tag "r2911",
                                  :filename "src/clj/cljs/analyzer.clj",
                                  :lines [570 580]},
                         :examples [{:id "e591ff",
                                     :content "```clj\n(def v [1 2])\n\n(if (empty? v) \"empty!\" \"filled!\")\n;;=> \"filled!\"\n\n(str \"This vector is \"\n  (if (empty? v) \"empty!\" \"filled!\"))\n;;=> \"This vector is filled!\"\n```"}],
                         :full-name "special/if",
                         :clj-symbol "clojure.core/if"},
           "cljs.core/ObjMap" {:ns "cljs.core",
                               :name "ObjMap",
                               :type "type",
                               :signature ["[meta keys strobj update-count __hash]"],
                               :source {:code "(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj update-count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY ObjMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (alength keys))\n      (map #(vector % (aget strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (alength keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (aget strobj k)\n      not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if ^boolean (goog/isString k)\n        (if (or (> update-count (.-HASHMAP_THRESHOLD ObjMap))\n                (>= (alength keys) (.-HASHMAP_THRESHOLD ObjMap)))\n          (obj-map->hash-map coll k v)\n          (if-not (nil? (scan-array 1 k keys))\n            (let [new-strobj (obj-clone strobj keys)]\n              (aset new-strobj k v)\n              (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n            (let [new-strobj (obj-clone strobj keys) ; append\n                  new-keys (aclone keys)]\n              (aset new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))))\n        ;; non-string key. game over.\n        (obj-map->hash-map coll k v)))\n  (-contains-key? [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      true\n      false))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength keys)]\n      (loop [keys (.sort keys obj-map-compare-keys)\n             init init]\n        (if (seq keys)\n          (let [k (first keys)\n                init (f init k (aget strobj k))]\n            (if (reduced? init)\n              @init\n              (recur (rest keys) init)))\n          init))))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (let [new-keys (aclone keys)\n            new-strobj (obj-clone strobj keys)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [5050 5152]},
                               :full-name "cljs.core/ObjMap",
                               :full-name-encode "cljs.core_ObjMap",
                               :history [["+" "0.0-927"]]},
           "cljs.core/sequence" {:ns "cljs.core",
                                 :name "sequence",
                                 :signature ["[coll]"
                                             "[xform coll]"
                                             "[xform coll & colls]"],
                                 :history [["+" "0.0-2120"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_sequence",
                                 :source {:code "(defn sequence\n  ([coll]\n     (if (seq? coll)\n       coll\n       (or (seq coll) ())))\n  ([xform coll]\n     (.create LazyTransformer xform coll))\n  ([xform coll & colls]\n     (.createMulti LazyTransformer xform (to-array (cons coll colls)))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3277 3293]},
                                 :full-name "cljs.core/sequence",
                                 :clj-symbol "clojure.core/sequence",
                                 :docstring "Coerces coll to a (possibly empty) sequence, if it is not already\none. Will not force a lazy seq. (sequence nil) yields (), When a\ntransducer is supplied, returns a lazy sequence of applications of\nthe transform to the items in coll(s), i.e. to the set of first\nitems of each coll, followed by the set of second\nitems in each coll, until any one of the colls is exhausted.  Any\nremaining items in other colls are ignored. The transform should accept\nnumber-of-colls arguments"},
           "cljs.core/zipmap" {:description "Returns a map with `keys` mapped to corresponding `vals`.\n\n<pre>user=> (zipmap [:a :b :c :d] [1 2 3 4])\n{:a 1, :b 2, :c 3, :d 4}</pre>",
                               :ns "cljs.core",
                               :name "zipmap",
                               :signature ["[keys vals]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/interleave"],
                               :full-name-encode "cljs.core_zipmap",
                               :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map (transient {})\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc! map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        (persistent! map))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7676 7686]},
                               :full-name "cljs.core/zipmap",
                               :clj-symbol "clojure.core/zipmap",
                               :docstring "Returns a map with the keys mapped to the corresponding vals."},
           "cljs.core/hash-combine" {:ns "cljs.core",
                                     :name "hash-combine",
                                     :type "function",
                                     :signature ["[seed hash]"],
                                     :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed\n    (+ hash 0x9e3779b9\n      (bit-shift-left seed 6)\n      (bit-shift-right seed 2))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [566 571]},
                                     :full-name "cljs.core/hash-combine",
                                     :full-name-encode "cljs.core_hash-combine",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/reversible?" {:description "Returns true if `coll` implements the `IReversible` protocol, false otherwise.\n\nVectors, sorted maps, and sorted sets implement `IReversible`.",
                                    :return-type boolean,
                                    :ns "cljs.core",
                                    :name "reversible?",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_reversibleQMARK",
                                    :source {:code "(defn ^boolean reversible? [coll]\n  (satisfies? IReversible coll))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2391 2392]},
                                    :full-name "cljs.core/reversible?",
                                    :clj-symbol "clojure.core/reversible?"},
           "syntax/arg" {:ns "syntax",
                         :name "arg",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :full-name-encode "syntax_arg",
                         :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                  :repo "tools.reader",
                                  :tag "tools.reader-0.8.10",
                                  :filename "src/main/clojure/clojure/tools/reader.clj",
                                  :lines [591 610]},
                         :extra-sources [{:code "(defn- read-arg\n  [rdr pct]\n  (if-not (thread-bound? #'arg-env)\n    (read-symbol rdr pct)\n    (let [ch (peek-char rdr)]\n      (cond\n       (or (whitespace? ch)\n           (macro-terminating? ch)\n           (nil? ch))\n       (register-arg 1)\n\n       (identical? ch \\&)\n       (do (read-char rdr)\n           (register-arg -1))\n\n       :else\n       (let [n (read rdr true nil true)]\n         (if-not (integer? n)\n           (throw (IllegalStateException. \"Arg literal must be %, %& or %integer\"))\n           (register-arg n)))))))",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [418 437]}],
                         :syntax-form "%",
                         :full-name "syntax/arg",
                         :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.core.reducers/flatten" {:ns "clojure.core.reducers",
                                            :name "flatten",
                                            :signature ["[]" "[coll]"],
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers_flatten",
                                            :source {:code "(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [130 143]},
                                            :full-name "clojure.core.reducers/flatten",
                                            :clj-symbol "clojure.core.reducers/flatten",
                                            :docstring "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."},
           "cljs.core/max-key" {:description "Returns the `x` for which `(k x)` is greatest.\n\n`(k x)` should return a number.",
                                :ns "cljs.core",
                                :name "max-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/max"
                                          "cljs.core/min-key"],
                                :full-name-encode "cljs.core_max-key",
                                :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7688 7693]},
                                :full-name "cljs.core/max-key",
                                :clj-symbol "clojure.core/max-key",
                                :docstring "Returns the x for which (k x), a number, is greatest."},
           "clojure.zip/insert-child" {:ns "clojure.zip",
                                       :name "insert-child",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_insert-child",
                                       :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [194 198]},
                                       :full-name "clojure.zip/insert-child",
                                       :clj-symbol "clojure.zip/insert-child",
                                       :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
           "cljs.repl.browser/send-404" {:ns "cljs.repl.browser",
                                         :name "send-404",
                                         :signature ["[conn path]"],
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser_send-404",
                                         :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [92 98]},
                                         :full-name "cljs.repl.browser/send-404",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/defrecord" {:ns "cljs.core",
                                  :name "defrecord",
                                  :signature ["[rsym fields & impls]"],
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core_defrecord",
                                  :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [rsym (vary-meta rsym assoc :internal-ctor true)\n        r    (vary-meta\n               (:name (cljs.analyzer/resolve-var (dissoc &env :locals) rsym))\n               assoc :internal-ctor true)]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (core/list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [995 1007]},
                                  :full-name "cljs.core/defrecord",
                                  :clj-symbol "clojure.core/defrecord"},
           "cljs.core/eduction" {:ns "cljs.core",
                                 :name "eduction",
                                 :signature ["[xform coll]"],
                                 :history [["+" "0.0-2371"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_eduction",
                                 :source {:code "(defn eduction\n  [xform coll]\n  (Eduction. xform coll))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8622 8627]},
                                 :full-name "cljs.core/eduction",
                                 :docstring "Returns a reducible/iterable/seqable application of\nthe transducer to the items in coll. Note that these applications\t\nwill be performed every time iterator/seq/reduce is called."},
           "cljs.core/ex-info" {:ns "cljs.core",
                                :name "ex-info",
                                :signature ["[msg data]"
                                            "[msg data cause]"],
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core_ex-info",
                                :source {:code "(defn ex-info\n  ([msg data] (ex-info msg data nil))\n  ([msg data cause]\n    ;; this way each new ExceptionInfo instance will inherit\n    ;; stack property from newly created Error\n    (set! (.-prototype ExceptionInfo) (js/Error msg))\n    (set! (.. ExceptionInfo -prototype -name) \"ExceptionInfo\")\n    (set! (.. ExceptionInfo -prototype -constructor) ExceptionInfo)\n\n    ;; since we've changed the prototype, we need to\n    ;; re-establish protocol implementations here\n    (set! (.. ExceptionInfo -prototype -toString) pr-str*)\n    (extend-type ExceptionInfo\n      IPrintWithWriter\n      (-pr-writer [obj writer opts]\n        (pr-writer-ex-info obj writer opts)))\n    (ExceptionInfo. msg data cause)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [9193 9212]},
                                :full-name "cljs.core/ex-info",
                                :clj-symbol "clojure.core/ex-info",
                                :docstring "Alpha - subject to change.\nCreate an instance of ExceptionInfo, an Error type that carries a\nmap of additional data."},
           "cljs.repl.browser/repl-env" {:ns "cljs.repl.browser",
                                         :name "repl-env",
                                         :signature ["[& {:as opts}]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser_repl-env",
                                         :source {:code "(defn repl-env\n  [& {:as opts}]\n  (let [ups-deps (cljsc/get-upstream-deps (java.lang.ClassLoader/getSystemClassLoader))\n        opts (assoc opts\n               :ups-libs (:libs ups-deps)\n               :ups-foreign-libs (:foreign-libs ups-deps))\n        compiler-env (cljs.env/default-compiler-env opts)\n        opts (merge (BrowserEnv.)\n               {:port           9000\n                :optimizations  :simple\n                :working-dir    (or (:output-dir opts)\n                                    (->> [\".repl\" (util/clojurescript-version)]\n                                      (remove empty?) (string/join \"-\")))\n                :serve-static   true\n                :static-dir     (cond-> [\".\" \"out/\"]\n                                  (:output-dir opts) (conj (:output-dir opts)))\n                :preloaded-libs []\n                :src            \"src/\"\n                ::env/compiler  compiler-env\n                :source-map     false}\n               opts)]\n    (cljs.env/with-compiler-env compiler-env\n      (reset! preloaded-libs\n        (set (concat\n               (always-preload opts)\n               (map str (:preloaded-libs opts)))))\n      (reset! loaded-libs @preloaded-libs)\n      (println \"Compiling client js ...\")\n      (swap! browser-state\n        (fn [old]\n          (assoc old :client-js\n            (create-client-js-file\n              opts\n              (io/file (:working-dir opts) \"client.js\")))))\n      (println \"Waiting for browser to connect ...\")\n      opts)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [256 311]},
                                         :full-name "cljs.repl.browser/repl-env",
                                         :docstring "Create a browser-connected REPL environment.\n\nOptions:\n\nport:           The port on which the REPL server will run. Defaults to 9000.\nworking-dir:    The directory where the compiled REPL client JavaScript will\n                be stored. Defaults to \".repl\" with a ClojureScript version\n                suffix, eg. \".repl-0.0-2138\".\nserve-static:   Should the REPL server attempt to serve static content?\n                Defaults to true.\nstatic-dir:     List of directories to search for static content. Defaults to\n                [\".\" \"out/\"].\npreloaded-libs: List of namespaces that should not be sent from the REPL server\n                to the browser. This may be required if the browser is already\n                loading code and reloading it would cause a problem.\noptimizations:  The level of optimization to use when compiling the client\n                end of the REPL. Defaults to :simple.\nsrc:            The source directory containing user-defined cljs files. Used to\n                support reflection. Defaults to \"src/\".\n"},
           "cljs.repl.nashorn/bootstrap-repl" {:ns "cljs.repl.nashorn",
                                               :name "bootstrap-repl",
                                               :type "function",
                                               :signature ["[engine output-dir opts]"],
                                               :source {:code "(defn bootstrap-repl [engine output-dir opts]\n  (env/ensure\n    (let [deps-file \".nashorn_repl_deps.js\"\n          core (io/resource \"cljs/core.cljs\")\n          core-js (closure/compile core\n                    (assoc opts\n                      :output-file (closure/src-file->target-file core)))\n          deps (closure/add-dependencies opts core-js)]\n      ;; output unoptimized code and the deps file\n      ;; for all compiled namespaces\n      (apply closure/output-unoptimized\n        (assoc opts :output-to (.getPath (io/file output-dir deps-file)))\n        deps)\n      ;; load the deps file so we can goog.require cljs.core etc.\n      (load-js-file engine deps-file))))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/clj/cljs/repl/nashorn.clj",
                                                        :lines [110
                                                                124]},
                                               :full-name "cljs.repl.nashorn/bootstrap-repl",
                                               :full-name-encode "cljs.repl.nashorn_bootstrap-repl",
                                               :history [["+"
                                                          "0.0-2814"]]},
           "cljs.core/butlast" {:description "Returns a sequence of all but the last item in `s`.\n\n`butlast` runs in linear time.",
                                :ns "cljs.core",
                                :name "butlast",
                                :signature ["[s]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/first"
                                          "cljs.core/rest"
                                          "cljs.core/last"
                                          "cljs.core/next"
                                          "cljs.core/drop-last"
                                          "cljs.core/take-last"],
                                :full-name-encode "cljs.core_butlast",
                                :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7661 7665]},
                                :examples [{:id "7a4676",
                                            :content "```clj\n(butlast [1 2 3])\n;;=> (1 2)\n\n(butlast [1 2])\n;;=> (1)\n\n(butlast [1])\n;;=> nil\n\n(butlast [])\n;;=> nil\n```"}],
                                :full-name "cljs.core/butlast",
                                :clj-symbol "clojure.core/butlast"},
           "cljs.core/array-iter" {:ns "cljs.core",
                                   :name "array-iter",
                                   :type "function",
                                   :signature ["[x]"],
                                   :source {:code "(defn array-iter [x]\n  (ArrayIter. x 0))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3090 3091]},
                                   :full-name "cljs.core/array-iter",
                                   :full-name-encode "cljs.core_array-iter",
                                   :history [["+" "0.0-2301"]]},
           "cljs.core/print-str" {:ns "cljs.core",
                                  :name "print-str",
                                  :signature ["[& objs]"],
                                  :history [["+" "0.0-1011"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_print-str",
                                  :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8306 8309]},
                                  :full-name "cljs.core/print-str",
                                  :clj-symbol "clojure.core/print-str",
                                  :docstring "print to a string, returning it"},
           "cljs.core/hash" {:ns "cljs.core",
                             :name "hash",
                             :signature ["[o]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_hash",
                             :source {:code "(defn hash [o]\n  (cond\n    (implements? IHash o)\n    (-hash ^not-native o)\n\n    (number? o)\n    (js-mod (Math/floor o) 2147483647)\n\n    (true? o) 1\n\n    (false? o) 0\n\n    (string? o)\n    (m3-hash-int (hash-string o))\n\n    (instance? js/Date o)\n    (.valueOf o)\n\n    (nil? o) 0\n\n    :else\n    (-hash o)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [543 564]},
                             :full-name "cljs.core/hash",
                             :clj-symbol "clojure.core/hash"},
           "cljs.core/bit-set" {:description "Set bit at index `n`.  Same as `x | (1 << y)` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-set",
                                :signature ["[x n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-clear"],
                                :full-name-encode "cljs.core_bit-set",
                                :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2125 2128]},
                                :extra-sources ({:code "(defmacro ^::ana/numeric bit-set [x n]\n  (core/list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [538 539]}),
                                :examples [{:id "6a8a49",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-set 2r1100 1)\n;;=> 14\n;; 14 = 2r1110\n```\n\nSame number in decimal:\n\n```clj\n(bit-set 12 1)\n;;=> 14\n```"}],
                                :full-name "cljs.core/bit-set",
                                :clj-symbol "clojure.core/bit-set",
                                :docstring "Set bit at index n"},
           "cljs.core/clj->js" {:description "Recursively transforms ClojureScript values to JavaScript.\n\n| ClojureScript |        | JavaScript |         |\n|---------------|--------|------------|---------|\n| Set           | `#{}`  | Array      | `[]`    |\n| Vector        | `[]`   | Array      | `[]`    |\n| List          | `()`   | Array      | `[]`    |\n| Keyword       | `:foo` | String     | `\"foo\"` |\n| Symbol        | `bar`  | String     | `\"bar\"` |\n| Map           | `{}`   | Object     | `{}`    |",
                                :ns "cljs.core",
                                :name "clj->js",
                                :signature ["[x]"],
                                :history [["+" "0.0-1552"]],
                                :type "function",
                                :related ["cljs.core/js->clj"],
                                :full-name-encode "cljs.core_clj-GTjs",
                                :source {:code "(defn clj->js\n   [x]\n   (when-not (nil? x)\n     (if (satisfies? IEncodeJS x)\n       (-clj->js x)\n       (cond\n         (keyword? x) (name x)\n         (symbol? x) (str x)\n         (map? x) (let [m (js-obj)]\n                    (doseq [[k v] x]\n                      (aset m (key->js k) (clj->js v)))\n                    m)\n         (coll? x) (let [arr (array)]\n                     (doseq [x (map clj->js x)]\n                       (.push arr x))\n                     arr)\n         :else x))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8652 8671]},
                                :examples [{:id "2b1057",
                                            :content "```clj\n(clj->js {:foo 1 :bar 2})\n;;=> #js {:foo 1, :bar 2}\n\n(clj->js [:foo \"bar\" 'baz])\n;;=> #js [\"foo\" \"bar\" \"baz\"]\n\n(clj->js [1 {:foo \"bar\"} 4])\n;;=> #js [1 #js {:foo \"bar\"} 4]\n```"}],
                                :full-name "cljs.core/clj->js",
                                :docstring "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."},
           "cljs.core/concat" {:description "Returns a lazy sequence representing the concatenation of the elements in the\nsupplied collections.",
                               :ns "cljs.core",
                               :name "concat",
                               :signature ["[]"
                                           "[x]"
                                           "[x y]"
                                           "[x y & zs]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/conj"
                                         "cljs.core/into"],
                               :full-name-encode "cljs.core_concat",
                               :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2877 2900]},
                               :full-name "cljs.core/concat",
                               :clj-symbol "clojure.core/concat",
                               :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
           "cljs.test/IAsyncTest" {:ns "cljs.test",
                                   :name "IAsyncTest",
                                   :type "protocol",
                                   :full-name-encode "cljs.test_IAsyncTest",
                                   :source {:code "(defprotocol IAsyncTest\n  \"Marker protocol denoting CPS function to begin asynchronous\n  testing.\")",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/test.cljs",
                                            :lines [399 401]},
                                   :full-name "cljs.test/IAsyncTest",
                                   :docstring "Marker protocol denoting CPS function to begin asynchronous\n  testing.",
                                   :history [["+" "0.0-2814"]]},
           "cljs.core/conj" {:description "conj(oin)\n\nReturns a new collection with the `x`s \"added\" to `coll`.\n\nThe \"addition\" may happen at different \"places\" depending on the collection\ntype.\n\n`(conj nil item)` returns `(item)`.",
                             :ns "cljs.core",
                             :name "conj",
                             :signature ["[]"
                                         "[coll]"
                                         "[coll x]"
                                         "[coll x & xs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/cons"
                                       "cljs.core/into"
                                       "cljs.core/peek"
                                       "cljs.core/pop"],
                             :full-name-encode "cljs.core_conj",
                             :source {:code "(defn conj\n  ([] [])\n  ([coll] coll)\n  ([coll x]\n    (if-not (nil? coll)\n      (-conj coll x)\n      (list x)))\n  ([coll x & xs]\n    (if xs\n      (recur (conj coll x) (first xs) (next xs))\n      (conj coll x))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1184 1197]},
                             :full-name "cljs.core/conj",
                             :clj-symbol "clojure.core/conj",
                             :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
           "cljs.core/unchecked-short" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-short",
                                        :signature ["[x]"],
                                        :history [["+" "0.0-1798"]],
                                        :type "function",
                                        :full-name-encode "cljs.core_unchecked-short",
                                        :source {:code "(defn ^number unchecked-short [x] x)",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [1955]},
                                        :extra-sources ({:code "(defmacro unchecked-short [x] x)",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [368]}),
                                        :full-name "cljs.core/unchecked-short",
                                        :clj-symbol "clojure.core/unchecked-short"},
           "clojure.set/difference" {:description "Return a set that is the first set without elements of the remaining sets.",
                                     :ns "clojure.set",
                                     :name "difference",
                                     :signature ["[s1]"
                                                 "[s1 s2]"
                                                 "[s1 s2 & sets]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["clojure.set/union"
                                               "clojure.set/intersection"
                                               "clojure.set/superset?"
                                               "clojure.set/project"],
                                     :full-name-encode "clojure.set_difference",
                                     :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [46 58]},
                                     :full-name "clojure.set/difference",
                                     :clj-symbol "clojure.set/difference",
                                     :docstring "Return a set that is the first set without elements of the remaining sets"},
           "cljs.core/byte" {:return-type number,
                             :ns "cljs.core",
                             :name "byte",
                             :signature ["[x]"],
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core_byte",
                             :source {:code "(defn ^number byte [x] x)",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1939]},
                             :extra-sources ({:code "(defmacro byte [x] x)",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [361]}),
                             :full-name "cljs.core/byte",
                             :clj-symbol "clojure.core/byte"},
           "cljs.core/when-first" {:description "With `bindings` as `x`, `xs`, roughly the same as `(when (seq xs) (let [x (first\nxs)] body))` but `xs` is evaluated only once.",
                                   :ns "cljs.core",
                                   :name "when-first",
                                   :signature ["[bindings & body]"],
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core_when-first",
                                   :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when-let [xs# (seq ~xs)]\n       (let [~x (first xs#)]\n           ~@body))))",
                                            :repo "clojure",
                                            :tag "clojure-1.6.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [4230 4242]},
                                   :full-name "cljs.core/when-first",
                                   :clj-symbol "clojure.core/when-first",
                                   :docstring "bindings => x xs\n\nRoughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"},
           "cljs.reader/*tag-table*" {:ns "cljs.reader",
                                      :name "*tag-table*",
                                      :type "dynamic var",
                                      :source {:code "(def ^:dynamic *tag-table*\n  (atom {\"inst\"  read-date\n         \"uuid\"  read-uuid\n         \"queue\" read-queue\n         \"js\"    read-js}))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [567 571]},
                                      :full-name "cljs.reader/*tag-table*",
                                      :full-name-encode "cljs.reader_STARtag-tableSTAR",
                                      :history [["+" "0.0-1236"]]},
           "cljs.core/distinct?" {:description "Returns true if no two of the arguments are `=`",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "distinct?",
                                  :signature ["[x]"
                                              "[x y]"
                                              "[x y & more]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/distinct"],
                                  :full-name-encode "cljs.core_distinctQMARK",
                                  :source {:code "(defn ^boolean distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1641 1655]},
                                  :examples [{:id "b32799",
                                              :content "```clj\n(distinct? 1)\n;;=> true\n\n(distinct? 1 2)\n;;=> true\n\n(distinct? 1 1)\n;;=> false\n\n(distinct? 1 2 3)\n;;=> true\n\n(distinct? 1 2 1)\n;;=> false\n```\n\nApply it a collection:\n\n```clj\n(apply distinct? [1 2 3])\n;;=> true\n\n(apply distinct? [1 2 1])\n;;=> false\n```"}],
                                  :full-name "cljs.core/distinct?",
                                  :clj-symbol "clojure.core/distinct?",
                                  :docstring "Returns true if no two of the arguments are ="},
           "clojure.core.reducers/filter" {:ns "clojure.core.reducers",
                                           :name "filter",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers_filter",
                                           :source {:code "(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [117 128]},
                                           :full-name "clojure.core.reducers/filter",
                                           :clj-symbol "clojure.core.reducers/filter",
                                           :docstring "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.core/INamed" {:ns "cljs.core",
                               :name "INamed",
                               :history [["+" "0.0-1798"]],
                               :type "protocol",
                               :full-name-encode "cljs.core_INamed",
                               :source {:code "(defprotocol INamed\n  (^string -name [x])\n  (^string -namespace [x]))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [410 412]},
                               :methods [{:name "-name",
                                          :signature ["[x]"],
                                          :docstring nil}
                                         {:name "-namespace",
                                          :signature ["[x]"],
                                          :docstring nil}],
                               :full-name "cljs.core/INamed",
                               :clj-symbol "clojure.lang/Named"},
           "cljs.repl/merge-spec" {:ns "cljs.repl",
                                   :name "merge-spec",
                                   :signature ["[[lib & {:as aindex}] [_ & {:as bindex}]]"],
                                   :history [["+" "0.0-2629"]
                                             ["-" "0.0-2655"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl_merge-spec",
                                   :source {:code "(defn merge-spec [[lib & {:as aindex}] [_ & {:as bindex}]]\n  (let [merged-map\n        (merge-with\n          (fn [x y]\n            (if (vector? x)\n              (vec (distinct (into x y)))\n              y))\n          aindex bindex)]\n    (apply vector lib\n      (apply concat\n        (sort\n          (fn [[sa] [sb]]\n            (compare (spec-sort sa) (spec-sort sb)))\n          merged-map)))))",
                                            :repo "clojurescript",
                                            :tag "r2644",
                                            :filename "src/clj/cljs/repl.clj",
                                            :lines [196 209]},
                                   :full-name "cljs.repl/merge-spec",
                                   :removed {:in "0.0-2655",
                                             :last-seen "0.0-2644"}},
           "syntax/set" {:description "Signifies a literal set.  Values must be unique.",
                         :ns "syntax",
                         :name "set",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["cljs.core/hash-set"
                                   "cljs.core/sorted-set"
                                   "cljs.core/sorted-set-by"],
                         :full-name-encode "syntax_set",
                         :source {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                  :repo "tools.reader",
                                  :tag "tools.reader-0.8.10",
                                  :filename "src/main/clojure/clojure/tools/reader.clj",
                                  :lines [612 623]},
                         :extra-sources [{:code "(defn- read-set\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-set (PersistentHashSet/createWithCheck (read-delimited \\} rdr true))\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (with-meta the-set\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [358 373]}],
                         :syntax-form "#{}",
                         :examples [{:id "f11ab6",
                                     :content "```clj\n#{1 2 3}\n;;=> #{1 2 3}\n```\n\nDuplicate values will cause an error:\n\n```clj\n#{1 1 2 3}\n;; Error: Duplicate key: 1\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#sets",
                         :full-name "syntax/set",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/add-to-string-hash-cache" {:ns "cljs.core",
                                                 :name "add-to-string-hash-cache",
                                                 :type "function",
                                                 :signature ["[k]"],
                                                 :source {:code "(defn add-to-string-hash-cache [k]\n  (let [h (hash-string* k)]\n    (aset string-hash-cache k h)\n    (set! string-hash-cache-count (inc string-hash-cache-count))\n    h))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [528
                                                                  532]},
                                                 :full-name "cljs.core/add-to-string-hash-cache",
                                                 :full-name-encode "cljs.core_add-to-string-hash-cache",
                                                 :history [["+"
                                                            "0.0-1424"]]},
           "cljs.repl.rhino/repl-env" {:ns "cljs.repl.rhino",
                                       :name "repl-env",
                                       :signature ["[]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.rhino_repl-env",
                                       :source {:code "(defn repl-env\n  []\n  (let [cx (Context/enter)\n        scope (.initStandardObjects cx)\n        base (io/resource \"goog/base.js\")\n        deps (io/resource \"goog/deps.js\")\n        new-repl-env (merge (RhinoEnv.) {:cx cx :scope scope})]\n    (assert base \"Can't find goog/base.js in classpath\")\n    (assert deps \"Can't find goog/deps.js in classpath\")\n    (ScriptableObject/putProperty scope\n      \"___repl_env\" (Context/javaToJS new-repl-env scope))\n    (with-open [r (io/reader base)]\n      (-eval r new-repl-env \"goog/base.js\" 1))\n    (-eval bootjs new-repl-env \"bootjs\" 1)\n    ;; Load deps.js line-by-line to avoid 64K method limit\n    (with-open [reader (io/reader deps)]\n      (doseq [^String line (line-seq reader)]\n        (-eval line new-repl-env \"goog/deps.js\" 1)))\n    new-repl-env))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/repl/rhino.clj",
                                                :lines [145 165]},
                                       :full-name "cljs.repl.rhino/repl-env",
                                       :docstring "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls."},
           "cljs.core/HashCollisionNode" {:ns "cljs.core",
                                          :name "HashCollisionNode",
                                          :signature ["[edit collision-hash cnt arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_HashCollisionNode",
                                          :source {:code "(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (let [len     (* 2 cnt)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (set! (.-val added-leaf?) true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (= (aget arr idx) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (== idx -1) inode\n            (== cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) (aget arr (inc idx))\n            :else                  not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) [(aget arr idx) (aget arr (inc idx))]\n            :else                  not-found)))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable-array [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (if (> (alength arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (set! (.-val added-leaf?) true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (alength arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (set! (.-val added-leaf?) true)\n              (.ensure-editable-array inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (== idx -1)\n        inode\n        (do (aset removed-leaf? 0 true)\n            (if (== cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5972 6068]},
                                          :full-name "cljs.core/HashCollisionNode",
                                          :clj-symbol "clojure.lang/HashCollisionNode"},
           "cljs.core/m3-mix-K1" {:return-type number,
                                  :ns "cljs.core",
                                  :name "m3-mix-K1",
                                  :signature ["[k1]"],
                                  :history [["+" "0.0-2261"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_m3-mix-K1",
                                  :source {:code "(defn ^number m3-mix-K1 [k1]\n  (-> k1 (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [472 473]},
                                  :full-name "cljs.core/m3-mix-K1"},
           "cljs.core/object?" {:description "Returns true if `x` is a JavaScript object, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "object?",
                                :signature ["[x]"],
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :related ["cljs.core/array?"],
                                :full-name-encode "cljs.core_objectQMARK",
                                :source {:code "(defn ^boolean object? [x]\n  (if-not (nil? x)\n    (identical? (.-constructor x) js/Object)\n    false))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [108 111]},
                                :full-name "cljs.core/object?"},
           "cljs.core/pos?" {:description "Returns true if `n` is greater than 0, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "pos?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/neg?"
                                       "cljs.core/zero?"],
                             :full-name-encode "cljs.core_posQMARK",
                             :source {:code "(defn ^boolean pos?\n  [n] (cljs.core/pos? n))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2171 2173]},
                             :extra-sources ({:code "(defmacro ^::ana/numeric pos? [x]\n  `(> ~x 0))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [469 470]}),
                             :full-name "cljs.core/pos?",
                             :clj-symbol "clojure.core/pos?",
                             :docstring "Returns true if num is greater than zero, else false"},
           "cljs.test/block" {:ns "cljs.test",
                              :name "block",
                              :signature ["[fns]"],
                              :history [["+" "0.0-2814"]],
                              :type "function",
                              :full-name-encode "cljs.test_block",
                              :source {:code "(defn block\n  [fns]\n  (some-> fns\n          (vary-meta assoc ::block? true)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/test.cljs",
                                       :lines [427 432]},
                              :full-name "cljs.test/block",
                              :docstring "Tag a seq of fns to be picked up by run-block as injected\ncontinuation.  See run-block."},
           "cljs.core/into-array" {:description "Returns a new JavaScript array from the elements of `aseq`.",
                                   :return-type array,
                                   :ns "cljs.core",
                                   :name "into-array",
                                   :signature ["[aseq]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/to-array"
                                             "cljs.core/make-array"],
                                   :full-name-encode "cljs.core_into-array",
                                   :source {:code "(defn ^array into-array\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [217 221]},
                                   :full-name "cljs.core/into-array",
                                   :clj-symbol "clojure.core/into-array"},
           "syntax/tagged-literal" {:ns "syntax",
                                    :name "tagged-literal",
                                    :history [["+" "0.0-1211"]],
                                    :type "syntax",
                                    :full-name-encode "syntax_tagged-literal",
                                    :source {:code "(defn- read-tagged [rdr initch]\n  (let [tag (read rdr true nil false)]\n    (if-not (symbol? tag)\n      (reader-error rdr \"Reader tag must be a symbol\"))\n    (if-let [f (or (*data-readers* tag)\n                   (default-data-readers tag))]\n      (read-tagged* rdr tag f)\n      (if (.contains (name tag) \".\")\n        (read-ctor rdr tag)\n        (if-let [f *default-data-reader-fn*]\n          (f tag (read rdr true nil true))\n          (reader-error rdr \"No reader function for tag \" (name tag)))))))",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [662 673]},
                                    :syntax-form "#",
                                    :edn-doc "https://github.com/edn-format/edn#tagged-elements",
                                    :full-name "syntax/tagged-literal",
                                    :clj-doc "http://clojure.org/reader#toc4"},
           "cljs.core/PersistentVector" {:ns "cljs.core",
                                         :name "PersistentVector",
                                         :signature ["[meta cnt shift root tail __hash]"],
                                         :history [["+" "0.0-1006"]],
                                         :type "type",
                                         :full-name-encode "cljs.core_PersistentVector",
                                         :source {:code "(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (PersistentVector. meta cnt shift root tail __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentVector. meta cnt shift root tail __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (== 1 cnt) (-with-meta (.-EMPTY PersistentVector) meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (unchecked-array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) (.-EMPTY-NODE PersistentVector) nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [len (alength tail)\n            new-tail (make-array (inc len))]\n        (dotimes [i len]\n          (aset new-tail i (aget tail i)))\n        (aset new-tail len o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (> (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (instance? PersistentVector other)\n      (if (== cnt (count other))\n        (let [me-iter  (-iterator coll)\n              you-iter (-iterator other)]\n          (loop []\n            (if (.hasNext me-iter)\n              (let [x (.next me-iter)\n                    y (.next you-iter)]\n                (if (= x y)\n                  (recur)\n                  false))\n              true)))\n        false)\n      (equiv-sequential coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (cond\n      (zero? cnt) nil\n      (<= cnt 32) (IndexedSeq. tail 0)\n      :else (chunked-seq coll (first-array-for-longvec coll) 0 0)))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (aget (unchecked-array-for coll n) (bit-and n 0x01f))\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IMapEntry\n  (-key [coll]\n    (-nth coll 0))\n  (-val [coll]\n    (-nth coll 1))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (number? k)\n      (-assoc-n coll k v)\n      (throw (js/Error. \"Vector's key for assoc must be a number.\"))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (cond\n       (and (<= 0 n) (< n cnt))\n       (if (<= (tail-off coll) n)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and n 0x01f) val)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root n val) tail nil))\n       (== n cnt) (-conj coll val)\n       :else (throw (js/Error. (str \"Index \" n \" out of bounds  [0,\" cnt \"]\")))))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce v f))\n  (-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (+ j i) (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (RSeq. coll (dec cnt) nil)))\n\n  IIterable\n  (-iterator [this]\n    (ranged-iterator this 0 cnt)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [4276 4456]},
                                         :full-name "cljs.core/PersistentVector",
                                         :clj-symbol "clojure.lang/PersistentVector"},
           "cljs.core/IHash" {:ns "cljs.core",
                              :name "IHash",
                              :type "protocol",
                              :full-name-encode "cljs.core_IHash",
                              :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [333 334]},
                              :methods [{:name "-hash",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IHash",
                              :history [["+" "0.0-927"]]},
           "cljs.repl.node/seq->js-array" {:ns "cljs.repl.node",
                                           :name "seq->js-array",
                                           :type "function",
                                           :signature ["[v]"],
                                           :source {:code "(defn seq->js-array [v]\n  (str \"[\" (apply str (interpose \", \" (map pr-str v))) \"]\"))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/repl/node.clj",
                                                    :lines [74 75]},
                                           :full-name "cljs.repl.node/seq->js-array",
                                           :full-name-encode "cljs.repl.node_seq-GTjs-array",
                                           :history [["+" "0.0-2814"]]},
           "clojure.reflect/doc" {:ns "clojure.reflect",
                                  :name "doc",
                                  :signature ["[sym]"],
                                  :history [["+" "0.0-1503"]],
                                  :type "function",
                                  :full-name-encode "clojure.reflect_doc",
                                  :source {:code "(defn doc\n  [sym]\n  (meta sym print-doc))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/reflect.cljs",
                                           :lines [44 48]},
                                  :full-name "clojure.reflect/doc",
                                  :docstring "Queries the reflection api with a fully qualified symbol, then prints\ndocumentation information at the repl."},
           "cljs.core/is_proto_" {:ns "cljs.core",
                                  :name "is_proto_",
                                  :type "function",
                                  :signature ["[x]"],
                                  :source {:code "(defn is_proto_\n  [x]\n  (identical? (.-prototype (.-constructor x)) x))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [127 129]},
                                  :full-name "cljs.core/is_proto_",
                                  :full-name-encode "cljs.core_is_proto_",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/shorts" {:ns "cljs.core",
                               :name "shorts",
                               :signature ["[x]"],
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :full-name-encode "cljs.core_shorts",
                               :source {:code "(defn shorts [x] x)",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2059]},
                               :full-name "cljs.core/shorts",
                               :clj-symbol "clojure.core/shorts"},
           "cljs.core/TransientVector" {:ns "cljs.core",
                                        :name "TransientVector",
                                        :signature ["[cnt shift root tail]"],
                                        :history [["+" "0.0-1211"]],
                                        :type "type",
                                        :full-name-encode "cljs.core_TransientVector",
                                        :source {:code "(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if ^boolean (.-edit root)\n      (if (< (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (> (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if (number? key)\n      (-assoc-n! tcoll key val)\n      (throw (js/Error. \"TransientVector's key for assoc! must be a number.\"))))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 n) (< n cnt))\n        (if (<= (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (== n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str \"Index \" n \" out of bounds for TransientVector of length\" cnt))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [tcoll]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n        (== 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (unchecked-editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if-not (nil? nr)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. \"pop! after persistent!\"))))\n\n  ICounted\n  (-count [coll]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if ^boolean (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. \"nth after persistent!\"))))\n\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4750 4879]},
                                        :full-name "cljs.core/TransientVector",
                                        :clj-symbol "clojure.lang/TransientVector"},
           "cljs.core/keep-indexed" {:description "Returns a lazy sequence of the non-nil results of `(f index item)`. Note, this\nmeans false return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a stateful transducer when no collection is provided.",
                                     :ns "cljs.core",
                                     :name "keep-indexed",
                                     :signature ["[f]" "[f coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/map-indexed"
                                               "cljs.core/keep"],
                                     :full-name-encode "cljs.core_keep-indexed",
                                     :source {:code "(defn keep-indexed\n  ([f]\n   (fn [rf]\n     (let [ia (volatile! -1)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [i (vswap! ia inc)\n                  v (f i input)]\n              (if (nil? v)\n                result\n                (rf result v))))))))\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (-nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3622 3656]},
                                     :full-name "cljs.core/keep-indexed",
                                     :clj-symbol "clojure.core/keep-indexed",
                                     :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects.  Returns a stateful transducer when no collection is\nprovided."},
           "cljs.core/bit-shift-right" {:description "Bitwise shift right `n` bits.  Same as `x >> n` in JavaScript.",
                                        :ns "cljs.core",
                                        :name "bit-shift-right",
                                        :signature ["[x n]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :related ["cljs.core/bit-shift-left"
                                                  "cljs.core/unsigned-bit-shift-right"],
                                        :full-name-encode "cljs.core_bit-shift-right",
                                        :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [2139 2141]},
                                        :extra-sources ({:code "(defmacro ^::ana/numeric bit-shift-right [x n]\n  (core/list 'js* \"(~{} >> ~{})\" x n))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [529
                                                                 530]}),
                                        :examples [{:id "5b75af",
                                                    :content "Bits can be entered using radix notation:\n\n```clj\n(bit-shift-right 2r1010 1)\n;;=> 5\n;; 5 = 2r0101\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-shift-right 10 1)\n;;=> 5\n```"}],
                                        :full-name "cljs.core/bit-shift-right",
                                        :clj-symbol "clojure.core/bit-shift-right",
                                        :docstring "Bitwise shift right"},
           "cljs.repl.server/stop" {:ns "cljs.repl.server",
                                    :name "stop",
                                    :type "function",
                                    :signature ["[]"],
                                    :source {:code "(defn stop []\n  (.close (:socket @state)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl/server.clj",
                                             :lines [175 176]},
                                    :full-name "cljs.repl.server/stop",
                                    :full-name-encode "cljs.repl.server_stop",
                                    :history [["+" "0.0-1503"]]},
           "cljs.core/comparator" {:ns "cljs.core",
                                   :name "comparator",
                                   :signature ["[pred]"],
                                   :history [["+" "0.0-1586"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_comparator",
                                   :source {:code "(defn comparator\n  [pred]\n  (fn [x y]\n    (cond (pred x y) -1 (pred y x) 1 :else 0)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [9239 9243]},
                                   :full-name "cljs.core/comparator",
                                   :clj-symbol "clojure.core/comparator",
                                   :docstring "Returns an JavaScript compatible comparator based upon pred."},
           "cljs.core/ES6Iterator" {:ns "cljs.core",
                                    :name "ES6Iterator",
                                    :type "type",
                                    :signature ["[s]"],
                                    :source {:code "(deftype ES6Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [781 788]},
                                    :full-name "cljs.core/ES6Iterator",
                                    :full-name-encode "cljs.core_ES6Iterator",
                                    :history [["+" "0.0-2371"]]},
           "cljs.core/PersistentTreeSet" {:ns "cljs.core",
                                          :name "PersistentTreeSet",
                                          :signature ["[meta tree-map __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_PersistentTreeSet",
                                          :source {:code "(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentTreeSet. meta tree-map __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeSet. meta tree-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeSet. meta (-empty tree-map) 0))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? (count tree-map))\n      (map key (rseq tree-map))))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (let [n (.entry-at tree-map v)]\n      (if-not (nil? n)\n        (.-key n)\n        not-found)))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [7487 7573]},
                                          :full-name "cljs.core/PersistentTreeSet",
                                          :clj-symbol "clojure.lang/PersistentTreeSet"},
           "clojure.zip/insert-right" {:ns "clojure.zip",
                                       :name "insert-right",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip_insert-right",
                                       :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [174 181]},
                                       :full-name "clojure.zip/insert-right",
                                       :clj-symbol "clojure.zip/insert-right",
                                       :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
           "cljs.core/make-hierarchy" {:ns "cljs.core",
                                       :name "make-hierarchy",
                                       :signature ["[]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core_make-hierarchy",
                                       :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [8766 8768]},
                                       :full-name "cljs.core/make-hierarchy",
                                       :clj-symbol "clojure.core/make-hierarchy",
                                       :docstring "Creates a hierarchy object for use with derive, isa? etc."},
           "cljs.core/repeat" {:description "Returns a lazy sequence of `x`s.\n\nThe length of the sequence is infinite, or `n` if provided.",
                               :ns "cljs.core",
                               :name "repeat",
                               :signature ["[x]" "[n x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/repeatedly"
                                         "cljs.core/cycle"
                                         "cljs.core/constantly"
                                         "cljs.core/dotimes"],
                               :full-name-encode "cljs.core_repeat",
                               :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3881 3884]},
                               :full-name "cljs.core/repeat",
                               :clj-symbol "clojure.core/repeat",
                               :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
           "syntax/syntax-quote" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nPrevent evaluation of the following form.\n\nAdds namespace-qualification to any symbols inside the following form by\nresolving them in the current context.\n\nAny non-namespaced symbols ending with `#` will resolve to a generated symbol\nof the same name with `_` and a unique ID appended.  All references to that\nsymbol within a syntax-quoted expression will resolve to the same generated\nsymbol.",
                                  :ns "syntax",
                                  :name "syntax-quote",
                                  :history [["+" "0.0-927"]],
                                  :type "syntax",
                                  :related ["syntax/quote"
                                            "syntax/unquote"
                                            "syntax/unquote-splicing"],
                                  :full-name-encode "syntax_syntax-quote",
                                  :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [591 610]},
                                  :extra-sources [{:code "(defn- read-syntax-quote\n  [rdr backquote]\n  (binding [gensym-env {}]\n    (-> (read rdr true nil true)\n      syntax-quote*)))",
                                                   :repo "tools.reader",
                                                   :tag "tools.reader-0.8.10",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [585 589]}],
                                  :syntax-form "`",
                                  :examples [{:id "bffbdf",
                                              :content "```clj\n`foo\n;;=> cljs.user/foo\n\n`foo#\n;;=> foo__20418__auto__\n\n`(def foo 1)\n;;=> (def cljs.user/foo 1)\n```"}],
                                  :full-name "syntax/syntax-quote",
                                  :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/array-list" {:ns "cljs.core",
                                   :name "array-list",
                                   :type "function",
                                   :signature ["[]"],
                                   :source {:code "(defn array-list []\n  (ArrayList. (array)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7710 7711]},
                                   :full-name "cljs.core/array-list",
                                   :full-name-encode "cljs.core_array-list",
                                   :history [["+" "0.0-2301"]]},
           "cljs.repl.rhino/goog-require" {:ns "cljs.repl.rhino",
                                           :name "goog-require",
                                           :type "function",
                                           :signature ["[repl-env opts rule]"],
                                           :source {:code "(defn goog-require [repl-env opts rule]\n  (let [path        (string/replace (comp/munge rule) \\. File/separatorChar)\n        output-dir  (util/output-directory opts)\n        cljsc-path  (str output-dir File/separator (str path \".js\"))\n        cljs-path   (str path \".cljs\")\n        gpath       (-eval (str \"goog.dependencies_.nameToPath['\" rule \"']\")\n                      repl-env \"<cljs repl>\" 1)\n        js-path     (str \"goog/\" gpath)\n        js-out-path (io/file output-dir \"goog\"\n                      (string/replace gpath \\/ File/separatorChar))]\n    (let [compiled (io/file cljsc-path)]\n      (if (.exists compiled)\n        ;; TODO: only take this path if analysis cache is available\n        ;; - David\n        (do\n          (with-open [reader (io/reader compiled)]\n            (-eval reader repl-env cljsc-path 1)))\n        (if-let [res (io/resource cljs-path)]\n          (binding [ana/*cljs-ns* 'cljs.user]\n            (repl/load-stream repl-env cljs-path res))\n          (if-let [res (io/resource js-path)]\n            (with-open [reader (io/reader res)]\n              (-eval reader repl-env js-path 1))\n            (if (.exists js-out-path)\n              (with-open [reader (io/reader js-out-path)]\n                (-eval reader repl-env js-path 1))\n              (throw\n               (Exception.\n                 (str \"Cannot find \"\n                   cljs-path \" or \"\n                   js-path \" or \"\n                   (.getName js-out-path) \" in classpath\"))))))))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/repl/rhino.clj",
                                                    :lines [78 109]},
                                           :full-name "cljs.repl.rhino/goog-require",
                                           :full-name-encode "cljs.repl.rhino_goog-require",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/prn-str-with-opts" {:ns "cljs.core",
                                          :name "prn-str-with-opts",
                                          :signature ["[objs opts]"],
                                          :history [["+" "0.0-1011"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_prn-str-with-opts",
                                          :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\\n\"\n    (let [sb (pr-sb-with-opts objs opts)]\n      (.append sb \\newline)\n      (str sb))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [8261 8268]},
                                          :full-name "cljs.core/prn-str-with-opts",
                                          :docstring "Same as pr-str-with-opts followed by (newline)"},
           "cljs.core/MultiFn" {:ns "cljs.core",
                                :name "MultiFn",
                                :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core_MultiFn",
                                :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IFn\n  (-invoke [mf]\n    (let [dispatch-val (dispatch-fn)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn)))\n  (-invoke [mf a]\n    (let [dispatch-val (dispatch-fn a)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a)))\n  (-invoke [mf a b]\n    (let [dispatch-val (dispatch-fn a b)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b)))\n  (-invoke [mf a b c]\n    (let [dispatch-val (dispatch-fn a b c)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c)))\n  (-invoke [mf a b c d]\n    (let [dispatch-val (dispatch-fn a b c d)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d)))\n  (-invoke [mf a b c d e]\n    (let [dispatch-val (dispatch-fn a b c d e)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e)))\n  (-invoke [mf a b c d e f]\n    (let [dispatch-val (dispatch-fn a b c d e f)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f)))\n  (-invoke [mf a b c d e f g]\n    (let [dispatch-val (dispatch-fn a b c d e f g)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g)))\n  (-invoke [mf a b c d e f g h]\n    (let [dispatch-val (dispatch-fn a b c d e f g h)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h)))\n  (-invoke [mf a b c d e f g h i]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i)))\n  (-invoke [mf a b c d e f g h i j]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j)))\n  (-invoke [mf a b c d e f g h i j k]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k)))\n  (-invoke [mf a b c d e f g h i j k l]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l)))\n  (-invoke [mf a b c d e f g h i j k l m]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m)))\n  (-invoke [mf a b c d e f g h i j k l m n]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n)))\n  (-invoke [mf a b c d e f g h i j k l m n o]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o)))\n  (-invoke [mf a b c d e f g h i j k l m n o p]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s t)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s t)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t rest]\n    (let [dispatch-val (apply dispatch-fn a b c d e f g h i j k l m n o p q r s t rest)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (apply target-fn a b c d e f g h i j k l m n o p q r s t rest)))\n    \n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n  \n  INamed\n  (-name [this] (-name name))\n  (-namespace [this] (-namespace name))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8944 9127]},
                                :full-name "cljs.core/MultiFn",
                                :clj-symbol "clojure.lang/MultiFn"},
           "cljs.test/successful?" {:ns "cljs.test",
                                    :name "successful?",
                                    :signature ["[summary]"],
                                    :history [["+" "0.0-2496"]],
                                    :type "function",
                                    :full-name-encode "cljs.test_successfulQMARK",
                                    :source {:code "(defn successful?\n  [summary]\n  (and (zero? (:fail summary 0))\n       (zero? (:error summary 0))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/test.cljs",
                                             :lines [566 571]},
                                    :full-name "cljs.test/successful?",
                                    :clj-symbol "clojure.test/successful?",
                                    :docstring "Returns true if the given test summary indicates all tests\nwere successful, false otherwise."},
           "cljs.core/hash-keyword" {:ns "cljs.core",
                                     :name "hash-keyword",
                                     :type "function",
                                     :signature ["[k]"],
                                     :source {:code "(defn hash-keyword [k]\n  (int (+ (hash-symbol k) 0x9e3779b9)))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2479 2480]},
                                     :full-name "cljs.core/hash-keyword",
                                     :full-name-encode "cljs.core_hash-keyword",
                                     :history [["+" "0.0-2261"]]},
           "cljs.test/run-tests-block" {:ns "cljs.test",
                                        :name "run-tests-block",
                                        :signature ["[env-or-ns & namespaces]"],
                                        :history [["+" "0.0-2814"]],
                                        :type "macro",
                                        :full-name-encode "cljs.test_run-tests-block",
                                        :source {:code "(defmacro run-tests-block\n  [env-or-ns & namespaces]\n  (assert (every?\n           (fn [[quote ns]] (and (= quote 'quote) (symbol? ns)))\n           namespaces)\n          \"All arguments to run-tests must be quoted symbols\")\n  (let [is-ns (ns? env-or-ns)\n        env (gensym \"env\")\n        summary (gensym \"summary\")]\n    `(let [~env ~(if is-ns\n                   `(cljs.test/empty-env)\n                   env-or-ns)\n           ~summary (cljs.core/volatile!\n                     {:test 0 :pass 0 :fail 0 :error 0\n                      :type :summary})]\n       (concat ~@(map\n                  (fn [ns]\n                    `(concat (cljs.test/test-ns-block ~env ~ns)\n                             [(fn []\n                                (cljs.core/vswap!\n                                 ~summary\n                                 (partial merge-with +)\n                                 (:report-counters\n                                  (cljs.test/get-and-clear-env!))))]))\n                  (if is-ns\n                    (concat [env-or-ns] namespaces)\n                    namespaces))\n               [(fn []\n                   (cljs.test/set-env! ~env)\n                   (do-report (deref ~summary))\n                   (cljs.test/clear-env!))]))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/test.clj",
                                                 :lines [247 279]},
                                        :full-name "cljs.test/run-tests-block",
                                        :docstring "Like test-vars, but returns a block for further composition and\nlater execution."},
           "cljs.core/Reduced" {:ns "cljs.core",
                                :name "Reduced",
                                :signature ["[val]"],
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core_Reduced",
                                :source {:code "(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [894 896]},
                                :full-name "cljs.core/Reduced",
                                :clj-symbol "clojure.lang/Reduced"},
           "cljs.core/not-any?" {:description "Returns false if `(pred x)` is logical true for any `x` in `coll`, else true.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "not-any?",
                                 :signature ["[pred coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/every?"
                                           "cljs.core/some"],
                                 :full-name-encode "cljs.core_not-anyQMARK",
                                 :source {:code "(defn ^boolean not-any?\n  [pred coll] (not (some pred coll)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3318 3321]},
                                 :full-name "cljs.core/not-any?",
                                 :clj-symbol "clojure.core/not-any?",
                                 :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
           "cljs.reader/read-regex" {:ns "cljs.reader",
                                     :name "read-regex",
                                     :type "function",
                                     :signature ["[rdr ch]"],
                                     :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-raw-string* rdr ch) re-pattern))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [385 387]},
                                     :full-name "cljs.reader/read-regex",
                                     :full-name-encode "cljs.reader_read-regex",
                                     :history [["+" "0.0-927"]]},
           "cljs.repl/spec-sort" {:ns "cljs.repl",
                                  :name "spec-sort",
                                  :type "var",
                                  :source {:code "(def spec-sort\n  {:as 0\n   :refer 1\n   :refer-macros 2\n   :include-macros 3})",
                                           :repo "clojurescript",
                                           :tag "r2644",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [190 194]},
                                  :full-name "cljs.repl/spec-sort",
                                  :full-name-encode "cljs.repl_spec-sort",
                                  :history [["+" "0.0-2629"]
                                            ["-" "0.0-2655"]],
                                  :removed {:in "0.0-2655",
                                            :last-seen "0.0-2644"}},
           "clojure.zip/next" {:ns "clojure.zip",
                               :name "next",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_next",
                               :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [206 219]},
                               :full-name "clojure.zip/next",
                               :clj-symbol "clojure.zip/next",
                               :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
           "syntax/dispatch" {:ns "syntax",
                              :name "dispatch",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :full-name-encode "syntax_dispatch",
                              :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                       :repo "tools.reader",
                                       :tag "tools.reader-0.8.10",
                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                       :lines [591 610]},
                              :extra-sources [{:code "(defn- read-dispatch\n  [rdr _]\n  (if-let [ch (read-char rdr)]\n    (if-let [dm (dispatch-macros ch)]\n      (dm rdr ch)\n      (if-let [obj (read-tagged (doto rdr (unread ch)) ch)] ;; ctor reader is implemented as a taggged literal\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))\n    (reader-error rdr \"EOF while reading character\")))",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.10",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [53 61]}],
                              :syntax-form "#",
                              :edn-doc "https://github.com/edn-format/edn#-dispatch-character",
                              :full-name "syntax/dispatch",
                              :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.test/async" {:ns "cljs.test",
                              :name "async",
                              :signature ["[done & body]"],
                              :history [["+" "0.0-2814"]],
                              :type "macro",
                              :full-name-encode "cljs.test_async",
                              :source {:code "(defmacro async\n  [done & body]\n  `(reify\n     cljs.test/IAsyncTest\n     cljs.core/IFn\n     (~'-invoke [_# ~done]\n       ~@body)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/clj/cljs/test.clj",
                                       :lines [222 239]},
                              :full-name "cljs.test/async",
                              :docstring "Wraps body as a CPS function that can be returned from a test to\ncontinue asynchronously.  Binds done to a function that must be\ninvoked once and from an async context after any assertions.\n\n(deftest example-with-timeout\n  (async done\n    (js/setTimeout (fn []\n                     ;; make assertions in async context...\n                     (done) ;; ...then call done\n                     )\n                   0)))"},
           "cljs.core/IFn" {:ns "cljs.core",
                            :name "IFn",
                            :history [["+" "0.0-971"]],
                            :type "protocol",
                            :full-name-encode "cljs.core_IFn",
                            :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q r]\n    [this a b c d e f g h i j k l m n o p q r s]\n    [this a b c d e f g h i j k l m n o p q r s t]\n    [this a b c d e f g h i j k l m n o p q r s t rest]))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [234 257]},
                            :methods [{:name "-invoke",
                                       :signature ["[this]"
                                                   "[this a]"
                                                   "[this a b]"
                                                   "[this a b c]"
                                                   "[this a b c d]"
                                                   "[this a b c d e]"
                                                   "[this a b c d e f]"
                                                   "[this a b c d e f g]"
                                                   "[this a b c d e f g h]"
                                                   "[this a b c d e f g h i]"
                                                   "[this a b c d e f g h i j]"
                                                   "[this a b c d e f g h i j k]"
                                                   "[this a b c d e f g h i j k l]"
                                                   "[this a b c d e f g h i j k l m]"
                                                   "[this a b c d e f g h i j k l m n]"
                                                   "[this a b c d e f g h i j k l m n o]"
                                                   "[this a b c d e f g h i j k l m n o p]"
                                                   "[this a b c d e f g h i j k l m n o p q]"
                                                   "[this a b c d e f g h i j k l m n o p q r]"
                                                   "[this a b c d e f g h i j k l m n o p q r s]"
                                                   "[this a b c d e f g h i j k l m n o p q r s t]"
                                                   "[this a b c d e f g h i j k l m n o p q r s t rest]"],
                                       :docstring nil}],
                            :full-name "cljs.core/IFn",
                            :clj-symbol "clojure.lang/IFn"},
           "cljs.core/aget" {:description "Returns the value at index `i` from JavaScript arrays and objects.\n\nCan be used to retrieve nested properties with the additional `idxs` arguments.",
                             :ns "cljs.core",
                             :name "aget",
                             :signature ["[array i]"
                                         "[array i & idxs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/.."
                                       "cljs.core/aset"
                                       "cljs.core/get"
                                       "cljs.core/nth"],
                             :full-name-encode "cljs.core_aget",
                             :source {:code "(defn aget\n  ([array i]\n     (cljs.core/aget array i))\n  ([array i & idxs]\n     (apply aget (aget array i) idxs)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [196 201]},
                             :extra-sources ({:code "(defmacro aget\n  ([a i]\n     (core/list 'js* \"(~{}[~{}])\" a i))\n  ([a i & idxs]\n     (let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n      `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~a ~i ~@idxs))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [340 345]}),
                             :examples [{:id "e36007",
                                         :content "```js\n// JavaScript\nvar a = {\"foo\": [5, 6]};\n\na[\"foo\"];\n//=> [5, 6]\n\na[\"foo\"][0];\n//=> 5\n```\n\n```clj\n;; ClojureScript\n(def a #js {:foo #js [5 6]})\n\n(aget a \"foo\")\n;;=> #js [5 6]\n\n(aget a \"foo\" 0)\n;;=> 5\n```"}
                                        {:id "c9029e",
                                         :content "```js\n// JavaScript\ndocument.location.href;\n//=> \"http://example.com\"\n```\n\nThe following are equivalent:\n\n```clj\n;; ClojureScript\n(aget js/document \"location\" \"href\")\n;;=> \"http://example.com\"\n\n(.. js/document -location -href)\n;;=> \"http://example.com\"\n```"}],
                             :full-name "cljs.core/aget",
                             :clj-symbol "clojure.core/aget",
                             :docstring "Returns the value at the index."},
           "cljs.core/if-let" {:description "When `test` is logical true, evaluates `then` with the value of `test` bound to\n`x`. Otherwise, evaluates `else` with no bindings.\n\n`else` defaults to nil.",
                               :ns "cljs.core",
                               :name "if-let",
                               :signature ["[[x test] then]"
                                           "[[x test] then else]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :related ["cljs.core/when-let"
                                         "special/if"],
                               :full-name-encode "cljs.core_if-let",
                               :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                        :repo "clojure",
                                        :tag "clojure-1.6.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [1721 1739]},
                               :full-name "cljs.core/if-let",
                               :clj-symbol "clojure.core/if-let",
                               :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
           "cljs.core//" {:description "If no denominators are supplied, returns 1/numerator, else returns numerator\ndivided by all of the denominators.",
                          :return-type number,
                          :ns "cljs.core",
                          :name "/",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/*" "cljs.core/quot"],
                          :full-name-encode "cljs.core_SLASH",
                          :source {:code "(defn ^number /\n  ([x] (/ 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1866 1871]},
                          :extra-sources ({:code "(defmacro ^::ana/numeric /\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [425 428]}),
                          :examples [{:id "824bb7",
                                      :content "```clj\n(/ 6 3)\n;;=> 2\n\n(/ 6 3 2)\n;;=> 1\n\n(/ 10)\n;;=> 0.1\n\n(/ 1 3)\n;;=> 0.3333333333333333\n```"}],
                          :full-name "cljs.core//",
                          :clj-symbol "clojure.core//",
                          :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/unchecked-int" {:ns "cljs.core",
                                      :name "unchecked-int",
                                      :signature ["[x]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_unchecked-int",
                                      :source {:code "(defn unchecked-int\n  [x]\n  (fix x))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [2041 2044]},
                                      :full-name "cljs.core/unchecked-int",
                                      :clj-symbol "clojure.core/unchecked-int",
                                      :docstring "Coerce to int by stripping decimal places."},
           "cljs.repl.server/read-get" {:ns "cljs.repl.server",
                                        :name "read-get",
                                        :type "function",
                                        :signature ["[line rdr]"],
                                        :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [89 94]},
                                        :full-name "cljs.repl.server/read-get",
                                        :full-name-encode "cljs.repl.server_read-get",
                                        :history [["+" "0.0-1503"]]},
           "cljs.core/min-key" {:description "Returns the `x` for which `(k x)` is least.\n\n`(k x)` should return a number.",
                                :ns "cljs.core",
                                :name "min-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/min"
                                          "cljs.core/max-key"],
                                :full-name-encode "cljs.core_min-key",
                                :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7695 7700]},
                                :full-name "cljs.core/min-key",
                                :clj-symbol "clojure.core/min-key",
                                :docstring "Returns the x for which (k x), a number, is least."},
           "clojure.zip/root" {:ns "clojure.zip",
                               :name "root",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_root",
                               :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [124 133]},
                               :full-name "clojure.zip/root",
                               :clj-symbol "clojure.zip/root",
                               :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
           "cljs.core/drop-while" {:description "Returns a lazy sequence of the items in `coll` starting from the first item for\nwhich `(pred item)` returns logical false.\n\nReturns a stateful transducer when no collection is provided.",
                                   :ns "cljs.core",
                                   :name "drop-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/take-while"
                                             "cljs.core/split-with"],
                                   :full-name-encode "cljs.core_drop-while",
                                   :source {:code "(defn drop-while\n  ([pred]\n     (fn [rf]\n       (let [da (volatile! true)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [drop? @da]\n                (if (and drop? (pred input))\n                  result\n                  (do\n                    (vreset! da nil)\n                    (rf result input)))))))))\n  ([pred coll]\n     (let [step (fn [pred coll]\n                  (let [s (seq coll)]\n                    (if (and s (pred (first s)))\n                      (recur pred (rest s))\n                      s)))]\n       (lazy-seq (step pred coll)))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3845 3868]},
                                   :full-name "cljs.core/drop-while",
                                   :clj-symbol "clojure.core/drop-while",
                                   :docstring "Returns a lazy sequence of the items in coll starting from the\nfirst item for which (pred item) returns logical false.  Returns a\nstateful transducer when no collection is provided."},
           "cljs.repl.browser/send-repl-client-page" {:ns "cljs.repl.browser",
                                                      :name "send-repl-client-page",
                                                      :type "function",
                                                      :signature ["[request conn opts]"],
                                                      :source {:code "(defn send-repl-client-page\n  [request conn opts]\n  (server/send-and-close conn 200\n    (str \"<html><head><meta charset=\\\"UTF-8\\\"></head><body>\n          <script type=\\\"text/javascript\\\">\"\n         (repl-client-js)\n         \"</script>\"\n         \"<script type=\\\"text/javascript\\\">\n          clojure.browser.repl.client.start(\\\"http://\" (-> request :headers :host) \"\\\");\n          </script>\"\n         \"</body></html>\")\n    \"text/html\"))",
                                                               :repo "clojurescript",
                                                               :tag "r2911",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [54
                                                                       65]},
                                                      :full-name "cljs.repl.browser/send-repl-client-page",
                                                      :full-name-encode "cljs.repl.browser_send-repl-client-page",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "clojure.browser.repl/evaluate-javascript" {:ns "clojure.browser.repl",
                                                       :name "evaluate-javascript",
                                                       :signature ["[conn block]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.repl_evaluate-javascript",
                                                       :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch :default e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                :repo "clojurescript",
                                                                :tag "r2911",
                                                                :filename "src/cljs/clojure/browser/repl.cljs",
                                                                :lines [32
                                                                        41]},
                                                       :full-name "clojure.browser.repl/evaluate-javascript",
                                                       :docstring "Process a single block of JavaScript received from the server"},
           "cljs.core/set-validator!" {:description "Sets a validator function for atom `a`.\n\n`fn` must be nil or a side-effect-free function of one argument, which will be\npassed the intended new state on any state change. `fn` should return false or\nthrow an Error if the new state is unacceptable.\n\nIf the current value of `a` is unacceptable to `fn` when `set-validator!` is\ncalled, an Error will be thrown and the validator will not be set.\n\n`(set-validator! my-atom nil)` will remove the validator from `my-atom`.",
                                       :ns "cljs.core",
                                       :name "set-validator!",
                                       :signature ["[a fn]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["cljs.core/atom"
                                                 "cljs.core/get-validator"],
                                       :full-name-encode "cljs.core_set-validatorBANG",
                                       :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [3585 3593]},
                                       :full-name "cljs.core/set-validator!",
                                       :clj-symbol "clojure.core/set-validator!",
                                       :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
           "syntax/queue-literal" {:ns "syntax",
                                   :name "queue-literal",
                                   :history [["+" "0.0-1424"]],
                                   :type "tagged literal",
                                   :full-name-encode "syntax_queue-literal",
                                   :source {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/tagged_literals.clj",
                                            :lines [44 48]},
                                   :extra-sources [{:code "(defn read-queue\n  [form]\n  (when-not (vector? form)\n    (throw (RuntimeException. \"Queue literal expects a vector for its elements.\")))\n  (list 'cljs.core/into 'cljs.core.PersistentQueue.EMPTY form))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/tagged_literals.clj",
                                                    :lines [4 8]}],
                                   :syntax-form "#queue []",
                                   :full-name "syntax/queue-literal"},
           "cljs.core/<" {:description "Returns true if each successive number argument is greater than the previous\none, false otherwise.",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name "<",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/<="],
                          :full-name-encode "cljs.core_LT",
                          :source {:code "(defn ^boolean <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1873 1883]},
                          :extra-sources ({:code "(defmacro ^::ana/numeric <\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [435 438]}),
                          :examples [{:id "02e6d3",
                                      :content "```clj\n(< 1 2)\n;;=> true\n\n(< 2 1)\n;;=> false\n\n(< 1 1)\n;;=> false\n\n(< 2 3 4 5 6)\n;;=> true\n```"}],
                          :full-name "cljs.core/<",
                          :clj-symbol "clojure.core/<",
                          :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
           "cljs.repl.reflect/read-url-string" {:ns "cljs.repl.reflect",
                                                :name "read-url-string",
                                                :type "var",
                                                :source {:code "(def read-url-string (comp read-string url-decode))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/clj/cljs/repl/reflect.clj",
                                                         :lines [42]},
                                                :full-name "cljs.repl.reflect/read-url-string",
                                                :full-name-encode "cljs.repl.reflect_read-url-string",
                                                :history [["+"
                                                           "0.0-1503"]]},
           "cljs.core/fn" {:description "Defines a function.\n\n`name?` is an optional name of the function to be used inside `body`. This is\nuseful for recursive calls. Note that `name?` in `fn` is not the same as the\n`name` argument to `defn`, which defines a global symbol for the function.\n\n`params*` are the arguments to the function and a binding form for the symbols\nthat the arguments will take inside the body of the function. Functions can have\narity of 0-20 and there is no runtime enforcement of arity when calling a\nfunction (just like in JavaScript).\n\n`prepost-map?` is an optional map with optional keys `:pre` and `:post` that\ncontain collections of [pre or post conditions](http://blog.fogus.me/2009/12/21/clojures-pre-and-post/)\nfor the function.\n\n`body` is a series of expressions that execute when the function is called. The\narguments to the function are mapped to symbols in `params*` and are available\nin `body`. The value of the last expression in `body` is the return value of\ncalling the function.",
                           :ns "cljs.core",
                           :name "fn",
                           :signature ["[name? [params*] prepost-map? body]"
                                       "[name? ([params*] prepost-map? body)+]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/defn"
                                     "cljs.core/defn-"],
                           :full-name-encode "cljs.core_fn",
                           :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) \n                 (list sigs) \n                 (if (seq? (first sigs))\n                   sigs\n                   ;; Assume single arity syntax\n                   (throw (IllegalArgumentException. \n                            (if (seq sigs)\n                              (str \"Parameter declaration \" \n                                   (first sigs)\n                                   \" should be a vector\")\n                              (str \"Parameter declaration missing\"))))))\n          psig (fn* [sig]\n                 ;; Ensure correct type before destructuring sig\n                 (when (not (seq? sig))\n                   (throw (IllegalArgumentException.\n                            (str \"Invalid signature \" sig\n                                 \" should be a list\"))))\n                 (let [[params & body] sig\n                       _ (when (not (vector? params))\n                           (throw (IllegalArgumentException. \n                                    (if (seq? (first sigs))\n                                      (str \"Parameter declaration \" params\n                                           \" should be a vector\")\n                                      (str \"Invalid signature \" sig\n                                           \" should be a list\")))))\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                    :repo "clojure",
                                    :tag "clojure-1.6.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [4143 4203]},
                           :extra-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n fn (fn* fn [&form &env & decl] \n         (.withMeta ^clojure.lang.IObj (cons 'fn* decl) \n                    (.meta ^clojure.lang.IMeta &form))))",
                                            :repo "clojure",
                                            :tag "clojure-1.6.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [42 47]}),
                           :full-name "cljs.core/fn",
                           :clj-symbol "clojure.core/fn",
                           :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
           "cljs.core/split-with" {:description "Returns a vector of `[(take-while pred coll) (drop-while pred coll)]`",
                                   :ns "cljs.core",
                                   :name "split-with",
                                   :signature ["[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/split-at"
                                             "clojure.string/split"
                                             "cljs.core/take-while"
                                             "cljs.core/drop-while"],
                                   :full-name-encode "cljs.core_split-with",
                                   :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7928 7931]},
                                   :full-name "cljs.core/split-with",
                                   :clj-symbol "clojure.core/split-with",
                                   :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
           "cljs.core/IWriter" {:ns "cljs.core",
                                :name "IWriter",
                                :type "protocol",
                                :full-name-encode "cljs.core_IWriter",
                                :source {:code "(defprotocol IWriter\n  (-write [writer s])\n  (-flush [writer]))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [357 359]},
                                :methods [{:name "-write",
                                           :signature ["[writer s]"],
                                           :docstring nil}
                                          {:name "-flush",
                                           :signature ["[writer]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IWriter",
                                :history [["+" "0.0-1503"]]},
           "cljs.repl.browser/preloaded-libs" {:ns "cljs.repl.browser",
                                               :name "preloaded-libs",
                                               :type "var",
                                               :source {:code "(def preloaded-libs (atom #{}))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [27]},
                                               :full-name "cljs.repl.browser/preloaded-libs",
                                               :full-name-encode "cljs.repl.browser_preloaded-libs",
                                               :history [["+"
                                                          "0.0-1424"]]},
           "cljs.core/IReduce" {:ns "cljs.core",
                                :name "IReduce",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core_IReduce",
                                :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [324 325]},
                                :methods [{:name "-reduce",
                                           :signature ["[coll f]"
                                                       "[coll f start]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IReduce",
                                :clj-symbol "clojure.lang/IReduce"},
           "cljs.reader/symbol-pattern" {:ns "cljs.reader",
                                         :name "symbol-pattern",
                                         :type "var",
                                         :source {:code "(def symbol-pattern (re-pattern \"^[:]?([^0-9/].*/)?([^0-9/][^/]*)$\"))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [101]},
                                         :full-name "cljs.reader/symbol-pattern",
                                         :full-name-encode "cljs.reader_symbol-pattern",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashSet.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashSet.fromArray",
                                                    :signature ["[items no-clone]"],
                                                    :history [["+"
                                                               "0.0-1443"]],
                                                    :parent-type "PersistentHashSet",
                                                    :type "function",
                                                    :full-name-encode "cljs.core_PersistentHashSetDOTfromArray",
                                                    :source {:code "(set! (.-fromArray PersistentHashSet)\n  (fn [items ^boolean no-clone]\n    (let [len (alength items)]\n      (if (<= len (.-HASHMAP-THRESHOLD PersistentArrayMap))\n        (let [arr (if no-clone items (aclone items))]\n          (loop [i 0\n                 out (transient (.-EMPTY PersistentArrayMap))]\n            (if (< i len)\n              (recur (inc i) (-assoc! out (aget items i) nil))\n              (PersistentHashSet. nil (-persistent! out) nil))))\n       (loop [i 0\n              out (transient (.-EMPTY PersistentHashSet))]\n         (if (< i len)\n           (recur (inc i) (-conj! out (aget items i)))\n           (-persistent! out)))))))",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [7432
                                                                     7446]},
                                                    :full-name "cljs.core/PersistentHashSet.fromArray"},
           "cljs.core/repeatedly" {:description "Takes a function `f` of no args, presumably with side effects, and returns an\ninfinite (or length `n` if supplied) lazy sequence of calls to it.",
                                   :ns "cljs.core",
                                   :name "repeatedly",
                                   :signature ["[f]" "[n f]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/repeat"
                                             "cljs.core/iterate"
                                             "cljs.core/lazy-seq"
                                             "cljs.core/dotimes"
                                             "cljs.core/constantly"],
                                   :full-name-encode "cljs.core_repeatedly",
                                   :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3890 3895]},
                                   :full-name "cljs.core/repeatedly",
                                   :clj-symbol "clojure.core/repeatedly",
                                   :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
           "cljs.build.api/mark-cljs-ns-for-recompile!" {:ns "cljs.build.api",
                                                         :name "mark-cljs-ns-for-recompile!",
                                                         :signature ["[ns-sym]"
                                                                     "[ns-sym output-dir]"],
                                                         :history [["+"
                                                                    "0.0-2496"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.build.api_mark-cljs-ns-for-recompileBANG",
                                                         :source {:code "(defn mark-cljs-ns-for-recompile!\n  ([ns-sym] (mark-cljs-ns-for-recompile! ns-sym nil))\n  ([ns-sym output-dir]\n    (let [s (target-file-for-cljs-ns output-dir ns-sym)]\n      (when (.exists s)\n        (.setLastModified s 5000)))))",
                                                                  :repo "clojurescript",
                                                                  :tag "r2911",
                                                                  :filename "src/clj/cljs/build/api.clj",
                                                                  :lines [37
                                                                          43]},
                                                         :full-name "cljs.build.api/mark-cljs-ns-for-recompile!",
                                                         :docstring "Backdates a cljs target file so that it the cljs compiler will recompile it."},
           "cljs.reader/read-delimited-list" {:ns "cljs.reader",
                                              :name "read-delimited-list",
                                              :type "function",
                                              :signature ["[delim rdr recursive?]"],
                                              :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a (transient [])]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF while reading\"))\n      (if (identical? delim ch)\n        (persistent! a)\n        (if-let [macrofn (macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (identical? mret rdr) a (conj! a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (identical? o rdr) a (conj! a o))))))))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/cljs/reader.cljs",
                                                       :lines [225
                                                               238]},
                                              :full-name "cljs.reader/read-delimited-list",
                                              :full-name-encode "cljs.reader_read-delimited-list",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.test/inc-report-counter!" {:ns "cljs.test",
                                            :name "inc-report-counter!",
                                            :signature ["[name]"],
                                            :history [["+" "0.0-2496"]],
                                            :type "function",
                                            :full-name-encode "cljs.test_inc-report-counterBANG",
                                            :source {:code "(defn inc-report-counter!\n  [name]\n  (if (:report-counters (get-current-env))\n    (update-current-env! [:report-counters name] (fnil inc 0))))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/cljs/test.cljs",
                                                     :lines [295 300]},
                                            :full-name "cljs.test/inc-report-counter!",
                                            :docstring "Increments the named counter in *report-counters*, a ref to a map.\nDoes nothing if *report-counters* is nil."},
           "cljs.core/undefined?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "undefined?",
                                   :signature ["[x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_undefinedQMARK",
                                   :source {:code "(defn ^boolean undefined? [x]\n  (cljs.core/undefined? x))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1593 1594]},
                                   :extra-sources ({:code "(defmacro undefined? [x]\n  (bool-expr (core/list 'js* \"(void 0 === ~{})\" x)))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [316 317]}),
                                   :full-name "cljs.core/undefined?"},
           "clojure.zip/prev" {:ns "clojure.zip",
                               :name "prev",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_prev",
                               :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [221 230]},
                               :full-name "clojure.zip/prev",
                               :clj-symbol "clojure.zip/prev",
                               :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
           "cljs.core/seq?" {:description "Returns true if `x` is a sequence, false otherwise.\n\nAll collections can be converted into a sequence using `seq`.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "seq?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/seq"
                                       "cljs.core/sequential?"
                                       "cljs.core/vector?"
                                       "cljs.core/coll?"
                                       "cljs.core/list?"
                                       "cljs.core/map?"
                                       "cljs.core/set?"],
                             :full-name-encode "cljs.core_seqQMARK",
                             :source {:code "(defn ^boolean seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1596 1601]},
                             :full-name "cljs.core/seq?",
                             :clj-symbol "clojure.core/seq?",
                             :docstring "Return true if s satisfies ISeq"},
           "cljs.repl.browser/browser-state" {:ns "cljs.repl.browser",
                                              :name "browser-state",
                                              :type "var",
                                              :source {:code "(defonce browser-state\n  (atom {:return-value-fn nil\n         :client-js nil}))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [21 23]},
                                              :full-name "cljs.repl.browser/browser-state",
                                              :full-name-encode "cljs.repl.browser_browser-state",
                                              :history [["+"
                                                         "0.0-1503"]]},
           "cljs.core/prn-str" {:ns "cljs.core",
                                :name "prn-str",
                                :signature ["[& objs]"],
                                :history [["+" "0.0-1011"]],
                                :type "function",
                                :full-name-encode "cljs.core_prn-str",
                                :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8286 8289]},
                                :full-name "cljs.core/prn-str",
                                :clj-symbol "clojure.core/prn-str",
                                :docstring "Same as pr-str followed by (newline)"},
           "cljs.core/chunk-buffer" {:ns "cljs.core",
                                     :name "chunk-buffer",
                                     :type "function",
                                     :signature ["[capacity]"],
                                     :source {:code "(defn chunk-buffer [capacity]\n  (ChunkBuffer. (make-array capacity) 0))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2637 2638]},
                                     :full-name "cljs.core/chunk-buffer",
                                     :full-name-encode "cljs.core_chunk-buffer",
                                     :history [["+" "0.0-1424"]]},
           "cljs.core/odd?" {:description "Returns true if `n` is an odd number.\n\nThrows an exception if `n` is not an integer.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "odd?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/even?"],
                             :full-name-encode "cljs.core_oddQMARK",
                             :source {:code "(defn ^boolean odd?\n  [n] (not (even? n)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3329 3331]},
                             :full-name "cljs.core/odd?",
                             :clj-symbol "clojure.core/odd?",
                             :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
           "cljs.core/cons" {:description "Returns a new sequence where `x` is the first element and `coll` is the rest.",
                             :ns "cljs.core",
                             :name "cons",
                             :signature ["[x coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/conj"],
                             :full-name-encode "cljs.core_cons",
                             :source {:code "(defn cons\n  [x coll]\n  (if (or (nil? coll)\n          (implements? ISeq coll))\n    (Cons. nil x coll nil)\n    (Cons. nil x (seq coll) nil)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2468 2474]},
                             :full-name "cljs.core/cons",
                             :clj-symbol "clojure.core/cons",
                             :docstring "Returns a new seq where x is the first element and seq is the rest."},
           "syntax/function" {:description "Create an anonymous function.\n\n`#(...)` = `(fn [args] (...))`\n\nUse `%` or `%1` to access the first argument.  Use `%2`, `%3` and so on to\naccess subsequent arguments.  Use `%&` to access the rest of the arguments past\nthe highest individually referenced argument.\n\nNote that `#(1)` does not create a function that returns `1`, for the same\nreason that `(1)` does evaluate to `1`.\n\n`#()` forms cannot be nested, since this would create an ambiguity between the\nautomatically assigned argument names.",
                              :ns "syntax",
                              :name "function",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :related ["cljs.core/fn"
                                        "cljs.core/defn"],
                              :full-name-encode "syntax_function",
                              :source {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                       :repo "tools.reader",
                                       :tag "tools.reader-0.8.10",
                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                       :lines [612 623]},
                              :extra-sources [{:code "(defn- read-fn\n  [rdr _]\n  (if (thread-bound? #'arg-env)\n    (throw (IllegalStateException. \"Nested #()s are not allowed\")))\n  (binding [arg-env (sorted-map)]\n    (let [form (read (doto rdr (unread \\()) true nil true) ;; this sets bindings\n          rargs (rseq arg-env)\n          args (if rargs\n                 (let [higharg (key (first rargs))]\n                   (let [args (loop [i 1 args (transient [])]\n                                (if (> i higharg)\n                                  (persistent! args)\n                                  (recur (inc i) (conj! args (or (get arg-env i)\n                                                                 (garg i))))))\n                         args (if (arg-env -1)\n                                (conj args '& (arg-env -1))\n                                args)]\n                     args))\n                 [])]\n      (list 'fn* args form))))",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.10",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [386 405]}],
                              :syntax-form "#()",
                              :examples [{:id "6a87de",
                                          :content "```clj\n(map #(* 2 %) [1 2 3])\n;;=> (2 4 6)\n\n(def f #(println %1 %2 %&))\n(f 1 2 3 4 5)\n;; prints: 1 2 (3 4)\n```"}],
                              :full-name "syntax/function",
                              :clj-doc "http://clojure.org/reader#toc2"},
           "special/deftype*" {:ns "special",
                               :name "deftype*",
                               :type "special form",
                               :source {:code "(defmethod parse 'deftype*\n  [_ env form _ _]\n  (parse-type :deftype* env form))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/clj/cljs/analyzer.clj",
                                        :lines [1421 1423]},
                               :full-name "special/deftype*",
                               :full-name-encode "special_deftypeSTAR",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/read-set" {:ns "cljs.reader",
                                   :name "read-set",
                                   :type "function",
                                   :signature ["[rdr _]"],
                                   :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [381 383]},
                                   :full-name "cljs.reader/read-set",
                                   :full-name-encode "cljs.reader_read-set",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/descendants" {:ns "cljs.core",
                                    :name "descendants",
                                    :signature ["[tag]" "[h tag]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_descendants",
                                    :source {:code "(defn descendants\n  ([tag] (descendants @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [8816 8823]},
                                    :full-name "cljs.core/descendants",
                                    :clj-symbol "clojure.core/descendants",
                                    :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on JavaScript type inheritance\nrelationships."},
           "syntax/nil" {:description "`nil` is a representation of nothing.\n\nIt is common for operations to safely handle `nil` without\ncausing exceptions.\n\nExpressions evaluate to `nil` if there is no value to return.",
                         :ns "syntax",
                         :name "nil",
                         :history [["+" "0.0-927"]],
                         :type "special symbol",
                         :full-name-encode "syntax_nil",
                         :source {:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                  :repo "tools.reader",
                                  :tag "tools.reader-0.8.10",
                                  :filename "src/main/clojure/clojure/tools/reader.clj",
                                  :lines [275 301]},
                         :syntax-form "nil",
                         :examples [{:id "17b92a",
                                     :content "```clj\nnil\n;;=> nil\n```\n\n`nil` can sometimes mean \"not found\":\n\n```clj\n(:foo {})\n;;=> nil\n```\n\n`nil` can also mean that the operation didn't make sense:\n\n```clj\n(:foo nil)\n;;=> nil\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#nil",
                         :full-name "syntax/nil",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/map" {:description "Signifies a map.  Must contain pairs of key-values.  Keys and values can be any type.",
                         :ns "syntax",
                         :name "map",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["cljs.core/hash-map"
                                   "cljs.core/array-map"
                                   "cljs.core/sorted-map"
                                   "cljs.core/sorted-map-by"],
                         :full-name-encode "syntax_map",
                         :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                  :repo "tools.reader",
                                  :tag "tools.reader-0.8.10",
                                  :filename "src/main/clojure/clojure/tools/reader.clj",
                                  :lines [591 610]},
                         :extra-sources [{:code "(defn- read-map\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-map (read-delimited \\} rdr true)\n        map-count (count the-map)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (when (odd? map-count)\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (with-meta\n      (if (zero? map-count)\n        {}\n        (RT/map (to-array the-map)))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [205 226]}],
                         :syntax-form "{}",
                         :examples [{:id "4696ad",
                                     :content "```clj\n{:foo 1 :bar 2}\n;;=> {:foo 1, :bar 2}\n```\n\nUse any value as a key:\n\n```clj\n(def m {[1 2] 3})\n(get m [1 2])\n;;=> 3\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#maps",
                         :full-name "syntax/map",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "special/new" {:ns "special",
                          :name "new",
                          :type "special form",
                          :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args :as form] _ _]\n  (when-not (symbol? ctor) \n    (throw (error env \"First arg to new must be a symbol\")))\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         ctor-var (resolve-existing-var env ctor)\n         record-args\n         (when (and (:record ctor-var) (not (-> ctor meta :internal-ctor)))\n           (repeat 3 (analyze enve nil)))\n         argexprs (into (vec (map #(analyze enve %) args)) record-args)\n         known-num-fields (:num-fields ctor-var)\n         argc (count args)]\n     (when (and (not (-> ctor meta :internal-ctor))\n                known-num-fields (not= known-num-fields argc))\n       (warning :fn-arity env {:argc argc :ctor ctor}))\n     {:env env :op :new :form form :ctor ctorexpr :args argexprs\n      :children (into [ctorexpr] argexprs)\n      :tag (let [name (-> ctorexpr :info :name)]\n             (or ('{js/Object object\n                    js/String string\n                    js/Array  array\n                    js/Number number\n                    js/Function function\n                    js/Boolean boolean} name)\n                 name))})))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/clj/cljs/analyzer.clj",
                                   :lines [1017 1043]},
                          :full-name "special/new",
                          :full-name-encode "special_new",
                          :clj-symbol "clojure.core/new",
                          :history [["+" "0.0-927"]]},
           "cljs.core/take-nth" {:description "Returns a lazy seq of every `n`th item in `coll`.\n\nReturns a stateful transducer when no collection is provided.",
                                 :ns "cljs.core",
                                 :name "take-nth",
                                 :signature ["[n]" "[n coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_take-nth",
                                 :source {:code "(defn take-nth\n  ([n]\n     (fn [rf]\n       (let [ia (volatile! -1)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [i (vswap! ia inc)]\n                (if (zero? (rem i n))\n                  (rf result input)\n                  result)))))))\n  ([n coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (cons (first s) (take-nth n (drop n s)))))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7909 7926]},
                                 :full-name "cljs.core/take-nth",
                                 :clj-symbol "clojure.core/take-nth",
                                 :docstring "Returns a lazy seq of every nth item in coll.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.reader/throwing-reader" {:ns "cljs.reader",
                                          :name "throwing-reader",
                                          :type "function",
                                          :signature ["[msg]"],
                                          :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [366 369]},
                                          :full-name "cljs.reader/throwing-reader",
                                          :full-name-encode "cljs.reader_throwing-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.browser/send-static" {:ns "cljs.repl.browser",
                                            :name "send-static",
                                            :type "function",
                                            :signature ["[{path :path, :as request} conn opts]"],
                                            :source {:code "(defn send-static [{path :path :as request} conn opts]\n  (if (and (:static-dir opts)\n           (not= \"/favicon.ico\" path))\n    (let [path   (if (= \"/\" path) \"/index.html\" path)\n          st-dir (:static-dir opts)\n          local-path\n          (cond->\n            (seq (for [x (if (string? st-dir) [st-dir] st-dir)\n                       :when (.exists (io/file (str x path)))]\n                   (str x path)))\n            (complement nil?) first)\n          local-path\n          (if (nil? local-path)\n            (cond\n              (re-find #\".jar\" path)\n              (io/resource (second (string/split path #\".jar!/\")))\n              (re-find (Pattern/compile (System/getProperty \"user.dir\")) path)\n              (io/file (string/replace path (str (System/getProperty \"user.dir\") \"/\") \"\"))\n              :else nil)\n            local-path)]\n      (if local-path\n        (server/send-and-close conn 200 (slurp local-path)\n          (condp #(.endsWith %2 %1) path\n            \".html\" \"text/html\"\n            \".css\" \"text/css\"\n            \".html\" \"text/html\"\n            \".jpg\" \"image/jpeg\"\n            \".js\" \"text/javascript\"\n            \".cljs\" \"text/x-clojure\"\n            \".map\" \"application/json\"\n            \".png\" \"image/png\"\n            \"text/plain\"))\n        (server/send-404 conn path)))\n    (server/send-404 conn path)))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [67 100]},
                                            :full-name "cljs.repl.browser/send-static",
                                            :full-name-encode "cljs.repl.browser_send-static",
                                            :history [["+" "0.0-1211"]]},
           "cljs.core/double" {:return-type number,
                               :ns "cljs.core",
                               :name "double",
                               :signature ["[x]"],
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :full-name-encode "cljs.core_double",
                               :source {:code "(defn ^number double [x] x)",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1951]},
                               :extra-sources ({:code "(defmacro double [x] x)",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [364]}),
                               :full-name "cljs.core/double",
                               :clj-symbol "clojure.core/double"},
           "cljs.core/even?" {:description "Returns true if `n` is an even number.\n\nThrows an exception if `n` is not an integer.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "even?",
                              :signature ["[n]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/odd?"],
                              :full-name-encode "cljs.core_evenQMARK",
                              :source {:code "(defn ^boolean even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3323 3327]},
                              :full-name "cljs.core/even?",
                              :clj-symbol "clojure.core/even?",
                              :docstring "Returns true if n is even, throws an exception if n is not an integer"},
           "cljs.core/simple-benchmark" {:ns "cljs.core",
                                         :name "simple-benchmark",
                                         :signature ["[bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]"],
                                         :history [["+" "0.0-1236"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_simple-benchmark",
                                         :source {:code "(defmacro simple-benchmark\n  [bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]\n  (let [bs-str   (pr-str bindings)\n        expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str \", \" ~expr-str \", \"\n                         ~iterations \" runs, \" elapsed# \" msecs\"))))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1603 1619]},
                                         :full-name "cljs.core/simple-benchmark",
                                         :docstring "Runs expr iterations times in the context of a let expression with\nthe given bindings, then prints out the bindings and the expr\nfollowed by number of iterations and total time. The optional\nargument print-fn, defaulting to println, sets function used to\nprint the result. expr's string representation will be produced\nusing pr-str in any case."},
           "cljs.build.api/cljs-ns-dependents" {:ns "cljs.build.api",
                                                :name "cljs-ns-dependents",
                                                :signature ["[ns]"],
                                                :history [["+"
                                                           "0.0-2629"]],
                                                :type "function",
                                                :full-name-encode "cljs.build.api_cljs-ns-dependents",
                                                :source {:code "(defn cljs-ns-dependents\n  [ns]\n  (ana/ns-dependents ns))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/clj/cljs/build/api.clj",
                                                         :lines [66
                                                                 71]},
                                                :full-name "cljs.build.api/cljs-ns-dependents",
                                                :docstring "Given a namespace symbol return a seq of all dependent\nnamespaces sorted in dependency order. Will include\ntransient dependents."},
           "syntax/number" {:description "Signifies a number.  ClojureScript numbers are the same as JavaScript numbers;\nthey are represented as double-precision 64-bit format IEEE 754 values.",
                            :ns "syntax",
                            :name "number",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :full-name-encode "syntax_number",
                            :source {:code "(defn- read-number\n  [reader initch]\n  (loop [sb (doto (StringBuilder.) (.append initch))\n         ch (read-char reader)]\n    (if (or (whitespace? ch) (macros ch) (nil? ch))\n      (let [s (str sb)]\n        (unread reader ch)\n        (or (match-number s)\n            (reader-error reader \"Invalid number format [\" s \"]\")))\n      (recur (doto sb (.append ch)) (read-char reader)))))",
                                     :repo "tools.reader",
                                     :tag "tools.reader-0.8.10",
                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                     :lines [228 237]},
                            :syntax-form " ",
                            :examples [{:id "f96060",
                                        :content "```clj\n123\n;;=> 123\n\n123.45\n;;=> 123.45\n```\n\nScientific notation;\n\n```clj\n12e3\n;;=> 12000\n\n1.2e-3\n;;=> 0.0012\n```\n\nStandard hex and octal notations:\n\n```clj\n0x1f\n;;=> 31\n\n010\n;;=> 8\n```\n\nRadix notation for using up to base 36.\n\n```clj\n2r10111\n;;=> 23\n\n8r32\n;;=> 26\n\n16rFF\n;;=> 255\n\n36rZ\n;;=> 35\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#integers",
                            :full-name "syntax/number",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/persistent-array-map-seq" {:ns "cljs.core",
                                                 :name "persistent-array-map-seq",
                                                 :type "function",
                                                 :signature ["[arr i _meta]"],
                                                 :source {:code "(defn persistent-array-map-seq [arr i _meta]\n  (when (<= i (- (alength arr) 2))\n    (PersistentArrayMapSeq. arr i _meta)))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [5318
                                                                  5320]},
                                                 :full-name "cljs.core/persistent-array-map-seq",
                                                 :full-name-encode "cljs.core_persistent-array-map-seq",
                                                 :history [["+"
                                                            "0.0-1820"]]},
           "special/fn*" {:ns "special",
                          :name "fn*",
                          :type "special form",
                          :source {:code "(defmethod parse 'fn*\n  [op env [_ & args :as form] name _]\n  (analyze-wrap-meta\n   (let [[name meths] (if (symbol? (first args))\n                        [(first args) (next args)]\n                        [name (seq args)])\n         ;;turn (fn [] ...) into (fn ([]...))\n         meths (if (vector? (first meths)) (list meths) meths)\n         locals (:locals env)\n         name-var (if name\n                    (merge\n                     {:name name\n                      :info {:shadow (or (locals name)\n                                         (get-in env [:js-globals name]))}}\n                     (when-let [tag (-> name meta :tag)]\n                       {:ret-tag tag})))\n         locals (if (and locals name) (assoc locals name name-var) locals)\n         type (-> form meta ::type)\n         protocol-impl (-> form meta ::protocol-impl)\n         protocol-inline (-> form meta ::protocol-inline)\n         menv (if (> (count meths) 1) (assoc env :context :expr) env)\n         menv (merge menv\n                     {:protocol-impl protocol-impl\n                      :protocol-inline protocol-inline})\n         methods (map #(analyze-fn-method menv locals % type) meths)\n         max-fixed-arity (apply max (map :max-fixed-arity methods))\n         variadic (boolean (some :variadic methods))\n         locals (if name\n                  (update-in locals [name] assoc\n                             ;; TODO: can we simplify? - David\n                             :fn-var true\n                             :variadic variadic\n                             :max-fixed-arity max-fixed-arity\n                             :method-params (map :params methods)\n                             :methods methods)\n                  locals)\n         methods (if name\n                   ;; a second pass with knowledge of our function-ness/arity\n                   ;; lets us optimize self calls\n                   (no-warn (doall (map #(analyze-fn-method menv locals % type) meths)))\n                   methods)\n         form (vary-meta form dissoc ::protocol-impl ::protocol-inline ::type)]\n     (let [variadic-methods (filter :variadic methods)\n           variadic-params (count (:params (first variadic-methods)))\n           param-counts (map (comp count :params) methods)]\n       (when (< 1 (count variadic-methods))\n         (warning :multiple-variadic-overloads env {:name name-var}))\n       (when (not (or (zero? variadic-params) (= variadic-params (+ 1 max-fixed-arity))))\n         (warning :variadic-max-arity env {:name name-var}))\n       (when (not= (distinct param-counts) param-counts)\n         (warning :overload-arity env {:name name-var})))\n     {:env env :op :fn :form form :name name-var :methods methods :variadic variadic\n      :tag 'function\n      :recur-frames *recur-frames* :loop-lets *loop-lets*\n      :jsdoc [(when variadic \"@param {...*} var_args\")]\n      :max-fixed-arity max-fixed-arity\n      :protocol-impl protocol-impl\n      :protocol-inline protocol-inline\n      :children (mapv :expr methods)})))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/clj/cljs/analyzer.clj",
                                   :lines [816 874]},
                          :full-name "special/fn*",
                          :full-name-encode "special_fnSTAR",
                          :history [["+" "0.0-927"]]},
           "cljs.analyzer.api/ns-specs" {:ns "cljs.analyzer.api",
                                         :name "ns-specs",
                                         :signature ["[ns]"],
                                         :history [["+" "0.0-2629"]
                                                   ["-" "0.0-2655"]],
                                         :type "function",
                                         :full-name-encode "cljs.analyzer.api_ns-specs",
                                         :source {:code "(defn ns-specs\n  [ns]\n  {:pre [(symbol? ns)]}\n  (get-in @env/*compiler* [::ana/namespaces ns :specs]))",
                                                  :repo "clojurescript",
                                                  :tag "r2644",
                                                  :filename "src/clj/cljs/analyzer/api.clj",
                                                  :lines [48 53]},
                                         :full-name "cljs.analyzer.api/ns-specs",
                                         :docstring "Given a namespace return all the original specs for a namspace as originally\nprovided in the source.",
                                         :removed {:in "0.0-2655",
                                                   :last-seen "0.0-2644"}},
           "cljs.repl.nashorn/repl-env" {:ns "cljs.repl.nashorn",
                                         :name "repl-env",
                                         :signature ["[& {:keys [debug], :as opts}]"],
                                         :history [["+" "0.0-2814"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.nashorn_repl-env",
                                         :source {:code "(defn repl-env \n  [& {:keys [debug] :as opts}]\n  (let [engine (create-engine)\n        compiler-env (env/default-compiler-env)]\n    (merge (NashornEnv. engine debug)\n      {:cljs.env/compiler compiler-env}  ; required by cider middleware ?\n      opts)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl/nashorn.clj",
                                                  :lines [198 211]},
                                         :full-name "cljs.repl.nashorn/repl-env",
                                         :docstring "Create a Nashorn repl-env for use with the repl/repl* method in Clojurescript and as the\n:repl-env argument to piggieback/cljs-repl. Besides the usual repl options (e.g. :source-map),\nopts has the following extra parameters:\n\n:output-dir  the directory of the compiled files, e.g. \"resources/public/my-app\" (mandatory).\n:output-to   load this file initially into Nashorn, relative to output-dir.\n             Use a minimal bootstrapped cljs.core environment if not specified."},
           "clojure.set/subset?" {:description "Returns true if `a` is a subset of `b`, false otherwise.\n\nIn other words, returns true if all the elements of `a` can be found in `b`.",
                                  :ns "clojure.set",
                                  :name "subset?",
                                  :signature ["[a b]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/set"
                                            "cljs.core/set?"
                                            "clojure.set/superset?"],
                                  :full-name-encode "clojure.set_subsetQMARK",
                                  :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [131 135]},
                                  :full-name "clojure.set/subset?",
                                  :clj-symbol "clojure.set/subset?",
                                  :docstring "Is set1 a subset of set2?"},
           "cljs.core/flush" {:ns "cljs.core",
                              :name "flush",
                              :signature ["[]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core_flush",
                              :source {:code "(defn flush [] ;stub\n  nil)",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8141 8142]},
                              :full-name "cljs.core/flush",
                              :clj-symbol "clojure.core/flush"},
           "cljs.core/long-array" {:ns "cljs.core",
                                   :name "long-array",
                                   :signature ["[size-or-seq]"
                                               "[size init-val-or-seq]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_long-array",
                                   :source {:code "(defn long-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (long-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2801 2819]},
                                   :full-name "cljs.core/long-array",
                                   :clj-symbol "clojure.core/long-array"},
           "cljs.reader/reader-error" {:ns "cljs.reader",
                                       :name "reader-error",
                                       :type "function",
                                       :signature ["[rdr & msg]"],
                                       :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (js/Error. (apply str msg))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [69 71]},
                                       :full-name "cljs.reader/reader-error",
                                       :full-name-encode "cljs.reader_reader-error",
                                       :history [["+" "0.0-927"]]},
           "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                           :name "prewalk-replace",
                                           :signature ["[smap form]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk_prewalk-replace",
                                           :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [80 86]},
                                           :full-name "clojure.walk/prewalk-replace",
                                           :clj-symbol "clojure.walk/prewalk-replace",
                                           :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
           "cljs.core/*1" {:description "Only usable from a REPL.\n\nHolds the result of the last expression.",
                           :ns "cljs.core",
                           :name "*1",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*2"
                                     "cljs.core/*3"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR1",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [59 61]},
                           :examples [{:id "30a861",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n*1\n;;=> 10\n\n(inc *1)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*1",
                           :clj-symbol "clojure.core/*1",
                           :docstring "bound in a repl thread to the most recent value printed"},
           "cljs.core/subseq" {:description "`sc` must be a sorted collection.\n\n`test`, `start-test`, `end-test` must be `<`, `<=`, `>` or `>=`.\n\nReturns a sequence of those entries with keys `ek` for which\n`(test (.. sc comparator (compare ek key)) 0)` is true.",
                               :ns "cljs.core",
                               :name "subseq",
                               :signature ["[sc test key]"
                                           "[sc start-test start-key end-test end-key]"],
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :related ["cljs.core/rsubseq"
                                         "cljs.core/sorted-map"
                                         "cljs.core/sorted-set"
                                         "cljs.core/sorted-map-by"
                                         "cljs.core/sorted-set-by"],
                               :full-name-encode "cljs.core_subseq",
                               :source {:code "(defn subseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{> >=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7769 7782]},
                               :full-name "cljs.core/subseq",
                               :clj-symbol "clojure.core/subseq",
                               :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/Eduction" {:ns "cljs.core",
                                 :name "Eduction",
                                 :type "type",
                                 :signature ["[xform coll]"],
                                 :source {:code "(deftype Eduction [xform coll]\n   ISequential\n   \n   ISeqable\n   (-seq [_] (seq (sequence xform coll)))\n\n   IReduce\n   (-reduce [_ f init] (transduce xform f init coll))\n\n   IPrintWithWriter\n   (-pr-writer [coll writer opts]\n     (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8607 8618]},
                                 :full-name "cljs.core/Eduction",
                                 :full-name-encode "cljs.core_Eduction",
                                 :history [["+" "0.0-2371"]]},
           "cljs.core/Set.EMPTY" {:ns "cljs.core",
                                  :name "Set.EMPTY",
                                  :history [["+" "0.0-927"]
                                            ["-" "0.0-1211"]],
                                  :parent-type "Set",
                                  :type "var",
                                  :full-name-encode "cljs.core_SetDOTEMPTY",
                                  :source {:code "(set! cljs.core.Set/EMPTY (Set. nil (hash-map)))",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2708]},
                                  :full-name "cljs.core/Set.EMPTY",
                                  :removed {:in "0.0-1211",
                                            :last-seen "0.0-1011"}},
           "cljs.reader/read-unicode-char" {:ns "cljs.reader",
                                            :name "read-unicode-char",
                                            :signature ["[reader initch]"],
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1424"]],
                                            :type "function",
                                            :full-name-encode "cljs.reader_read-unicode-char",
                                            :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                     :repo "clojurescript",
                                                     :tag "r1236",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [171 173]},
                                            :full-name "cljs.reader/read-unicode-char",
                                            :removed {:in "0.0-1424",
                                                      :last-seen "0.0-1236"}},
           "cljs.core/dissoc" {:description "dissoc(iate)\n\nReturns a new map that does not contain a mapping for key(s).\n\nHas no effect on the map type (hashed/sorted).",
                               :ns "cljs.core",
                               :name "dissoc",
                               :signature ["[coll]"
                                           "[coll k]"
                                           "[coll k & ks]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/assoc"
                                         "cljs.core/disj"
                                         "cljs.core/select-keys"],
                               :full-name-encode "cljs.core_dissoc",
                               :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-dissoc coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (dissoc coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1383 1395]},
                               :examples [{:id "fd6ae9",
                                           :content "```clj\n(dissoc {:key \"value\" :key2 \"value2\"} :key)\n;;=> {:key2 \"value2\"}\n```"}],
                               :full-name "cljs.core/dissoc",
                               :clj-symbol "clojure.core/dissoc",
                               :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
           "cljs.core/exists?" {:ns "cljs.core",
                                :name "exists?",
                                :type "macro",
                                :signature ["[x]"],
                                :source {:code "(defmacro exists? [x]\n  (bool-expr\n    (core/list 'js* \"typeof ~{} !== 'undefined'\"\n      (vary-meta x assoc :cljs.analyzer/no-resolve true))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [311 314]},
                                :full-name "cljs.core/exists?",
                                :full-name-encode "cljs.core_existsQMARK",
                                :history [["+" "0.0-1798"]]},
           "cljs.core/ffirst" {:description "Same as `(first (first coll))`.",
                               :ns "cljs.core",
                               :name "ffirst",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/first"
                                         "cljs.core/fnext"
                                         "cljs.core/nfirst"],
                               :full-name-encode "cljs.core_ffirst",
                               :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1152 1155]},
                               :examples [{:id "575ba2",
                                           :content "```clj\n(ffirst [[1 2] [3 4] [5 6]])\n;;=> 1\n```"}],
                               :full-name "cljs.core/ffirst",
                               :clj-symbol "clojure.core/ffirst",
                               :docstring "Same as (first (first x))"},
           "clojure.zip/replace" {:ns "clojure.zip",
                                  :name "replace",
                                  :signature ["[loc node]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_replace",
                                  :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [183 187]},
                                  :full-name "clojure.zip/replace",
                                  :clj-symbol "clojure.zip/replace",
                                  :docstring "Replaces the node at this loc, without moving"},
           "cljs.core/vec" {:description "Creates a new vector containing the contents of `coll`",
                            :ns "cljs.core",
                            :name "vec",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/vector"
                                      "cljs.core/vector?"],
                            :full-name-encode "cljs.core_vec",
                            :source {:code "(defn vec [coll]\n  (if (array? coll)\n    (.fromArray PersistentVector coll true)\n    (-persistent!\n      (reduce -conj!\n        (-as-transient (.-EMPTY PersistentVector))\n        coll))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [4478 4484]},
                            :full-name "cljs.core/vec",
                            :clj-symbol "clojure.core/vec"},
           "cljs.core/or" {:description "Evaluates arguments one at a time from left to right. If an argument returns\nlogical true, `or` returns that value and doesn't evaluate any of the other\narguments, otherwise it returns the value of the last argument.\n\n`(or)` returns nil.",
                           :ns "cljs.core",
                           :name "or",
                           :signature ["[]" "[x]" "[x & next]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/and" "special/if"],
                           :full-name-encode "cljs.core_or",
                           :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n    (let [forms (concat [x] next)]\n      (if (every? #(simple-test-expr? &env %)\n            (map #(cljs.analyzer/analyze &env %) forms))\n        (let [or-str (->> (repeat (count forms) \"(~{})\")\n                        (interpose \" || \")\n                        (apply core/str))]\n          (bool-expr `(~'js* ~or-str ~@forms)))\n        `(let [or# ~x]\n           (if or# or# (or ~@next)))))))",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/clj/cljs/core.clj",
                                    :lines [240 256]},
                           :examples [{:id "d50433",
                                       :content "```clj\n(or)\n;;=> nil\n\n(or false)\n;;=> false\n\n(or true)\n;;=> true\n\n(or true true)\n;;=> true\n\n(or true false)\n;;=> true\n\n(or false false)\n;;=> false\n```"}
                                      {:id "62f291",
                                       :content "`nil` and `false` are the only falsy values and everything else is truthy:\n\n```clj\n(or \"foo\" \"bar\")\n;;=> \"bar\"\n\n(or \"foo\" nil)\n;;=> \"foo\"\n\n(or \"foo\" false)\n;;=> \"foo\"\n\n(or nil \"foo\")\n;;=> \"foo\"\n\n(or false \"foo\")\n;;=> \"foo\"\n```"}],
                           :full-name "cljs.core/or",
                           :clj-symbol "clojure.core/or",
                           :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
           "cljs.core/doubles" {:ns "cljs.core",
                                :name "doubles",
                                :signature ["[x]"],
                                :history [["+" "0.0-1798"]],
                                :type "function",
                                :full-name-encode "cljs.core_doubles",
                                :source {:code "(defn doubles [x] x)",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2062]},
                                :full-name "cljs.core/doubles",
                                :clj-symbol "clojure.core/doubles"},
           "cljs.core/mod" {:description "Returns the modulus of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).\n\nTruncates toward negative infinity.",
                            :ns "cljs.core",
                            :name "mod",
                            :signature ["[n d]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/rem"],
                            :full-name-encode "cljs.core_mod",
                            :source {:code "(defn mod\n  [n d]\n  (js-mod (+ (js-mod n d) d) d))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2070 2073]},
                            :examples [{:id "8165e8",
                                        :content "```clj\n(mod -5 3)\n;;=> 1\n\n(mod 5 3)\n;;=> 2\n\n(mod 5 0)\n;;=> NaN\n```"}],
                            :full-name "cljs.core/mod",
                            :clj-symbol "clojure.core/mod",
                            :docstring "Modulus of num and div. Truncates toward negative infinity."},
           "cljs.core/aset" {:description "Sets `val` at index `i` in JavaScript arrays and objects.\n\nCan be used to set nested properties with the additional `idxs` arguments.",
                             :ns "cljs.core",
                             :name "aset",
                             :signature ["[array i val]"
                                         "[array idx idx2 & idxv]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/aget"
                                       "special/set!"
                                       "cljs.core/assoc-in"],
                             :full-name-encode "cljs.core_aset",
                             :source {:code "(defn aset\n  ([array i val]\n    (cljs.core/aset array i val))\n  ([array idx idx2 & idxv]\n    (apply aset (aget array idx) idx2 idxv)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [203 208]},
                             :extra-sources ({:code "(defmacro aset\n  ([a i v]\n    (core/list 'js* \"(~{}[~{}] = ~{})\" a i v))\n  ([a idx idx2 & idxv]\n    (let [n    (core/dec (count idxv))\n          astr (apply core/str (repeat n \"[~{}]\"))]\n      `(~'js* ~(core/str \"(~{}[~{}][~{}]\" astr \" = ~{})\") ~a ~idx ~idx2 ~@idxv))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [347 353]}),
                             :examples [{:id "d1aa58",
                                         :content "```js\n// JavaScript\nvar a = {\"foo\": 3, \"bar\": [4, 5]};\n\na[\"foo\"] = 4;\na;\n//=> {\"foo\": 4, \"bar\": [4, 5]}\n\na[\"bar\"][0] = 6;\na;\n//=> {\"foo\": 4, \"bar\": [6, 5]}\n```\n\n```clj\n;; ClojureScript\n(def a #js {:foo 3, :bar #js [4 5]})\n\n(aset a \"foo\" 4)\na\n;;=> #js {:foo 4, :bar #js [4 5]}\n\n(aset a \"bar\" 0 6)\na\n;;=> #js {:foo 4, :bar #js [6 5]}\n```"}
                                        {:id "34bbf3",
                                         :content "```js\n// JavaScript\ndocument.location.href = \"http://example.com\";\n```\n\n```clj\n;; ClojureScript\n(aset js/document \"location\" \"href\" \"http://example.com\")\n```"}],
                             :full-name "cljs.core/aset",
                             :clj-symbol "clojure.core/aset",
                             :docstring "Sets the value at the index."},
           "cljs.core/second" {:description "Returns the second item in `coll`.\n\nSame as `(first (next coll))`",
                               :ns "cljs.core",
                               :name "second",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/first"
                                         "cljs.core/nth"
                                         "cljs.core/fnext"
                                         "cljs.core/next"],
                               :full-name-encode "cljs.core_second",
                               :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1147 1150]},
                               :full-name "cljs.core/second",
                               :clj-symbol "clojure.core/second",
                               :docstring "Same as (first (next x))"},
           "cljs.core/IChunkedNext" {:ns "cljs.core",
                                     :name "IChunkedNext",
                                     :type "protocol",
                                     :full-name-encode "cljs.core_IChunkedNext",
                                     :source {:code "(defprotocol IChunkedNext\n  (-chunked-next [coll]))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [407 408]},
                                     :methods [{:name "-chunked-next",
                                                :signature ["[coll]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IChunkedNext",
                                     :history [["+" "0.0-1424"]]},
           "cljs.core/bit-count" {:description "Counts the number of bits set in `x`.",
                                  :ns "cljs.core",
                                  :name "bit-count",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_bit-count",
                                  :source {:code "(defn bit-count\n  [v]\n  (let [v (- v (bit-and (bit-shift-right v 1) 0x55555555))\n        v (+ (bit-and v 0x33333333) (bit-and (bit-shift-right v 2) 0x33333333))]\n    (bit-shift-right (* (bit-and (+ v (bit-shift-right v 4)) 0xF0F0F0F) 0x1010101) 24)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2151 2156]},
                                  :examples [{:id "35c78c",
                                              :content "Bits can be entered using radix notation:\n\n```clj\n(bit-count 2r1011)\n;;=> 3\n```\n\nSame number in decimal:\n\n```clj\n(bit-count 11)\n;;=> 3\n```"}],
                                  :full-name "cljs.core/bit-count",
                                  :docstring "Counts the number of bits set in n"},
           "clojure.set/rename" {:ns "clojure.set",
                                 :name "rename",
                                 :signature ["[xrel kmap]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set_rename",
                                 :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [82 85]},
                                 :full-name "clojure.set/rename",
                                 :clj-symbol "clojure.set/rename",
                                 :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/m3-hash-int" {:return-type number,
                                    :ns "cljs.core",
                                    :name "m3-hash-int",
                                    :signature ["[in]"],
                                    :history [["+" "0.0-2261"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_m3-hash-int",
                                    :source {:code "(defn ^number m3-hash-int [in]\n  (if (zero? in)\n    in\n    (let [k1 (m3-mix-K1 in)\n          h1 (m3-mix-H1 m3-seed k1)]\n      (m3-fmix h1 4))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [487 492]},
                                    :full-name "cljs.core/m3-hash-int"},
           "cljs.core/assoc!" {:description "assoc(iate) on transient collection\n\nWhen applied to a transient map, adds mapping of key(s) to val(s).\n\nWhen applied to a transient vector, sets the val at index.  Note - index must\nbe <= (count vector).\n\nReturns coll.",
                               :ns "cljs.core",
                               :name "assoc!",
                               :signature ["[tcoll key val]"
                                           "[tcoll key val & kvs]"],
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :related ["cljs.core/transient"
                                         "cljs.core/persistent!"],
                               :full-name-encode "cljs.core_assocBANG",
                               :source {:code "(defn assoc!\n  ([tcoll key val]\n    (-assoc! tcoll key val))\n  ([tcoll key val & kvs]\n    (let [ntcoll (-assoc! tcoll key val)]\n      (if kvs\n        (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n        ntcoll))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2940 2950]},
                               :examples [{:id "7d1e6b",
                                           :content "```clj\n(def tcoll (transient! {}))\n(assoc! tcoll :a 1)\n(assoc! tcoll :b 2)\n\ntcoll\n;;=> #<[object Object]> \n\n(:a tcoll)\n;;=> 1\n\n(:b tcoll)\n;;=> 2\n\n(def a (persistent! tcoll))\n;;=> {:a 1 :b 2}\n```"}],
                               :full-name "cljs.core/assoc!",
                               :clj-symbol "clojure.core/assoc!",
                               :docstring "When applied to a transient map, adds mapping of key(s) to\nval(s). When applied to a transient vector, sets the val at index.\nNote - index must be <= (count vector). Returns coll."},
           "cljs.repl/mapped-line-and-column" {:ns "cljs.repl",
                                               :name "mapped-line-and-column",
                                               :signature ["[source-map line column]"],
                                               :history [["+"
                                                          "0.0-2814"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl_mapped-line-and-column",
                                               :source {:code "(defn mapped-line-and-column\n  [source-map line column]\n  (let [default [line column]]\n    ;; source maps are 0 indexed for lines\n    (if-let [columns (get source-map (dec line))]\n      (vec\n        (map inc\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; the last segment seems most accurate\n            (last\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:line :col])))\n      default)))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/clj/cljs/repl.clj",
                                                        :lines [197
                                                                215]},
                                               :full-name "cljs.repl/mapped-line-and-column",
                                               :docstring "Given a cljs.source-map source map data structure map a generated line\nand column back to the original line and column."},
           "cljs.test/get-and-clear-env!" {:ns "cljs.test",
                                           :name "get-and-clear-env!",
                                           :type "function",
                                           :signature ["[]"],
                                           :source {:code "(defn get-and-clear-env! []\n  \"Like get-current-env, but cleans env before returning.\"\n  (let [env (cljs.test/get-current-env)]\n    (clear-env!)\n    env))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/test.cljs",
                                                    :lines [273 277]},
                                           :full-name "cljs.test/get-and-clear-env!",
                                           :full-name-encode "cljs.test_get-and-clear-envBANG",
                                           :history [["+" "0.0-2814"]]},
           "cljs.core/delay?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "delay?",
                               :signature ["[x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_delayQMARK",
                               :source {:code "(defn ^boolean delay?\n  [x] (instance? Delay x))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8545 8547]},
                               :full-name "cljs.core/delay?",
                               :clj-symbol "clojure.core/delay?",
                               :docstring "returns true if x is a Delay created with delay"},
           "clojure.zip/left" {:ns "clojure.zip",
                               :name "left",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip_left",
                               :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [150 155]},
                               :full-name "clojure.zip/left",
                               :clj-symbol "clojure.zip/left",
                               :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
           "cljs.reader/not-implemented" {:ns "cljs.reader",
                                          :name "not-implemented",
                                          :type "function",
                                          :signature ["[rdr ch]"],
                                          :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [244 246]},
                                          :full-name "cljs.reader/not-implemented",
                                          :full-name-encode "cljs.reader_not-implemented",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/IAssociative" {:ns "cljs.core",
                                     :name "IAssociative",
                                     :history [["+" "0.0-927"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core_IAssociative",
                                     :source {:code "(defprotocol IAssociative\n  (^boolean -contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (^clj -assoc [coll k v]))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [289 292]},
                                     :methods [{:name "-contains-key?",
                                                :signature ["[coll k]"],
                                                :docstring nil}
                                               {:name "-assoc",
                                                :signature ["[coll k v]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IAssociative",
                                     :clj-symbol "clojure.lang/Associative"},
           "cljs.core/ObjMap.EMPTY" {:ns "cljs.core",
                                     :name "ObjMap.EMPTY",
                                     :type "var",
                                     :parent-type "ObjMap",
                                     :source {:code "(set! (.-EMPTY ObjMap) (ObjMap. nil (array) (js-obj) 0 empty-unordered-hash))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [5154]},
                                     :full-name "cljs.core/ObjMap.EMPTY",
                                     :full-name-encode "cljs.core_ObjMapDOTEMPTY",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/group-by" {:description "Returns a map of the elements of `coll` keyed by the result of running `f` on\neach element.\n\nThe value at each key will be a vector of the corresponding elements in the\norder they appeared in `coll`.",
                                 :ns "cljs.core",
                                 :name "group-by",
                                 :signature ["[f coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/partition-by"
                                           "cljs.core/frequencies"],
                                 :full-name-encode "cljs.core_group-by",
                                 :source {:code "(defn group-by\n  [f coll]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8754 8764]},
                                 :full-name "cljs.core/group-by",
                                 :clj-symbol "clojure.core/group-by",
                                 :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
           "special/case*" {:ns "special",
                            :name "case*",
                            :type "special form",
                            :source {:code "(defmethod parse 'case*\n  [op env [_ sym tests thens default :as form] name _]\n  (assert (symbol? sym) \"case* must switch on symbol\")\n  (assert (every? vector? tests) \"case* tests must be grouped in vectors\")\n  (let [expr-env (assoc env :context :expr)\n        v        (disallowing-recur (analyze expr-env sym))\n        tests    (mapv #(mapv (fn [t] (analyze expr-env t)) %) tests)\n        thens    (mapv #(analyze env %) thens)\n        default  (analyze env default)]\n    (assert (every? (fn [t] (and (= :constant (:op t))\n                              ((some-fn number? string? char?) (:form t))))\n              (apply concat tests))\n      \"case* tests must be numbers or strings\")\n    {:env env :op :case* :form form\n     :v v :tests tests :thens thens :default default\n     :children (vec (concat [v] tests thens (if default [default])))}))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [582 597]},
                            :full-name "special/case*",
                            :full-name-encode "special_caseSTAR",
                            :history [["+" "0.0-2227"]]},
           "cljs.reader/*default-data-reader-fn*" {:ns "cljs.reader",
                                                   :name "*default-data-reader-fn*",
                                                   :type "dynamic var",
                                                   :source {:code "(def ^:dynamic *default-data-reader-fn*\n  (atom nil))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [573
                                                                    574]},
                                                   :full-name "cljs.reader/*default-data-reader-fn*",
                                                   :full-name-encode "cljs.reader_STARdefault-data-reader-fnSTAR",
                                                   :history [["+"
                                                              "0.0-1576"]]},
           "cljs.core/*e" {:description "Only usable from a REPL.\n\nHolds the result of the last exception.",
                           :ns "cljs.core",
                           :name "*e",
                           :history [["+" "0.0-2814"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*2"
                                     "cljs.core/*3"],
                           :full-name-encode "cljs.core_STARe",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent exception caught by the repl\"}\n  *e)",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [71 73]},
                           :examples [{:id "bea858",
                                       :content "```clj\n(defn cause-error []\n  (throw \"Error: something went wrong\"))\n\n(cause-error)\n;; Error: something went wrong\n\n*e\n;;=> \"Error: something went wrong\"\n```"}],
                           :full-name "cljs.core/*e",
                           :clj-symbol "clojure.core/*e",
                           :docstring "bound in a repl thread to the most recent exception caught by the repl"},
           "cljs.core/sorted-map-by" {:description "Returns a new sorted map with supplied mappings, using the supplied comparator\nfunction.\n\n`keyvals` must be an even number of forms.",
                                      :ns "cljs.core",
                                      :name "sorted-map-by",
                                      :signature ["[comparator & keyvals]"],
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :related ["cljs.core/sorted-map"
                                                "cljs.core/subseq"
                                                "cljs.core/rsubseq"
                                                "cljs.core/sorted-set-by"],
                                      :full-name-encode "cljs.core_sorted-map-by",
                                      :source {:code "(defn sorted-map-by\n  ([comparator & keyvals]\n     (loop [in (seq keyvals)\n            out (PersistentTreeMap. (fn->comparator comparator) nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7167 7175]},
                                      :full-name "cljs.core/sorted-map-by",
                                      :clj-symbol "clojure.core/sorted-map-by",
                                      :docstring "keyval => key val\nReturns a new sorted map with supplied mappings, using the supplied comparator."},
           "cljs.core/symbol" {:ns "cljs.core",
                               :name "symbol",
                               :signature ["[name]" "[ns name]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_symbol",
                               :source {:code "(defn symbol\n  ([name]\n     (if (symbol? name)\n       name\n       (symbol nil name)))\n  ([ns name]\n     (let [sym-str (if-not (nil? ns)\n                     (str ns \"/\" name)\n                     name)]\n       (Symbol. ns name sym-str nil nil))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [630 639]},
                               :full-name "cljs.core/symbol",
                               :clj-symbol "clojure.core/symbol"},
           "cljs.core/volatile?" {:ns "cljs.core",
                                  :name "volatile?",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_volatileQMARK",
                                  :source {:code "(defn volatile?\n  [x] (instance? Volatile x))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3613 3615]},
                                  :full-name "cljs.core/volatile?",
                                  :docstring "Returns true if x is a volatile."},
           "cljs.core/Delay" {:ns "cljs.core",
                              :name "Delay",
                              :signature ["[f value]"],
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core_Delay",
                              :source {:code "(deftype Delay [^:mutable f ^:mutable value]\n  IDeref\n  (-deref [_]\n    (when f\n      (set! value (f))\n      (set! f nil))\n    value)\n\n  IPending\n  (-realized? [d]\n    (not f)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8533 8543]},
                              :full-name "cljs.core/Delay",
                              :clj-symbol "clojure.lang/Delay"},
           "cljs.core/methods" {:ns "cljs.core",
                                :name "methods",
                                :signature ["[multifn]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_methods",
                                :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [9145 9147]},
                                :full-name "cljs.core/methods",
                                :clj-symbol "clojure.core/methods",
                                :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
           "cljs.test/test-vars" {:ns "cljs.test",
                                  :name "test-vars",
                                  :signature ["[vars]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test_test-vars",
                                  :source {:code "(defn test-vars\n  [vars]\n  (run-block (test-vars-block vars)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/test.cljs",
                                           :lines [556 561]},
                                  :full-name "cljs.test/test-vars",
                                  :clj-symbol "clojure.test/test-vars",
                                  :docstring "Groups vars by their namespace and runs test-vars on them with\nappropriate fixtures assuming they are present in the current\ntesting environment."},
           "cljs.core/lazy-cat" {:description "Expands to code which yields a lazy sequence of the concatenation of the\nsupplied collections. Each collections expression is not evaluated until it is\nneeded.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><code>(lazy-cat x y z)</code>\n      <td><pre>\n(concat (lazy-seq x)\n        (lazy-seq y)\n        (lazy-seq z))</pre></td></tr></tbody></table>",
                                 :ns "cljs.core",
                                 :name "lazy-cat",
                                 :signature ["[& colls]"],
                                 :history [["+" "0.0-1803"]],
                                 :type "macro",
                                 :related ["cljs.core/lazy-seq"
                                           "cljs.core/concat"],
                                 :full-name-encode "cljs.core_lazy-cat",
                                 :source {:code "(defmacro lazy-cat\n  [& colls]\n  `(concat ~@(map #(core/list `lazy-seq %) colls)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1658 1665]},
                                 :full-name "cljs.core/lazy-cat",
                                 :clj-symbol "clojure.core/lazy-cat",
                                 :docstring "Expands to code which yields a lazy sequence of the concatenation\nof the supplied colls.  Each coll expr is not evaluated until it is\nneeded. \n\n(lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"},
           "cljs.core/vector" {:description "Creates a new vector containing `args`.",
                               :ns "cljs.core",
                               :name "vector",
                               :signature ["[& args]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/vec"
                                         "cljs.core/vector?"
                                         "cljs.core/pop"
                                         "cljs.core/into"],
                               :full-name-encode "cljs.core_vector",
                               :source {:code "(defn vector [& args]\n  (if (and (instance? IndexedSeq args) (zero? (.-i args)))\n    (.fromArray PersistentVector (.-arr args) true)\n    (vec args)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4486 4489]},
                               :extra-sources ({:code "(defmacro vector\n  ([] '(.-EMPTY cljs.core/PersistentVector))\n  ([& xs]\n    (let [cnt (count xs)]\n      (if (core/< cnt 32)\n        `(cljs.core/PersistentVector. nil ~cnt 5\n           (.-EMPTY-NODE cljs.core/PersistentVector) (array ~@xs) nil)\n        (vary-meta\n          `(.fromArray cljs.core/PersistentVector (array ~@xs) true)\n          assoc :tag 'cljs.core/PersistentVector)))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [1419 1428]}),
                               :full-name "cljs.core/vector",
                               :clj-symbol "clojure.core/vector"},
           "cljs.core/rand-int" {:description "Returns a random integer between 0 inclusive and `n` exclusive.",
                                 :ns "cljs.core",
                                 :name "rand-int",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/rand"],
                                 :full-name-encode "cljs.core_rand-int",
                                 :source {:code "(defn rand-int\n  [n] (Math/floor (* (Math/random) n)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8743 8745]},
                                 :full-name "cljs.core/rand-int",
                                 :clj-symbol "clojure.core/rand-int",
                                 :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
           "cljs.core/m3-seed" {:ns "cljs.core",
                                :name "m3-seed",
                                :type "var",
                                :source {:code "(def m3-seed 0)",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [468]},
                                :full-name "cljs.core/m3-seed",
                                :full-name-encode "cljs.core_m3-seed",
                                :history [["+" "0.0-2261"]]},
           "cljs.core/PersistentQueue.EMPTY" {:ns "cljs.core",
                                              :name "PersistentQueue.EMPTY",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :parent-type "PersistentQueue",
                                              :type "var",
                                              :full-name-encode "cljs.core_PersistentQueueDOTEMPTY",
                                              :source {:code "(set! (.-EMPTY PersistentQueue) (PersistentQueue. nil 0 nil [] empty-ordered-hash))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [4977]},
                                              :full-name "cljs.core/PersistentQueue.EMPTY",
                                              :clj-symbol "clojure.lang/PersistentQueue.EMPTY"},
           "cljs.core/unchecked-float" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-float",
                                        :signature ["[x]"],
                                        :history [["+" "0.0-1798"]],
                                        :type "function",
                                        :full-name-encode "cljs.core_unchecked-float",
                                        :source {:code "(defn ^number unchecked-float [x] x)",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [1956]},
                                        :extra-sources ({:code "(defmacro unchecked-float [x] x)",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [369]}),
                                        :full-name "cljs.core/unchecked-float",
                                        :clj-symbol "clojure.core/unchecked-float"},
           "clojure.core.reducers/append!" {:ns "clojure.core.reducers",
                                            :name "append!",
                                            :signature ["[acc x]"],
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers_appendBANG",
                                            :source {:code "(defn append!\n  [acc x]\n  (doto acc (.push x)))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [232 235]},
                                            :full-name "clojure.core.reducers/append!",
                                            :clj-symbol "clojure.core.reducers/append!",
                                            :docstring ".adds x to acc and returns acc"},
           "syntax/js-literal" {:description "Create a literal JavaScript object or array.  Data in the form of a map `{}` or\nvector `[]` must follow the `#js` tag, which will be converted at compile-time\nto a JavaScript object or array, respectively.\n\nThis will not implicitly convert nested data into JavaScript objects or arrays.",
                                :ns "syntax",
                                :name "js-literal",
                                :history [["+" "0.0-2120"]],
                                :type "tagged literal",
                                :related ["cljs.core/js-obj"
                                          "cljs.core/array"
                                          "cljs.core/clj->js"],
                                :full-name-encode "syntax_js-literal",
                                :source {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/tagged_literals.clj",
                                         :lines [44 48]},
                                :extra-sources [{:code "(defn read-js\n  [form]\n  (when-not (or (vector? form) (map? form))\n    (throw (RuntimeException. \"JavaScript literal must use map or vector notation\")))\n  (when-not (or (not (map? form))\n                (every? valid-js-literal-key? (keys form)))\n    (throw (RuntimeException. \"JavaScript literal keys must be strings or unqualified keywords\")))\n  (JSValue. form))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/tagged_literals.clj",
                                                 :lines [35 42]}],
                                :syntax-form ["#js {}" "#js []"],
                                :examples [{:id "05e121",
                                            :content "```clj\n#js {:foo 1 bar 2}\n;;=> #js {:foo 1, :bar 2}\n\n#js [1 2 3]\n;;=> #js [1 2 3]\n```\n\nFor readability, it is sometimes preferable to use `clj->js` rather than nested\n`#js` tags.\n\n```clj\n#js {:foo #js {:bar 1}}\n;;=> #js {:foo #js {:bar 1}}\n\n(clj->js {:foo {:bar 1}})\n;;=> #js {:foo #js {:bar 1}}\n```"}],
                                :full-name "syntax/js-literal"},
           "cljs.core/NodeSeq" {:ns "cljs.core",
                                :name "NodeSeq",
                                :signature ["[meta nodes i s __hash]"],
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core_NodeSeq",
                                :source {:code "(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (NodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      [(aget nodes i) (aget nodes (inc i))]\n      (first s)))\n\n  (-rest [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6088 6130]},
                                :full-name "cljs.core/NodeSeq",
                                :clj-symbol "clojure.lang/NodeSeq"},
           "cljs.core/letfn" {:description "Takes a vector of function definitions `fnspecs` and binds the functions to\ntheir names. All of the names are available in all of the definitions of the\nfunctions as well as `body`.\n\n`fnspecs` must be a vector with an even number of forms. See `let`.\n\n`letfn` is a wrapper over one of ClojureScript's [special forms].\n\n[special forms]:http://clojure.org/special_forms",
                              :ns "cljs.core",
                              :name "letfn",
                              :signature ["[fnspecs & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/let"],
                              :full-name-encode "cljs.core_letfn",
                              :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                       :repo "clojure",
                                       :tag "clojure-1.6.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [6033 6044]},
                              :full-name "cljs.core/letfn",
                              :clj-symbol "clojure.core/letfn",
                              :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
           "cljs.reader/read-discard" {:ns "cljs.reader",
                                       :name "read-discard",
                                       :type "function",
                                       :signature ["[rdr _]"],
                                       :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [389 392]},
                                       :full-name "cljs.reader/read-discard",
                                       :full-name-encode "cljs.reader_read-discard",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl.server/read-headers" {:ns "cljs.repl.server",
                                            :name "read-headers",
                                            :type "function",
                                            :signature ["[rdr]"],
                                            :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr) header-lines []]\n    (if (= \"\" next-line)\n      header-lines ;; we're done reading headers\n      (recur\n        (.readLine rdr)\n        (conj header-lines next-line)))))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/clj/cljs/repl/server.clj",
                                                     :lines [70 76]},
                                            :full-name "cljs.repl.server/read-headers",
                                            :full-name-encode "cljs.repl.server_read-headers",
                                            :history [["+" "0.0-1503"]]},
           "cljs.core/gen-apply-to" {:ns "cljs.core",
                                     :name "gen-apply-to",
                                     :type "macro",
                                     :signature ["[]"],
                                     :source {:code "(defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1638 1646]},
                                     :full-name "cljs.core/gen-apply-to",
                                     :full-name-encode "cljs.core_gen-apply-to",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/inc" {:description "Returns a number one greater than `x`.",
                            :ns "cljs.core",
                            :name "inc",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/dec"],
                            :full-name-encode "cljs.core_inc",
                            :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [888 890]},
                            :extra-sources ({:code "(defmacro ^::ana/numeric inc [x]\n  `(+ ~x 1))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [463 464]}),
                            :full-name "cljs.core/inc",
                            :clj-symbol "clojure.core/inc",
                            :docstring "Returns a number one greater than num."},
           "cljs.core/name" {:description "Returns a string value of a keyword, string, or symbol.\n\n`(name :foo)` => `\"foo\"`\n\n`(name \"foo\")` => `\"foo\"`\n\n`(name 'foo)` => `\"foo\"`",
                             :ns "cljs.core",
                             :name "name",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_name",
                             :source {:code "(defn name\n  [x]\n  (if (implements? INamed x)\n    (-name ^not-native x)\n    (if (string? x)\n      x\n      (throw (js/Error. (str \"Doesn't support name: \" x))))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7667 7674]},
                             :full-name "cljs.core/name",
                             :clj-symbol "clojure.core/name",
                             :docstring "Returns the name String of a string, symbol or keyword."},
           "cljs.test/test-ns-block" {:ns "cljs.test",
                                      :name "test-ns-block",
                                      :signature ["[env [quote ns :as form]]"],
                                      :history [["+" "0.0-2814"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test_test-ns-block",
                                      :source {:code "(defmacro test-ns-block\n  ([env [quote ns :as form]]\n   (assert (and (= quote 'quote) (symbol? ns)) \"Argument to test-ns must be a quoted symbol\")\n   (assert (ana-api/find-ns ns) (str \"Namespace \" ns \" does not exist\"))\n   `[(fn []\n       (cljs.test/set-env! ~env)\n       (cljs.test/do-report {:type :begin-test-ns, :ns ~form})\n       ;; If the namespace has a test-ns-hook function, call that:\n       ~(if-let [v (ana-api/ns-resolve ns 'test-ns-hook)]\n          `(~(symbol (name ns) \"test-ns-hook\"))\n          ;; Otherwise, just test every var in the namespace.\n          `(cljs.test/block (cljs.test/test-all-vars-block ~form))))\n     (fn []\n       (cljs.test/do-report {:type :end-test-ns, :ns ~form}))]))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/test.clj",
                                               :lines [335 350]},
                                      :full-name "cljs.test/test-ns-block",
                                      :docstring "Like test-ns, but returns a block for further composition and\nlater execution.  Does not clear the current env."},
           "cljs.core/cycle" {:description "Returns an infinite lazy sequence of repetitions of the items in `coll`.",
                              :ns "cljs.core",
                              :name "cycle",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/lazy-seq"
                                        "cljs.core/repeatedly"],
                              :full-name-encode "cljs.core_cycle",
                              :source {:code "(defn cycle\n  [coll] (lazy-seq\n          (when-let [s (seq coll)]\n            (concat s (cycle s)))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3870 3874]},
                              :full-name "cljs.core/cycle",
                              :clj-symbol "clojure.core/cycle",
                              :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
           "cljs.core/rsubseq" {:description "`sc` must be a sorted collection.\n\n`test`, `start-test`, `end-test` must be `<`, `<=`, `>` or `>=`.\n\nReturns a reverse sequence of those entries with keys `ek` for which\n`(test (.. sc comparator (compare ek key)) 0)` is true.",
                                :ns "cljs.core",
                                :name "rsubseq",
                                :signature ["[sc test key]"
                                            "[sc start-test start-key end-test end-key]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :related ["cljs.core/subseq"],
                                :full-name-encode "cljs.core_rsubseq",
                                :source {:code "(defn rsubseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{< <=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7784 7797]},
                                :full-name "cljs.core/rsubseq",
                                :clj-symbol "clojure.core/rsubseq",
                                :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a reverse seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/divide" {:ns "cljs.core",
                               :name "divide",
                               :type "macro",
                               :signature ["[x]"
                                           "[x y]"
                                           "[x y & more]"],
                               :source {:code "(defmacro ^::ana/numeric divide\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [430 433]},
                               :full-name "cljs.core/divide",
                               :full-name-encode "cljs.core_divide",
                               :history [["+" "0.0-1798"]]},
           "cljs.core/hash-ordered-coll" {:return-type number,
                                          :ns "cljs.core",
                                          :name "hash-ordered-coll",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-2261"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_hash-ordered-coll",
                                          :source {:code "(defn ^number hash-ordered-coll\n  [coll]\n  (loop [n 0 hash-code 1 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n        (next coll))\n      (mix-collection-hash hash-code n))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [825 834]},
                                          :full-name "cljs.core/hash-ordered-coll",
                                          :clj-symbol "clojure.core/hash-ordered-coll",
                                          :docstring "Returns the hash code, consistent with =, for an external ordered\ncollection implementing Iterable.\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "cljs.core/nil-iter" {:ns "cljs.core",
                                 :name "nil-iter",
                                 :type "function",
                                 :signature ["[]"],
                                 :source {:code "(defn nil-iter []\n  (reify\n    Object\n    (hasNext [_] false)\n    (next [_] (js/Error. \"No such element\"))\n    (remove [_] (js/Error. \"Unsupported operation\"))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3062 3067]},
                                 :full-name "cljs.core/nil-iter",
                                 :full-name-encode "cljs.core_nil-iter",
                                 :history [["+" "0.0-2301"]]},
           "cljs.analyzer.api/all-ns" {:ns "cljs.analyzer.api",
                                       :name "all-ns",
                                       :signature ["[]"],
                                       :history [["+" "0.0-2496"]],
                                       :type "function",
                                       :full-name-encode "cljs.analyzer.api_all-ns",
                                       :source {:code "(defn all-ns\n  []\n  (keys (get @env/*compiler* ::ana/namespaces)))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/analyzer/api.clj",
                                                :lines [24 28]},
                                       :full-name "cljs.analyzer.api/all-ns",
                                       :clj-symbol "clojure.core/all-ns",
                                       :docstring "Return all the namespace analysis maps. Analagous to clojure.core/all-ns but\nreturns analysis maps not Namespace instances."},
           "cljs.test/run-all-tests" {:ns "cljs.test",
                                      :name "run-all-tests",
                                      :signature ["[]" "[re]"],
                                      :history [["+" "0.0-2496"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test_run-all-tests",
                                      :source {:code "(defmacro run-all-tests\n  ([] `(cljs.test/run-all-tests nil))\n  ([re]\n   `(cljs.test/run-tests (cljs.test/empty-env)\n      ~@(map\n          (fn [ns] `(quote ~ns))\n          (cond->> (ana-api/all-ns)\n            re (filter #(re-matches re (name %))))))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/test.clj",
                                               :lines [292 303]},
                                      :full-name "cljs.test/run-all-tests",
                                      :clj-symbol "clojure.test/run-all-tests",
                                      :docstring "Runs all tests in all namespaces; prints results.\nOptional argument is a regular expression; only namespaces with\nnames matching the regular expression (with re-matches) will be\ntested."},
           "cljs.core/map" {:description "Returns a lazy sequence of applying function `f` to every element of `coll`.\n\nWhen more than one collection is provided, returns a lazy sequence consisting of\nthe result of applying `f` to the set of first items of each `c`, followed by\napplying `f` to the set of second items in each `c`, until any one of the `c`s\nis exhausted. Any remaining items in other `c`s are ignored. Function `f` should\naccept number-of-`c`s arguments.\n\nReturns a transducer when no collection is provided.",
                            :ns "cljs.core",
                            :name "map",
                            :signature ["[f]"
                                        "[f coll]"
                                        "[f c1 c2]"
                                        "[f c1 c2 c3]"
                                        "[f c1 c2 c3 & colls]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/map-indexed"
                                      "cljs.core/amap"
                                      "cljs.core/mapcat"
                                      "cljs.core/keep"
                                      "cljs.core/juxt"],
                            :full-name-encode "cljs.core_map",
                            :source {:code "(defn map\n  ([f]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (rf result (f input)))\n        ([result input & inputs]\n           (rf result (apply f input inputs))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (-nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [3736 3781]},
                            :full-name "cljs.core/map",
                            :clj-symbol "clojure.core/map",
                            :docstring "Returns a lazy sequence consisting of the result of applying f to\nthe set of first items of each coll, followed by applying f to the\nset of second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments. Returns a transducer when\nno collection is provided."},
           "cljs.core/ChunkBuffer" {:ns "cljs.core",
                                    :name "ChunkBuffer",
                                    :signature ["[buf end]"],
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core_ChunkBuffer",
                                    :source {:code "(deftype ChunkBuffer [^:mutable buf ^:mutable end]\n  Object\n  (add [_ o]\n    (aset buf end o)\n    (set! end (inc end)))\n\n  (chunk [_ o]\n    (let [ret (ArrayChunk. buf 0 end)]\n      (set! buf nil)\n      ret))\n\n  ICounted\n  (-count [_] end))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2623 2635]},
                                    :full-name "cljs.core/ChunkBuffer",
                                    :clj-symbol "clojure.lang/ChunkBuffer"},
           "cljs.repl/repl-read" {:ns "cljs.repl",
                                  :name "repl-read",
                                  :signature ["[request-prompt request-exit]"
                                              "[request-prompt request-exit opts]"],
                                  :history [["+" "0.0-2719"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl_repl-read",
                                  :source {:code "(defn repl-read\n  ([request-prompt request-exit]\n   (repl-read request-prompt request-exit *repl-opts*))\n  ([request-prompt request-exit opts]\n   (binding [*in* (if (true? (:source-map-inline opts))\n                    ((:reader opts))\n                    *in*)]\n     (or ({:line-start request-prompt :stream-end request-exit}\n          (skip-whitespace *in*))\n        (let [input (reader/read)]\n          (skip-if-eol *in*)\n          input)))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [69 90]},
                                  :full-name "cljs.repl/repl-read",
                                  :docstring "Default :read hook for repl. Reads from *in* which must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF into a single\n\\newline. repl-read:\n  - skips whitespace, then\n    - returns request-prompt on start of line, or\n    - returns request-exit on end of stream, or\n    - reads an object from the input stream, then\n      - skips the next input character if it's end of line, then\n      - returns the object."},
           "syntax/list" {:description "Signifies a literal list.  When evaluated, it is interpreted as a call to some\ncode.  The first argument is called with the subsequent arguments.",
                          :ns "syntax",
                          :name "list",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :related ["syntax/vector" "syntax/quote"],
                          :full-name-encode "syntax_list",
                          :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                   :repo "tools.reader",
                                   :tag "tools.reader-0.8.10",
                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                   :lines [591 610]},
                          :extra-sources [{:code "(defn- read-list\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-list (read-delimited \\) rdr true)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (with-meta (if (empty? the-list)\n                 '()\n                 (clojure.lang.PersistentList/create the-list))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [169 186]}],
                          :syntax-form "()",
                          :examples [{:id "cd26b0",
                                      :content "The following is a list that is evaluated to create var `a`:\n\n```clj\n(def a 1)\n```\n\nAn empty list is unevaluated and left as an empty list:\n\n```clj\n()\n;;=> ()\n```\n\nTo signify an unevaluated list, precede it with a quote:\n\n```clj\n'(1 2 3)\n;;=> (1 2 3)\n```"}],
                          :edn-doc "https://github.com/edn-format/edn#lists",
                          :full-name "syntax/list",
                          :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/amap" {:description "For quickly creating a new JavaScript array by mapping an expression `expr`\nacross a JavaScript array `a`.  The expression can use `ret` as the current\nresult, which is initialized to `a`.  It can also use `idx` to get the current\nindex.",
                             :ns "cljs.core",
                             :name "amap",
                             :signature ["[a idx ret expr]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/map"],
                             :full-name-encode "cljs.core_amap",
                             :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1496 1509]},
                             :examples [{:id "3a7471",
                                         :content "```clj\n(def a #js [1 2 3])\n(amap a i ret (* 10 (aget a i)))\n;;=> #js [10 20 30]\n```"}
                                        {:id "0f57af",
                                         :content "You can also use `ret` inside the mapped expression if you want to use the\ncurrent result:\n\n```clj\n(def a #js [1 2 3])\n(amap a i ret (+ (if (pos? i)\n                   (aget ret (dec i))\n                   0)\n                 (* 10 (aget a i))))\n;;=> #js [10 30 60]\n```"}],
                             :full-name "cljs.core/amap",
                             :clj-symbol "clojure.core/amap",
                             :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting\neach element of ret to the evaluation of expr, returning the new\narray ret."},
           "cljs.repl/repl-caught" {:ns "cljs.repl",
                                    :name "repl-caught",
                                    :type "function",
                                    :signature ["[e repl-env opts]"],
                                    :source {:code "(defn repl-caught [e repl-env opts]\n  (if (and (instance? IExceptionInfo e)\n           (#{:js-eval-error :js-eval-exception} (:type (ex-data e))))\n    (let [{:keys [type repl-env error form js]} (ex-data e)]\n      (case type\n        :js-eval-error\n        (display-error repl-env error form opts)\n\n        :js-eval-exception\n        (display-error repl-env error form\n          (if (:repl-verbose opts)\n            #(prn \"Error evaluating:\" form :as js)\n            (constantly nil))\n          opts)))\n    (binding [*out* *err*]\n      (.printStackTrace e))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [558 573]},
                                    :full-name "cljs.repl/repl-caught",
                                    :full-name-encode "cljs.repl_repl-caught",
                                    :history [["+" "0.0-2911"]]},
           "syntax/uuid-literal" {:ns "syntax",
                                  :name "uuid-literal",
                                  :history [["+" "0.0-1424"]],
                                  :type "tagged literal",
                                  :full-name-encode "syntax_uuid-literal",
                                  :source {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/clj/cljs/tagged_literals.clj",
                                           :lines [44 48]},
                                  :extra-sources [{:code "(defn read-uuid\n  [form]\n  (when-not (string? form)\n    (throw (RuntimeException. \"UUID literal expects a string as its representation.\")))\n  (try\n    (java.util.UUID/fromString form)\n    (catch Throwable e\n      (throw (RuntimeException. (.getMessage e))))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [10 17]}],
                                  :syntax-form "#uuid \"\"",
                                  :edn-doc "https://github.com/edn-format/edn#uuid-f81d4fae-7dec-11d0-a765-00a0c91e6bf6",
                                  :full-name "syntax/uuid-literal",
                                  :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.6.0/src/clj/clojure/core.clj#L6947"},
           "clojure.zip/children" {:ns "clojure.zip",
                                   :name "children",
                                   :signature ["[loc]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip_children",
                                   :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [69 74]},
                                   :full-name "clojure.zip/children",
                                   :clj-symbol "clojure.zip/children",
                                   :docstring "Returns a seq of the children of node at loc, which must be a branch"},
           "special/set!" {:description "Sets `js-var` to `val` using the JavaScript `=` operator.",
                           :ns "special",
                           :name "set!",
                           :signature ["[js-var val]"],
                           :history [["+" "0.0-927"]],
                           :type "special form",
                           :related ["cljs.core/aset"
                                     "cljs.core/reset!"],
                           :full-name-encode "special_setBANG",
                           :source {:code "(defmethod parse 'set!\n  [_ env [_ target val alt :as form] _ _]\n  (let [[target val] (if alt\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n     (let [enve (assoc env :context :expr)\n           targetexpr (cond\n                       ;; TODO: proper resolve\n                       (= target '*unchecked-if*)\n                       (do\n                         (reset! *unchecked-if* val)\n                         ::set-unchecked-if)\n\n                       (symbol? target)\n                       (do\n                         (let [local (-> env :locals target)]\n                           (when-not (or (nil? local)\n                                         (and (:field local)\n                                              (or (:mutable local)\n                                                  (:unsynchronized-mutable local)\n                                                  (:volatile-mutable local))))\n                             (throw (error env \"Can't set! local var or non-mutable field\"))))\n                         (analyze-symbol enve target))\n\n                       :else\n                       (when (seq? target)\n                         (let [targetexpr (analyze-seq enve target nil)]\n                           (when (:field targetexpr)\n                             targetexpr))))\n           valexpr (analyze enve val)]\n       (when-not targetexpr \n         (throw (error env \"set! target must be a field or a symbol naming a var\")))\n       (cond\n        (= targetexpr ::set-unchecked-if) {:env env :op :no-op}\n        :else {:env env :op :set! :form form :target targetexpr :val valexpr\n               :children [targetexpr valexpr]})))))",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [1045 1082]},
                           :full-name "special/set!",
                           :clj-symbol "clojure.core/set!"},
           "cljs.core/when-not" {:description "Evaluates `test`. If logical false, evaluates `body` in an implicit `do`.",
                                 :ns "cljs.core",
                                 :name "when-not",
                                 :signature ["[test & body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/when"
                                           "cljs.core/when-let"
                                           "special/if"],
                                 :full-name-encode "cljs.core_when-not",
                                 :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                          :repo "clojure",
                                          :tag "clojure-1.6.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [477 481]},
                                 :full-name "cljs.core/when-not",
                                 :clj-symbol "clojure.core/when-not",
                                 :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
           "clojure.set/index" {:ns "clojure.set",
                                :name "index",
                                :signature ["[xrel ks]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set_index",
                                :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [87 95]},
                                :full-name "clojure.set/index",
                                :clj-symbol "clojure.set/index",
                                :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
           "cljs.repl.browser/send-and-close" {:ns "cljs.repl.browser",
                                               :name "send-and-close",
                                               :signature ["[conn status form]"
                                                           "[conn status form content-type]"],
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-1503"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser_send-and-close",
                                               :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                        :repo "clojurescript",
                                                        :tag "r1450",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [69 90]},
                                               :full-name "cljs.repl.browser/send-and-close",
                                               :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response.",
                                               :removed {:in "0.0-1503",
                                                         :last-seen "0.0-1450"}},
           "cljs.core/chunked-seq?" {:return-type boolean,
                                     :ns "cljs.core",
                                     :name "chunked-seq?",
                                     :signature ["[x]"],
                                     :history [["+" "0.0-1424"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_chunked-seqQMARK",
                                     :source {:code "(defn ^boolean chunked-seq?\n  [x] (implements? IChunkedSeq x))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1547 1548]},
                                     :full-name "cljs.core/chunked-seq?"},
           "clojure.browser.dom/log" {:ns "clojure.browser.dom",
                                      :name "log",
                                      :type "function",
                                      :signature ["[& args]"],
                                      :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/clojure/browser/dom.cljs",
                                               :lines [20 21]},
                                      :full-name "clojure.browser.dom/log",
                                      :full-name-encode "clojure.browser.dom_log",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.fromArray" {:ns "cljs.core",
                                         :name "Vector.fromArray",
                                         :signature ["[xs]"],
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1798"]],
                                         :parent-type "Vector",
                                         :type "function",
                                         :full-name-encode "cljs.core_VectorDOTfromArray",
                                         :source {:code "(set! cljs.core.Vector/fromArray (fn [xs] (Vector. nil xs nil)))",
                                                  :repo "clojurescript",
                                                  :tag "r1586",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2861]},
                                         :full-name "cljs.core/Vector.fromArray",
                                         :removed {:in "0.0-1798",
                                                   :last-seen "0.0-1586"}},
           "cljs.repl/ns-info" {:ns "cljs.repl",
                                :name "ns-info",
                                :signature ["[f]"],
                                :history [["+" "0.0-2814"]],
                                :type "function",
                                :full-name-encode "cljs.repl_ns-info",
                                :source {:code "(defn ns-info\n  [f]\n  (let [f' (js-src->cljs-src f)]\n    (when (.exists f')\n      (ana/parse-ns f'))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/repl.clj",
                                         :lines [189 195]},
                                :full-name "cljs.repl/ns-info",
                                :docstring "Given a path to a js source file return the ns info for the corresponding\nClojureScript file if it exists."},
           "cljs.core/make-array" {:description "Creates an empty JavaScript array of size `size`.",
                                   :return-type array,
                                   :ns "cljs.core",
                                   :name "make-array",
                                   :signature ["[size]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/aclone"
                                             "cljs.core/array"],
                                   :full-name-encode "cljs.core_make-array",
                                   :source {:code "(defn ^array make-array\n  ([size]\n     (js/Array. size))\n  ([type size]\n     (make-array size)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [167 171]},
                                   :extra-sources ({:code "(defmacro make-array\n  [size]\n  (vary-meta\n    (if (core/number? size)\n      `(array ~@(take size (repeat nil)))\n      `(js/Array. ~size))\n    assoc :tag 'array))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [1406 1412]}),
                                   :full-name "cljs.core/make-array",
                                   :clj-symbol "clojure.core/make-array"},
           "cljs.core/sorted-set-by" {:description "Returns a new sorted set with supplied `keys`, using the supplied `comparator`.",
                                      :ns "cljs.core",
                                      :name "sorted-set-by",
                                      :signature ["[comparator & keys]"],
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :related ["cljs.core/sorted-set"
                                                "cljs.core/sorted-map-by"
                                                "cljs.core/compare"],
                                      :full-name-encode "cljs.core_sorted-set-by",
                                      :source {:code "(defn sorted-set-by\n  ([comparator & keys]\n   (reduce -conj\n           (PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7612 7617]},
                                      :full-name "cljs.core/sorted-set-by",
                                      :clj-symbol "clojure.core/sorted-set-by",
                                      :docstring "Returns a new sorted set with supplied keys, using the supplied comparator."},
           "cljs.repl.node/repl-env" {:ns "cljs.repl.node",
                                      :name "repl-env",
                                      :type "function",
                                      :signature ["[& {:as options}]"],
                                      :source {:code "(defn repl-env\n  [& {:as options}]\n  (repl-env* options))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/clj/cljs/repl/node.clj",
                                               :lines [194 196]},
                                      :full-name "cljs.repl.node/repl-env",
                                      :full-name-encode "cljs.repl.node_repl-env",
                                      :history [["+" "0.0-2629"]]},
           "cljs.core/partition-by" {:description "Applies `f` to each value in `coll`, splitting it each time `f` returns a new\nvalue. Returns a lazy sequence of partitions.\n\nReturns a stateful transducer when no collection is provided.",
                                     :ns "cljs.core",
                                     :name "partition-by",
                                     :signature ["[f]" "[f coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/partition"
                                               "cljs.core/partition-all"
                                               "cljs.core/group-by"],
                                     :full-name-encode "cljs.core_partition-by",
                                     :source {:code "(defn partition-by\n  ([f]\n     (fn [rf]\n       (let [a (array-list)\n             pa (volatile! ::none)]\n         (fn\n           ([] (rf))\n           ([result]\n              (let [result (if (.isEmpty a)\n                             result\n                             (let [v (vec (.toArray a))]\n                               ;;clear first!\n                               (.clear a)\n                               (unreduced (rf result v))))]\n                (rf result)))\n           ([result input]\n              (let [pval @pa\n                    val (f input)]\n                (vreset! pa val)\n                (if (or (keyword-identical? pval ::none)\n                        (= val pval))\n                  (do\n                    (.add a input)\n                    result)\n                  (let [v (vec (.toArray a))]\n                    (.clear a)\n                    (let [ret (rf result v)]\n                      (when-not (reduced? ret)\n                        (.add a input))\n                      ret)))))))))\n  ([f coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [fst (first s)\n               fv (f fst)\n               run (cons fst (take-while #(= fv (f %)) (next s)))]\n           (cons run (partition-by f (seq (drop (count run) s)))))))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [7933 7972]},
                                     :full-name "cljs.core/partition-by",
                                     :clj-symbol "clojure.core/partition-by",
                                     :docstring "Applies f to each value in coll, splitting it each time f returns a\nnew value.  Returns a lazy seq of partitions.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.repl/skip-if-eol" {:ns "cljs.repl",
                                    :name "skip-if-eol",
                                    :signature ["[s]"],
                                    :history [["+" "0.0-2719"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl_skip-if-eol",
                                    :source {:code "(defn skip-if-eol\n  [s]\n  (let [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      (do (readers/unread s c) :body))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [36 48]},
                                    :full-name "cljs.repl/skip-if-eol",
                                    :docstring "If the next character on stream s is a newline, skips it, otherwise\nleaves the stream untouched. Returns :line-start, :stream-end, or :body\nto indicate the relative location of the next character on s. The stream\nmust either be an instance of LineNumberingPushbackReader or duplicate\nits behavior of both supporting .unread and collapsing all of CR, LF, and\nCRLF to a single \\newline."},
           "cljs.core/sort-by" {:description "Returns a sorted sequence of the items in `coll`, where the sort order is\ndetermined by comparing `(keyfn item)`.\n\n`comp` can be boolean-valued comparison function, or a -/0/+ valued comparator.\n\n`comp` defaults to `compare`.",
                                :ns "cljs.core",
                                :name "sort-by",
                                :signature ["[keyfn coll]"
                                            "[keyfn comp coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/sort"
                                          "cljs.core/compare"],
                                :full-name-encode "cljs.core_sort-by",
                                :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1725 1733]},
                                :full-name "cljs.core/sort-by",
                                :clj-symbol "clojure.core/sort-by",
                                :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.core/with-meta" {:description "Returns an object of the same type and value as `obj`, with map `m` as its\nmetadata.",
                                  :ns "cljs.core",
                                  :name "with-meta",
                                  :signature ["[obj m]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/alter-meta!"
                                            "cljs.core/vary-meta"],
                                  :full-name-encode "cljs.core_with-meta",
                                  :source {:code "(defn with-meta\n  [o meta]\n  (if (and (fn? o) (not (satisfies? IWithMeta o)))\n    (MetaFn. o meta)\n    (when-not (nil? o)\n      (-with-meta o meta))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1453 1460]},
                                  :examples [{:id "f189d4",
                                              :content "```clj\n(def a ^:foo [1 2 3])\n(def b (with-meta a {:bar true}))\n\n(= a b)\n;;=> true\n\n(meta a)\n;;=> {:foo true}\n\n(meta b)\n;;=> {:bar true}\n```"}],
                                  :full-name "cljs.core/with-meta",
                                  :clj-symbol "clojure.core/with-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
           "cljs.core/NeverEquiv" {:ns "cljs.core",
                                   :name "NeverEquiv",
                                   :type "type",
                                   :signature ["[]"],
                                   :source {:code "(deftype NeverEquiv []\n  Object\n  (equiv [this other]\n    (-equiv this other))\n  IEquiv\n  (-equiv [o other] false))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [4981 4986]},
                                   :full-name "cljs.core/NeverEquiv",
                                   :full-name-encode "cljs.core_NeverEquiv",
                                   :history [["+" "0.0-927"]]},
           "cljs.analyzer.api/in-cljs-user" {:ns "cljs.analyzer.api",
                                             :name "in-cljs-user",
                                             :signature ["[env & body]"],
                                             :history [["+"
                                                        "0.0-2629"]],
                                             :type "macro",
                                             :full-name-encode "cljs.analyzer.api_in-cljs-user",
                                             :source {:code "(defmacro in-cljs-user\n  [env & body]\n  `(binding [cljs.analyzer/*cljs-ns* 'cljs.user]\n     (cljs.env/with-compiler-env ~env\n       ~@body)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/clj/cljs/analyzer/api.clj",
                                                      :lines [51 57]},
                                             :full-name "cljs.analyzer.api/in-cljs-user",
                                             :docstring "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\nenvironment atom and runs body."},
           "cljs.core/select-keys" {:description "Returns a map containing only those entries in `map` whose key is in `keys`.",
                                    :ns "cljs.core",
                                    :name "select-keys",
                                    :signature ["[map keys]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core_select-keys",
                                    :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        (with-meta ret (meta map)))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7337 7349]},
                                    :full-name "cljs.core/select-keys",
                                    :clj-symbol "clojure.core/select-keys",
                                    :docstring "Returns a map containing only those entries in map whose key is in keys"},
           "special/loop*" {:ns "special",
                            :name "loop*",
                            :type "special form",
                            :source {:code "(defmethod parse 'loop*\n  [op encl-env form _ _]\n  (analyze-let encl-env form true))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [994 996]},
                            :full-name "special/loop*",
                            :full-name-encode "special_loopSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.core/ISeq" {:ns "cljs.core",
                             :name "ISeq",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core_ISeq",
                             :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (^clj -rest [coll]))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [279 281]},
                             :methods [{:name "-first",
                                        :signature ["[coll]"],
                                        :docstring nil}
                                       {:name "-rest",
                                        :signature ["[coll]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISeq",
                             :clj-symbol "clojure.lang/ISeq"},
           "cljs.core/disj!" {:ns "cljs.core",
                              :name "disj!",
                              :signature ["[tcoll val]"
                                          "[tcoll val & vals]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core_disjBANG",
                              :source {:code "(defn disj!\n  ([tcoll val]\n    (-disjoin! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-disjoin! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2968 2977]},
                              :full-name "cljs.core/disj!",
                              :clj-symbol "clojure.core/disj!",
                              :docstring "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.test/try-expr" {:ns "cljs.test",
                                 :name "try-expr",
                                 :signature ["[msg form]"],
                                 :history [["+" "0.0-2496"]],
                                 :type "macro",
                                 :full-name-encode "cljs.test_try-expr",
                                 :source {:code "(defmacro try-expr\n  [msg form]\n  `(try\n     ~(cljs.test/assert-expr &env msg form)\n     (catch :default t#\n       (cljs.test/do-report \n         {:type :error, :message ~msg,\n          :expected '~form, :actual t#}))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/clj/cljs/test.clj",
                                          :lines [135 144]},
                                 :full-name "cljs.test/try-expr",
                                 :clj-symbol "clojure.test/try-expr",
                                 :docstring "Used by the 'is' macro to catch unexpected exceptions.\nYou don't call this."},
           "cljs.core/type->str" {:ns "cljs.core",
                                  :name "type->str",
                                  :type "function",
                                  :signature ["[ty]"],
                                  :source {:code "(defn type->str [ty]\n  (if-let [s (.-cljs$lang$ctorStr ty)]\n    s\n    (str ty)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [150 153]},
                                  :full-name "cljs.core/type->str",
                                  :full-name-encode "cljs.core_type-GTstr",
                                  :history [["+" "0.0-1859"]]},
           "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                            :name "postwalk-replace",
                                            :signature ["[smap form]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.walk_postwalk-replace",
                                            :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/walk.cljs",
                                                     :lines [88 94]},
                                            :full-name "clojure.walk/postwalk-replace",
                                            :clj-symbol "clojure.walk/postwalk-replace",
                                            :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
           "cljs.core/ES6SetEntriesIterator" {:ns "cljs.core",
                                              :name "ES6SetEntriesIterator",
                                              :type "type",
                                              :signature ["[s]"],
                                              :source {:code "(deftype ES6SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [5174
                                                               5181]},
                                              :full-name "cljs.core/ES6SetEntriesIterator",
                                              :full-name-encode "cljs.core_ES6SetEntriesIterator",
                                              :history [["+"
                                                         "0.0-2371"]]},
           "cljs.core/pr-with-opts" {:ns "cljs.core",
                                     :name "pr-with-opts",
                                     :signature ["[objs opts]"],
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_pr-with-opts",
                                     :source {:code "(defn pr-with-opts\n  [objs opts]\n  (doseq [string (pr-seq (first objs) opts)]\n    (string-print string))\n  (doseq [obj (next objs)]\n    (string-print \" \")\n    (doseq [string (pr-seq obj opts)]\n      (string-print string))))",
                                              :repo "clojurescript",
                                              :tag "r1450",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6171 6180]},
                                     :full-name "cljs.core/pr-with-opts",
                                     :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts",
                                     :removed {:in "0.0-1503",
                                               :last-seen "0.0-1450"}},
           "cljs.core/->>" {:description "The thread-last macro \"threads\" an expression through several forms as the last\nitem in a list.\n\nInserts `x` as the last item in the first form, making a list of it if it is not\na list already. If there are more forms, inserts the first form as the last item\nin second form, etc.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(->> x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x y z (d (a b c x)))</pre></td></tr></tbody></table>",
                            :ns "cljs.core",
                            :name "->>",
                            :signature ["[x & forms]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/->"],
                            :full-name-encode "cljs.core_-GTGT",
                            :source {:code "(defmacro ->>\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x))]\n        (recur threaded (next forms)))\n      x)))",
                                     :repo "clojure",
                                     :tag "clojure-1.6.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [1574 1588]},
                            :examples [{:id "1dc72c",
                                        :content "Sequence transformation functions often take a sequence as the last argument,\nthus the thread-last macro is commonly used with them.  Here we compute the sum\nof the first 10 even squares:\n\n```clj\n(->> (range)\n     (map #(* % %))\n     (filter even?)\n     (take 10)\n     (reduce +))\n;;=> 1140\n```\n\nThis expands to:\n\n```clj\n(reduce +\n  (take 10\n    (filter even?\n      (map #(* % %)\n        (range)))))\n;;=> 1140\n```"}],
                            :full-name "cljs.core/->>",
                            :clj-symbol "clojure.core/->>",
                            :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
           "cljs.core/defonce" {:ns "cljs.core",
                                :name "defonce",
                                :signature ["[x init]"],
                                :history [["+" "0.0-2156"]],
                                :type "macro",
                                :full-name-encode "cljs.core_defonce",
                                :source {:code "(defmacro defonce [x init]\n  `(when-not (exists? ~x)\n     (def ~x ~init)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [70 72]},
                                :full-name "cljs.core/defonce",
                                :clj-symbol "clojure.core/defonce"},
           "cljs.core/nil?" {:description "Returns true if `x` is nil, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "nil?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/true?"
                                       "cljs.core/false?"
                                       "cljs.core/identity"],
                             :full-name-encode "cljs.core_nilQMARK",
                             :source {:code "(defn ^boolean nil?\n  [x]\n  (coercive-= x nil))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [89 92]},
                             :extra-sources ({:code "(defmacro nil? [x]\n  `(coercive-= ~x nil))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [258 259]}),
                             :full-name "cljs.core/nil?",
                             :clj-symbol "clojure.core/nil?",
                             :docstring "Returns true if x is nil, false otherwise."},
           "cljs.repl.rhino/bootjs" {:ns "cljs.repl.rhino",
                                     :name "bootjs",
                                     :type "var",
                                     :return-type String,
                                     :source {:code "(def ^String bootjs\n  (str \"var global = this;\"\n       \"goog.require = function(rule){\"\n       \"Packages.clojure.lang.RT[\\\"var\\\"](\\\"cljs.repl.rhino\\\",\\\"goog-require\\\")\"\n       \".invoke(___repl_env, __repl_opts, rule);}\"))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/repl/rhino.clj",
                                              :lines [20 24]},
                                     :full-name "cljs.repl.rhino/bootjs",
                                     :full-name-encode "cljs.repl.rhino_bootjs",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/load-file*" {:ns "cljs.core",
                                   :name "load-file*",
                                   :type "macro",
                                   :signature ["[f]"],
                                   :source {:code "(defmacro load-file* [f]\n  (core/let [{:keys [target output-dir]} (:options @env/*compiler*)]\n    (core/condp = target\n      ;; under Node.js, always relative to JVM working directory\n      :nodejs `(. js/goog (~'nodeGlobalRequire (str ~output-dir ~File/separator ~f)))\n      `(. js/goog (~'importScript_ ~f)))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [1694 1699]},
                                   :full-name "cljs.core/load-file*",
                                   :full-name-encode "cljs.core_load-fileSTAR",
                                   :history [["+" "0.0-2719"]]},
           "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                          :name "stringify-keys",
                                          :signature ["[m]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.walk_stringify-keys",
                                          :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/clojure/walk.cljs",
                                                   :lines [72 78]},
                                          :full-name "clojure.walk/stringify-keys",
                                          :clj-symbol "clojure.walk/stringify-keys",
                                          :docstring "Recursively transforms all map keys from keywords to strings."},
           "clojure.browser.repl/order" {:ns "clojure.browser.repl",
                                         :name "order",
                                         :type "var",
                                         :source {:code "(def order (atom 0))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/clojure/browser/repl.cljs",
                                                  :lines [60]},
                                         :full-name "clojure.browser.repl/order",
                                         :full-name-encode "clojure.browser.repl_order",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/memoize" {:description "Returns a memoized version of a referentially transparent function.\n\nA memoized version of a function keeps a cache of the mappings from arguments to\nresults in memory. When calls with the same arguments are repeated often, a\nmemoized function has higher performance at the expense of higher memory usage.",
                                :ns "cljs.core",
                                :name "memoize",
                                :signature ["[f]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_memoize",
                                :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (let [v (get @mem args lookup-sentinel)]\n        (if (identical? v lookup-sentinel)\n          (let [ret (apply f args)]\n            (swap! mem assoc args ret)\n            ret)\n          v)))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8706 8719]},
                                :full-name "cljs.core/memoize",
                                :clj-symbol "clojure.core/memoize",
                                :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
           "cljs.core/pr-sequential" {:ns "cljs.core",
                                      :name "pr-sequential",
                                      :signature ["[print-one begin sep end opts coll]"],
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core_pr-sequential",
                                      :source {:code "(defn ^:deprecated pr-sequential\n  [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6210 6217]},
                                      :full-name "cljs.core/pr-sequential",
                                      :docstring "Do not use this.  It is kept for backwards compatibility with the\nold IPrintable protocol.",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "clojure.zip/make-node" {:ns "clojure.zip",
                                    :name "make-node",
                                    :signature ["[loc node children]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip_make-node",
                                    :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [76 80]},
                                    :full-name "clojure.zip/make-node",
                                    :clj-symbol "clojure.zip/make-node",
                                    :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
           "syntax/deref" {:description "Used to dereference a reference value (e.g. an atom).  Expands to `(deref ...)`.\n\n`@foo` = `(deref foo)`",
                           :ns "syntax",
                           :name "deref",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["cljs.core/deref"],
                           :full-name-encode "syntax_deref",
                           :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                    :repo "tools.reader",
                                    :tag "tools.reader-0.8.10",
                                    :filename "src/main/clojure/clojure/tools/reader.clj",
                                    :lines [591 610]},
                           :extra-sources [{:code "(defn- wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.10",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [335 338]}],
                           :syntax-form "@",
                           :examples [{:id "08f886",
                                       :content "```clj\n(def a (atom 1))\n@a\n;;=> 1\n\n(deref a)\n;;=> 1\n```"}],
                           :full-name "syntax/deref",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/PersistentVector.EMPTY" {:ns "cljs.core",
                                               :name "PersistentVector.EMPTY",
                                               :history [["+"
                                                          "0.0-1006"]],
                                               :parent-type "PersistentVector",
                                               :type "var",
                                               :full-name-encode "cljs.core_PersistentVectorDOTEMPTY",
                                               :source {:code "(set! (.-EMPTY PersistentVector)\n  (PersistentVector. nil 0 5 (.-EMPTY-NODE PersistentVector) (array) empty-ordered-hash))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [4460
                                                                4461]},
                                               :full-name "cljs.core/PersistentVector.EMPTY",
                                               :clj-symbol "clojure.lang/PersistentVector.EMPTY"},
           "specialrepl/load-namespace" {:description "Only usable from a REPL.\n\nLoad a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once\nand only once.",
                                         :ns "specialrepl",
                                         :name "load-namespace",
                                         :signature ["[name]"],
                                         :history [["+" "0.0-927"]],
                                         :type "special form (repl)",
                                         :full-name-encode "specialrepl_load-namespace",
                                         :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n        (when-not (and (= quote 'quote) (symbol? ns-name))\n          (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n        (when-not (ana/get-namespace ns-name)\n          (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n          (-evaluate repl-env \"<cljs repl>\" 1\n            (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n        (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (let [is-self-require? (self-require? specs)\n              [target-ns restore-ns]\n              (if-not is-self-require?\n                [ana/*cljs-ns* nil]\n                ['cljs.user ana/*cljs-ns*])]\n          (evaluate-form repl-env env \"<cljs repl>\"\n            (with-meta\n              `(~'ns ~target-ns\n                 (:require\n                   ~@(map\n                       (fn [quoted-spec-or-kw]\n                         (if (keyword? quoted-spec-or-kw)\n                           quoted-spec-or-kw\n                           (second quoted-spec-or-kw)))\n                       specs)))\n              {:merge true :line 1 :column 1})\n            identity opts)\n          (when is-self-require?\n            (set! ana/*cljs-ns* restore-ns)))))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n        (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n        (evaluate-form repl-env env \"<cljs repl>\"\n          (with-meta\n            `(~'ns ~ana/*cljs-ns*\n               (:require-macros\n                 ~@(map\n                     (fn [quoted-spec-or-kw]\n                       (if (keyword? quoted-spec-or-kw)\n                         quoted-spec-or-kw\n                         (second quoted-spec-or-kw)))\n                     specs)))\n            {:merge true :line 1 :column 1})\n          identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n        (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n        (load-namespace repl-env ns opts)))}))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl.clj",
                                                  :lines [475 543]},
                                         :examples [{:id "0b1a1d",
                                                     :content "```clj\n(load-namespace 'clojure.set)\n```"}],
                                         :full-name "specialrepl/load-namespace"},
           "cljs.reader/float-pattern" {:ns "cljs.reader",
                                        :name "float-pattern",
                                        :type "var",
                                        :source {:code "(def float-pattern (re-pattern \"^([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?$\"))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [100]},
                                        :full-name "cljs.reader/float-pattern",
                                        :full-name-encode "cljs.reader_float-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/ancestors" {:ns "cljs.core",
                                  :name "ancestors",
                                  :signature ["[tag]" "[h tag]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_ancestors",
                                  :source {:code "(defn ancestors\n  ([tag] (ancestors @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8808 8814]},
                                  :full-name "cljs.core/ancestors",
                                  :clj-symbol "clojure.core/ancestors",
                                  :docstring "Returns the immediate and indirect parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/integer?" {:description "Returns true if `n` is an integer, false otherwise.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "integer?",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/int"],
                                 :full-name-encode "cljs.core_integerQMARK",
                                 :source {:code "(defn ^boolean integer?\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (== (js/parseFloat n) (js/parseInt n 10))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1614 1620]},
                                 :full-name "cljs.core/integer?",
                                 :clj-symbol "clojure.core/integer?",
                                 :docstring "Returns true if n is an integer."},
           "cljs.core/HashMap.EMPTY" {:ns "cljs.core",
                                      :name "HashMap.EMPTY",
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :parent-type "HashMap",
                                      :type "var",
                                      :full-name-encode "cljs.core_HashMapDOTEMPTY",
                                      :source {:code "(set! cljs.core.HashMap/EMPTY (HashMap. nil 0 (js-obj) 0))",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3830]},
                                      :full-name "cljs.core/HashMap.EMPTY",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "cljs.core/Vector.EMPTY" {:ns "cljs.core",
                                     :name "Vector.EMPTY",
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1798"]],
                                     :parent-type "Vector",
                                     :type "var",
                                     :full-name-encode "cljs.core_VectorDOTEMPTY",
                                     :source {:code "(set! cljs.core.Vector/EMPTY (Vector. nil (array) 0))",
                                              :repo "clojurescript",
                                              :tag "r1586",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2859]},
                                     :full-name "cljs.core/Vector.EMPTY",
                                     :removed {:in "0.0-1798",
                                               :last-seen "0.0-1586"}},
           "clojure.zip/xml-zip" {:ns "clojure.zip",
                                  :name "xml-zip",
                                  :signature ["[root]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip_xml-zip",
                                  :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [50 58]},
                                  :full-name "clojure.zip/xml-zip",
                                  :clj-symbol "clojure.zip/xml-zip",
                                  :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
           "clojure.walk/walk" {:ns "clojure.walk",
                                :name "walk",
                                :signature ["[inner outer form]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.walk_walk",
                                :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/clojure/walk.cljs",
                                         :lines [37 48]},
                                :full-name "clojure.walk/walk",
                                :clj-symbol "clojure.walk/walk",
                                :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/ifn?" {:description "Returns true if `f` implements the `IFn` protocol, false otherwise.\n\nFunctions, keywords, map, sets, and vectors can be called as functions.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "ifn?",
                             :signature ["[f]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/fn?"],
                             :full-name-encode "cljs.core_ifnQMARK",
                             :source {:code "(defn ^boolean ifn? [f]\n  (or (fn? f) (satisfies? IFn f)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1611 1612]},
                             :full-name "cljs.core/ifn?",
                             :clj-symbol "clojure.core/ifn?"},
           "cljs.core/bit-xor" {:description "Bitwise \"exclusive or\". Same as `x ^ y` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-xor",
                                :signature ["[x y]" "[x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/bit-and"
                                          "cljs.core/bit-or"],
                                :full-name-encode "cljs.core_bit-xor",
                                :source {:code "(defn bit-xor\n  ([x y] (cljs.core/bit-xor x y))\n  ([x y & more]\n     (reduce bit-xor (cljs.core/bit-xor x y) more)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2087 2091]},
                                :extra-sources ({:code "(defmacro ^::ana/numeric bit-xor\n  ([x y] (core/list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [509 511]}),
                                :examples [{:id "3ccd99",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-xor 2r1100 2r1010)\n;;=> 6\n;; 6 = 2r0110\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-xor 12 10)\n;;=> 6\n```"}],
                                :full-name "cljs.core/bit-xor",
                                :clj-symbol "clojure.core/bit-xor",
                                :docstring "Bitwise exclusive or"},
           "clojure.set/union" {:description "Return a set that is the union of the input sets.",
                                :ns "clojure.set",
                                :name "union",
                                :signature ["[]"
                                            "[s1]"
                                            "[s1 s2]"
                                            "[s1 s2 & sets]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["clojure.set/intersection"
                                          "clojure.set/difference"
                                          "clojure.set/superset?"],
                                :full-name-encode "clojure.set_union",
                                :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [19 29]},
                                :full-name "clojure.set/union",
                                :clj-symbol "clojure.set/union",
                                :docstring "Return a set that is the union of the input sets"},
           "cljs.core/case" {:description "Takes an expression and a set of clauses. Each clause can take the form of\neither:\n\n`test-constant result-expr`\n\n`(test-constant1 ... test-constantN)  result-expr`\n\nThe test-constants are not evaluated. They must be compile-time literals, and\nneed not be quoted. If the expression is equal to a test-constant, the\ncorresponding `result-expr` is returned. A single default expression can follow\nthe clauses, and its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an Error is thrown.\n\nUnlike `cond` and `condp`, `case` does a constant-time dispatch, the clauses are\nnot considered sequentially. All manner of constant expressions are acceptable\nin `case`, including numbers, strings, symbols, keywords, and ClojureScript\ncomposites thereof. Note that since lists are used to group multiple constants\nthat map to the same expression, a vector can be used to match a list if needed.\nThe test-constants need not be all of the same type.",
                             :ns "cljs.core",
                             :name "case",
                             :signature ["[e & clauses]"],
                             :history [["+" "0.0-1211"]],
                             :type "macro",
                             :related ["cljs.core/cond"
                                       "cljs.core/condp"],
                             :full-name-encode "cljs.core_case",
                             :source {:code "(defmacro case [e & clauses]\n  (core/let [default (if (odd? (count clauses))\n                       (last clauses)\n                       `(throw\n                          (js/Error.\n                            (core/str \"No matching clause: \" ~e))))\n             env     &env\n             pairs   (reduce\n                       (fn [m [test expr]]\n                         (core/cond\n                           (seq? test)\n                           (reduce\n                             (fn [m test]\n                               (let [test (if (core/symbol? test)\n                                            (core/list 'quote test)\n                                            test)]\n                                 (assoc-test m test expr env)))\n                             m test)\n                           (core/symbol? test)\n                           (assoc-test m (core/list 'quote test) expr env)\n                           :else\n                           (assoc-test m test expr env)))\n                     {} (partition 2 clauses))\n             esym    (gensym)\n             tests   (keys pairs)]\n    (cond\n      (every? (some-fn core/number? core/string? core/char?) tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 tests      (mapv #(if (seq? %) (vec %) [%]) (take-nth 2 no-default))\n                 thens      (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e] (case* ~esym ~tests ~thens ~default)))\n\n      (every? core/keyword? tests)\n      (let [tests (->> tests\n                       (map #(.substring (core/str %) 1))\n                       vec\n                       (mapv #(if (seq? %) (vec %) [%])))\n            thens (vec (vals pairs))]\n        `(let [~esym (if (keyword? ~e) (.-fqn ~e) nil)]\n           (case* ~esym ~tests ~thens ~default)))\n      \n      ;; equality\n      :else\n      `(let [~esym ~e]\n         (cond\n           ~@(mapcat (fn [[m c]] `((cljs.core/= ~m ~esym) ~c)) pairs)\n           :else ~default)))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1192 1238]},
                             :examples [{:id "09a90c",
                                         :content "```clj\n(def a 1)\n(def b 2)\n\n(case a\n  0 \"zero\"\n  1 \"one\"\n  \"default\")\n;;=> \"one\"\n\n(case b\n  0 \"zero\"\n  1 \"one\"\n  \"default\")\n;;=> \"default\"\n\n(case b\n  0 \"zero\"\n  1 \"one\")\n;; Error: No matching clause: 2\n```"}],
                             :full-name "cljs.core/case",
                             :clj-symbol "clojure.core/case"},
           "cljs.repl/IJavaScriptEnv" {:ns "cljs.repl",
                                       :name "IJavaScriptEnv",
                                       :type "protocol",
                                       :full-name-encode "cljs.repl_IJavaScriptEnv",
                                       :source {:code "(defprotocol IJavaScriptEnv\n  (-setup [repl-env opts] \"initialize the environment\")\n  (-evaluate [repl-env filename line js] \"evaluate a javascript string\")\n  (-load [repl-env provides url] \"load code at url into the environment\")\n  (-tear-down [repl-env] \"dispose of the environment\"))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [98 102]},
                                       :methods [{:name "-setup",
                                                  :signature ["[repl-env opts]"],
                                                  :docstring "initialize the environment"}
                                                 {:name "-evaluate",
                                                  :signature ["[repl-env filename line js]"],
                                                  :docstring "evaluate a javascript string"}
                                                 {:name "-load",
                                                  :signature ["[repl-env provides url]"],
                                                  :docstring "load code at url into the environment"}
                                                 {:name "-tear-down",
                                                  :signature ["[repl-env]"],
                                                  :docstring "dispose of the environment"}],
                                       :full-name "cljs.repl/IJavaScriptEnv",
                                       :history [["+" "0.0-927"]]},
           "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                         :name "PushbackReader",
                                         :type "protocol",
                                         :full-name-encode "cljs.reader_PushbackReader",
                                         :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [13 16]},
                                         :methods [{:name "read-char",
                                                    :signature ["[reader]"],
                                                    :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                   {:name "unread",
                                                    :signature ["[reader ch]"],
                                                    :docstring "Push back a single character on to the stream"}],
                                         :full-name "cljs.reader/PushbackReader",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/isa?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "isa?",
                             :signature ["[child parent]"
                                         "[h child parent]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_isaQMARK",
                             :source {:code "(defn ^boolean isa?\n  ([child parent] (isa? @(get-global-hierarchy) child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (== (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (== i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [8780 8798]},
                             :full-name "cljs.core/isa?",
                             :clj-symbol "clojure.core/isa?",
                             :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a JavaScript type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
           "cljs.pprint/PrettyFlush" {:ns "cljs.pprint",
                                      :name "PrettyFlush",
                                      :type "protocol",
                                      :full-name-encode "cljs.pprint_PrettyFlush",
                                      :source {:code "(defprotocol PrettyFlush (ppflush [this]))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/pprint.cljs",
                                               :lines [120]},
                                      :methods [{:name "ppflush",
                                                 :signature ["[this]"],
                                                 :docstring nil}],
                                      :full-name "cljs.pprint/PrettyFlush",
                                      :history [["+" "0.0-2496"]]},
           "clojure.browser.net/xhr-connection" {:ns "clojure.browser.net",
                                                 :name "xhr-connection",
                                                 :signature ["[]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net_xhr-connection",
                                                 :source {:code "(defn xhr-connection\n  []\n  (XhrIo.))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [81
                                                                  84]},
                                                 :full-name "clojure.browser.net/xhr-connection",
                                                 :docstring "Returns an XhrIo connection"},
           "cljs.core/as->" {:description "Binds `name` to `expr`, evaluates the first form in the lexical context of that\nbinding, then binds `name` to that result, repeating for each successive form,\nreturning the result of the last form.\n\nUseful for when you want a threading macro to use different \"places\" at each\nform.",
                             :ns "cljs.core",
                             :name "as->",
                             :signature ["[expr name & forms]"],
                             :history [["+" "0.0-1798"]],
                             :type "macro",
                             :related ["cljs.core/->"
                                       "cljs.core/->>"
                                       "cljs.core/cond->"
                                       "cljs.core/cond->>"
                                       "cljs.core/some->"
                                       "cljs.core/some->>"],
                             :full-name-encode "cljs.core_as-GT",
                             :source {:code "(defmacro as->\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) forms)]\n     ~name))",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [6913 6921]},
                             :examples [{:id "5e7eef",
                                         :content "```clj\n(as-> [1 2 3 4] x\n  (reduce + x)\n  (/ x 2))\n;;=> 5\n```"}],
                             :full-name "cljs.core/as->",
                             :clj-symbol "clojure.core/as->",
                             :docstring "Binds name to expr, evaluates the first form in the lexical context\nof that binding, then binds name to that result, repeating for each\nsuccessive form, returning the result of the last form."},
           "clojure.core.reducers/reducer" {:ns "clojure.core.reducers",
                                            :name "reducer",
                                            :signature ["[coll xf]"],
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers_reducer",
                                            :source {:code "(defn reducer\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [66 77]},
                                            :full-name "clojure.core.reducers/reducer",
                                            :clj-symbol "clojure.core.reducers/reducer",
                                            :docstring "Given a reducible collection, and a transformation function xf,\nreturns a reducible collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.core/subs" {:description "Returns the substring of `s` beginning at `start` inclusive, and ending at `end`\nexclusive.\n\n`end` defaults to the length of the string.",
                             :ns "cljs.core",
                             :name "subs",
                             :signature ["[s start]" "[s start end]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core_subs",
                             :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2208 2212]},
                             :full-name "cljs.core/subs",
                             :clj-symbol "clojure.core/subs",
                             :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
           "syntax/unquote" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nIntended for use inside a syntax-quote.\n\nForces evaluation of the following form.",
                             :ns "syntax",
                             :name "unquote",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/syntax-quote"
                                       "syntax/unquote-splicing"],
                             :full-name-encode "syntax_unquote",
                             :source {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                      :repo "tools.reader",
                                      :tag "tools.reader-0.8.10",
                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                      :lines [591 610]},
                             :extra-sources [{:code "(defn- read-unquote\n  [rdr comma]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~))))",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [447 452]}],
                             :syntax-form "~",
                             :examples [{:id "1ff51e",
                                         :content "```clj\n(def foo 1)\n`~foo\n;;=> 1\n\n`(def foo ~foo)\n;;=> (def cljs.user/foo 1)\n```"}],
                             :full-name "syntax/unquote",
                             :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/symbol?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "symbol?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_symbolQMARK",
                                :source {:code "(defn ^boolean symbol? [x]\n  (instance? Symbol x))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [576 577]},
                                :extra-sources ({:code "(defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [334 335]}),
                                :full-name "cljs.core/symbol?",
                                :clj-symbol "clojure.core/symbol?"},
           "clojure.data/Diff" {:ns "clojure.data",
                                :name "Diff",
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "clojure.data_Diff",
                                :source {:code "(defprotocol Diff\n  \"Implementation detail. Subject to change.\"\n  (diff-similar [a b] \"Implementation detail. Subject to change.\"))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/clojure/data.cljs",
                                         :lines [79 81]},
                                :methods [{:name "diff-similar",
                                           :signature ["[a b]"],
                                           :docstring "Implementation detail. Subject to change."}],
                                :full-name "clojure.data/Diff",
                                :clj-symbol "clojure.data/Diff",
                                :docstring "Implementation detail. Subject to change."},
           "clojure.string/replace" {:description "Replaces all instance of `match` with `replacement` in `s`.\n\nThe options for match / replacement are:\n\n| match  | replacement |\n|--------|-------------|\n| string | string      |\n| regex  | string      |\n| regex  | function    |",
                                     :ns "clojure.string",
                                     :name "replace",
                                     :signature ["[s match replacement]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/subs"
                                               "clojure.string/split"
                                               "clojure.string/replace-first"],
                                     :full-name-encode "clojure.string_replace",
                                     :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [27 38]},
                                     :full-name "clojure.string/replace",
                                     :clj-symbol "clojure.string/replace",
                                     :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/string?" {:description "Returns true if `x` is a string, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "string?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core_stringQMARK",
                                :source {:code "(defn ^boolean string? [x]\n  (goog/isString x))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [113 114]},
                                :extra-sources ({:code "(defmacro string? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'string'\" x)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [307 308]}),
                                :full-name "cljs.core/string?",
                                :clj-symbol "clojure.core/string?"},
           "cljs.core/partition-all" {:description "Returns a lazy sequence of lists like `partition`, but may include partitions\nwith fewer than `n` items at the end.\n\nReturns a stateful transducer when no collection is provided.",
                                      :ns "cljs.core",
                                      :name "partition-all",
                                      :signature ["[n]"
                                                  "[n coll]"
                                                  "[n step coll]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :related ["cljs.core/partition"
                                                "cljs.core/partition-by"],
                                      :full-name-encode "cljs.core_partition-all",
                                      :source {:code "(defn partition-all\n  ([n]\n   (fn [rf]\n     (let [a (array-list)]\n       (fn\n         ([] (rf))\n         ([result]\n            (let [result (if (.isEmpty a)\n                           result\n                           (let [v (vec (.toArray a))]\n                             ;;clear first!\n                             (.clear a)\n                             (unreduced (rf result v))))]\n              (rf result)))\n         ([result input]\n            (.add a input)\n            (if (== n (.size a))\n              (let [v (vec (.toArray a))]\n                (.clear a)\n                (rf result v))\n              result))))))\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7713 7742]},
                                      :full-name "cljs.core/partition-all",
                                      :clj-symbol "clojure.core/partition-all",
                                      :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.core/Var" {:ns "cljs.core",
                            :name "Var",
                            :signature ["[val sym _meta]"],
                            :history [["+" "0.0-2496"]],
                            :type "type",
                            :full-name-encode "cljs.core_Var",
                            :source {:code "(deftype Var [val sym _meta]\n  IDeref\n  (-deref [_] (val))\n  IMeta\n  (-meta [_] _meta)\n  Fn\n  IFn\n  (-invoke [_]\n    ((val)))\n  (-invoke [_ a]\n    ((val) a))\n  (-invoke [_ a b]\n    ((val) a b))\n  (-invoke [_ a b c]\n    ((val) a b c))\n  (-invoke [_ a b c d]\n    ((val) a b c d))\n  (-invoke [_ a b c d e]\n    ((val) a b c d e))\n  (-invoke [_ a b c d e f]\n    ((val) a b c d e f))\n  (-invoke [_ a b c d e f g]\n    ((val) a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    ((val) a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    ((val) a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    ((val) a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    ((val) a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    ((val) a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    ((val) a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    ((val) a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    ((val) a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    ((val) a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    ((val) a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    ((val) a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    ((val) a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    ((val) a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply (val) a b c d e f g h i j k l m n o p q r s t rest)))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [641 691]},
                            :full-name "cljs.core/Var",
                            :clj-symbol "clojure.lang/Var"},
           "cljs.core/RedNode" {:ns "cljs.core",
                                :name "RedNode",
                                :type "type",
                                :signature ["[key val left right __hash]"],
                                :source {:code "(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. \"red-black tree invariant violation\")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6730 6869]},
                                :full-name "cljs.core/RedNode",
                                :full-name-encode "cljs.core_RedNode",
                                :history [["+" "0.0-1211"]]},
           "cljs.repl/IParseStacktrace" {:ns "cljs.repl",
                                         :name "IParseStacktrace",
                                         :type "protocol",
                                         :full-name-encode "cljs.repl_IParseStacktrace",
                                         :source {:code "(defprotocol IParseStacktrace\n  (-parse-stacktrace [repl-env stacktrace error build-options]\n    \"Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir.\"))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl.clj",
                                                  :lines [109 120]},
                                         :methods [{:name "-parse-stacktrace",
                                                    :signature ["[repl-env stacktrace error build-options]"],
                                                    :docstring "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir."}],
                                         :full-name "cljs.repl/IParseStacktrace",
                                         :history [["+" "0.0-2843"]]},
           "cljs.core/ExceptionInfo" {:ns "cljs.core",
                                      :name "ExceptionInfo",
                                      :signature ["[message data cause]"],
                                      :history [["+" "0.0-1576"]],
                                      :type "type",
                                      :full-name-encode "cljs.core_ExceptionInfo",
                                      :source {:code "(deftype ExceptionInfo [message data cause])",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [9180]},
                                      :full-name "cljs.core/ExceptionInfo",
                                      :clj-symbol "clojure.lang/ExceptionInfo"},
           "cljs.core/merge-with" {:description "Returns a map that consists of the rest of the maps `conj`-ed onto the first.\n\nIf a key occurs in more than one map, the mapping(s) from the latter (left-to-\nright) will be combined with the mapping in the result by calling `(f val-in-\nresult val-in-latter)`.",
                                   :ns "cljs.core",
                                   :name "merge-with",
                                   :signature ["[f & maps]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/merge"],
                                   :full-name-encode "cljs.core_merge-with",
                                   :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7321 7335]},
                                   :full-name "cljs.core/merge-with",
                                   :clj-symbol "clojure.core/merge-with",
                                   :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
           "cljs.core/key" {:description "Returns the key of the map entry.",
                            :ns "cljs.core",
                            :name "key",
                            :signature ["[map-entry]"],
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :related ["cljs.core/keys"],
                            :full-name-encode "cljs.core_key",
                            :source {:code "(defn key\n  [map-entry]\n  (-key map-entry))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [7240 7243]},
                            :full-name "cljs.core/key",
                            :clj-symbol "clojure.core/key",
                            :docstring "Returns the key of the map entry."},
           "clojure.browser.dom/set-properties" {:ns "clojure.browser.dom",
                                                 :name "set-properties",
                                                 :signature ["[e m]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom_set-properties",
                                                 :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (apply gobject/create (interleave (keys m) (vals m)))))",
                                                          :repo "clojurescript",
                                                          :tag "r2911",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [136
                                                                  140]},
                                                 :full-name "clojure.browser.dom/set-properties",
                                                 :docstring "Set properties on an element"},
           "clojure.data/diff" {:ns "clojure.data",
                                :name "diff",
                                :signature ["[a b]"],
                                :history [["+" "0.0-1503"]],
                                :type "function",
                                :full-name-encode "clojure.data_diff",
                                :source {:code "(defn diff\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/clojure/data.cljs",
                                         :lines [144 161]},
                                :full-name "clojure.data/diff",
                                :clj-symbol "clojure.data/diff",
                                :docstring "Recursively compares a and b, returning a tuple of\n[things-only-in-a things-only-in-b things-in-both].\nComparison rules:\n\n* For equal a and b, return [nil nil a].\n* Maps are subdiffed where keys match and values differ.\n* Sets are never subdiffed.\n* All sequential things are treated as associative collections\n  by their indexes, with results returned as vectors.\n* Everything else (including strings!) is treated as\n  an atom and compared for equality."},
           "cljs.core/ITransientAssociative" {:ns "cljs.core",
                                              :name "ITransientAssociative",
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "protocol",
                                              :full-name-encode "cljs.core_ITransientAssociative",
                                              :source {:code "(defprotocol ITransientAssociative\n  (^clj -assoc! [tcoll key val]))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [384
                                                               385]},
                                              :methods [{:name "-assoc!",
                                                         :signature ["[tcoll key val]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/ITransientAssociative",
                                              :clj-symbol "clojure.lang/ITransientAssociative"},
           "cljs.core/trampoline" {:ns "cljs.core",
                                   :name "trampoline",
                                   :signature ["[f]" "[f & args]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core_trampoline",
                                   :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [8721 8735]},
                                   :full-name "cljs.core/trampoline",
                                   :clj-symbol "clojure.core/trampoline",
                                   :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
           "cljs.test/test-ns" {:ns "cljs.test",
                                :name "test-ns",
                                :signature ["[ns]"
                                            "[env [quote ns :as form]]"],
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test_test-ns",
                                :source {:code "(defmacro test-ns\n  ([ns] `(cljs.test/test-ns (cljs.test/empty-env) ~ns))\n  ([env [quote ns :as form]]\n   `(cljs.test/run-block\n     (concat (cljs.test/test-ns-block ~env ~form)\n             [(fn []\n                (cljs.test/clear-env!))]))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/test.clj",
                                         :lines [352 364]},
                                :full-name "cljs.test/test-ns",
                                :clj-symbol "clojure.test/test-ns",
                                :docstring "If the namespace defines a function named test-ns-hook, calls that.\nOtherwise, calls test-all-vars on the namespace.  'ns' is a\nnamespace object or a symbol.\n\nInternally binds *report-counters* to a ref initialized to\n*initial-report-counters*.  "},
           "cljs.core/implements?" {:ns "cljs.core",
                                    :name "implements?",
                                    :signature ["[psym x]"],
                                    :history [["+" "0.0-2014"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core_implementsQMARK",
                                    :source {:code "(defmacro implements?\n  [psym x]\n  (let [p          (:name\n                    (cljs.analyzer/resolve-var\n                      (dissoc &env :locals) psym))\n        prefix     (protocol-prefix p)\n        xsym       (bool-expr (gensym))\n        [part bit] (fast-path-protocols p)\n        msym       (symbol\n                      (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    `(let [~xsym ~x]\n       (if ~xsym\n         (let [bit# ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit))]\n           (if (or bit#\n                 ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             false))\n         false))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [1052 1070]},
                                    :full-name "cljs.core/implements?",
                                    :docstring "EXPERIMENTAL"},
           "cljs.repl.browser/handle-connection" {:ns "cljs.repl.browser",
                                                  :name "handle-connection",
                                                  :signature ["[opts conn]"],
                                                  :history [["+"
                                                             "0.0-927"]
                                                            ["-"
                                                             "0.0-1503"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser_handle-connection",
                                                  :source {:code "(defn handle-connection\n  [opts conn]\n  (let [rdr (BufferedReader. (InputStreamReader. (.getInputStream conn)))]\n    (if-let [request (read-request rdr)]\n      (case (:method request)\n        :get (handle-get opts conn request)\n        :post (handle-post conn (read-string (:content request)))\n        (.close conn))\n      (.close conn))))",
                                                           :repo "clojurescript",
                                                           :tag "r1450",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [248
                                                                   256]},
                                                  :full-name "cljs.repl.browser/handle-connection",
                                                  :removed {:in "0.0-1503",
                                                            :last-seen "0.0-1450"}},
           "clojure.browser.repl/send-print" {:ns "clojure.browser.repl",
                                              :name "send-print",
                                              :signature ["[url data]"
                                                          "[url data n]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl_send-print",
                                              :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [46 58]},
                                              :full-name "clojure.browser.repl/send-print",
                                              :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times."},
           "cljs.core/ICounted" {:ns "cljs.core",
                                 :name "ICounted",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core_ICounted",
                                 :source {:code "(defprotocol ICounted\n  (^number -count [coll] \"constant time count\"))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [262 263]},
                                 :methods [{:name "-count",
                                            :signature ["[coll]"],
                                            :docstring "constant time count"}],
                                 :full-name "cljs.core/ICounted",
                                 :clj-symbol "clojure.lang/Counted"},
           "cljs.core/IEquiv" {:ns "cljs.core",
                               :name "IEquiv",
                               :type "protocol",
                               :full-name-encode "cljs.core_IEquiv",
                               :source {:code "(defprotocol IEquiv\n  (^boolean -equiv [o other]))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [330 331]},
                               :methods [{:name "-equiv",
                                          :signature ["[o other]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IEquiv",
                               :history [["+" "0.0-927"]]},
           "cljs.core/reduce-kv" {:description "Reduces an associative collection.\n\n`f` should be a function of 3 arguments. Returns the result of applying `f` to\n`init`, the first key and the first value in `coll`, then applying `f` to that\nresult and the 2nd key and value, etc.\n\nIf `coll` contains no entries, returns `init` and `f` is not called.\n\nNote that `reduce-kv` is supported on vectors, where the keys will be the\nordinals.",
                                  :ns "cljs.core",
                                  :name "reduce-kv",
                                  :signature ["[f init coll]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :related ["cljs.core/reduce"],
                                  :full-name-encode "cljs.core_reduce-kv",
                                  :source {:code "(defn reduce-kv\n  ([f init coll]\n    (if-not (nil? coll)\n      (-kv-reduce coll f init)\n      init)))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1802 1812]},
                                  :full-name "cljs.core/reduce-kv",
                                  :clj-symbol "clojure.core/reduce-kv",
                                  :docstring "Reduces an associative collection. f should be a function of 3\narguments. Returns the result of applying f to init, the first key\nand the first value in coll, then applying f to that result and the\n2nd key and value, etc. If coll contains no entries, returns init\nand f is not called. Note that reduce-kv is supported on vectors,\nwhere the keys will be the ordinals."},
           "cljs.core/js-delete" {:description "Deletes property `key` in JavaScript object `obj`.\n\nEquivalent to `delete obj[key]` in JavaScript.",
                                  :ns "cljs.core",
                                  :name "js-delete",
                                  :signature ["[obj key]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/dissoc"],
                                  :full-name-encode "cljs.core_js-delete",
                                  :source {:code "(defn js-delete [obj key]\n  (cljs.core/js-delete obj key))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1562 1563]},
                                  :extra-sources ({:code "(defmacro js-delete [obj key]\n  (core/list 'js* \"delete ~{}[~{}]\" obj key))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [287 288]}),
                                  :examples [{:id "5b24ea",
                                              :content "```clj\n(def a #js {:foo 1 :bar 2})\n(js-delete a \"foo\")\n\na\n;;=> #js {:bar 2}\n```"}],
                                  :full-name "cljs.core/js-delete"},
           "syntax/NaN" {:ns "syntax",
                         :name "NaN",
                         :type "special symbol",
                         :full-name-encode "syntax_NaN",
                         :source {:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                  :repo "tools.reader",
                                  :tag "tools.reader-0.8.10",
                                  :filename "src/main/clojure/clojure/tools/reader.clj",
                                  :lines [275 301]},
                         :syntax-form "NaN",
                         :full-name "syntax/NaN",
                         :history [["+" "0.0-1853"]]},
           "cljs.core/PersistentTreeSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentTreeSet",
                                                :type "var",
                                                :full-name-encode "cljs.core_PersistentTreeSetDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentTreeSet)\n  (PersistentTreeSet. nil (.-EMPTY PersistentTreeMap) empty-unordered-hash))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [7575
                                                                 7576]},
                                                :full-name "cljs.core/PersistentTreeSet.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentTreeSet.EMPTY"},
           "cljs.core/comment" {:description "Ignores all `body` forms (i.e. \"commenting out\"). Returns nil.\n\nThis is often used near the bottom of a file to hold expressions that test\ndifferent functions during development.  Specific expressions within the\n`comment` can then be selected and evaluated from some editors.\n\nYou can also use `;` to \"comment out\" code until the end of a line.",
                                :ns "cljs.core",
                                :name "comment",
                                :signature ["[& body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core_comment",
                                :source {:code "(defmacro comment\n  [& body])",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [4341 4344]},
                                :examples [{:id "482fd7",
                                            :content "```clj\n(comment 123)\n;;=> nil\n\n(comment\n  (foo 1 2 3)\n  (bar \"hello\"))\n;;=> nil\n```\n\nInner forms must still be syntactically correct:\n\n```clj\n(comment [1 2 3]])\n;; Error: Unmatched delimiter ]\n\n(comment a : b)\n;; Error: Invalid token :\n```"}],
                                :full-name "cljs.core/comment",
                                :clj-symbol "clojure.core/comment",
                                :docstring "Ignores body, yields nil"},
           "cljs.reader/special-symbols" {:ns "cljs.reader",
                                          :name "special-symbols",
                                          :type "function",
                                          :signature ["[t not-found]"],
                                          :source {:code "(defn special-symbols [t not-found]\n  (cond\n    (identical? t \"nil\") nil\n    (identical? t \"true\") true\n    (identical? t \"false\") false\n    (identical? t \"/\") '/\n    :else not-found))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [319 325]},
                                          :full-name "cljs.reader/special-symbols",
                                          :full-name-encode "cljs.reader_special-symbols",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.node/setup" {:ns "cljs.repl.node",
                                   :name "setup",
                                   :type "function",
                                   :signature ["[repl-env]"
                                               "[repl-env opts]"],
                                   :source {:code "(defn setup\n  ([repl-env] (setup repl-env nil))\n  ([repl-env opts]\n    (let [output-dir (io/file (:output-dir opts))\n          _    (.mkdirs output-dir)\n          of   (io/file output-dir \"node_repl.js\")\n          _   (spit of\n                (string/replace (slurp (io/resource \"cljs/repl/node_repl.js\"))\n                  \"var PORT = 5001;\"\n                  (str \"var PORT = \" (:port repl-env) \";\")))\n          bldr (ProcessBuilder. (into-array [(get opts :node-command \"node\")]))\n          _    (-> bldr\n                 (.redirectInput of)\n                 (.redirectOutput ProcessBuilder$Redirect/INHERIT)\n                 (.redirectError ProcessBuilder$Redirect/INHERIT))\n          proc (.start bldr)\n          env  (ana/empty-env)\n          core (io/resource \"cljs/core.cljs\")\n          ;; represent paths as vectors so we can emit JS arrays, this is to\n          ;; paper over Windows issues with minimum hassle - David\n          path (.getPath (.getCanonicalFile output-dir))\n          [fc & cs] (rest (util/path-seq path)) ;; remove leading empty string\n          root (.substring path 0 (+ (.indexOf path fc) (count fc)))\n          root-path (vec (cons root cs))\n          rewrite-path (conj root-path \"goog\")]\n      (reset! (:proc repl-env) proc)\n      (loop [r nil]\n        (when-not (= r \"ready\")\n          (Thread/sleep 50)\n          (try\n            (reset! (:socket repl-env) (socket (:host repl-env) (:port repl-env)))\n            (catch Exception e))\n          (if @(:socket repl-env)\n            (recur (read-response (:in @(:socket repl-env))))\n            (recur nil))))\n      ;; compile cljs.core & its dependencies, goog/base.js must be available\n      ;; for bootstrap to load, use new closure/compile as it can handle\n      ;; resources in JARs\n      (let [core-js (closure/compile core\n                      (assoc opts\n                        :output-file\n                        (closure/src-file->target-file core)))\n            deps    (closure/add-dependencies opts core-js)]\n        ;; output unoptimized code and the deps file\n        ;; for all compiled namespaces\n        (apply closure/output-unoptimized\n          (assoc opts\n            :output-to (.getPath (io/file output-dir \"node_repl_deps.js\")))\n          deps))\n      ;; bootstrap, replace __dirname as __dirname won't be set\n      ;; properly due to how we are running it - David\n      (node-eval repl-env\n        (-> (slurp (io/resource \"cljs/bootstrap_node.js\"))\n          (string/replace \"path.resolve(__dirname, '..', 'base.js')\"\n            (platform-path (conj rewrite-path \"bootstrap\" \"..\" \"base.js\")))\n          (string/replace\n            \"path.join(\\\".\\\", \\\"..\\\", src)\"\n            (str \"path.join(\" (platform-path rewrite-path) \", src)\"))\n          (string/replace\n            \"var CLJS_ROOT = \\\".\\\";\"\n            (str \"var CLJS_ROOT = \" (platform-path root-path) \";\"))))\n      ;; load the deps file so we can goog.require cljs.core etc.\n      (node-eval repl-env\n        (str \"require(\"\n             (platform-path (conj root-path \"node_repl_deps.js\"))\n             \")\"))\n      ;; monkey-patch isProvided_ to avoid useless warnings - David\n      (node-eval repl-env\n        (str \"goog.isProvided_ = function(x) { return false; };\"))\n      ;; monkey-patch goog.require, skip all the loaded checks\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(set! (.-require js/goog)\n           (fn [name]\n             (js/CLOSURE_IMPORT_SCRIPT\n               (aget (.. js/goog -dependencies_ -nameToPath) name)))))\n      ;; load cljs.core, setup printing\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(do\n           (.require js/goog \"cljs.core\")\n           (enable-console-print!)))\n      ;; redef goog.require to track loaded libs\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(do\n           (set! *loaded-libs* #{\"cljs.core\"})\n           (set! (.-require js/goog)\n             (fn [name reload]\n               (when (or (not (contains? *loaded-libs* name)) reload)\n                 (set! *loaded-libs* (conj (or *loaded-libs* #{}) name))\n                 (js/CLOSURE_IMPORT_SCRIPT\n                   (aget (.. js/goog -dependencies_ -nameToPath) name))))))))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/repl/node.clj",
                                            :lines [80 169]},
                                   :full-name "cljs.repl.node/setup",
                                   :full-name-encode "cljs.repl.node_setup",
                                   :history [["+" "0.0-2629"]]},
           "cljs.core/BitmapIndexedNode.EMPTY" {:ns "cljs.core",
                                                :name "BitmapIndexedNode.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "BitmapIndexedNode",
                                                :type "var",
                                                :full-name-encode "cljs.core_BitmapIndexedNodeDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY BitmapIndexedNode) (BitmapIndexedNode. nil 0 (make-array 0)))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [5851]},
                                                :full-name "cljs.core/BitmapIndexedNode.EMPTY",
                                                :clj-symbol "clojure.lang/BitmapIndexedNode.EMPTY"},
           "cljs.reader/register-default-tag-parser!" {:ns "cljs.reader",
                                                       :name "register-default-tag-parser!",
                                                       :type "function",
                                                       :signature ["[f]"],
                                                       :source {:code "(defn register-default-tag-parser!\n  [f]\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] f))\n    old-parser))",
                                                                :repo "clojurescript",
                                                                :tag "r2911",
                                                                :filename "src/cljs/cljs/reader.cljs",
                                                                :lines [602
                                                                        606]},
                                                       :full-name "cljs.reader/register-default-tag-parser!",
                                                       :full-name-encode "cljs.reader_register-default-tag-parserBANG",
                                                       :history [["+"
                                                                  "0.0-1576"]]},
           "cljs.core/alength" {:description "For interop, it returns the length of a JavaScript array or string.",
                                :return-type number,
                                :ns "cljs.core",
                                :name "alength",
                                :signature ["[a]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/count"],
                                :full-name-encode "cljs.core_alength",
                                :source {:code "(defn ^number alength\n  [array]\n  (cljs.core/alength array))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [210 213]},
                                :extra-sources ({:code "(defmacro alength [a]\n  (vary-meta\n    (core/list 'js* \"~{}.length\" a)\n    assoc :tag 'number))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [1491 1494]}),
                                :examples [{:id "26f79f",
                                            :content "```clj\n(def a #js [1 2 3])\n\n(alength a)\n;;=> 3\n\n(.-length a)\n;;=> 3\n\n(aget a \"length\")\n;;=> 3\n\n(count a)\n;;=> 3\n```"}],
                                :full-name "cljs.core/alength",
                                :clj-symbol "clojure.core/alength",
                                :docstring "Returns the length of the array. Works on arrays of all types."},
           "cljs.core/mk-bound-fn" {:ns "cljs.core",
                                    :name "mk-bound-fn",
                                    :type "function",
                                    :signature ["[sc test key]"],
                                    :source {:code "(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7763 7767]},
                                    :full-name "cljs.core/mk-bound-fn",
                                    :full-name-encode "cljs.core_mk-bound-fn",
                                    :history [["+" "0.0-1211"]]},
           "cljs.reader/validate-unicode-escape" {:ns "cljs.reader",
                                                  :name "validate-unicode-escape",
                                                  :type "function",
                                                  :signature ["[unicode-pattern reader escape-char unicode-str]"],
                                                  :source {:code "(defn validate-unicode-escape [unicode-pattern reader escape-char unicode-str]\n  (if (re-matches unicode-pattern unicode-str)\n    unicode-str\n    (reader-error reader \"Unexpected unicode escape \\\\\" escape-char unicode-str)))",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/cljs/cljs/reader.cljs",
                                                           :lines [184
                                                                   187]},
                                                  :full-name "cljs.reader/validate-unicode-escape",
                                                  :full-name-encode "cljs.reader_validate-unicode-escape",
                                                  :history [["+"
                                                             "0.0-1424"]]},
           "special/quote" {:ns "special",
                            :name "quote",
                            :type "special form",
                            :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _ _]\n  (analyze (assoc env :quoted? true) x))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [1013 1015]},
                            :full-name "special/quote",
                            :full-name-encode "special_quote",
                            :clj-symbol "clojure.core/quote",
                            :history [["+" "0.0-927"]]},
           "cljs.core/VectorNode" {:ns "cljs.core",
                                   :name "VectorNode",
                                   :type "type",
                                   :signature ["[edit arr]"],
                                   :source {:code "(deftype VectorNode [edit arr])",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [4157]},
                                   :full-name "cljs.core/VectorNode",
                                   :full-name-encode "cljs.core_VectorNode",
                                   :history [["+" "0.0-1211"]]},
           "cljs.core/string-hash-cache-count" {:ns "cljs.core",
                                                :name "string-hash-cache-count",
                                                :type "var",
                                                :source {:code "(def string-hash-cache-count 0)",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [514]},
                                                :full-name "cljs.core/string-hash-cache-count",
                                                :full-name-encode "cljs.core_string-hash-cache-count",
                                                :history [["+"
                                                           "0.0-1424"]]},
           "cljs.core/tree-seq" {:description "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n\n`branch?` must be a function of one argument that returns true if passed a node\nthat can have children (but may not).\n\n`children` must be a function of one argument that returns a sequence of the\nchildren. `children` will only be called on nodes for which `branch?` returns\ntrue.\n\n`root` is the root node of the tree.",
                                 :ns "cljs.core",
                                 :name "tree-seq",
                                 :signature ["[branch? children root]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_tree-seq",
                                 :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3998 4011]},
                                 :full-name "cljs.core/tree-seq",
                                 :clj-symbol "clojure.core/tree-seq",
                                 :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
           "cljs.reader/read-unmatched-delimiter" {:ns "cljs.reader",
                                                   :name "read-unmatched-delimiter",
                                                   :type "function",
                                                   :signature ["[rdr ch]"],
                                                   :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmatched delimiter \" ch))",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [260
                                                                    262]},
                                                   :full-name "cljs.reader/read-unmatched-delimiter",
                                                   :full-name-encode "cljs.reader_read-unmatched-delimiter",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "clojure.core.reducers/take-while" {:ns "clojure.core.reducers",
                                               :name "take-while",
                                               :signature ["[pred]"
                                                           "[pred coll]"],
                                               :history [["+"
                                                          "0.0-1236"]],
                                               :type "function",
                                               :full-name-encode "clojure.core.reducers_take-while",
                                               :source {:code "(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/clojure/core/reducers.cljs",
                                                        :lines [152
                                                                162]},
                                               :full-name "clojure.core.reducers/take-while",
                                               :clj-symbol "clojure.core.reducers/take-while",
                                               :docstring "Ends the reduction of coll when (pred val) returns logical false."},
           "cljs.reader/register-tag-parser!" {:ns "cljs.reader",
                                               :name "register-tag-parser!",
                                               :type "function",
                                               :signature ["[tag f]"],
                                               :source {:code "(defn register-tag-parser!\n  [tag f]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* assoc tag f)\n    old-parser))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [588
                                                                593]},
                                               :full-name "cljs.reader/register-tag-parser!",
                                               :full-name-encode "cljs.reader_register-tag-parserBANG",
                                               :history [["+"
                                                          "0.0-1236"]]},
           "cljs.core/every-pred" {:description "Takes a set of predicate functions and returns a function `f` that returns true\nif all of its composing predicates return a logical true value against all of\nits arguments, else it returns false.\n\nNote that `f` is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates.",
                                   :ns "cljs.core",
                                   :name "every-pred",
                                   :signature ["[p]"
                                               "[p1 p2]"
                                               "[p1 p2 p3]"
                                               "[p1 p2 p3 & ps]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/some-fn"
                                             "cljs.core/and"],
                                   :full-name-encode "cljs.core_every-pred",
                                   :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3658 3695]},
                                   :full-name "cljs.core/every-pred",
                                   :clj-symbol "clojure.core/every-pred",
                                   :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
           "special/var" {:ns "special",
                          :name "var",
                          :type "special form",
                          :source {:code "(defmethod parse 'var\n  [op env [_ sym :as form] _ _]\n  (let [var (resolve-var env sym (confirm-var-exists-throw))]\n    {:env env :op :var-special :form form\n     :var (analyze env sym)\n     :sym (analyze env `(quote ~(symbol (name (:ns var)) (name (:name var)))))\n     :meta (let [ks [:ns :doc :file :line :column]\n                 m (merge\n                     (assoc (zipmap ks (map #(list 'quote (get var %)) ks))\n                       :name `(quote ~(symbol (name (:name var))))\n                       :test `(when ~sym (.-cljs$lang$test ~sym))\n                       :arglists (map with-meta (:arglists var) (:arglists-meta var)))\n                     (let [user-meta (:meta var)\n                           uks (keys user-meta)]\n                       (zipmap uks\n                         (map #(list 'quote (get user-meta %)) uks))))]\n             (analyze env m))}))",
                                   :repo "clojurescript",
                                   :tag "r2911",
                                   :filename "src/clj/cljs/analyzer.clj",
                                   :lines [552 568]},
                          :full-name "special/var",
                          :full-name-encode "special_var",
                          :clj-symbol "clojure.core/var",
                          :history [["+" "0.0-2496"]]},
           "syntax/js-ns" {:ns "syntax",
                           :name "js-ns",
                           :syntax-form "js/",
                           :type "special namespace",
                           :full-name "syntax/js-ns",
                           :full-name-encode "syntax_js-ns",
                           :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashSet" {:ns "cljs.core",
                                          :name "PersistentHashSet",
                                          :signature ["[meta hash-map __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_PersistentHashSet",
                                          :source {:code "(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashSet. meta hash-map __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashSet. meta hash-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentHashSet) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (-count hash-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (-dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (-as-transient hash-map))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [7355 7427]},
                                          :full-name "cljs.core/PersistentHashSet",
                                          :clj-symbol "clojure.lang/PersistentHashSet"},
           "cljs.repl/doc" {:description "Prints documentation for the var or special form with the name `name`.",
                            :ns "cljs.repl",
                            :name "doc",
                            :signature ["[name]"],
                            :history [["+" "0.0-2496"]],
                            :type "macro",
                            :related ["cljs.repl/find-doc"
                                      "cljs.core/meta"
                                      "special/var"],
                            :full-name-encode "cljs.repl_doc",
                            :source {:code "(defmacro doc\n  [sym]\n  `(cljs.repl/print-doc (meta (var ~sym))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/repl.clj",
                                     :lines [771 774]},
                            :examples [{:id "4d2768",
                                        :content "```clj\n(doc map)\n;; Prints:\n;;  -------------------------\n;;  cljs.core/map\n;;  [f coll]\n;;    Returns a lazy sequence consisting of the result of applying f to\n;;    the set of first items of each coll, followed by applying f to the\n;;    set of second items in each coll, until any one of the colls is\n;;    exhausted.  Any remaining items in other colls are ignored. Function\n;;    f should accept number-of-colls arguments. Returns a transducer when\n;;    no collection is provided.\n;;\n;;=> nil\n```"}],
                            :full-name "cljs.repl/doc",
                            :clj-symbol "clojure.repl/doc",
                            :docstring "Prints documentation for a var or special form given its name"},
           "clojure.set/rename-keys" {:ns "clojure.set",
                                      :name "rename-keys",
                                      :signature ["[map kmap]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.set_rename-keys",
                                      :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce\n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m))\n     (apply dissoc map (keys kmap)) kmap))",
                                               :repo "clojurescript",
                                               :tag "r2911",
                                               :filename "src/cljs/clojure/set.cljs",
                                               :lines [72 80]},
                                      :full-name "clojure.set/rename-keys",
                                      :clj-symbol "clojure.set/rename-keys",
                                      :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/peek" {:description "Returns the first element of a list; same as `first`.\n\nReturns the last element of a vector, and much more efficient than using `last`.\n\nReturns nil if `coll` is empty.",
                             :ns "cljs.core",
                             :name "peek",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/first"
                                       "cljs.core/pop"
                                       "cljs.core/conj"],
                             :full-name-encode "cljs.core_peek",
                             :source {:code "(defn peek\n  [coll]\n  (when-not (nil? coll)\n    (-peek coll)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1469 1474]},
                             :examples [{:id "4abc4c",
                                         :content "With vectors:\n\n```clj\n(peek [1 2 3])\n;;=> 3\n\n(peek [1 2])\n;;=> 2\n\n(peek [1])\n;;=> 1\n\n(peek [])\n;;=> nil\n```"}
                                        {:id "d50bd0",
                                         :content "With lists:\n\n```clj\n(peek '(1 2 3))\n;;=> 1\n\n(peek '(1 2))\n;;=> 1\n\n(peek '(1))\n;;=> 1\n\n(peek '())\n;;=> nil\n```"}],
                             :full-name "cljs.core/peek",
                             :clj-symbol "clojure.core/peek",
                             :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
           "cljs.core/pr-str-with-opts" {:ns "cljs.core",
                                         :name "pr-str-with-opts",
                                         :signature ["[objs opts]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_pr-str-with-opts",
                                         :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\"\n    (str (pr-sb-with-opts objs opts))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [8253 8259]},
                                         :full-name "cljs.core/pr-str-with-opts",
                                         :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts"},
           "cljs.core/IChunk" {:ns "cljs.core",
                               :name "IChunk",
                               :history [["+" "0.0-1424"]],
                               :type "protocol",
                               :full-name-encode "cljs.core_IChunk",
                               :source {:code "(defprotocol IChunk\n  (-drop-first [coll]))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [400 401]},
                               :methods [{:name "-drop-first",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IChunk",
                               :clj-symbol "clojure.lang/IChunk"},
           "cljs.core/ITransientVector" {:ns "cljs.core",
                                         :name "ITransientVector",
                                         :history [["+" "0.0-1211"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core_ITransientVector",
                                         :source {:code "(defprotocol ITransientVector\n  (^clj -assoc-n! [tcoll n val])\n  (^clj -pop! [tcoll]))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [390 392]},
                                         :methods [{:name "-assoc-n!",
                                                    :signature ["[tcoll n val]"],
                                                    :docstring nil}
                                                   {:name "-pop!",
                                                    :signature ["[tcoll]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/ITransientVector",
                                         :clj-symbol "clojure.lang/ITransientVector"},
           "cljs.core/IPrintWithWriter" {:ns "cljs.core",
                                         :name "IPrintWithWriter",
                                         :history [["+" "0.0-1503"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core_IPrintWithWriter",
                                         :source {:code "(defprotocol IPrintWithWriter\n  \"The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.\"\n  (-pr-writer [o writer opts]))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [361 367]},
                                         :methods [{:name "-pr-writer",
                                                    :signature ["[o writer opts]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/IPrintWithWriter",
                                         :docstring "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."},
           "cljs.core/test" {:ns "cljs.core",
                             :name "test",
                             :signature ["[v]"],
                             :history [["+" "0.0-2496"]],
                             :type "function",
                             :full-name-encode "cljs.core_test",
                             :source {:code "(defn test\n  [v]\n  (let [f (.-cljs$lang$test v)]\n    (if f\n      (do (f) :ok)\n      :no-test)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [9251 9258]},
                             :full-name "cljs.core/test",
                             :clj-symbol "clojure.core/test",
                             :docstring "test [v] finds fn at key :test in var metadata and calls it,\npresuming failure will throw exception"},
           "cljs.core/map?" {:description "Returns true if `x` is a map, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "map?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/hash-map"
                                       "cljs.core/sorted-map"],
                             :full-name-encode "cljs.core_mapQMARK",
                             :source {:code "(defn ^boolean map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1534 1539]},
                             :full-name "cljs.core/map?",
                             :clj-symbol "clojure.core/map?",
                             :docstring "Return true if x satisfies IMap"},
           "cljs.repl.node/node-eval" {:ns "cljs.repl.node",
                                       :name "node-eval",
                                       :signature ["[repl-env js]"],
                                       :history [["+" "0.0-2629"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.node_node-eval",
                                       :source {:code "(defn node-eval\n  [repl-env js]\n  (let [{:keys [in out]} @(:socket repl-env)]\n    ;; escape backslash for Node.js under Windows\n    (write out js)\n    (let [result (json/read-str\n                   (read-response in) :key-fn keyword)]\n      (condp = (:status result)\n        \"success\"\n        {:status :success\n         :value (:value result)}\n\n        \"exception\"\n        {:status :exception\n         :value (:value result)}))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/repl/node.clj",
                                                :lines [51 66]},
                                       :full-name "cljs.repl.node/node-eval",
                                       :docstring "Evaluate a JavaScript string in the Node REPL process."},
           "cljs.reader/StringPushbackReader" {:ns "cljs.reader",
                                               :name "StringPushbackReader",
                                               :type "type",
                                               :signature ["[s buffer idx]"],
                                               :source {:code "(deftype StringPushbackReader [s buffer ^:mutable idx]\n  PushbackReader\n  (read-char [reader]\n    (if (zero? (alength buffer))\n      (do\n        (set! idx (inc idx))\n        (aget s idx))\n      (.pop buffer)))\n  (unread [reader ch]\n    (.push buffer ch)))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [18 27]},
                                               :full-name "cljs.reader/StringPushbackReader",
                                               :full-name-encode "cljs.reader_StringPushbackReader",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/PersistentTreeMap" {:ns "cljs.core",
                                          :name "PersistentTreeMap",
                                          :signature ["[comp tree cnt meta __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core_PersistentTreeMap",
                                          :source {:code "(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k]\n    (-lookup coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  (entry-at [coll k]\n    (loop [t tree]\n      (if-not (nil? t)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  ICloneable\n  (-clone [_] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeMap. comp nil 0 meta 0))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if-not (nil? tree)\n      (tree-map-kv-reduce tree f init)\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if-not (nil? n)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (nil? t)\n        (let [found-node (nth found 0)]\n          (if (= v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (not (nil? (.entry-at coll k))))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (nil? t)\n        (if (nil? (nth found 0))\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if-not (nil? t)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1 nil)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (when-not (nil? stack)\n            (PersistentTreeMapSeq. nil stack ascending? -1 nil))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [6980 7124]},
                                          :full-name "cljs.core/PersistentTreeMap",
                                          :clj-symbol "clojure.lang/PersistentTreeMap"},
           "cljs.core/HashMap.fromArrays" {:ns "cljs.core",
                                           :name "HashMap.fromArrays",
                                           :signature ["[ks vs]"],
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1798"]],
                                           :parent-type "HashMap",
                                           :type "function",
                                           :full-name-encode "cljs.core_HashMapDOTfromArrays",
                                           :source {:code "(set! cljs.core.HashMap/fromArrays (fn [ks vs]\n  (let [len (alength ks)]\n    (loop [i 0, out cljs.core.HashMap/EMPTY]\n      (if (< i len)\n        (recur (inc i) (assoc out (aget ks i) (aget vs i)))\n        out)))))",
                                                    :repo "clojurescript",
                                                    :tag "r1586",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3832 3837]},
                                           :full-name "cljs.core/HashMap.fromArrays",
                                           :removed {:in "0.0-1798",
                                                     :last-seen "0.0-1586"}},
           "cljs.core/deref" {:description "Returns the current value of atom `x`.\n\nThe `@` reader macro is often used instead of `deref`. `@foo` is the same thing\nas `(deref foo)`.",
                              :ns "cljs.core",
                              :name "deref",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/atom"],
                              :full-name-encode "cljs.core_deref",
                              :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [920 922]},
                              :full-name "cljs.core/deref",
                              :clj-symbol "clojure.core/deref"},
           "cljs.core/reductions" {:description "Returns a lazy sequence of the intermediate values of the reduction (as per\n`reduce`) of `coll` by `f`, starting with `init`.",
                                   :ns "cljs.core",
                                   :name "reductions",
                                   :signature ["[f coll]"
                                               "[f init coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/reduce"],
                                   :full-name-encode "cljs.core_reductions",
                                   :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7983 7995]},
                                   :full-name "cljs.core/reductions",
                                   :clj-symbol "clojure.core/reductions",
                                   :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
           "cljs.core/false?" {:description "Returns true if `x` is the value false, false otherwise.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "false?",
                               :signature ["[x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/true?"
                                         "cljs.core/not"],
                               :full-name-encode "cljs.core_falseQMARK",
                               :source {:code "(defn ^boolean false?\n  [x] (cljs.core/false? x))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1585 1587]},
                               :extra-sources ({:code "(defmacro false? [x]\n  (bool-expr (core/list 'js* \"~{} === false\" x)))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [299 300]}),
                               :full-name "cljs.core/false?",
                               :clj-symbol "clojure.core/false?",
                               :docstring "Returns true if x is the value false, false otherwise."},
           "cljs.core/bit-flip" {:description "Flip bit at index `n`.  Same as `x ^ (1 << y)` in JavaScript.",
                                 :ns "cljs.core",
                                 :name "bit-flip",
                                 :signature ["[x n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/bit-set"
                                           "cljs.core/bit-clear"],
                                 :full-name-encode "cljs.core_bit-flip",
                                 :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2116 2119]},
                                 :extra-sources ({:code "(defmacro ^::ana/numeric bit-flip [x n]\n  (core/list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [520 521]}),
                                 :examples [{:id "5d7ee0",
                                             :content "Bits can be entered using radix notation:\n\n```clj\n(bit-flip 2r1111 2)\n;;=> 11\n;; 11 = 2r1011\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-flip 15 2)\n;;=> 11\n```"}],
                                 :full-name "cljs.core/bit-flip",
                                 :clj-symbol "clojure.core/bit-flip",
                                 :docstring "Flip bit at index n"},
           "cljs.test/deftest" {:ns "cljs.test",
                                :name "deftest",
                                :signature ["[name & body]"],
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test_deftest",
                                :source {:code "(defmacro deftest\n  [name & body]\n  (when ana/*load-tests*\n    `(do\n       (def ~(vary-meta name assoc :test `(fn [] ~@body))\n         (fn [] (cljs.test/test-var (.-cljs$lang$var ~name))))\n       (set! (.-cljs$lang$var ~name) (var ~name)))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/test.clj",
                                         :lines [204 220]},
                                :full-name "cljs.test/deftest",
                                :clj-symbol "clojure.test/deftest",
                                :docstring "Defines a test function with no arguments.  Test functions may call\nother tests, so tests may be composed.  If you compose tests, you\nshould also define a function named test-ns-hook; run-tests will\ncall test-ns-hook instead of testing all vars.\n\nNote: Actually, the test body goes in the :test metadata on the var,\nand the real function (the value of the var) calls test-var on\nitself.\n\nWhen cljs.analyzer/*load-tests* is false, deftest is ignored."},
           "cljs.core/ISet" {:ns "cljs.core",
                             :name "ISet",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core_ISet",
                             :source {:code "(defprotocol ISet\n  (^clj -disjoin [coll v]))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [302 303]},
                             :methods [{:name "-disjoin",
                                        :signature ["[coll v]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISet",
                             :clj-symbol "clojure.lang/IPersistentSet"},
           "cljs.core/StringIter" {:ns "cljs.core",
                                   :name "StringIter",
                                   :type "type",
                                   :signature ["[s i]"],
                                   :source {:code "(deftype StringIter [s ^:mutable i]\n  Object\n  (hasNext [_] (< i (alength s)))\n  (next [_]\n    (let [ret (.charAt s i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3069 3076]},
                                   :full-name "cljs.core/StringIter",
                                   :full-name-encode "cljs.core_StringIter",
                                   :history [["+" "0.0-2301"]]},
           "cljs.core/LazySeq" {:ns "cljs.core",
                                :name "LazySeq",
                                :signature ["[meta fn s __hash]"],
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core_LazySeq",
                                :source {:code "(deftype LazySeq [meta ^:mutable fn ^:mutable s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (sval [coll]\n    (if (nil? fn)\n      s\n      (do\n        (set! s (fn))\n        (set! fn nil)\n        s)))\n\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta fn s __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (first s)))\n  (-rest [coll]\n    (-seq coll)\n    (if-not (nil? s)\n      (rest s)\n      ()))\n\n  INext\n  (-next [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (next s)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (.sval coll)\n    (when-not (nil? s)\n      (loop [ls s]\n        (if (instance? LazySeq ls)\n          (recur (.sval ls))\n          (do (set! s ls)\n            (seq s))))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2555 2617]},
                                :full-name "cljs.core/LazySeq",
                                :clj-symbol "clojure.lang/LazySeq"},
           "cljs.core/pop!" {:ns "cljs.core",
                             :name "pop!",
                             :signature ["[tcoll]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core_popBANG",
                             :source {:code "(defn pop!\n  [tcoll]\n  (-pop! tcoll))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2962 2966]},
                             :full-name "cljs.core/pop!",
                             :clj-symbol "clojure.core/pop!",
                             :docstring "Removes the last item from a transient vector. If\nthe collection is empty, throws an exception. Returns coll"},
           "cljs.reader/parse-timestamp" {:ns "cljs.reader",
                                          :name "parse-timestamp",
                                          :type "function",
                                          :signature ["[ts]"],
                                          :source {:code "(defn parse-timestamp\n  [ts]\n  (if-let [[years months days hours minutes seconds ms offset]\n           (parse-and-validate-timestamp ts)]\n    (js/Date.\n     (- (.UTC js/Date years (dec months) days hours minutes seconds ms)\n        (* offset 60 1000)))\n    (reader-error nil (str \"Unrecognized date/time syntax: \" ts))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [517 524]},
                                          :full-name "cljs.reader/parse-timestamp",
                                          :full-name-encode "cljs.reader_parse-timestamp",
                                          :history [["+" "0.0-1424"]]},
           "cljs.repl/mapped-stacktrace" {:ns "cljs.repl",
                                          :name "mapped-stacktrace",
                                          :signature ["[stacktrace]"
                                                      "[stacktrace opts]"],
                                          :history [["+" "0.0-2843"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl_mapped-stacktrace",
                                          :source {:code "(defn mapped-stacktrace\n  ([stacktrace] (mapped-stacktrace stacktrace nil))\n  ([stacktrace opts]\n    (let [read-source-map' (memoize read-source-map)\n          ns-info' (memoize ns-info)]\n      (vec\n        (for [{:keys [function file line column] :as frame} stacktrace]\n          ;; need to convert file, a relative URL style path, to host-specific file\n          (let [rfile (io/file (URL. (.toURL (io/file (util/output-directory opts))) file))\n                [sm {:keys [ns source-file] :as ns-info}]\n                ((juxt read-source-map' ns-info') rfile)\n                [line' column'] (if ns-info\n                                  (mapped-line-and-column sm line column)\n                                  [line column])\n                name' (if (and ns-info function)\n                        (symbol (name ns) (cljrepl/demunge function))\n                        function)\n                file' (string/replace\n                        (.getCanonicalFile\n                          (if ns-info\n                            source-file\n                            (io/file rfile)))\n                        (str (System/getProperty \"user.dir\") File/separator) \"\")\n                url   (or (and ns-info (io/resource (util/ns->relpath ns)))\n                          (io/resource file))]\n            (merge\n              {:function name'\n               :file     (io/file file')\n               :line     line'\n               :column   column'}\n              (when url\n                {:url url}))))))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/repl.clj",
                                                   :lines [217 260]},
                                          :full-name "cljs.repl/mapped-stacktrace",
                                          :docstring "Given a vector representing the canonicalized JavaScript stacktrace\nreturn the ClojureScript stacktrace. The canonical stacktrace must be\nin the form:\n\n [{:file <string>\n   :function <string>\n   :line <integer>\n   :column <integer>}*]\n\n:file must be a URL path (without protocol) relative to :output-dir. The\nreturned mapped stacktrace will also contain :url entries to the original\nsources if it can be determined from the classpath."},
           "cljs.repl.rhino/IEval" {:ns "cljs.repl.rhino",
                                    :name "IEval",
                                    :type "protocol",
                                    :full-name-encode "cljs.repl.rhino_IEval",
                                    :source {:code "(defprotocol IEval\n  (-eval [this env filename line]))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/clj/cljs/repl/rhino.clj",
                                             :lines [29 30]},
                                    :methods [{:name "-eval",
                                               :signature ["[this env filename line]"],
                                               :docstring nil}],
                                    :full-name "cljs.repl.rhino/IEval",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/chunk-first" {:ns "cljs.core",
                                    :name "chunk-first",
                                    :type "function",
                                    :signature ["[s]"],
                                    :source {:code "(defn chunk-first [s]\n  (-chunked-first s))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2747 2748]},
                                    :full-name "cljs.core/chunk-first",
                                    :full-name-encode "cljs.core_chunk-first",
                                    :history [["+" "0.0-1424"]]},
           "cljs.core/ChunkedSeq" {:ns "cljs.core",
                                   :name "ChunkedSeq",
                                   :signature ["[vec node i off meta __hash]"],
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core_ChunkedSeq",
                                   :source {:code "(deftype ChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll m]\n    (chunked-seq vec node i off m))\n  IMeta\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    (with-meta (.-EMPTY PersistentVector) meta))\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n  (-chunked-rest [coll]\n    (let [end (+ i (alength node))]\n      (if (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0)\n        ())))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [end (+ i (alength node))]\n      (when (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce (subvec vec (+ i off) (count vec)) f))\n\n  (-reduce [coll f start]\n    (ci-reduce (subvec vec (+ i off) (count vec)) f start)))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [4493 4565]},
                                   :full-name "cljs.core/ChunkedSeq",
                                   :clj-symbol "clojure.lang/ChunkedSeq"},
           "cljs.test/testing" {:ns "cljs.test",
                                :name "testing",
                                :signature ["[string & body]"],
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test_testing",
                                :source {:code "(defmacro testing\n  ([string & body]\n   `(do\n      (cljs.test/update-current-env! [:testing-contexts] conj ~string)\n      (let [ret# (do ~@body)]\n        (cljs.test/update-current-env! [:testing-contexts] rest)\n        ret#))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/clj/cljs/test.clj",
                                         :lines [191 199]},
                                :full-name "cljs.test/testing",
                                :clj-symbol "clojure.test/testing",
                                :docstring "Adds a new string to the list of testing contexts.  May be nested,\nbut must occur inside a test function (deftest)."},
           "cljs.analyzer.api/resolve" {:ns "cljs.analyzer.api",
                                        :name "resolve",
                                        :signature ["[env sym]"],
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api_resolve",
                                        :source {:code "(defn resolve\n  [env sym]\n  {:pre [(map? env) (symbol? sym)]}\n  (try\n    (ana/resolve-var env sym\n      (ana/confirm-var-exists-throw))\n    (catch Exception e)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/analyzer/api.clj",
                                                 :lines [14 22]},
                                        :full-name "cljs.analyzer.api/resolve",
                                        :clj-symbol "clojure.core/resolve",
                                        :docstring "Given an analysis environment resolve a var. Analogous to\nclojure.core/resolve"},
           "cljs.repl.browser/start-server" {:ns "cljs.repl.browser",
                                             :name "start-server",
                                             :signature ["[opts]"],
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser_start-server",
                                             :source {:code "(defn start-server\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! server-state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [265 270]},
                                             :full-name "cljs.repl.browser/start-server",
                                             :docstring "Start the server on the specified port.",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.core/*2" {:description "Only usable from a REPL.\n\nHolds the result of the second to last expression.",
                           :ns "cljs.core",
                           :name "*2",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*3"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core_STAR2",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [63 65]},
                           :examples [{:id "208d41",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n(+ 4 8)\n;;=> 12\n\n*2\n;;=> 10\n\n(inc *2)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*2",
                           :clj-symbol "clojure.core/*2",
                           :docstring "bound in a repl thread to the second most recent value printed"},
           "cljs.repl.server/send-and-close" {:ns "cljs.repl.server",
                                              :name "send-and-close",
                                              :signature ["[conn status form]"
                                                          "[conn status form content-type]"],
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server_send-and-close",
                                              :source {:code "(defn send-and-close\n  ([conn status form]\n    (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n    (let [utf-8-form (.getBytes form \"UTF-8\")\n          content-length (count utf-8-form)\n          headers (map #(.getBytes (str % \"\\r\\n\"))\n                    [(status-line status)\n                     \"Server: ClojureScript REPL\"\n                     (str \"Content-Type: \"\n                       content-type\n                       \"; charset=utf-8\")\n                     (str \"Content-Length: \" content-length)\n                     \"\"])]\n      (with-open [os (.getOutputStream conn)]\n        (doseq [header headers]\n          (.write os header 0 (count header)))\n        (.write os utf-8-form 0 content-length)\n        (.flush os)\n        (.close conn)))))",
                                                       :repo "clojurescript",
                                                       :tag "r2911",
                                                       :filename "src/clj/cljs/repl/server.clj",
                                                       :lines [109
                                                               130]},
                                              :full-name "cljs.repl.server/send-and-close",
                                              :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response."},
           "cljs.test/ns?" {:ns "cljs.test",
                            :name "ns?",
                            :type "function",
                            :signature ["[x]"],
                            :source {:code "(defn ns? [x]\n  (and (seq? x) (= (first x) 'quote)))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/test.clj",
                                     :lines [244 245]},
                            :full-name "cljs.test/ns?",
                            :full-name-encode "cljs.test_nsQMARK",
                            :history [["+" "0.0-2496"]]},
           "clojure.browser.event/total-listener-count" {:ns "clojure.browser.event",
                                                         :name "total-listener-count",
                                                         :type "function",
                                                         :signature ["[]"],
                                                         :source {:code "(defn total-listener-count []\n  (events/getTotalListenerCount))",
                                                                  :repo "clojurescript",
                                                                  :tag "r2911",
                                                                  :filename "src/cljs/clojure/browser/event.cljs",
                                                                  :lines [87
                                                                          88]},
                                                         :full-name "clojure.browser.event/total-listener-count",
                                                         :full-name-encode "clojure.browser.event_total-listener-count",
                                                         :history [["+"
                                                                    "0.0-927"]]},
           "cljs.core/MultiStepper" {:ns "cljs.core",
                                     :name "MultiStepper",
                                     :type "type",
                                     :signature ["[xform iters nexts]"],
                                     :source {:code "(deftype MultiStepper [xform iters nexts]\n  Object\n  (hasNext [_]\n    (loop [iters (seq iters)]\n      (if-not (nil? iters)\n        (let [iter (first iters)]\n          (if-not (.hasNext iter)\n            false\n            (recur (next iters))))\n        true)))\n  (next [_]\n    (dotimes [i (alength iters)]\n      (aset nexts i (.next (aget iters i))))\n    (prim-seq nexts 0))\n  (step [this lt]\n    (loop []\n      (if (and (not (nil? (.-stepper lt)))\n               (.hasNext this))\n        (if (reduced? (apply xform (cons lt (.next this))))\n          (when-not (nil? (.-rest lt))\n            (set! (.. lt -rest -stepper) nil))\n          (recur))))\n    (when-not (nil? (.-stepper lt))\n      (xform lt))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3160 3183]},
                                     :full-name "cljs.core/MultiStepper",
                                     :full-name-encode "cljs.core_MultiStepper",
                                     :history [["+" "0.0-2301"]]},
           "cljs.core/alter-meta!" {:description "Alter the metadata of `data` to be `(apply f its-current-meta args)`.\n\nMetadata of vars cannot be altered since they are statically determined at compile-time.",
                                    :ns "cljs.core",
                                    :name "alter-meta!",
                                    :signature ["[data f & args]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/with-meta"
                                              "cljs.core/vary-meta"],
                                    :full-name-encode "cljs.core_alter-metaBANG",
                                    :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [8465 8472]},
                                    :examples [{:id "8378a0",
                                                :content "Metadata of symbols and collections can be altered:\n\n```clj\n(def a ^:foo [1 2 3])\n(meta a)\n;;=> {:foo true}\n\n(alter-meta! a assoc :bar true)\n(meta a)\n;;=> {:foo true, :bar true}\n```\n\nMetadata of vars cannot be altered:\n\n```clj\n(def a [1 2 3])\n(meta #'a)\n;;=> {:arglists (), :test nil, :name a, :column 1, :line 1, :file \"<cljs repl>\", :doc nil, :ns cljs.user}\n\n(alter-meta! #'a assoc :bar true)\n(:bar (meta #'a))\n;;=> nil\n```"}],
                                    :full-name "cljs.core/alter-meta!",
                                    :clj-symbol "clojure.core/alter-meta!",
                                    :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
           "clojure.browser.dom/click-element" {:ns "clojure.browser.dom",
                                                :name "click-element",
                                                :type "function",
                                                :signature ["[e]"],
                                                :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/clojure/browser/dom.cljs",
                                                         :lines [147
                                                                 149]},
                                                :full-name "clojure.browser.dom/click-element",
                                                :full-name-encode "clojure.browser.dom_click-element",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/seq-iter" {:ns "cljs.core",
                                 :name "seq-iter",
                                 :type "function",
                                 :signature ["[coll]"],
                                 :source {:code "(defn seq-iter [coll]\n  (SeqIter. INIT coll))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3114 3115]},
                                 :full-name "cljs.core/seq-iter",
                                 :full-name-encode "cljs.core_seq-iter",
                                 :history [["+" "0.0-2301"]]},
           "cljs.core/unchecked-remainder-int" {:ns "cljs.core",
                                                :name "unchecked-remainder-int",
                                                :signature ["[x n]"],
                                                :history [["+"
                                                           "0.0-1798"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_unchecked-remainder-int",
                                                :source {:code "(defn unchecked-remainder-int [x n]\n  (cljs.core/unchecked-remainder-int x n))",
                                                         :repo "clojurescript",
                                                         :tag "r2911",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [2014
                                                                 2015]},
                                                :extra-sources ({:code "(defmacro ^::ana/numeric unchecked-remainder-int\n  ([x n] `(mod ~x ~n)))",
                                                                 :repo "clojurescript",
                                                                 :tag "r2911",
                                                                 :filename "src/clj/cljs/core.clj",
                                                                 :lines [405
                                                                         406]}),
                                                :full-name "cljs.core/unchecked-remainder-int",
                                                :clj-symbol "clojure.core/unchecked-remainder-int"},
           "cljs.core/bit-shift-right-zero-fill" {:ns "cljs.core",
                                                  :name "bit-shift-right-zero-fill",
                                                  :signature ["[x n]"],
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_bit-shift-right-zero-fill",
                                                  :source {:code "(defn bit-shift-right-zero-fill\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))",
                                                           :repo "clojurescript",
                                                           :tag "r2911",
                                                           :filename "src/cljs/cljs/core.cljs",
                                                           :lines [2143
                                                                   2145]},
                                                  :extra-sources ({:code "(defmacro ^::ana/numeric bit-shift-right-zero-fill [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                   :repo "clojurescript",
                                                                   :tag "r2911",
                                                                   :filename "src/clj/cljs/core.clj",
                                                                   :lines [532
                                                                           533]}),
                                                  :full-name "cljs.core/bit-shift-right-zero-fill",
                                                  :docstring "DEPRECATED: Bitwise shift right with zero fill"},
           "cljs.core/when-some" {:description "When `test` is not nil, evaluates `body` with `x` bound to the value of `test`.",
                                  :ns "cljs.core",
                                  :name "when-some",
                                  :signature ["[[x test] & body]"],
                                  :history [["+" "0.0-2261"]],
                                  :type "macro",
                                  :related ["cljs.core/if-some"],
                                  :full-name-encode "cljs.core_when-some",
                                  :source {:code "(defmacro when-some\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (if (nil? temp#)\n         nil\n         (let [~form temp#]\n           ~@body)))))",
                                           :repo "clojure",
                                           :tag "clojure-1.6.0",
                                           :filename "src/clj/clojure/core.clj",
                                           :lines [1776 1791]},
                                  :full-name "cljs.core/when-some",
                                  :clj-symbol "clojure.core/when-some",
                                  :docstring "bindings => binding-form test\n\nWhen test is not nil, evaluates body with binding-form bound to the\nvalue of test"},
           "cljs.repl.browser/server-loop" {:ns "cljs.repl.browser",
                                            :name "server-loop",
                                            :signature ["[opts server-socket]"],
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser_server-loop",
                                            :source {:code "(defn server-loop\n  [opts server-socket]\n  (let [conn (.accept server-socket)]\n    (do (.setKeepAlive conn true)\n        (future (handle-connection opts conn))\n        (recur opts server-socket))))",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [258 263]},
                                            :full-name "cljs.repl.browser/server-loop",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "cljs.reader/read-meta" {:ns "cljs.reader",
                                    :name "read-meta",
                                    :type "function",
                                    :signature ["[rdr _]"],
                                    :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [371 379]},
                                    :full-name "cljs.reader/read-meta",
                                    :full-name-encode "cljs.reader_read-meta",
                                    :history [["+" "0.0-927"]]},
           "cljs.repl.server/send-404" {:ns "cljs.repl.server",
                                        :name "send-404",
                                        :type "function",
                                        :signature ["[conn path]"],
                                        :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n    (str\n      \"<html><body>\"\n      \"<h2>Page not found</h2>\"\n      \"No page \" path \" found on this server.\"\n      \"</body></html>\")\n    \"text/html\"))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [132 139]},
                                        :full-name "cljs.repl.server/send-404",
                                        :full-name-encode "cljs.repl.server_send-404",
                                        :history [["+" "0.0-1503"]]},
           "special/try*" {:ns "special",
                           :name "try*",
                           :type "special form",
                           :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze (assoc env :context :statement) `(do ~@fblock)))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        locals (if name\n                 (assoc locals name\n                   {:name name\n                    :line (get-line name env)\n                    :column (get-col name env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) `(do ~@(rest cblock))))\n        body (if name (pop body) body)\n        try (analyze (if (or name finally) catchenv env) `(do ~@body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name name\n     :catch catch\n     :children [try catch finally]}))",
                                    :repo "clojurescript",
                                    :tag "r1913",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [280 312]},
                           :full-name "special/try*",
                           :full-name-encode "special_trySTAR",
                           :history [["+" "0.0-927"] ["-" "0.0-1933"]],
                           :removed {:in "0.0-1933",
                                     :last-seen "0.0-1913"}},
           "syntax/ignore" {:description "Causes the following form to be completely skipped by the reader.  This is a\nmore complete removal than the `comment` macro which yields nil.",
                            :ns "syntax",
                            :name "ignore",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["syntax/comment"
                                      "cljs.core/comment"],
                            :full-name-encode "syntax_ignore",
                            :source {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                     :repo "tools.reader",
                                     :tag "tools.reader-0.8.10",
                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                     :lines [612 623]},
                            :extra-sources [{:code "(defn- read-discard\n  [rdr _]\n  (doto rdr\n    (read true nil true)))",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [375 378]}],
                            :syntax-form "#_",
                            :examples [{:id "f36d7a",
                                        :content "```clj\n{:foo #_bar 2}\n;;=> {:foo 2}\n```\n\nTo comment out the last line of a function without worrying about commenting out\nthe trailing parentheses:\n\n```clj\n(defn foo []\n  (println \"hello\")\n  #_(println \"world\"))\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#discard",
                            :full-name "syntax/ignore",
                            :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.test/test-var-block" {:ns "cljs.test",
                                       :name "test-var-block",
                                       :signature ["[v]"],
                                       :history [["+" "0.0-2814"]],
                                       :type "function",
                                       :full-name-encode "cljs.test_test-var-block",
                                       :source {:code "(defn test-var-block\n  [v]\n  {:pre [(instance? Var v)]}\n  (if-let [t (:test (meta v))]\n    [(fn []\n       (update-current-env! [:testing-vars] conj v)\n       (update-current-env! [:report-counters :test] inc)\n       (do-report {:type :begin-test-var :var v})\n       (let [{:keys [async-disabled]} (get-current-env)]\n         (cond-> (try\n                   (t)\n                   (catch :default e\n                     (do-report\n                      {:type :error\n                       :message \"Uncaught exception, not in assertion.\"\n                       :expected nil\n                       :actual e})))\n           async-disabled (-> async? not (assert async-disabled)))))\n     (fn []\n       (do-report {:type :end-test-var :var v})\n       (update-current-env! [:testing-vars] rest))]))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [437 459]},
                                       :full-name "cljs.test/test-var-block",
                                       :docstring "Like test-var, but returns a block for further composition and\nlater execution."},
           "cljs.core/range" {:description "Returns a lazy sequence of nums from `start` (inclusive) to `end` (exclusive),\nby `step`, where `start` defaults to 0, `step` to 1, and `end` to infinity.",
                              :ns "cljs.core",
                              :name "range",
                              :signature ["[]"
                                          "[end]"
                                          "[start end]"
                                          "[start end step]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/repeat"],
                              :full-name-encode "cljs.core_range",
                              :source {:code "(defn range\n  ([] (range 0 (.-MAX-VALUE js/Number) 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step nil)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7900 7907]},
                              :full-name "cljs.core/range",
                              :clj-symbol "clojure.core/range",
                              :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
           "cljs.repl.browser/read-post" {:ns "cljs.repl.browser",
                                          :name "read-post",
                                          :signature ["[line rdr]"],
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.browser_read-post",
                                          :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                   :repo "clojurescript",
                                                   :tag "r1450",
                                                   :filename "src/clj/cljs/repl/browser.clj",
                                                   :lines [143 152]},
                                          :full-name "cljs.repl.browser/read-post",
                                          :removed {:in "0.0-1503",
                                                    :last-seen "0.0-1450"}},
           "cljs.core/reify" {:ns "cljs.core",
                              :name "reify",
                              :signature ["[& impls]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core_reify",
                              :source {:code "(defmacro reify [& impls]\n  (let [t        (with-meta (gensym \"t\") {:anonymous true})\n        meta-sym (gensym \"meta\")\n        this-sym (gensym \"_\")\n        locals   (keys (:locals &env))\n        ns       (-> &env :ns :name)\n        munge    cljs.compiler/munge]\n    `(do\n       (when-not (exists? ~(symbol (core/str ns) (core/str t)))\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals ~(ana/elide-reader-meta (meta &form))))))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [613 629]},
                              :full-name "cljs.core/reify",
                              :clj-symbol "clojure.core/reify"},
           "cljs.core/satisfies?" {:ns "cljs.core",
                                   :name "satisfies?",
                                   :signature ["[psym x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core_satisfiesQMARK",
                                   :source {:code "(defmacro satisfies?\n  [psym x]\n  (let [p          (:name\n                     (cljs.analyzer/resolve-var\n                       (dissoc &env :locals) psym))\n         prefix     (protocol-prefix p)\n         xsym       (bool-expr (gensym))\n         [part bit] (fast-path-protocols p)\n         msym       (symbol\n                      (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    `(let [~xsym ~x]\n       (if ~xsym\n         (let [bit# ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit))]\n           (if (or bit#\n                 ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             (if (coercive-not (. ~xsym ~msym))\n               (cljs.core/native-satisfies? ~psym ~xsym)\n               false)))\n         (cljs.core/native-satisfies? ~psym ~xsym)))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [1072 1092]},
                                   :full-name "cljs.core/satisfies?",
                                   :clj-symbol "clojure.core/satisfies?",
                                   :docstring "Returns true if x satisfies the protocol"},
           "cljs.core/nth" {:description "Returns the value at index `n` or `not-found` if the index is out of bounds.\n\n`nth` will throw an exception if `n` is out of bounds and `not-found` is not\nsupplied.\n\n`nth` works for Strings, Arrays, Regex Matchers, Lists, and Sequences. For\nSequences, `nth` takes O(n) time.",
                            :ns "cljs.core",
                            :name "nth",
                            :signature ["[coll n]"
                                        "[coll n not-found]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/first"
                                      "cljs.core/second"
                                      "cljs.core/nthnext"
                                      "cljs.core/get"],
                            :full-name-encode "cljs.core_nth",
                            :source {:code "(defn nth\n  ([coll n]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"index argument to nth must be a number\"))\n\n      (nil? coll)\n      coll\n\n      (implements? IIndexed coll)\n      (-nth ^not-native coll n)\n\n      (array? coll)\n      (when (< n (.-length coll))\n        (aget coll n))\n\n      (string? coll)\n      (when (< n (.-length coll))\n        (aget coll n))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      (satisfies? ISeq coll)\n      (linear-traversal-nth coll n)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll)))))))\n  ([coll n not-found]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"index argument to nth must be a number.\"))\n\n      (nil? coll)\n      not-found\n\n      (implements? IIndexed coll)\n      (-nth ^not-native coll n not-found)\n\n      (array? coll)\n      (if (< n (.-length coll))\n        (aget coll n)\n        not-found)\n\n      (string? coll)\n      (if (< n (.-length coll))\n        (aget coll n)\n        not-found)\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      (satisfies? ISeq coll)\n      (linear-traversal-nth coll n not-found)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll))))))))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1252 1314]},
                            :full-name "cljs.core/nth",
                            :clj-symbol "clojure.core/nth",
                            :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
           "cljs.core/list" {:description "Creates a new list containing `items`.",
                             :ns "cljs.core",
                             :name "list",
                             :signature ["[& items]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/vector"
                                       "cljs.core/list?"],
                             :full-name-encode "cljs.core_list",
                             :source {:code "(defn list [& xs]\n  (let [arr (if (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n              (.-arr xs)\n              (let [arr (array)]\n                (loop [^not-native xs xs]\n                  (if-not (nil? xs)\n                    (do\n                      (.push arr (-first xs))\n                      (recur (-next xs)))\n                    arr))))]\n    (loop [i (alength arr) ^not-native r ()]\n      (if (> i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2404 2417]},
                             :extra-sources ({:code "(defmacro list\n  ([] '(.-EMPTY cljs.core/List))\n  ([x & xs]\n    `(-conj (list ~@xs) ~x)))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1414 1417]}),
                             :full-name "cljs.core/list",
                             :clj-symbol "clojure.core/list"},
           "cljs.core/defn" {:description "Defines a function.\n\n`doc-string?` is an optional documentation string.\n\n`attr-map?` is an optional map of [metadata](http://clojure.org/metadata) to\nattach to the global variable name.\n\n`prepost-map?` is an optional map with optional keys `:pre` and `:post` that\ncontain collections of [pre or post conditions](http://blog.fogus.me/2009/12/21/clojures-pre-and-post/)\nfor the function.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(defn foo [a b c]\n  (\\* a b c))</pre></td>\n      <td><pre>\n(def foo\n  (fn [a b c]\n    (\\* a b c)))</pre></td></tr></tbody></table>",
                             :ns "cljs.core",
                             :name "defn",
                             :signature ["[name doc-string? attr-map? [params*] prepost-map? body]"
                                         "[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["special/def"
                                       "cljs.core/defn-"
                                       "cljs.core/defmacro"
                                       "cljs.core/fn"],
                             :full-name-encode "cljs.core_defn",
                             :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n        (if (instance? clojure.lang.Symbol name)\n          nil\n          (throw (IllegalArgumentException. \"First argument to defn must be a symbol\")))\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [266 316]},
                             :full-name "cljs.core/defn",
                             :clj-symbol "clojure.core/defn",
                             :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata. prepost-map defines a map with optional keys\n :pre and :post that contain collections of pre or post conditions."},
           "cljs.core/rand-nth" {:description "Returns a random element from a sequential collection `coll`.\n\nHas the same performance characteristics as `nth`.",
                                 :ns "cljs.core",
                                 :name "rand-nth",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/rand"],
                                 :full-name-encode "cljs.core_rand-nth",
                                 :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8747 8752]},
                                 :full-name "cljs.core/rand-nth",
                                 :clj-symbol "clojure.core/rand-nth",
                                 :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
           "cljs.core/ex-cause" {:ns "cljs.core",
                                 :name "ex-cause",
                                 :signature ["[ex]"],
                                 :history [["+" "0.0-1576"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_ex-cause",
                                 :source {:code "(defn ex-cause\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-cause ex)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [9230 9237]},
                                 :full-name "cljs.core/ex-cause",
                                 :docstring "Alpha - subject to change.\nReturns exception cause (an Error / ExceptionInfo) if ex is an\nExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/atom" {:description "Creates and returns an atom with an initial value of `x`.\n\n`opts` is an optional map with optional keys `:meta` and `:validator`.\n\n`:meta` should be a [metadata-map](http://clojure.org/metadata) for the atom.\n\n`:validator` should be a validator function for the atom. See `set-validator!`\nfor more information.",
                             :ns "cljs.core",
                             :name "atom",
                             :signature ["[x]" "[x opts]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/atom"
                                       "cljs.core/swap!"
                                       "cljs.core/reset!"
                                       "cljs.core/set-validator!"
                                       "cljs.core/get-validator"],
                             :full-name-encode "cljs.core_atom",
                             :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3520 3535]},
                             :examples [{:id "e6a38a",
                                         :content "```clj\n(def a (atom 1))\n\n@a\n;;=> 1\n\n(reset! a 2)\n@a\n;;=> 2\n\n(swap! a inc)\n@a\n;;=> 3\n```"}],
                             :full-name "cljs.core/atom",
                             :clj-symbol "clojure.core/atom",
                             :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
           "cljs.reader/read-keyword" {:ns "cljs.reader",
                                       :name "read-keyword",
                                       :type "function",
                                       :signature ["[reader initch]"],
                                       :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        a (re-matches* symbol-pattern token)\n        token (aget a 0)\n        ns (aget a 1)\n        name (aget a 2)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if (and (not (nil? ns)) (> (.-length ns) 0))\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [337 351]},
                                       :full-name "cljs.reader/read-keyword",
                                       :full-name-encode "cljs.reader_read-keyword",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/Vector" {:ns "cljs.core",
                               :name "Vector",
                               :signature ["[meta array __hash]"],
                               :history [["+" "0.0-927"]
                                         ["-" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core_Vector",
                               :source {:code "(deftype Vector [meta array ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (alength array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (alength array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array nil))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (alength array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (alength array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (alength array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (alength array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :repo "clojurescript",
                                        :tag "r1586",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2772 2857]},
                               :full-name "cljs.core/Vector",
                               :removed {:in "0.0-1798",
                                         :last-seen "0.0-1586"}},
           "cljs.reader/skip-line" {:ns "cljs.reader",
                                    :name "skip-line",
                                    :signature ["[reader _]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader_skip-line",
                                    :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (identical? ch \\newline) (identical? ch \\return) (nil? ch))\n        reader\n        (recur)))))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [89 96]},
                                    :full-name "cljs.reader/skip-line",
                                    :docstring "Advances the reader to the end of a line. Returns the reader"},
           "cljs.core/namespace" {:ns "cljs.core",
                                  :name "namespace",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core_namespace",
                                  :source {:code "(defn namespace\n  [x]\n  (if (implements? INamed x)\n    (-namespace ^not-native x)\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2533 2538]},
                                  :full-name "cljs.core/namespace",
                                  :clj-symbol "clojure.core/namespace",
                                  :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
           "cljs.nodejs/require" {:ns "cljs.nodejs",
                                  :name "require",
                                  :type "var",
                                  :source {:code "(def require (js* \"require\"))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [15]},
                                  :full-name "cljs.nodejs/require",
                                  :full-name-encode "cljs.nodejs_require",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/chunk-rest" {:ns "cljs.core",
                                   :name "chunk-rest",
                                   :type "function",
                                   :signature ["[s]"],
                                   :source {:code "(defn chunk-rest [s]\n  (-chunked-rest s))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2750 2751]},
                                   :full-name "cljs.core/chunk-rest",
                                   :full-name-encode "cljs.core_chunk-rest",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/unchecked-long" {:ns "cljs.core",
                                       :name "unchecked-long",
                                       :signature ["[x]"],
                                       :history [["+" "0.0-1798"]],
                                       :type "function",
                                       :full-name-encode "cljs.core_unchecked-long",
                                       :source {:code "(defn unchecked-long\n  [x]\n  (fix x))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [2051 2054]},
                                       :full-name "cljs.core/unchecked-long",
                                       :clj-symbol "clojure.core/unchecked-long",
                                       :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.repl.server/connection" {:ns "cljs.repl.server",
                                          :name "connection",
                                          :signature ["[]"],
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.server_connection",
                                          :source {:code "(defn connection\n  []\n  (let [p    (promise)\n        conn (:connection @state)]\n    (if (and conn (not (.isClosed conn)))\n      (do\n        (deliver p conn)\n        p)\n      (do\n        (swap! state (fn [old] (assoc old :promised-conn p)))\n        p))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/repl/server.clj",
                                                   :lines [14 26]},
                                          :full-name "cljs.repl.server/connection",
                                          :docstring "Promise to return a connection when one is available. If a\nconnection is not available, store the promise in server/state."},
           "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                              :name "EventType",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-2301"]],
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.event_EventType",
                                              :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                       :repo "clojurescript",
                                                       :tag "r2280",
                                                       :filename "src/cljs/clojure/browser/event.cljs",
                                                       :lines [17 18]},
                                              :methods [{:name "event-types",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.event/EventType",
                                              :removed {:in "0.0-2301",
                                                        :last-seen "0.0-2280"}},
           "cljs.core/ranged-iterator" {:ns "cljs.core",
                                        :name "ranged-iterator",
                                        :type "function",
                                        :signature ["[v start end]"],
                                        :source {:code "(defn ranged-iterator [v start end]\n  (let [i start]\n    (RangedIterator. i (- i (js-mod i 32))\n      (when (< start (count v))\n        (unchecked-array-for v i))\n      v start end)))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4266 4271]},
                                        :full-name "cljs.core/ranged-iterator",
                                        :full-name-encode "cljs.core_ranged-iterator",
                                        :history [["+" "0.0-2371"]]},
           "cljs.repl.rhino/rhino-setup" {:ns "cljs.repl.rhino",
                                          :name "rhino-setup",
                                          :type "function",
                                          :signature ["[repl-env opts]"],
                                          :source {:code "(defn rhino-setup [repl-env opts]\n  (let [env   (ana/empty-env)\n        scope (:scope repl-env)]\n    (ScriptableObject/putProperty scope \"__repl_opts\"\n      (Context/javaToJS opts scope))\n    (repl/load-file repl-env \"cljs/core.cljs\" opts)\n    (ScriptableObject/putProperty scope\n      \"out\" (Context/javaToJS *out* scope))\n    (binding [ana/*cljs-ns* 'cljs.core]\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(do\n           (set! (.-isProvided_ js/goog) (fn [_] false))\n           (set! *print-fn* (fn [x] (.write js/out x))))))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [118 130]},
                                          :full-name "cljs.repl.rhino/rhino-setup",
                                          :full-name-encode "cljs.repl.rhino_rhino-setup",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/merge" {:description "Returns a map that consists of the rest of the maps `conj`-ed onto the first.\n\nIf a key occurs in more than one map, the mapping from the rightmost map will\n\"win\".",
                              :ns "cljs.core",
                              :name "merge",
                              :signature ["[& maps]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/merge-with"
                                        "cljs.core/hash-map"],
                              :full-name-encode "cljs.core_merge",
                              :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                       :repo "clojurescript",
                                       :tag "r2911",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7313 7319]},
                              :full-name "cljs.core/merge",
                              :clj-symbol "clojure.core/merge",
                              :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
           "clojure.core.reducers/remove" {:ns "clojure.core.reducers",
                                           :name "remove",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers_remove",
                                           :source {:code "(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (filter (complement pred) coll))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [145 150]},
                                           :full-name "clojure.core.reducers/remove",
                                           :clj-symbol "clojure.core.reducers/remove",
                                           :docstring "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.build.api/src-file->goog-require" {:return-type String,
                                                    :ns "cljs.build.api",
                                                    :name "src-file->goog-require",
                                                    :signature ["[src]"
                                                                "[src options]"],
                                                    :history [["+"
                                                               "0.0-2629"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.build.api_src-file-GTgoog-require",
                                                    :source {:code "(defn ^String src-file->goog-require\n  ([src] (closure/src-file->goog-require src))\n  ([src options]\n    (closure/src-file->goog-require src options)))",
                                                             :repo "clojurescript",
                                                             :tag "r2911",
                                                             :filename "src/clj/cljs/build/api.clj",
                                                             :lines [86
                                                                     91]},
                                                    :full-name "cljs.build.api/src-file->goog-require",
                                                    :docstring "Given a ClojureScript or Google Closure style JavaScript source file return\nthe goog.require statement for it."},
           "cljs.repl.node/write" {:ns "cljs.repl.node",
                                   :name "write",
                                   :type "function",
                                   :signature ["[out js]"],
                                   :source {:code "(defn write [^BufferedWriter out ^String js]\n  (.write out js)\n  (.write out (int 0)) ;; terminator\n  (.flush out))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/repl/node.clj",
                                            :lines [34 37]},
                                   :full-name "cljs.repl.node/write",
                                   :full-name-encode "cljs.repl.node_write",
                                   :history [["+" "0.0-2629"]]},
           "cljs.repl/read-source-map" {:ns "cljs.repl",
                                        :name "read-source-map",
                                        :signature ["[f]"],
                                        :history [["+" "0.0-2814"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl_read-source-map",
                                        :source {:code "(defn read-source-map\n  [f]\n  (let [smf (io/file (str f \".map\"))]\n    (when (.exists smf)\n      (sm/decode (json/read-str (slurp smf) :key-fn keyword)))))",
                                                 :repo "clojurescript",
                                                 :tag "r2911",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [173 178]},
                                        :full-name "cljs.repl/read-source-map",
                                        :docstring "Return the source map for the JavaScript source file."},
           "cljs.core/set-entries-iterator" {:ns "cljs.core",
                                             :name "set-entries-iterator",
                                             :signature ["[coll]"],
                                             :history [["+"
                                                        "0.0-2268"]
                                                       ["-"
                                                        "0.0-2371"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_set-entries-iterator",
                                             :source {:code "(defn set-entries-iterator [coll]\n  (SetEntriesIterator. (seq coll)))",
                                                      :repo "clojurescript",
                                                      :tag "r2356",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [4896
                                                              4897]},
                                             :full-name "cljs.core/set-entries-iterator",
                                             :removed {:in "0.0-2371",
                                                       :last-seen "0.0-2356"}},
           "clojure.browser.repl/send-result" {:ns "clojure.browser.repl",
                                               :name "send-result",
                                               :type "function",
                                               :signature ["[connection url data]"],
                                               :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/clojure/browser/repl.cljs",
                                                        :lines [43 44]},
                                               :full-name "clojure.browser.repl/send-result",
                                               :full-name-encode "clojure.browser.repl_send-result",
                                               :history [["+"
                                                          "0.0-927"]]},
           "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                           :name "keywordize-keys",
                                           :signature ["[m]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk_keywordize-keys",
                                           :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [64 70]},
                                           :full-name "clojure.walk/keywordize-keys",
                                           :clj-symbol "clojure.walk/keywordize-keys",
                                           :docstring "Recursively transforms all map keys from strings to keywords."},
           "cljs.core/entries-iterator" {:ns "cljs.core",
                                         :name "entries-iterator",
                                         :signature ["[coll]"],
                                         :history [["+" "0.0-2268"]
                                                   ["-" "0.0-2371"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_entries-iterator",
                                         :source {:code "(defn entries-iterator [coll]\n  (EntriesIterator. (seq coll)))",
                                                  :repo "clojurescript",
                                                  :tag "r2356",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [4883 4884]},
                                         :full-name "cljs.core/entries-iterator",
                                         :removed {:in "0.0-2371",
                                                   :last-seen "0.0-2356"}},
           "cljs.core/reduced" {:ns "cljs.core",
                                :name "reduced",
                                :signature ["[x]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core_reduced",
                                :source {:code "(defn reduced\n  [x]\n  (Reduced. x))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [898 901]},
                                :full-name "cljs.core/reduced",
                                :clj-symbol "clojure.core/reduced",
                                :docstring "Wraps x in a way such that a reduce will terminate with the value x"},
           "cljs.reader/read-string*" {:ns "cljs.reader",
                                       :name "read-string*",
                                       :type "function",
                                       :signature ["[reader _]"],
                                       :source {:code "(defn read-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading\")\n     (identical? \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (identical? \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [293 302]},
                                       :full-name "cljs.reader/read-string*",
                                       :full-name-encode "cljs.reader_read-stringSTAR",
                                       :history [["+" "0.0-1236"]]},
           "cljs.core/ChunkedCons" {:ns "cljs.core",
                                    :name "ChunkedCons",
                                    :signature ["[chunk more meta __hash]"],
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core_ChunkedCons",
                                    :source {:code "(deftype ChunkedCons [chunk more meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IWithMeta\n  (-with-meta [coll m]\n    (ChunkedCons. chunk more m __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ASeq\n  ISeq\n  (-first [coll] (-nth chunk 0))\n  (-rest [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (if (nil? more)\n        ()\n        more)))\n\n  INext\n  (-next [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (let [more (-seq more)]\n        (when-not (nil? more)\n          more))))\n\n  IChunkedSeq\n  (-chunked-first [coll] chunk)\n  (-chunked-rest [coll]\n    (if (nil? more)\n      ()\n      more))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (if (nil? more)\n      nil\n      more))\n\n  ICollection\n  (-conj [this o]\n    (cons o this))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash)))",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2672 2732]},
                                    :full-name "cljs.core/ChunkedCons",
                                    :clj-symbol "clojure.lang/ChunkedCons"},
           "cljs.core/derive" {:ns "cljs.core",
                               :name "derive",
                               :signature ["[tag parent]"
                                           "[h tag parent]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core_derive",
                               :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap-global-hierarchy! derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8825 8857]},
                               :full-name "cljs.core/derive",
                               :clj-symbol "clojure.core/derive",
                               :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "clojure.zip/zipper" {:ns "clojure.zip",
                                 :name "zipper",
                                 :signature ["[branch? children make-node root]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_zipper",
                                 :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [18 32]},
                                 :full-name "clojure.zip/zipper",
                                 :clj-symbol "clojure.zip/zipper",
                                 :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
           "cljs.test/empty-env" {:ns "cljs.test",
                                  :name "empty-env",
                                  :type "function",
                                  :signature ["[]" "[reporter]"],
                                  :source {:code "(defn empty-env\n  ([] (empty-env ::default))\n  ([reporter]\n   {:report-counters {:test 0 :pass 0 :fail 0 :error 0}\n    :testing-vars ()\n    :testing-contexts ()\n    :reporter reporter}))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/test.cljs",
                                           :lines [251 257]},
                                  :full-name "cljs.test/empty-env",
                                  :full-name-encode "cljs.test_empty-env",
                                  :history [["+" "0.0-2496"]]},
           "clojure.core.reducers/mapcat" {:ns "clojure.core.reducers",
                                           :name "mapcat",
                                           :signature ["[f]"
                                                       "[f coll]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers_mapcat",
                                           :source {:code "(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [106 115]},
                                           :full-name "clojure.core.reducers/mapcat",
                                           :clj-symbol "clojure.core.reducers/mapcat",
                                           :docstring "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."},
           "clojure.zip/remove" {:ns "clojure.zip",
                                 :name "remove",
                                 :signature ["[loc]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip_remove",
                                 :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [237 251]},
                                 :full-name "clojure.zip/remove",
                                 :clj-symbol "clojure.zip/remove",
                                 :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
           "syntax/var" {:description "Accesses the var attached to the given symbol.\n\n`#'x` = `(var x)`",
                         :ns "syntax",
                         :name "var",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["special/var"],
                         :full-name-encode "syntax_var",
                         :source {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                  :repo "tools.reader",
                                  :tag "tools.reader-0.8.10",
                                  :filename "src/main/clojure/clojure/tools/reader.clj",
                                  :lines [612 623]},
                         :extra-sources [{:code "(defn- wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [335 338]}],
                         :syntax-form "#'",
                         :examples [{:id "673ef6",
                                     :content "Access the metadata of a var:\n\n```clj\n(def x 123)\n(meta #'x)\n;;=> {:arglists (), :test nil, :name x, :column 1, :line 1, :file \"<cljs repl>\", :doc nil, :ns cljs.user}\n```"}],
                         :full-name "syntax/var",
                         :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/find" {:description "Returns the map entry for key `k`, or nil if `k` is not found.",
                             :ns "cljs.core",
                             :name "find",
                             :signature ["[coll k]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/get"
                                       "cljs.core/get-in"],
                             :full-name-encode "cljs.core_find",
                             :source {:code "(defn find\n  [coll k]\n  (when (and (not (nil? coll))\n             (associative? coll)\n             (contains? coll k))\n    [k (get coll k)]))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1633 1639]},
                             :full-name "cljs.core/find",
                             :clj-symbol "clojure.core/find",
                             :docstring "Returns the map entry for key, or nil if key not present."},
           "cljs.repl.node/repl-env*" {:ns "cljs.repl.node",
                                       :name "repl-env*",
                                       :type "function",
                                       :signature ["[options]"],
                                       :source {:code "(defn repl-env* [options]\n  (let [{:keys [host port]}\n        (merge\n          {:host \"localhost\"\n           :port (+ 49000 (rand-int 10000))}\n          options)]\n    (NodeEnv. host port (atom nil) (atom nil))))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/clj/cljs/repl/node.clj",
                                                :lines [186 192]},
                                       :full-name "cljs.repl.node/repl-env*",
                                       :full-name-encode "cljs.repl.node_repl-envSTAR",
                                       :history [["+" "0.0-2629"]]},
           "cljs.core/hash-set" {:description "Returns a new hash set with supplied `keys`.\n\nAny equal keys are handled as if by repeated uses of `conj`.",
                                 :ns "cljs.core",
                                 :name "hash-set",
                                 :signature ["[]" "[& keys]"],
                                 :history [["+" "0.0-1443"]],
                                 :type "function",
                                 :related ["cljs.core/set"
                                           "cljs.core/sorted-set"],
                                 :full-name-encode "cljs.core_hash-set",
                                 :source {:code "(defn hash-set\n  ([] #{})\n  ([& keys] (set keys)))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7603 7605]},
                                 :extra-sources ({:code "(defmacro hash-set\n  ([] `(.-EMPTY cljs.core/PersistentHashSet))\n  ([& xs]\n    (if (core/and (core/<= (count xs) 8)\n                  (every? #(= (:op %) :constant)\n                    (map #(cljs.analyzer/analyze &env %) xs))\n                  (= (count (into #{} xs)) (count xs)))\n      `(cljs.core/PersistentHashSet. nil\n         (cljs.core/PersistentArrayMap. nil ~(count xs) (array ~@(interleave xs (repeat nil))) nil)\n         nil)\n      (vary-meta\n        `(.fromArray cljs.core/PersistentHashSet (array ~@xs) true)\n        assoc :tag 'cljs.core/PersistentHashSet))))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1450 1462]}),
                                 :full-name "cljs.core/hash-set",
                                 :clj-symbol "clojure.core/hash-set"},
           "cljs.core/*print-dup*" {:ns "cljs.core",
                                    :name "*print-dup*",
                                    :type "dynamic var",
                                    :source {:code "(def ^:dynamic *print-dup* false)",
                                             :repo "clojurescript",
                                             :tag "r2911",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [36]},
                                    :full-name "cljs.core/*print-dup*",
                                    :full-name-encode "cljs.core_STARprint-dupSTAR",
                                    :clj-symbol "clojure.core/*print-dup*",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/set-from-indexed-seq" {:ns "cljs.core",
                                             :name "set-from-indexed-seq",
                                             :type "function",
                                             :signature ["[iseq]"],
                                             :source {:code "(defn set-from-indexed-seq [iseq]\n  (let [arr (.-arr iseq)\n        ret (areduce arr i ^not-native res (-as-transient #{})\n              (-conj! res (aget arr i)))]\n    (-persistent! ^not-native ret)))",
                                                      :repo "clojurescript",
                                                      :tag "r2911",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [7580
                                                              7584]},
                                             :full-name "cljs.core/set-from-indexed-seq",
                                             :full-name-encode "cljs.core_set-from-indexed-seq",
                                             :history [["+"
                                                        "0.0-1877"]]},
           "cljs.core/object-array" {:ns "cljs.core",
                                     :name "object-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :history [["+" "0.0-1211"]],
                                     :type "function",
                                     :full-name-encode "cljs.core_object-array",
                                     :source {:code "(defn object-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (object-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2841 2859]},
                                     :full-name "cljs.core/object-array",
                                     :clj-symbol "clojure.core/object-array"},
           "cljs.core/indexed?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "indexed?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_indexedQMARK",
                                 :source {:code "(defn ^boolean indexed?\n  [x] (satisfies? IIndexed x))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [994 996]},
                                 :full-name "cljs.core/indexed?",
                                 :docstring "Returns true if coll implements nth in constant time"},
           "cljs.core/partial" {:description "Takes a function `f` and fewer than the normal arguments to `f`. Returns a\nfunction that takes a variable number of additional arguments. When called, the\nreturned function calls `f` with the original arguments plus the additional\narguments.\n\n`((partial f a b) c d)` => `(f a b c d)`",
                                :ns "cljs.core",
                                :name "partial",
                                :signature ["[f]"
                                            "[f arg1]"
                                            "[f arg1 arg2]"
                                            "[f arg1 arg2 arg3]"
                                            "[f arg1 arg2 arg3 & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/comp"
                                          "cljs.core/juxt"],
                                :full-name-encode "cljs.core_partial",
                                :source {:code "(defn partial\n  ([f] f)\n  ([f arg1]\n   (fn\n     ([] (f arg1))\n     ([x] (f arg1 x))\n     ([x y] (f arg1 x y))\n     ([x y z] (f arg1 x y z))\n     ([x y z & args] (apply f arg1 x y z args))))\n  ([f arg1 arg2]\n   (fn\n     ([] (f arg1 arg2))\n     ([x] (f arg1 arg2 x))\n     ([x y] (f arg1 arg2 x y))\n     ([x y z] (f arg1 arg2 x y z))\n     ([x y z & args] (apply f arg1 arg2 x y z args))))\n  ([f arg1 arg2 arg3]\n   (fn\n     ([] (f arg1 arg2 arg3))\n     ([x] (f arg1 arg2 arg3 x))\n     ([x y] (f arg1 arg2 arg3 x y))\n     ([x y z] (f arg1 arg2 arg3 x y z))\n     ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3376 3403]},
                                :full-name "cljs.core/partial",
                                :clj-symbol "clojure.core/partial",
                                :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
           "cljs.core/keyword?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "keyword?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core_keywordQMARK",
                                 :source {:code "(defn ^boolean keyword? [x]\n  (instance? Keyword x))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2522 2523]},
                                 :extra-sources ({:code "(defmacro keyword? [x]\n  (bool-expr `(instance? Keyword ~x)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [337 338]}),
                                 :full-name "cljs.core/keyword?",
                                 :clj-symbol "clojure.core/keyword?"},
           "clojure.browser.event/fire-listeners" {:ns "clojure.browser.event",
                                                   :name "fire-listeners",
                                                   :type "function",
                                                   :signature ["[obj type capture event]"],
                                                   :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                            :repo "clojurescript",
                                                            :tag "r2911",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [84
                                                                    85]},
                                                   :full-name "clojure.browser.event/fire-listeners",
                                                   :full-name-encode "clojure.browser.event_fire-listeners",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/Iterator" {:ns "cljs.core",
                                 :name "Iterator",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-2268"]
                                           ["-" "0.0-2371"]],
                                 :type "type",
                                 :full-name-encode "cljs.core_Iterator",
                                 :source {:code "(deftype Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))",
                                          :repo "clojurescript",
                                          :tag "r2356",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4861 4868]},
                                 :full-name "cljs.core/Iterator",
                                 :removed {:in "0.0-2371",
                                           :last-seen "0.0-2356"}},
           "cljs.core/vreset!" {:ns "cljs.core",
                                :name "vreset!",
                                :signature ["[vol newval]"],
                                :history [["+" "0.0-2496"]],
                                :type "function",
                                :full-name-encode "cljs.core_vresetBANG",
                                :source {:code "(defn vreset!\n  [vol newval]  (-vreset! vol newval))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3617 3620]},
                                :full-name "cljs.core/vreset!",
                                :docstring "Sets the value of volatile to newval without regard for the\ncurrent value. Returns newval."},
           "cljs.core/interleave" {:description "Returns a lazy seq of the first item in each collection, then the second items,\nthen the third, etc.",
                                   :ns "cljs.core",
                                   :name "interleave",
                                   :signature ["[c1 c2]"
                                               "[c1 c2 & colls]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/interpose"
                                             "cljs.core/zipmap"],
                                   :full-name-encode "cljs.core_interleave",
                                   :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3902 3914]},
                                   :full-name "cljs.core/interleave",
                                   :clj-symbol "clojure.core/interleave",
                                   :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
           "cljs.core/TransientHashSet" {:ns "cljs.core",
                                         :name "TransientHashSet",
                                         :signature ["[transient-map]"],
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core_TransientHashSet",
                                         :source {:code "(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [7450 7485]},
                                         :full-name "cljs.core/TransientHashSet",
                                         :clj-symbol "clojure.lang/TransientHashSet"},
           "cljs.core/*flush-on-newline*" {:ns "cljs.core",
                                           :name "*flush-on-newline*",
                                           :type "dynamic var",
                                           :source {:code "(def ^:dynamic *flush-on-newline* true)",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [32]},
                                           :full-name "cljs.core/*flush-on-newline*",
                                           :full-name-encode "cljs.core_STARflush-on-newlineSTAR",
                                           :clj-symbol "clojure.core/*flush-on-newline*",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/get-in" {:description "Returns the value in a nested associative structure, where `ks` is a sequence of\nkeys.\n\nReturns nil if the key is not found, or `not-found` if supplied.",
                               :ns "cljs.core",
                               :name "get-in",
                               :signature ["[m ks]"
                                           "[m ks not-found]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/assoc-in"
                                         "cljs.core/update-in"
                                         "cljs.core/find"
                                         "cljs.core/get"],
                               :full-name-encode "cljs.core_get-in",
                               :source {:code "(defn get-in\n  ([m ks]\n     (get-in m ks nil))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (if (not (satisfies? ILookup m))\n           not-found\n           (let [m (get m (first ks) sentinel)]\n             (if (identical? sentinel m)\n               not-found\n               (recur sentinel m (next ks)))))\n         m))))",
                                        :repo "clojurescript",
                                        :tag "r2911",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4082 4101]},
                               :full-name "cljs.core/get-in",
                               :clj-symbol "clojure.core/get-in",
                               :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of keys. Returns nil if the key is not present,\nor the not-found value if supplied."},
           "clojure.browser.dom/element" {:ns "clojure.browser.dom",
                                          :name "element",
                                          :type "function",
                                          :signature ["[tag-or-text]"
                                                      "[tag & children]"],
                                          :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                   :repo "clojurescript",
                                                   :tag "r2911",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [81 90]},
                                          :full-name "clojure.browser.dom/element",
                                          :full-name-encode "clojure.browser.dom_element",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prim-seq" {:ns "cljs.core",
                                 :name "prim-seq",
                                 :type "function",
                                 :signature ["[prim]" "[prim i]"],
                                 :source {:code "(defn prim-seq\n  ([prim]\n     (prim-seq prim 0))\n  ([prim i]\n     (when (< i (alength prim))\n       (IndexedSeq. prim i))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1077 1082]},
                                 :full-name "cljs.core/prim-seq",
                                 :full-name-encode "cljs.core_prim-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/<=" {:description "Returns true if each successive number argument is greater than or equal to the\nprevious one, false otherwise.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name "<=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :related ["cljs.core/<"],
                           :full-name-encode "cljs.core_LTEQ",
                           :source {:code "(defn ^boolean <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                    :repo "clojurescript",
                                    :tag "r2911",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1885 1895]},
                           :extra-sources ({:code "(defmacro ^::ana/numeric <=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                            :repo "clojurescript",
                                            :tag "r2911",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [440 443]}),
                           :examples [{:id "adb3fd",
                                       :content "```clj\n(<= 1 2)\n;;=> true\n\n(<= 2 2)\n;;=> true\n\n(<= 3 2)\n;;=> false\n\n(<= 2 3 4 5 6)\n;;=> true\n```"}],
                           :full-name "cljs.core/<=",
                           :clj-symbol "clojure.core/<=",
                           :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
           "clojure.set/map-invert" {:ns "clojure.set",
                                     :name "map-invert",
                                     :signature ["[m]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set_map-invert",
                                     :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [97 99]},
                                     :full-name "clojure.set/map-invert",
                                     :clj-symbol "clojure.set/map-invert",
                                     :docstring "Returns the map with the vals mapped to the keys."},
           "clojure.browser.event/listen" {:ns "clojure.browser.event",
                                           :name "listen",
                                           :type "function",
                                           :signature ["[src type fn]"
                                                       "[src type fn capture?]"],
                                           :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (events/listen src\n                    (get (event-types src) type type)\n                    fn\n                    capture?)))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [46 53]},
                                           :full-name "clojure.browser.event/listen",
                                           :full-name-encode "clojure.browser.event_listen",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/neg?" {:description "Returns true if `n` is less than 0, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "neg?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/pos?"
                                       "cljs.core/zero?"],
                             :full-name-encode "cljs.core_negQMARK",
                             :source {:code "(defn ^boolean neg?\n  [x] (cljs.core/neg? x))",
                                      :repo "clojurescript",
                                      :tag "r2911",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2178 2180]},
                             :extra-sources ({:code "(defmacro ^::ana/numeric neg? [x]\n  `(< ~x 0))",
                                              :repo "clojurescript",
                                              :tag "r2911",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [472 473]}),
                             :full-name "cljs.core/neg?",
                             :clj-symbol "clojure.core/neg?",
                             :docstring "Returns true if num is less than zero, else false"},
           "cljs.analyzer.api/ns-interns" {:ns "cljs.analyzer.api",
                                           :name "ns-interns",
                                           :signature ["[ns]"],
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api_ns-interns",
                                           :source {:code "(defn ns-interns\n  [ns]\n  {:pre [(symbol? ns)]}\n  (get-in @env/*compiler* [::ana/namespaces ns :defs]))",
                                                    :repo "clojurescript",
                                                    :tag "r2911",
                                                    :filename "src/clj/cljs/analyzer/api.clj",
                                                    :lines [37 42]},
                                           :full-name "cljs.analyzer.api/ns-interns",
                                           :clj-symbol "clojure.core/ns-interns",
                                           :docstring "Given a namespace return all the var analysis maps. Analagous to\nclojure.core/ns-interns but returns var analysis maps not vars."},
           "cljs.core/mix-collection-hash" {:return-type number,
                                            :ns "cljs.core",
                                            :name "mix-collection-hash",
                                            :signature ["[hash-basis count]"],
                                            :history [["+" "0.0-2261"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_mix-collection-hash",
                                            :source {:code "(defn ^number mix-collection-hash\n  [hash-basis count]\n  (let [h1 m3-seed\n        k1 (m3-mix-K1 hash-basis)\n        h1 (m3-mix-H1 h1 k1)]\n    (m3-fmix h1 count)))",
                                                     :repo "clojurescript",
                                                     :tag "r2911",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [813 823]},
                                            :full-name "cljs.core/mix-collection-hash",
                                            :clj-symbol "clojure.core/mix-collection-hash",
                                            :docstring "Mix final collection hash for ordered or unordered collections.\nhash-basis is the combined collection hash, count is the number\nof elements included in the basis. Note this is the hash code\nconsistent with =, different from .hashCode.\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "clojure.browser.dom/replace-node" {:ns "clojure.browser.dom",
                                               :name "replace-node",
                                               :signature ["[old-node new-node]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.dom_replace-node",
                                               :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                        :repo "clojurescript",
                                                        :tag "r2911",
                                                        :filename "src/cljs/clojure/browser/dom.cljs",
                                                        :lines [114
                                                                122]},
                                               :full-name "clojure.browser.dom/replace-node",
                                               :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string."},
           "syntax/boolean" {:description "`true` or `false`",
                             :ns "syntax",
                             :name "boolean",
                             :history [["+" "0.0-927"]],
                             :type "special symbol",
                             :related ["cljs.core/boolean"
                                       "special/if"
                                       "cljs.core/if-not"
                                       "cljs.core/not"
                                       "cljs.core/cond"],
                             :full-name-encode "syntax_boolean",
                             :source {:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                      :repo "tools.reader",
                                      :tag "tools.reader-0.8.10",
                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                      :lines [275 301]},
                             :syntax-form ["true" "false"],
                             :examples [{:id "1afc59",
                                         :content "```clj\ntrue\n;;=> true\n\nfalse\n;;=> false\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#booleans",
                             :full-name "syntax/boolean",
                             :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/destructure" {:ns "syntax",
                                 :name "destructure",
                                 :history [["+" "0.0-927"]],
                                 :type "binding",
                                 :full-name-encode "syntax_destructure",
                                 :source {:code "(defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n         pb (fn pb [bvec b v]\n              (core/let [pvec\n                     (fn [bvec b val]\n                       (core/let [gvec (gensym \"vec__\")]\n                         (core/loop [ret (-> bvec (conj gvec) (conj val))\n                                     n 0\n                                     bs b\n                                     seen-rest? false]\n                           (if (seq bs)\n                             (core/let [firstb (first bs)]\n                               (core/cond\n                                 (= firstb '&) (recur (pb ret (second bs) (core/list `nthnext gvec n))\n                                                      n\n                                                      (nnext bs)\n                                                      true)\n                                 (= firstb :as) (pb ret (second bs) gvec)\n                                 :else (if seen-rest?\n                                         (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                         (recur (pb ret firstb (core/list `nth gvec n nil))\n                                                (core/inc n)\n                                                (next bs)\n                                                seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (core/let [gmap (gensym \"map__\")\n                                  defaults (:or b)]\n                         (core/loop [ret (-> bvec (conj gmap) (conj v)\n                                             (conj gmap) (conj `(if (seq? ~gmap) (apply core/hash-map ~gmap) ~gmap))\n                                             ((fn [ret]\n                                                (if (:as b)\n                                                  (conj ret (:as b) gmap)\n                                                  ret))))\n                                     bes (reduce\n                                          (fn [bes entry]\n                                            (reduce #(assoc %1 %2 ((val entry) %2))\n                                                    (dissoc bes (key entry))\n                                                    ((key entry) bes)))\n                                          (dissoc b :as :or)\n                                          {:keys #(if (core/keyword? %) % (keyword (core/str %))),\n                                           :strs core/str, :syms #(core/list `quote %)})]\n                           (if (seq bes)\n                             (core/let [bb (key (first bes))\n                                        bk (val (first bes))\n                                        has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (core/list `get gmap bk (defaults bb))\n                                                   (core/list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                    (core/cond\n                      (core/symbol? b) (-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw (new Exception (core/str \"Unsupported binding form: \" b))))))\n         process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n        (if (every? core/symbol? (map first bents))\n          bindings\n          (if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n            (throw (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs))))\n            (reduce process-entry [] bents)))))",
                                          :repo "clojurescript",
                                          :tag "r2911",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [82 145]},
                                 :syntax-form [":keys"
                                               ":syms"
                                               ":strs"
                                               ":or"
                                               ":as"
                                               "&"],
                                 :full-name "syntax/destructure",
                                 :clj-doc "http://clojure.org/special_forms#toc18"},
           "special/catch" {:description "`catch` should be used inside of a `try` expression.\n\n`exception-type` should be the type of exception thrown (usually `js/Error` or\n`js/Object`). When there is a match, the thrown exception will be bound to\n`name` inside of `expr*` and `expr*` will be evaluated and returned as the value\nof the `try` expression.",
                            :ns "special",
                            :name "catch",
                            :signature ["[exception-type name expr*]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :related ["special/try"
                                      "special/finally"
                                      "special/throw"],
                            :full-name-encode "special_catch",
                            :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                     :repo "clojurescript",
                                     :tag "r2911",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [606 665]},
                            :full-name "special/catch",
                            :clj-symbol "clojure.core/catch"},
           "cljs.core/reverse" {:description "Returns a sequence of the items in `coll` in reverse order. Not lazy.",
                                :ns "cljs.core",
                                :name "reverse",
                                :signature ["[coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/rseq"],
                                :full-name-encode "cljs.core_reverse",
                                :source {:code "(defn reverse\n  [coll]\n  (if (reversible? coll)\n    (rseq coll)\n    (reduce conj () coll)))",
                                         :repo "clojurescript",
                                         :tag "r2911",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2397 2402]},
                                :full-name "cljs.core/reverse",
                                :clj-symbol "clojure.core/reverse",
                                :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
           "cljs.repl.browser/ordering" {:ns "cljs.repl.browser",
                                         :name "ordering",
                                         :type "var",
                                         :source {:code "(def ordering (agent {:expecting nil :fns {}}))",
                                                  :repo "clojurescript",
                                                  :tag "r2911",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [122]},
                                         :full-name "cljs.repl.browser/ordering",
                                         :full-name-encode "cljs.repl.browser_ordering",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/realized?" {:description "Returns true if a value has been produced for a lazy sequence.",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "realized?",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/lazy-seq"],
                                  :full-name-encode "cljs.core_realizedQMARK",
                                  :source {:code "(defn ^boolean realized?\n  [d]\n  (-realized? d))",
                                           :repo "clojurescript",
                                           :tag "r2911",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8556 8559]},
                                  :full-name "cljs.core/realized?",
                                  :clj-symbol "clojure.core/realized?",
                                  :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."},
           "cljs.core/ensure-reduced" {:ns "cljs.core",
                                       :name "ensure-reduced",
                                       :signature ["[x]"],
                                       :history [["+" "0.0-2411"]],
                                       :type "function",
                                       :full-name-encode "cljs.core_ensure-reduced",
                                       :source {:code "(defn ensure-reduced\n  [x]\n  (if (reduced? x) x (reduced x)))",
                                                :repo "clojurescript",
                                                :tag "r2911",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [908 911]},
                                       :full-name "cljs.core/ensure-reduced",
                                       :docstring "If x is already reduced?, returns it, else returns (reduced x)"}},
 :api {:syntax {:changes [{:cljs-version "0.0-927",
                           :cljs-date "2012-01-20",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790",
                           :added #{"syntax/Math-ns"
                                    "syntax/symbol"
                                    "syntax/vector"
                                    "syntax/string"
                                    "syntax/comment"
                                    "syntax/quote"
                                    "syntax/keyword-qualify"
                                    "syntax/meta"
                                    "syntax/regex"
                                    "syntax/eval"
                                    "syntax/unquote-splicing"
                                    "syntax/keyword"
                                    "syntax/character"
                                    "syntax/unreadable"
                                    "syntax/hashbang"
                                    "syntax/arg"
                                    "syntax/set"
                                    "syntax/syntax-quote"
                                    "syntax/dispatch"
                                    "syntax/function"
                                    "syntax/nil"
                                    "syntax/map"
                                    "syntax/number"
                                    "syntax/list"
                                    "syntax/deref"
                                    "syntax/unquote"
                                    "syntax/js-ns"
                                    "syntax/ignore"
                                    "syntax/var"
                                    "syntax/boolean"
                                    "syntax/destructure"}}
                          {:cljs-version "0.0-971",
                           :cljs-date "2012-01-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-993",
                           :cljs-date "2012-02-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1006",
                           :cljs-date "2012-03-30",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1011",
                           :cljs-date "2012-04-02",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1211",
                           :cljs-date "2012-05-09",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376",
                           :added #{"syntax/tagged-literal"}}
                          {:cljs-version "0.0-1236",
                           :cljs-date "2012-05-16",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1424",
                           :cljs-date "2012-06-16",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376",
                           :added #{"syntax/inst-literal"
                                    "syntax/queue-literal"
                                    "syntax/uuid-literal"}}
                          {:cljs-version "0.0-1443",
                           :cljs-date "2012-07-06",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1449",
                           :cljs-date "2012-07-24",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1450",
                           :cljs-date "2012-07-25",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1503",
                           :cljs-date "2012-10-12",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1513",
                           :cljs-date "2012-10-19",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1535",
                           :cljs-date "2012-11-08",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1552",
                           :cljs-date "2012-12-03",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1576",
                           :cljs-date "2013-01-27",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1586",
                           :cljs-date "2013-02-16",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1798",
                           :cljs-date "2013-05-03",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1803",
                           :cljs-date "2013-05-06",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1806",
                           :cljs-date "2013-05-10",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1820",
                           :cljs-date "2013-06-07",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1835",
                           :cljs-date "2013-06-21",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1843",
                           :cljs-date "2013-07-16",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1844",
                           :cljs-date "2013-07-19",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1847",
                           :cljs-date "2013-07-23",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f"}
                          {:cljs-version "0.0-1853",
                           :cljs-date "2013-08-05",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.5",
                           :added #{"syntax/Infinity" "syntax/NaN"}}
                          {:cljs-version "0.0-1859",
                           :cljs-date "2013-08-19",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1877",
                           :cljs-date "2013-09-08",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1878",
                           :cljs-date "2013-09-11",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1885",
                           :cljs-date "2013-09-15",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1886",
                           :cljs-date "2013-09-15",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1889",
                           :cljs-date "2013-09-15",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1895",
                           :cljs-date "2013-09-24",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1896",
                           :cljs-date "2013-09-24",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1909",
                           :cljs-date "2013-09-27",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.8"}
                          {:cljs-version "0.0-1913",
                           :cljs-date "2013-10-05",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.8"}
                          {:cljs-version "0.0-1933",
                           :cljs-date "2013-10-11",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.9"}
                          {:cljs-version "0.0-1934",
                           :cljs-date "2013-10-11",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.9"}
                          {:cljs-version "0.0-1978",
                           :cljs-date "2013-10-28",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2014",
                           :cljs-date "2013-11-06",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2024",
                           :cljs-date "2013-11-08",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2027",
                           :cljs-date "2013-11-08",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2030",
                           :cljs-date "2013-11-08",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2060",
                           :cljs-date "2013-11-21",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2067",
                           :cljs-date "2013-11-22",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2069",
                           :cljs-date "2013-11-22",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2075",
                           :cljs-date "2013-11-23",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2080",
                           :cljs-date "2013-11-23",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2120",
                           :cljs-date "2013-12-13",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0",
                           :added #{"syntax/js-literal"}}
                          {:cljs-version "0.0-2127",
                           :cljs-date "2013-12-20",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2134",
                           :cljs-date "2013-12-30",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2138",
                           :cljs-date "2013-12-31",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2156",
                           :cljs-date "2014-01-29",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2173",
                           :cljs-date "2014-02-22",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2197",
                           :cljs-date "2014-03-26",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2199",
                           :cljs-date "2014-04-01",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2202",
                           :cljs-date "2014-04-02",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2227",
                           :cljs-date "2014-05-22",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2234",
                           :cljs-date "2014-06-13",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2261",
                           :cljs-date "2014-07-02",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140226-71326067",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2268",
                           :cljs-date "2014-07-06",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140226-71326067",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2277",
                           :cljs-date "2014-07-25",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140226-71326067",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2280",
                           :cljs-date "2014-08-01",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2301",
                           :cljs-date "2014-08-07",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2307",
                           :cljs-date "2014-08-07",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2311",
                           :cljs-date "2014-08-09",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2322",
                           :cljs-date "2014-08-27",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2341",
                           :cljs-date "2014-09-18",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2342",
                           :cljs-date "2014-09-18",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.9"}
                          {:cljs-version "0.0-2356",
                           :cljs-date "2014-09-26",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.9"}
                          {:cljs-version "0.0-2371",
                           :cljs-date "2014-10-10",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.9"}
                          {:cljs-version "0.0-2411",
                           :cljs-date "2014-12-05",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2496",
                           :cljs-date "2014-12-17",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2498",
                           :cljs-date "2014-12-19",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2505",
                           :cljs-date "2014-12-21",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2511",
                           :cljs-date "2014-12-22",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2629",
                           :cljs-date "2015-01-01",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2644",
                           :cljs-date "2015-01-02",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2655",
                           :cljs-date "2015-01-03",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2657",
                           :cljs-date "2015-01-03",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2665",
                           :cljs-date "2015-01-04",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2719",
                           :cljs-date "2015-01-24",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2723",
                           :cljs-date "2015-01-24",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2725",
                           :cljs-date "2015-01-24",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2727",
                           :cljs-date "2015-01-25",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2740",
                           :cljs-date "2015-01-28",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2755",
                           :cljs-date "2015-02-01",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2758",
                           :cljs-date "2015-02-02",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2760",
                           :cljs-date "2015-02-02",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2814",
                           :cljs-date "2015-02-10",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2816",
                           :cljs-date "2015-02-10",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2843",
                           :cljs-date "2015-02-12",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2850",
                           :cljs-date "2015-02-13",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2911",
                           :cljs-date "2015-02-21",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}],
                :symbol-names #{"syntax/Math-ns"
                                "syntax/symbol"
                                "syntax/vector"
                                "syntax/inst-literal"
                                "syntax/string"
                                "syntax/comment"
                                "syntax/Infinity"
                                "syntax/quote"
                                "syntax/keyword-qualify"
                                "syntax/meta"
                                "syntax/regex"
                                "syntax/eval"
                                "syntax/unquote-splicing"
                                "syntax/keyword"
                                "syntax/character"
                                "syntax/unreadable"
                                "syntax/hashbang"
                                "syntax/arg"
                                "syntax/set"
                                "syntax/tagged-literal"
                                "syntax/syntax-quote"
                                "syntax/dispatch"
                                "syntax/queue-literal"
                                "syntax/function"
                                "syntax/nil"
                                "syntax/map"
                                "syntax/number"
                                "syntax/js-literal"
                                "syntax/list"
                                "syntax/uuid-literal"
                                "syntax/deref"
                                "syntax/unquote"
                                "syntax/NaN"
                                "syntax/js-ns"
                                "syntax/ignore"
                                "syntax/var"
                                "syntax/boolean"
                                "syntax/destructure"}},
       :library {:changes [{:cljs-version "0.0-927",
                            :cljs-date "2012-01-20",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/keys"
                                     "cljs.core/reset!"
                                     "clojure.set/select"
                                     "cljs.core/delay"
                                     "cljs.core/bit-not"
                                     "cljs.core/partition"
                                     "cljs.core/parents"
                                     "cljs.core/aclone"
                                     "cljs.core/reset-meta!"
                                     "special/defrecord*"
                                     "cljs.reader/dispatch-macros"
                                     "cljs.core/ICollection"
                                     "cljs.core/every?"
                                     "clojure.zip/node"
                                     "cljs.core/IEmptyableCollection"
                                     "clojure.zip/right"
                                     "cljs.core/=="
                                     "special/."
                                     "clojure.browser.net/*timeout*"
                                     "cljs.core/remove-method"
                                     "cljs.core/frequencies"
                                     "cljs.core/pop"
                                     "cljs.core/not-every?"
                                     "cljs.core/some-fn"
                                     "clojure.browser.event/remove-all"
                                     "cljs.core/doto"
                                     "cljs.core/take-while"
                                     "cljs.reader/escape-char-map"
                                     "clojure.browser.event/all-listeners"
                                     "cljs.core/vals"
                                     "cljs.core/IDeref"
                                     "clojure.browser.dom/log-obj"
                                     "cljs.core/for"
                                     "cljs.core/instance?"
                                     "cljs.reader/read-comment"
                                     "cljs.reader/read-number"
                                     "cljs.core/ILookup"
                                     "cljs.core/when"
                                     "clojure.browser.dom/set-value"
                                     "cljs.reader/read-past"
                                     "cljs.core/to-array"
                                     "cljs.core/interpose"
                                     "clojure.browser.net/ICrossPageChannel"
                                     "special/finally"
                                     "cljs.core/Cons"
                                     "cljs.core/re-find"
                                     "cljs.core/IMeta"
                                     "cljs.core/assoc-in"
                                     "clojure.string/join"
                                     "clojure.zip/rights"
                                     "cljs.core/split-at"
                                     "clojure.zip/append-child"
                                     "cljs.core/binding"
                                     "cljs.core/Set"
                                     "cljs.reader/macro-terminating?"
                                     "cljs.core/prefers"
                                     "cljs.core/vary-meta"
                                     "cljs.core/when-let"
                                     "cljs.core/drop"
                                     "cljs.core/while"
                                     "cljs.core/import-macros"
                                     "cljs.core/string-print"
                                     "cljs.core/-"
                                     "clojure.zip/vector-zip"
                                     "cljs.core/js->clj"
                                     "cljs.core/List"
                                     "cljs.core/identical?"
                                     "cljs.core/*main-cli-fn*"
                                     "clojure.browser.dom/html->dom"
                                     "cljs.core/some"
                                     "cljs.core/doall"
                                     "cljs.core/condp"
                                     "clojure.zip/down"
                                     "cljs.core/IPending"
                                     "cljs.core/count"
                                     "cljs.core/bit-test"
                                     "cljs.core/loop"
                                     "cljs.core/subvec"
                                     "cljs.core/bit-clear"
                                     "cljs.core/gensym"
                                     "special/recur"
                                     "cljs.core/+"
                                     "cljs.core/comp"
                                     "cljs.reader/desugar-meta"
                                     "cljs.core/pr"
                                     "clojure.string/upper-case"
                                     "clojure.browser.event/expose"
                                     "clojure.browser.event/listen-once"
                                     "cljs.core/empty?"
                                     "cljs.core/newline"
                                     "cljs.core/replace"
                                     "cljs.core/rand"
                                     "cljs.core/add-watch"
                                     "clojure.string/capitalize"
                                     "cljs.core/replicate"
                                     "special/do"
                                     "cljs.core/sequential?"
                                     "cljs.core/underive"
                                     "cljs.core/get-method"
                                     "cljs.core/="
                                     "cljs.core/defn-"
                                     "cljs.reader/read-symbol"
                                     "cljs.reader/push-back-reader"
                                     "cljs.core/deftype"
                                     "cljs.core/Subvec"
                                     "special/ns"
                                     "cljs.core/extend-protocol"
                                     "cljs.reader/read"
                                     "cljs.core/EmptyList"
                                     "clojure.walk/postwalk"
                                     "clojure.zip/edit"
                                     "cljs.core/re-seq"
                                     "cljs.reader/read-list"
                                     "cljs.core/Atom"
                                     "cljs.core/IMap"
                                     "cljs.reader/read-vector"
                                     "clojure.set/join"
                                     "cljs.core/HashMap"
                                     "cljs.reader/int-pattern"
                                     "cljs.core/swap!"
                                     "cljs.core/dec"
                                     "clojure.browser.dom/remove-children"
                                     "cljs.core/get-validator"
                                     "cljs.core/coll?"
                                     "cljs.core/bit-or"
                                     "cljs.core/nfirst"
                                     "cljs.core/keep"
                                     "cljs.core/take"
                                     "cljs.core/cond"
                                     "cljs.core/bit-and"
                                     "cljs.core/ObjMap.fromObject"
                                     "clojure.browser.event/unique-event-id"
                                     "clojure.set/project"
                                     "special/js*"
                                     "clojure.string/trim-newline"
                                     "specialrepl/in-ns"
                                     "special/let*"
                                     "special/throw"
                                     "clojure.zip/insert-left"
                                     "cljs.core/true?"
                                     "clojure.browser.net/xpc-connection"
                                     "cljs.core/not"
                                     "cljs.core/js-obj"
                                     "cljs.core/complement"
                                     "cljs.core/spread"
                                     "cljs.core/keyword"
                                     "cljs.core/sort"
                                     "clojure.string/trim"
                                     "cljs.core/meta"
                                     "cljs.core/time"
                                     "cljs.core/boolean"
                                     "cljs.reader/read-token"
                                     "cljs.core/update-in"
                                     "cljs.core/map-indexed"
                                     "cljs.core/IStack"
                                     "cljs.core/IIndexed"
                                     "clojure.browser.repl/repl-print"
                                     "clojure.browser.net/xpc-config-fields"
                                     "cljs.core/nnext"
                                     "cljs.core/*print-meta*"
                                     "cljs.reader/read-dispatch"
                                     "cljs.core/distinct"
                                     "cljs.reader/wrapping-reader"
                                     "cljs.core/prn"
                                     "clojure.zip/leftmost"
                                     "cljs.core/>="
                                     "cljs.reader/macros"
                                     "cljs.core/doseq"
                                     "cljs.core/*"
                                     "cljs.core/into"
                                     "cljs.core/defmethod"
                                     "cljs.core/rest"
                                     "cljs.core/dotimes"
                                     "clojure.zip/lefts"
                                     "clojure.browser.dom/ensure-element"
                                     "cljs.core/defmacro"
                                     "cljs.core/remove"
                                     "cljs.core/if-not"
                                     "clojure.zip/path"
                                     "cljs.core/mapcat"
                                     "cljs.core/IWatchable"
                                     "clojure.zip/rightmost"
                                     "cljs.core/->"
                                     "cljs.core/remove-all-methods"
                                     "clojure.string/replace-first"
                                     "clojure.browser.dom/get-value"
                                     "cljs.nodejs/process"
                                     "cljs.core/not="
                                     "cljs.core/js-keys"
                                     "clojure.zip/seq-zip"
                                     "cljs.core/IVector"
                                     "cljs.core/empty"
                                     "cljs.core/re-matches"
                                     "clojure.browser.dom/DOMBuilder"
                                     "cljs.core/extend-type"
                                     "cljs.core/ISeqable"
                                     "cljs.core/assoc"
                                     "clojure.browser.repl/xpc-connection"
                                     "cljs.core/IDerefWithTimeout"
                                     "clojure.browser.repl/start-evaluator"
                                     "clojure.browser.event/unlisten"
                                     "cljs.core/fnil"
                                     "cljs.core/this-as"
                                     "cljs.core/PersistentQueueSeq"
                                     "cljs.core/counted?"
                                     "clojure.string/trimr"
                                     "cljs.core/force"
                                     "cljs.core/compare-and-set!"
                                     "cljs.core/set?"
                                     "clojure.string/escape"
                                     "cljs.core/remove-watch"
                                     "cljs.core/IMultiFn"
                                     "clojure.zip/end?"
                                     "clojure.set/superset?"
                                     "clojure.browser.net/IConnection"
                                     "cljs.core/let"
                                     "cljs.core/dorun"
                                     "cljs.core/pr-str"
                                     "cljs.core/IPrintable"
                                     "cljs.core/defprotocol"
                                     "cljs.core/assert"
                                     "cljs.core/declare"
                                     "cljs.core/fn?"
                                     "cljs.core/associative?"
                                     "cljs.core/list*"
                                     "cljs.core/reduce"
                                     "clojure.browser.event/has-listener"
                                     "cljs.core/compare"
                                     "cljs.core/contains?"
                                     "cljs.core/prefer-method"
                                     "cljs.core/array-seq"
                                     "cljs.core/PersistentQueue"
                                     "cljs.core/drop-last"
                                     "cljs.reader/read-string"
                                     "cljs.core/vector?"
                                     "cljs.core/defmulti"
                                     "cljs.core/List.EMPTY"
                                     "clojure.browser.event/dispatch-event"
                                     "clojure.string/split-lines"
                                     "cljs.core/areduce"
                                     "cljs.core/disj"
                                     "clojure.browser.net/event-types"
                                     "clojure.string/lower-case"
                                     "cljs.core/*print-fn*"
                                     "cljs.core/str"
                                     "cljs.core/ISequential"
                                     "cljs.core/set"
                                     "special/def"
                                     "cljs.core/print"
                                     "clojure.string/blank?"
                                     "clojure.browser.dom/append"
                                     "cljs.core/take-last"
                                     "clojure.set/intersection"
                                     "cljs.core/fnext"
                                     "cljs.core/apply"
                                     "clojure.walk/prewalk"
                                     "cljs.core/flatten"
                                     "cljs.core/get"
                                     "cljs.core/.."
                                     "cljs.core/Range"
                                     "cljs.core/zero?"
                                     "cljs.core/identity"
                                     "cljs.core/first"
                                     "cljs.reader/ratio-pattern"
                                     "cljs.core/>"
                                     "cljs.core/juxt"
                                     "cljs.core/max"
                                     "cljs.core/*3"
                                     "cljs.core/number?"
                                     "cljs.core/array"
                                     "cljs.core/nthnext"
                                     "cljs.core/re-pattern"
                                     "cljs.core/missing-protocol"
                                     "clojure.browser.dom/set-text"
                                     "clojure.zip/up"
                                     "cljs.core/IWithMeta"
                                     "cljs.core/bit-and-not"
                                     "clojure.string/triml"
                                     "clojure.string/split"
                                     "cljs.core/hash-map"
                                     "cljs.core/rem"
                                     "cljs.core/IRecord"
                                     "cljs.core/constantly"
                                     "clojure.browser.dom/get-element"
                                     "cljs.core/and"
                                     "clojure.browser.repl/wrap-message"
                                     "clojure.browser.event/unlisten-by-key"
                                     "cljs.core/try"
                                     "cljs.core/iterate"
                                     "cljs.core/lazy-seq"
                                     "specialrepl/load-file"
                                     "cljs.core/IndexedSeq"
                                     "cljs.core/next"
                                     "cljs.core/*print-readably*"
                                     "cljs.core/last"
                                     "cljs.core/bit-shift-left"
                                     "clojure.string/reverse"
                                     "cljs.core/min"
                                     "cljs.reader/escape-char"
                                     "cljs.reader/read-map"
                                     "cljs.core/seq"
                                     "cljs.core/not-empty"
                                     "cljs.core/println"
                                     "clojure.browser.repl/connect"
                                     "clojure.browser.dom/insert-at"
                                     "cljs.core/quot"
                                     "clojure.browser.event/get-listener"
                                     "cljs.core/filter"
                                     "clojure.zip/branch?"
                                     "special/if"
                                     "cljs.core/ObjMap"
                                     "cljs.core/zipmap"
                                     "cljs.core/hash-combine"
                                     "cljs.core/max-key"
                                     "clojure.zip/insert-child"
                                     "cljs.core/defrecord"
                                     "cljs.core/butlast"
                                     "cljs.core/hash"
                                     "cljs.core/bit-set"
                                     "cljs.core/concat"
                                     "cljs.core/conj"
                                     "clojure.set/difference"
                                     "cljs.core/when-first"
                                     "cljs.core/distinct?"
                                     "cljs.core/pos?"
                                     "cljs.core/IHash"
                                     "cljs.core/is_proto_"
                                     "cljs.core/keep-indexed"
                                     "cljs.core/bit-shift-right"
                                     "clojure.zip/insert-right"
                                     "cljs.core/make-hierarchy"
                                     "cljs.core/repeat"
                                     "cljs.core/MultiFn"
                                     "cljs.core/not-any?"
                                     "cljs.reader/read-regex"
                                     "clojure.zip/next"
                                     "cljs.core/aget"
                                     "cljs.core/if-let"
                                     "cljs.core//"
                                     "cljs.core/min-key"
                                     "clojure.zip/root"
                                     "cljs.core/drop-while"
                                     "clojure.browser.repl/evaluate-javascript"
                                     "cljs.core/set-validator!"
                                     "cljs.core/<"
                                     "cljs.core/fn"
                                     "cljs.core/split-with"
                                     "cljs.core/IReduce"
                                     "cljs.reader/symbol-pattern"
                                     "cljs.core/repeatedly"
                                     "cljs.reader/read-delimited-list"
                                     "cljs.core/undefined?"
                                     "clojure.zip/prev"
                                     "cljs.core/seq?"
                                     "cljs.core/odd?"
                                     "cljs.core/cons"
                                     "special/deftype*"
                                     "cljs.reader/read-set"
                                     "cljs.core/descendants"
                                     "special/new"
                                     "cljs.core/take-nth"
                                     "cljs.reader/throwing-reader"
                                     "cljs.core/even?"
                                     "special/fn*"
                                     "clojure.set/subset?"
                                     "cljs.core/flush"
                                     "cljs.reader/reader-error"
                                     "clojure.walk/prewalk-replace"
                                     "cljs.core/*1"
                                     "cljs.core/Set.EMPTY"
                                     "cljs.reader/read-unicode-char"
                                     "cljs.core/dissoc"
                                     "cljs.core/ffirst"
                                     "clojure.zip/replace"
                                     "cljs.core/vec"
                                     "cljs.core/or"
                                     "cljs.core/mod"
                                     "cljs.core/aset"
                                     "cljs.core/second"
                                     "clojure.set/rename"
                                     "cljs.core/delay?"
                                     "clojure.zip/left"
                                     "cljs.reader/not-implemented"
                                     "cljs.core/IAssociative"
                                     "cljs.core/ObjMap.EMPTY"
                                     "cljs.core/group-by"
                                     "cljs.core/symbol"
                                     "cljs.core/Delay"
                                     "cljs.core/methods"
                                     "cljs.core/vector"
                                     "cljs.core/rand-int"
                                     "cljs.core/PersistentQueue.EMPTY"
                                     "cljs.core/letfn"
                                     "cljs.reader/read-discard"
                                     "cljs.core/inc"
                                     "cljs.core/name"
                                     "cljs.core/cycle"
                                     "cljs.core/map"
                                     "cljs.core/amap"
                                     "clojure.zip/children"
                                     "special/set!"
                                     "cljs.core/when-not"
                                     "clojure.set/index"
                                     "clojure.browser.dom/log"
                                     "cljs.core/Vector.fromArray"
                                     "cljs.core/partition-by"
                                     "cljs.core/sort-by"
                                     "cljs.core/with-meta"
                                     "cljs.core/NeverEquiv"
                                     "cljs.core/select-keys"
                                     "special/loop*"
                                     "cljs.core/ISeq"
                                     "clojure.walk/postwalk-replace"
                                     "cljs.core/pr-with-opts"
                                     "cljs.core/->>"
                                     "cljs.core/nil?"
                                     "clojure.walk/stringify-keys"
                                     "clojure.browser.repl/order"
                                     "cljs.core/memoize"
                                     "cljs.core/pr-sequential"
                                     "clojure.zip/make-node"
                                     "specialrepl/load-namespace"
                                     "cljs.reader/float-pattern"
                                     "cljs.core/ancestors"
                                     "cljs.core/integer?"
                                     "cljs.core/HashMap.EMPTY"
                                     "cljs.core/Vector.EMPTY"
                                     "clojure.zip/xml-zip"
                                     "clojure.walk/walk"
                                     "cljs.core/bit-xor"
                                     "clojure.set/union"
                                     "cljs.reader/PushbackReader"
                                     "cljs.core/isa?"
                                     "clojure.browser.net/xhr-connection"
                                     "cljs.core/subs"
                                     "cljs.core/symbol?"
                                     "clojure.string/replace"
                                     "cljs.core/string?"
                                     "cljs.core/partition-all"
                                     "cljs.core/merge-with"
                                     "clojure.browser.dom/set-properties"
                                     "cljs.core/trampoline"
                                     "clojure.browser.repl/send-print"
                                     "cljs.core/ICounted"
                                     "cljs.core/IEquiv"
                                     "cljs.core/js-delete"
                                     "cljs.core/comment"
                                     "cljs.reader/special-symbols"
                                     "cljs.core/alength"
                                     "special/quote"
                                     "cljs.core/tree-seq"
                                     "cljs.reader/read-unmatched-delimiter"
                                     "cljs.core/every-pred"
                                     "clojure.set/rename-keys"
                                     "cljs.core/peek"
                                     "cljs.core/pr-str-with-opts"
                                     "cljs.core/map?"
                                     "cljs.reader/StringPushbackReader"
                                     "cljs.core/HashMap.fromArrays"
                                     "cljs.core/deref"
                                     "cljs.core/reductions"
                                     "cljs.core/false?"
                                     "cljs.core/bit-flip"
                                     "cljs.core/ISet"
                                     "cljs.core/LazySeq"
                                     "cljs.core/*2"
                                     "clojure.browser.event/total-listener-count"
                                     "cljs.core/alter-meta!"
                                     "clojure.browser.dom/click-element"
                                     "cljs.reader/read-meta"
                                     "special/try*"
                                     "cljs.core/range"
                                     "cljs.core/reify"
                                     "cljs.core/satisfies?"
                                     "cljs.core/nth"
                                     "cljs.core/list"
                                     "cljs.core/defn"
                                     "cljs.core/rand-nth"
                                     "cljs.core/atom"
                                     "cljs.reader/read-keyword"
                                     "cljs.core/Vector"
                                     "cljs.reader/skip-line"
                                     "cljs.core/namespace"
                                     "cljs.nodejs/require"
                                     "clojure.browser.event/EventType"
                                     "cljs.core/merge"
                                     "clojure.browser.repl/send-result"
                                     "clojure.walk/keywordize-keys"
                                     "cljs.core/derive"
                                     "clojure.zip/zipper"
                                     "clojure.zip/remove"
                                     "cljs.core/find"
                                     "cljs.core/*print-dup*"
                                     "cljs.core/partial"
                                     "cljs.core/keyword?"
                                     "clojure.browser.event/fire-listeners"
                                     "cljs.core/interleave"
                                     "cljs.core/*flush-on-newline*"
                                     "cljs.core/get-in"
                                     "clojure.browser.dom/element"
                                     "cljs.core/prim-seq"
                                     "cljs.core/<="
                                     "clojure.set/map-invert"
                                     "clojure.browser.event/listen"
                                     "cljs.core/neg?"
                                     "clojure.browser.dom/replace-node"
                                     "special/catch"
                                     "cljs.core/reverse"
                                     "cljs.core/realized?"}}
                           {:cljs-version "0.0-971",
                            :cljs-date "2012-01-27",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/type" "cljs.core/IFn"}}
                           {:cljs-version "0.0-993",
                            :cljs-date "2012-02-27",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790"}
                           {:cljs-version "0.0-1006",
                            :cljs-date "2012-03-30",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/PersistentVector.EMPTY_NODE"
                                     "cljs.core/PersistentVector.fromArray"
                                     "cljs.core/PersistentVector"
                                     "cljs.core/PersistentVector.EMPTY"}}
                           {:cljs-version "0.0-1011",
                            :cljs-date "2012-04-02",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/println-str"
                                     "cljs.core/print-str"
                                     "cljs.core/prn-str-with-opts"
                                     "cljs.core/prn-str"}}
                           {:cljs-version "0.0-1211",
                            :cljs-date "2012-05-09",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"cljs.core/ITransientCollection"
                                     "cljs.core/transient"
                                     "cljs.core/dissoc!"
                                     "cljs.core/PersistentArrayMap.fromArrays"
                                     "cljs.core/ITransientSet"
                                     "cljs.core/array-map"
                                     "cljs.core/rseq"
                                     "cljs.core/ITransientMap"
                                     "cljs.core/ArrayNodeSeq"
                                     "cljs.core/list?"
                                     "cljs.core/val"
                                     "cljs.core/BitmapIndexedNode"
                                     "cljs.core/IMapEntry"
                                     "cljs.core/*unchecked-if*"
                                     "cljs.core/seqable?"
                                     "cljs.core/sorted-map"
                                     "cljs.core/ASeq"
                                     "cljs.core/reduceable?"
                                     "cljs.core/vector-seq"
                                     "cljs.core/conj!"
                                     "cljs.core/PersistentHashMap"
                                     "cljs.core/IReversible"
                                     "cljs.core/IKVReduce"
                                     "cljs.core/BlackNode"
                                     "cljs.core/PersistentHashSet.EMPTY"
                                     "cljs.core/PersistentArrayMap"
                                     "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                     "cljs.core/int"
                                     "cljs.core/ISorted"
                                     "cljs.core/double-array"
                                     "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                     "cljs.core/PersistentArrayMap.EMPTY"
                                     "cljs.core/reduced?"
                                     "cljs.core/PersistentTreeMapSeq"
                                     "cljs.core/persistent!"
                                     "cljs.core/PersistentHashMap.fromArrays"
                                     "cljs.core/sorted-set"
                                     "cljs.core/PersistentTreeMap.EMPTY"
                                     "cljs.core/IList"
                                     "cljs.core/PersistentHashMap.EMPTY"
                                     "cljs.core/to-array-2d"
                                     "cljs.core/filterv"
                                     "cljs.core/IEditableCollection"
                                     "cljs.core/ArrayNode"
                                     "cljs.core/TransientHashMap"
                                     "cljs.core/TransientArrayMap"
                                     "cljs.core/mapv"
                                     "cljs.core/long"
                                     "cljs.core/reversible?"
                                     "cljs.core/HashCollisionNode"
                                     "cljs.core/into-array"
                                     "cljs.core/TransientVector"
                                     "cljs.core/PersistentTreeSet"
                                     "cljs.core/Reduced"
                                     "cljs.core/long-array"
                                     "cljs.core/subseq"
                                     "cljs.core/bit-count"
                                     "cljs.core/assoc!"
                                     "cljs.core/sorted-map-by"
                                     "cljs.core/NodeSeq"
                                     "cljs.core/gen-apply-to"
                                     "cljs.core/rsubseq"
                                     "cljs.core/make-array"
                                     "cljs.core/sorted-set-by"
                                     "cljs.core/disj!"
                                     "cljs.core/ifn?"
                                     "cljs.core/case"
                                     "cljs.core/RedNode"
                                     "cljs.core/key"
                                     "cljs.core/ITransientAssociative"
                                     "cljs.core/reduce-kv"
                                     "cljs.core/PersistentTreeSet.EMPTY"
                                     "cljs.core/BitmapIndexedNode.EMPTY"
                                     "cljs.core/mk-bound-fn"
                                     "cljs.core/VectorNode"
                                     "cljs.core/PersistentHashSet"
                                     "cljs.core/ITransientVector"
                                     "cljs.core/PersistentTreeMap"
                                     "cljs.core/pop!"
                                     "cljs.core/bit-shift-right-zero-fill"
                                     "cljs.core/reduced"
                                     "cljs.core/object-array"
                                     "cljs.core/indexed?"
                                     "cljs.core/TransientHashSet"},
                            :removed #{"cljs.core/Set"
                                       "cljs.core/Set.EMPTY"}}
                           {:cljs-version "0.0-1236",
                            :cljs-date "2012-05-16",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"clojure.core.reducers/drop"
                                     "special/letfn*"
                                     "clojure.core.reducers/folder"
                                     "clojure.core.reducers/Cat"
                                     "clojure.core.reducers/foldcat"
                                     "clojure.core.reducers/fold"
                                     "clojure.core.reducers/monoid"
                                     "clojure.core.reducers/map"
                                     "clojure.core.reducers/cat"
                                     "clojure.core.reducers/take"
                                     "cljs.reader/maybe-read-tagged-type"
                                     "clojure.core.reducers/reduce"
                                     "clojure.core.reducers/flatten"
                                     "cljs.reader/*tag-table*"
                                     "clojure.core.reducers/filter"
                                     "cljs.core/simple-benchmark"
                                     "clojure.core.reducers/append!"
                                     "clojure.core.reducers/reducer"
                                     "clojure.core.reducers/take-while"
                                     "cljs.reader/register-tag-parser!"
                                     "clojure.core.reducers/remove"
                                     "cljs.reader/read-string*"
                                     "clojure.core.reducers/mapcat"}}
                           {:cljs-version "0.0-1424",
                            :cljs-date "2012-06-16",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"cljs.core/Box"
                                     "cljs.core/array-chunk"
                                     "cljs.core/string-hash-cache"
                                     "cljs.reader/read-2-chars"
                                     "cljs.core/chunk"
                                     "cljs.core/chunk-next"
                                     "cljs.reader/make-unicode-char"
                                     "cljs.core/shuffle"
                                     "cljs.core/ArrayChunk"
                                     "cljs.core/chunk-cons"
                                     "cljs.core/chunked-seq"
                                     "cljs.reader/unicode-4-pattern"
                                     "cljs.core/IComparable"
                                     "cljs.reader/unicode-2-pattern"
                                     "cljs.core/check-string-hash-cache"
                                     "cljs.core/Keyword"
                                     "cljs.core/key-test"
                                     "cljs.core/IChunkedSeq"
                                     "cljs.core/chunk-append"
                                     "cljs.core/regexp?"
                                     "cljs.reader/read-4-chars"
                                     "cljs.core/UUID"
                                     "cljs.reader/deregister-tag-parser!"
                                     "cljs.core/INext"
                                     "cljs.core/RSeq"
                                     "cljs.core/add-to-string-hash-cache"
                                     "cljs.core/chunk-buffer"
                                     "cljs.core/IChunkedNext"
                                     "cljs.core/ChunkBuffer"
                                     "cljs.core/chunked-seq?"
                                     "cljs.reader/validate-unicode-escape"
                                     "cljs.core/string-hash-cache-count"
                                     "cljs.core/IChunk"
                                     "cljs.reader/parse-timestamp"
                                     "cljs.core/chunk-first"
                                     "cljs.core/ChunkedSeq"
                                     "cljs.core/chunk-rest"
                                     "cljs.core/ChunkedCons"},
                            :removed #{"cljs.core/vector-seq"
                                       "cljs.reader/read-unicode-char"}}
                           {:cljs-version "0.0-1443",
                            :cljs-date "2012-07-06",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"cljs.core/printf"
                                     "cljs.core/format"
                                     "cljs.core/obj-map"
                                     "cljs.core/memfn"
                                     "cljs.core/PersistentHashSet.fromArray"
                                     "cljs.core/hash-set"}}
                           {:cljs-version "0.0-1449",
                            :cljs-date "2012-07-24",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376"}
                           {:cljs-version "0.0-1450",
                            :cljs-date "2012-07-25",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376"}
                           {:cljs-version "0.0-1503",
                            :cljs-date "2012-10-12",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"clojure.data/EqualityPartition"
                                     "clojure.reflect/meta"
                                     "cljs.core/write-all"
                                     "cljs.core/pr-sequential-writer"
                                     "cljs.core/StringBufferWriter"
                                     "clojure.reflect/macroexpand"
                                     "cljs.core/pr-seq-writer"
                                     "clojure.reflect/print-doc"
                                     "clojure.reflect/doc"
                                     "cljs.core/IWriter"
                                     "clojure.data/Diff"
                                     "clojure.data/diff"
                                     "cljs.core/IPrintWithWriter"},
                            :removed #{"cljs.core/pr-with-opts"}}
                           {:cljs-version "0.0-1513",
                            :cljs-date "2012-10-19",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376"}
                           {:cljs-version "0.0-1535",
                            :cljs-date "2012-11-08",
                            :clj-version "1.4.0",
                            :gclosure-lib "20120710-r2029",
                            :added #{"cljs.core/with-out-str"}}
                           {:cljs-version "0.0-1552",
                            :cljs-date "2012-12-03",
                            :clj-version "1.4.0",
                            :gclosure-lib "20120710-r2029",
                            :added #{"cljs.core/Fn"
                                     "cljs.core/IEncodeJS"
                                     "cljs.core/js-mod"
                                     "cljs.core/IEncodeClojure"
                                     "cljs.core/clj->js"}}
                           {:cljs-version "0.0-1576",
                            :cljs-date "2013-01-27",
                            :clj-version "1.4.0",
                            :gclosure-lib "20120710-r2029",
                            :added #{"cljs.core/ex-message"
                                     "cljs.reader/deregister-default-tag-parser!"
                                     "cljs.core/ex-data"
                                     "cljs.core/ex-info"
                                     "cljs.reader/*default-data-reader-fn*"
                                     "cljs.core/ExceptionInfo"
                                     "cljs.reader/register-default-tag-parser!"
                                     "cljs.core/ex-cause"}}
                           {:cljs-version "0.0-1586",
                            :cljs-date "2013-02-16",
                            :clj-version "1.4.0",
                            :gclosure-lib "20120710-r2029",
                            :added #{"cljs.core/comparator"}}
                           {:cljs-version "0.0-1798",
                            :cljs-date "2013-05-03",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2",
                            :added #{"cljs.core/unchecked-negate"
                                     "cljs.core/float"
                                     "cljs.core/int-array"
                                     "cljs.core/unchecked-multiply-int"
                                     "cljs.core/cond->"
                                     "cljs.core/unchecked-add"
                                     "cljs.core/Symbol"
                                     "cljs.core/chars"
                                     "cljs.core/short"
                                     "cljs.core/longs"
                                     "cljs.core/unchecked-multiply"
                                     "cljs.core/some->"
                                     "cljs.core/unchecked-negate-int"
                                     "cljs.core/unchecked-substract-int"
                                     "cljs.core/unchecked-double"
                                     "cljs.core/set-print-fn!"
                                     "cljs.core/unchecked-inc-int"
                                     "cljs.core/unchecked-subtract"
                                     "cljs.core/unchecked-add-int"
                                     "cljs.core/some->>"
                                     "cljs.core/unchecked-inc"
                                     "cljs.core/unchecked-subtract-int"
                                     "cljs.core/unchecked-substract"
                                     "cljs.core/unchecked-dec"
                                     "cljs.core/unchecked-divide-int"
                                     "cljs.core/ints"
                                     "cljs.core/PersistentArrayMap.fromArray"
                                     "cljs.core/unchecked-dec-int"
                                     "cljs.core/array?"
                                     "cljs.core/unchecked-char"
                                     "cljs.core/key->js"
                                     "cljs.core/char"
                                     "cljs.core/floats"
                                     "cljs.core/cond->>"
                                     "cljs.core/booleans"
                                     "cljs.core/not-native"
                                     "cljs.core/bytes"
                                     "cljs.core/unchecked-byte"
                                     "cljs.core/unchecked-short"
                                     "cljs.core/byte"
                                     "cljs.core/INamed"
                                     "cljs.core/shorts"
                                     "cljs.core/unchecked-int"
                                     "cljs.core/double"
                                     "cljs.core/exists?"
                                     "cljs.core/doubles"
                                     "cljs.core/unchecked-float"
                                     "cljs.core/divide"
                                     "cljs.core/as->"
                                     "cljs.core/unchecked-remainder-int"
                                     "cljs.core/unchecked-long"},
                            :removed #{"cljs.core/PersistentArrayMap.fromArrays"
                                       "cljs.core/HashMap"
                                       "cljs.core/IPrintable"
                                       "cljs.core/Vector.fromArray"
                                       "cljs.core/pr-sequential"
                                       "cljs.core/HashMap.EMPTY"
                                       "cljs.core/Vector.EMPTY"
                                       "cljs.core/HashMap.fromArrays"
                                       "cljs.core/Vector"}}
                           {:cljs-version "0.0-1803",
                            :cljs-date "2013-05-06",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2",
                            :added #{"cljs.core/special-symbol?"
                                     "cljs.core/lazy-cat"}}
                           {:cljs-version "0.0-1806",
                            :cljs-date "2013-05-10",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2",
                            :added #{"cljs.core/with-redefs"
                                     "cljs.core/pr-str*"}}
                           {:cljs-version "0.0-1820",
                            :cljs-date "2013-06-07",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2",
                            :added #{"cljs.core/ValSeq"
                                     "cljs.core/PersistentArrayMapSeq"
                                     "cljs.core/KeySeq"
                                     "cljs.core/persistent-array-map-seq"}}
                           {:cljs-version "0.0-1835",
                            :cljs-date "2013-06-21",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2"}
                           {:cljs-version "0.0-1843",
                            :cljs-date "2013-07-16",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2"}
                           {:cljs-version "0.0-1844",
                            :cljs-date "2013-07-19",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2"}
                           {:cljs-version "0.0-1847",
                            :cljs-date "2013-07-23",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f"}
                           {:cljs-version "0.0-1853",
                            :cljs-date "2013-08-05",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.5",
                            :added #{"cljs.reader/parse-and-validate-timestamp"}}
                           {:cljs-version "0.0-1859",
                            :cljs-date "2013-08-19",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6",
                            :added #{"cljs.core/type->str"}}
                           {:cljs-version "0.0-1877",
                            :cljs-date "2013-09-08",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6",
                            :added #{"cljs.core/keyword-identical?"
                                     "cljs.core/set-from-indexed-seq"}}
                           {:cljs-version "0.0-1878",
                            :cljs-date "2013-09-11",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1885",
                            :cljs-date "2013-09-15",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6",
                            :removed #{"cljs.core/printf"
                                       "cljs.core/format"}}
                           {:cljs-version "0.0-1886",
                            :cljs-date "2013-09-15",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1889",
                            :cljs-date "2013-09-15",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1895",
                            :cljs-date "2013-09-24",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1896",
                            :cljs-date "2013-09-24",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1909",
                            :cljs-date "2013-09-27",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.8"}
                           {:cljs-version "0.0-1913",
                            :cljs-date "2013-10-05",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.8"}
                           {:cljs-version "0.0-1933",
                            :cljs-date "2013-10-11",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.9",
                            :added #{"special/try"},
                            :removed #{"cljs.core/try" "special/try*"}}
                           {:cljs-version "0.0-1934",
                            :cljs-date "2013-10-11",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.9"}
                           {:cljs-version "0.0-1978",
                            :cljs-date "2013-10-28",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10"}
                           {:cljs-version "0.0-2014",
                            :cljs-date "2013-11-06",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10",
                            :added #{"cljs.core/*clojurescript-version*"
                                     "cljs.core/implements?"}}
                           {:cljs-version "0.0-2024",
                            :cljs-date "2013-11-08",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10"}
                           {:cljs-version "0.0-2027",
                            :cljs-date "2013-11-08",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10"}
                           {:cljs-version "0.0-2030",
                            :cljs-date "2013-11-08",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10"}
                           {:cljs-version "0.0-2060",
                            :cljs-date "2013-11-21",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10",
                            :added #{"cljs.core/enable-console-print!"
                                     "cljs.core/*print-length*"
                                     "cljs.core/*print-newline*"}}
                           {:cljs-version "0.0-2067",
                            :cljs-date "2013-11-22",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0"}
                           {:cljs-version "0.0-2069",
                            :cljs-date "2013-11-22",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0"}
                           {:cljs-version "0.0-2075",
                            :cljs-date "2013-11-23",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0"}
                           {:cljs-version "0.0-2080",
                            :cljs-date "2013-11-23",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0",
                            :added #{"cljs.core/unsigned-bit-shift-right"}}
                           {:cljs-version "0.0-2120",
                            :cljs-date "2013-12-13",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0",
                            :added #{"cljs.core/print-map"
                                     "cljs.core/sorted?"
                                     "cljs.core/*print-level*"
                                     "clojure.core.reducers/CollFold"
                                     "cljs.core/sequence"
                                     "cljs.core/object?"}}
                           {:cljs-version "0.0-2127",
                            :cljs-date "2013-12-20",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0"}
                           {:cljs-version "0.0-2134",
                            :cljs-date "2013-12-30",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0",
                            :added #{"cljs.core/clone"
                                     "cljs.core/ICloneable"}}
                           {:cljs-version "0.0-2138",
                            :cljs-date "2013-12-31",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0",
                            :added #{"cljs.core/specify"}}
                           {:cljs-version "0.0-2156",
                            :cljs-date "2014-01-29",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3",
                            :added #{"cljs.nodejs/enable-util-print!"
                                     "cljs.core/cloneable?"
                                     "cljs.core/specify!"
                                     "cljs.core/defonce"}}
                           {:cljs-version "0.0-2173",
                            :cljs-date "2014-02-22",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3",
                            :added #{"cljs.core/IReset"
                                     "cljs.core/IAtom"
                                     "cljs.core/ISwap"}}
                           {:cljs-version "0.0-2197",
                            :cljs-date "2014-03-26",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3"}
                           {:cljs-version "0.0-2199",
                            :cljs-date "2014-04-01",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3"}
                           {:cljs-version "0.0-2202",
                            :cljs-date "2014-04-02",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3"}
                           {:cljs-version "0.0-2227",
                            :cljs-date "2014-05-22",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3",
                            :added #{"special/case*"}}
                           {:cljs-version "0.0-2234",
                            :cljs-date "2014-06-13",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3",
                            :added #{"cljs.core/MetaFn"}}
                           {:cljs-version "0.0-2261",
                            :cljs-date "2014-07-02",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140226-71326067",
                            :treader-version "0.8.4",
                            :added #{"cljs.core/hash-unordered-coll"
                                     "cljs.core/int-rotate-left"
                                     "cljs.core/some?"
                                     "cljs.core/hash-string*"
                                     "cljs.core/m3-C1"
                                     "cljs.core/m3-fmix"
                                     "cljs.core/if-some"
                                     "cljs.core/m3-mix-H1"
                                     "cljs.core/m3-C2"
                                     "cljs.core/hash-string"
                                     "cljs.core/m3-hash-unencoded-chars"
                                     "cljs.reader/read-raw-string*"
                                     "cljs.core/m3-mix-K1"
                                     "cljs.core/hash-keyword"
                                     "cljs.core/m3-hash-int"
                                     "cljs.core/m3-seed"
                                     "cljs.core/hash-ordered-coll"
                                     "cljs.core/when-some"
                                     "cljs.core/mix-collection-hash"},
                            :removed #{"cljs.core/check-string-hash-cache"}}
                           {:cljs-version "0.0-2268",
                            :cljs-date "2014-07-06",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140226-71326067",
                            :treader-version "0.8.4",
                            :added #{"cljs.core/iterator"
                                     "cljs.core/SetEntriesIterator"
                                     "cljs.core/EntriesIterator"
                                     "cljs.core/set-entries-iterator"
                                     "cljs.core/entries-iterator"
                                     "cljs.core/Iterator"}}
                           {:cljs-version "0.0-2277",
                            :cljs-date "2014-07-25",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140226-71326067",
                            :treader-version "0.8.4",
                            :removed #{"cljs.core/unchecked-substract-int"
                                       "cljs.core/unchecked-substract"}}
                           {:cljs-version "0.0-2280",
                            :cljs-date "2014-08-01",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4"}
                           {:cljs-version "0.0-2301",
                            :cljs-date "2014-08-07",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4",
                            :added #{"cljs.core/LazyTransformer.createMulti"
                                     "cljs.core/flatmap"
                                     "cljs.core/ArrayList"
                                     "cljs.core/stepper"
                                     "cljs.core/LazyTransformer.create"
                                     "cljs.core/ArrayIter"
                                     "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"
                                     "cljs.core/LazyTransformer"
                                     "cljs.core/dedupe"
                                     "cljs.core/string-iter"
                                     "cljs.core/run!"
                                     "cljs.core/lazy-transformer"
                                     "cljs.core/random-sample"
                                     "cljs.core/iter"
                                     "cljs.core/multi-stepper"
                                     "cljs.core/Iteration"
                                     "cljs.core/PersistentVector.EMPTY-NODE"
                                     "clojure.browser.event/IEventType"
                                     "cljs.core/SeqIter"
                                     "cljs.core/Stepper"
                                     "cljs.core/transduce"
                                     "cljs.core/iteration"
                                     "cljs.core/array-iter"
                                     "cljs.core/array-list"
                                     "cljs.core/nil-iter"
                                     "cljs.core/StringIter"
                                     "cljs.core/MultiStepper"
                                     "cljs.core/seq-iter"},
                            :removed #{"cljs.core/PersistentVector.EMPTY_NODE"
                                       "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                       "clojure.browser.event/EventType"}}
                           {:cljs-version "0.0-2307",
                            :cljs-date "2014-08-07",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4"}
                           {:cljs-version "0.0-2311",
                            :cljs-date "2014-08-09",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4"}
                           {:cljs-version "0.0-2322",
                            :cljs-date "2014-08-27",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4"}
                           {:cljs-version "0.0-2341",
                            :cljs-date "2014-09-18",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4",
                            :added #{"cljs.core/js-str"
                                     "cljs.core/cat"
                                     "cljs.core/completing"},
                            :removed #{"cljs.core/flatmap"}}
                           {:cljs-version "0.0-2342",
                            :cljs-date "2014-09-18",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.9"}
                           {:cljs-version "0.0-2356",
                            :cljs-date "2014-09-26",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.9",
                            :added #{"cljs.core/IIterable"
                                     "cljs.core/iterable?"}}
                           {:cljs-version "0.0-2371",
                            :cljs-date "2014-10-10",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.9",
                            :added #{"cljs.core/RangeIterator"
                                     "cljs.core/es6-set-entries-iterator"
                                     "cljs.core/es6-entries-iterator"
                                     "cljs.core/PersistentArrayMapIterator"
                                     "cljs.core/ES6EntriesIterator"
                                     "cljs.core/IndexedSeqIterator"
                                     "cljs.core/RangedIterator"
                                     "cljs.core/es6-iterator"
                                     "cljs.core/eduction"
                                     "cljs.core/ES6Iterator"
                                     "cljs.core/Eduction"
                                     "cljs.core/ES6SetEntriesIterator"
                                     "cljs.core/ranged-iterator"},
                            :removed #{"cljs.core/iterator"
                                       "cljs.core/SetEntriesIterator"
                                       "cljs.core/EntriesIterator"
                                       "cljs.core/Iteration"
                                       "cljs.core/iteration"
                                       "cljs.core/set-entries-iterator"
                                       "cljs.core/entries-iterator"
                                       "cljs.core/Iterator"}}
                           {:cljs-version "0.0-2411",
                            :cljs-date "2014-12-05",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.core/js-invoke"
                                     "cljs.core/ES6IteratorSeq"
                                     "cljs.core/unreduced"
                                     "cljs.core/es6-iterable"
                                     "cljs.core/nthrest"
                                     "cljs.core/js-in"
                                     "cljs.core/update"
                                     "cljs.core/es6-iterator-seq"
                                     "cljs.core/ensure-reduced"}}
                           {:cljs-version "0.0-2496",
                            :cljs-date "2014-12-17",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.test/get-current-env"
                                     "cljs.test/join-fixtures"
                                     "cljs.test/assert-predicate"
                                     "cljs.test/testing-contexts-str"
                                     "cljs.test/do-report"
                                     "cljs.test/set-env!"
                                     "cljs.test/run-tests"
                                     "cljs.repl/print-doc"
                                     "cljs.test/js-filename"
                                     "cljs.core/vswap!"
                                     "cljs.core/IVolatile"
                                     "cljs.test/file-and-line"
                                     "cljs.test/function?"
                                     "cljs.test/test-all-vars"
                                     "cljs.test/assert-any"
                                     "cljs.test/testing-vars-str"
                                     "cljs.test/compose-fixtures"
                                     "cljs.test/is"
                                     "cljs.core/js-debugger"
                                     "cljs.test/clear-env!"
                                     "cljs.core/Volatile"
                                     "cljs.core/ns-interns"
                                     "cljs.test/mapped-line-and-column"
                                     "cljs.test/test-var"
                                     "cljs.test/js-line-and-column"
                                     "cljs.core/volatile!"
                                     "cljs.test/*current-env*"
                                     "cljs.test/update-current-env!"
                                     "cljs.test/successful?"
                                     "cljs.test/inc-report-counter!"
                                     "cljs.core/volatile?"
                                     "cljs.test/test-vars"
                                     "cljs.test/run-all-tests"
                                     "cljs.test/try-expr"
                                     "cljs.pprint/PrettyFlush"
                                     "cljs.core/Var"
                                     "cljs.test/test-ns"
                                     "special/var"
                                     "cljs.repl/doc"
                                     "cljs.core/test"
                                     "cljs.test/deftest"
                                     "cljs.test/testing"
                                     "cljs.test/ns?"
                                     "cljs.test/empty-env"
                                     "cljs.core/vreset!"}}
                           {:cljs-version "0.0-2498",
                            :cljs-date "2014-12-19",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.test/use-fixtures"}}
                           {:cljs-version "0.0-2505",
                            :cljs-date "2014-12-21",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2511",
                            :cljs-date "2014-12-22",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2629",
                            :cljs-date "2015-01-01",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.test/are"
                                     "specialrepl/require"}}
                           {:cljs-version "0.0-2644",
                            :cljs-date "2015-01-02",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2655",
                            :cljs-date "2015-01-03",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.core/*loaded-libs*"}}
                           {:cljs-version "0.0-2657",
                            :cljs-date "2015-01-03",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"specialrepl/require-macros"}}
                           {:cljs-version "0.0-2665",
                            :cljs-date "2015-01-04",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2719",
                            :cljs-date "2015-01-24",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.repl/with-read-known"
                                     "cljs.core/PersistentHashMap.fromArray"
                                     "cljs.core/load-file*"}}
                           {:cljs-version "0.0-2723",
                            :cljs-date "2015-01-24",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2725",
                            :cljs-date "2015-01-24",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2727",
                            :cljs-date "2015-01-25",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2740",
                            :cljs-date "2015-01-28",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2755",
                            :cljs-date "2015-02-01",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2758",
                            :cljs-date "2015-02-02",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2760",
                            :cljs-date "2015-02-02",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2814",
                            :cljs-date "2015-02-10",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.test/test-vars-block"
                                     "cljs.test/run-block"
                                     "cljs.test/test-all-vars-block"
                                     "cljs.test/async?"
                                     "cljs.test/IAsyncTest"
                                     "cljs.test/block"
                                     "cljs.test/run-tests-block"
                                     "cljs.test/async"
                                     "cljs.test/get-and-clear-env!"
                                     "cljs.core/*e"
                                     "cljs.test/test-ns-block"
                                     "cljs.test/test-var-block"}}
                           {:cljs-version "0.0-2816",
                            :cljs-date "2015-02-10",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2843",
                            :cljs-date "2015-02-12",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2850",
                            :cljs-date "2015-02-13",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2911",
                            :cljs-date "2015-02-21",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"clojure.browser.net/IWebSocket"
                                     "clojure.browser.net/websocket-connection"},
                            :removed #{"cljs.repl/with-read-known"}}],
                 :symbol-names #{"cljs.core/keys"
                                 "cljs.core/unchecked-negate"
                                 "cljs.core/reset!"
                                 "cljs.core/ITransientCollection"
                                 "cljs.core/transient"
                                 "cljs.core/Fn"
                                 "clojure.data/EqualityPartition"
                                 "cljs.core/ex-message"
                                 "cljs.test/test-vars-block"
                                 "clojure.set/select"
                                 "cljs.core/hash-unordered-coll"
                                 "cljs.core/delay"
                                 "cljs.core/float"
                                 "cljs.core/bit-not"
                                 "cljs.core/partition"
                                 "cljs.core/IEncodeJS"
                                 "cljs.core/parents"
                                 "cljs.core/aclone"
                                 "cljs.core/reset-meta!"
                                 "cljs.core/IReset"
                                 "special/defrecord*"
                                 "cljs.core/Box"
                                 "cljs.reader/dispatch-macros"
                                 "cljs.core/int-rotate-left"
                                 "cljs.core/ICollection"
                                 "cljs.core/every?"
                                 "clojure.zip/node"
                                 "cljs.core/IEmptyableCollection"
                                 "clojure.zip/right"
                                 "cljs.core/int-array"
                                 "cljs.core/LazyTransformer.createMulti"
                                 "cljs.core/=="
                                 "cljs.core/dissoc!"
                                 "special/."
                                 "clojure.reflect/meta"
                                 "clojure.browser.net/*timeout*"
                                 "cljs.core/remove-method"
                                 "cljs.core/array-chunk"
                                 "clojure.core.reducers/drop"
                                 "clojure.browser.net/IWebSocket"
                                 "cljs.core/PersistentArrayMap.fromArrays"
                                 "cljs.core/frequencies"
                                 "cljs.core/pop"
                                 "cljs.repl/with-read-known"
                                 "cljs.core/flatmap"
                                 "cljs.core/not-every?"
                                 "cljs.core/js-invoke"
                                 "cljs.core/some-fn"
                                 "clojure.browser.event/remove-all"
                                 "cljs.core/doto"
                                 "cljs.core/take-while"
                                 "cljs.reader/escape-char-map"
                                 "clojure.browser.event/all-listeners"
                                 "cljs.core/ITransientSet"
                                 "cljs.core/vals"
                                 "cljs.core/IDeref"
                                 "cljs.core/string-hash-cache"
                                 "cljs.core/array-map"
                                 "clojure.browser.dom/log-obj"
                                 "cljs.nodejs/enable-util-print!"
                                 "cljs.core/for"
                                 "cljs.core/unchecked-multiply-int"
                                 "cljs.core/cond->"
                                 "cljs.core/instance?"
                                 "cljs.core/ValSeq"
                                 "cljs.core/rseq"
                                 "cljs.core/PersistentVector.EMPTY_NODE"
                                 "cljs.reader/read-comment"
                                 "cljs.core/ITransientMap"
                                 "cljs.core/*loaded-libs*"
                                 "cljs.reader/read-number"
                                 "cljs.core/ILookup"
                                 "cljs.core/when"
                                 "cljs.core/ArrayNodeSeq"
                                 "cljs.core/list?"
                                 "cljs.core/val"
                                 "clojure.browser.dom/set-value"
                                 "cljs.core/BitmapIndexedNode"
                                 "cljs.reader/read-past"
                                 "cljs.core/to-array"
                                 "cljs.core/interpose"
                                 "cljs.core/IMapEntry"
                                 "clojure.browser.net/ICrossPageChannel"
                                 "special/finally"
                                 "cljs.core/Cons"
                                 "cljs.core/re-find"
                                 "cljs.core/IMeta"
                                 "cljs.core/js-str"
                                 "cljs.test/are"
                                 "cljs.core/RangeIterator"
                                 "cljs.core/iterator"
                                 "cljs.core/assoc-in"
                                 "special/letfn*"
                                 "clojure.string/join"
                                 "cljs.core/*unchecked-if*"
                                 "cljs.core/some?"
                                 "cljs.core/seqable?"
                                 "clojure.zip/rights"
                                 "cljs.core/split-at"
                                 "clojure.zip/append-child"
                                 "cljs.core/binding"
                                 "cljs.test/get-current-env"
                                 "cljs.core/Set"
                                 "cljs.core/sorted-map"
                                 "cljs.reader/macro-terminating?"
                                 "cljs.test/join-fixtures"
                                 "cljs.core/prefers"
                                 "cljs.test/assert-predicate"
                                 "cljs.core/vary-meta"
                                 "cljs.core/unchecked-add"
                                 "cljs.core/when-let"
                                 "clojure.core.reducers/folder"
                                 "cljs.core/ASeq"
                                 "cljs.core/drop"
                                 "cljs.core/ArrayList"
                                 "cljs.core/stepper"
                                 "cljs.core/IAtom"
                                 "cljs.core/reduceable?"
                                 "cljs.core/while"
                                 "cljs.core/import-macros"
                                 "cljs.core/string-print"
                                 "cljs.core/ES6IteratorSeq"
                                 "cljs.core/-"
                                 "cljs.core/vector-seq"
                                 "cljs.core/IIterable"
                                 "cljs.test/testing-contexts-str"
                                 "clojure.zip/vector-zip"
                                 "cljs.reader/read-2-chars"
                                 "cljs.core/chunk"
                                 "cljs.core/conj!"
                                 "cljs.test/do-report"
                                 "cljs.core/print-map"
                                 "cljs.core/js->clj"
                                 "cljs.core/List"
                                 "cljs.core/identical?"
                                 "cljs.core/*main-cli-fn*"
                                 "clojure.browser.dom/html->dom"
                                 "cljs.core/LazyTransformer.create"
                                 "cljs.core/chunk-next"
                                 "cljs.core/enable-console-print!"
                                 "cljs.core/sorted?"
                                 "cljs.core/some"
                                 "cljs.core/PersistentArrayMapSeq"
                                 "cljs.reader/make-unicode-char"
                                 "clojure.core.reducers/Cat"
                                 "cljs.core/write-all"
                                 "cljs.core/doall"
                                 "cljs.core/condp"
                                 "clojure.zip/down"
                                 "cljs.core/IPending"
                                 "cljs.core/count"
                                 "cljs.core/bit-test"
                                 "cljs.core/js-mod"
                                 "cljs.core/es6-set-entries-iterator"
                                 "cljs.test/set-env!"
                                 "cljs.core/SetEntriesIterator"
                                 "cljs.core/loop"
                                 "cljs.core/subvec"
                                 "cljs.core/bit-clear"
                                 "cljs.core/gensym"
                                 "special/recur"
                                 "cljs.core/Symbol"
                                 "cljs.core/hash-string*"
                                 "cljs.core/shuffle"
                                 "cljs.core/+"
                                 "cljs.core/clone"
                                 "cljs.core/comp"
                                 "cljs.core/ArrayIter"
                                 "cljs.reader/desugar-meta"
                                 "cljs.core/pr"
                                 "cljs.test/run-tests"
                                 "clojure.string/upper-case"
                                 "cljs.core/chars"
                                 "clojure.browser.event/expose"
                                 "clojure.browser.event/listen-once"
                                 "cljs.core/m3-C1"
                                 "cljs.core/empty?"
                                 "cljs.core/m3-fmix"
                                 "cljs.core/newline"
                                 "cljs.core/PersistentHashMap"
                                 "cljs.core/replace"
                                 "cljs.core/rand"
                                 "cljs.core/add-watch"
                                 "cljs.core/cloneable?"
                                 "clojure.string/capitalize"
                                 "cljs.core/short"
                                 "cljs.core/replicate"
                                 "cljs.core/es6-entries-iterator"
                                 "special/do"
                                 "cljs.core/ArrayChunk"
                                 "cljs.core/sequential?"
                                 "cljs.core/underive"
                                 "cljs.core/PersistentArrayMapIterator"
                                 "cljs.core/get-method"
                                 "cljs.core/="
                                 "cljs.reader/deregister-default-tag-parser!"
                                 "cljs.core/defn-"
                                 "cljs.reader/read-symbol"
                                 "cljs.reader/push-back-reader"
                                 "cljs.core/deftype"
                                 "cljs.repl/print-doc"
                                 "cljs.core/longs"
                                 "cljs.core/Subvec"
                                 "cljs.core/if-some"
                                 "cljs.test/js-filename"
                                 "special/ns"
                                 "cljs.core/IReversible"
                                 "cljs.core/extend-protocol"
                                 "cljs.reader/read"
                                 "cljs.core/EmptyList"
                                 "cljs.core/specify!"
                                 "cljs.core/cat"
                                 "clojure.walk/postwalk"
                                 "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"
                                 "clojure.zip/edit"
                                 "cljs.core/unreduced"
                                 "cljs.core/re-seq"
                                 "cljs.reader/read-list"
                                 "cljs.core/IKVReduce"
                                 "cljs.core/Atom"
                                 "clojure.core.reducers/foldcat"
                                 "cljs.core/specify"
                                 "cljs.core/IMap"
                                 "cljs.core/pr-sequential-writer"
                                 "cljs.core/unchecked-multiply"
                                 "cljs.reader/read-vector"
                                 "clojure.set/join"
                                 "cljs.core/HashMap"
                                 "cljs.core/es6-iterable"
                                 "cljs.reader/int-pattern"
                                 "cljs.core/swap!"
                                 "cljs.core/dec"
                                 "cljs.core/EntriesIterator"
                                 "cljs.core/*clojurescript-version*"
                                 "clojure.core.reducers/fold"
                                 "cljs.core/StringBufferWriter"
                                 "clojure.browser.dom/remove-children"
                                 "cljs.core/BlackNode"
                                 "cljs.core/some->"
                                 "cljs.core/get-validator"
                                 "cljs.core/coll?"
                                 "cljs.core/unchecked-negate-int"
                                 "cljs.core/bit-or"
                                 "cljs.core/nfirst"
                                 "cljs.core/keep"
                                 "cljs.core/take"
                                 "cljs.core/PersistentHashSet.EMPTY"
                                 "cljs.core/cond"
                                 "cljs.core/bit-and"
                                 "cljs.core/MetaFn"
                                 "cljs.core/ObjMap.fromObject"
                                 "cljs.core/PersistentArrayMap"
                                 "clojure.browser.event/unique-event-id"
                                 "cljs.core/vswap!"
                                 "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                 "clojure.set/project"
                                 "cljs.core/int"
                                 "special/js*"
                                 "clojure.reflect/macroexpand"
                                 "clojure.string/trim-newline"
                                 "specialrepl/in-ns"
                                 "special/let*"
                                 "cljs.core/pr-seq-writer"
                                 "special/throw"
                                 "cljs.core/chunk-cons"
                                 "clojure.zip/insert-left"
                                 "cljs.core/*print-level*"
                                 "cljs.core/true?"
                                 "cljs.core/unchecked-substract-int"
                                 "clojure.browser.net/xpc-connection"
                                 "cljs.core/ES6EntriesIterator"
                                 "cljs.core/not"
                                 "cljs.core/js-obj"
                                 "cljs.core/complement"
                                 "cljs.core/spread"
                                 "cljs.core/unchecked-double"
                                 "cljs.core/keyword"
                                 "cljs.core/sort"
                                 "clojure.string/trim"
                                 "cljs.core/meta"
                                 "clojure.core.reducers/monoid"
                                 "cljs.core/time"
                                 "cljs.core/boolean"
                                 "cljs.reader/read-token"
                                 "cljs.core/update-in"
                                 "cljs.core/map-indexed"
                                 "cljs.core/IVolatile"
                                 "cljs.core/printf"
                                 "clojure.core.reducers/map"
                                 "cljs.core/IStack"
                                 "cljs.reader/parse-and-validate-timestamp"
                                 "cljs.core/ISorted"
                                 "cljs.test/file-and-line"
                                 "cljs.core/IIndexed"
                                 "clojure.browser.repl/repl-print"
                                 "clojure.browser.net/xpc-config-fields"
                                 "cljs.core/ISwap"
                                 "cljs.core/nnext"
                                 "cljs.core/*print-meta*"
                                 "cljs.reader/read-dispatch"
                                 "cljs.test/run-block"
                                 "cljs.core/distinct"
                                 "cljs.reader/wrapping-reader"
                                 "cljs.core/LazyTransformer"
                                 "cljs.core/double-array"
                                 "cljs.core/prn"
                                 "cljs.core/chunked-seq"
                                 "clojure.zip/leftmost"
                                 "cljs.core/nthrest"
                                 "cljs.core/js-in"
                                 "cljs.test/function?"
                                 "cljs.core/>="
                                 "clojure.browser.net/websocket-connection"
                                 "cljs.reader/macros"
                                 "cljs.core/doseq"
                                 "cljs.core/*"
                                 "cljs.core/into"
                                 "cljs.core/defmethod"
                                 "cljs.core/rest"
                                 "cljs.reader/unicode-4-pattern"
                                 "cljs.core/dotimes"
                                 "cljs.core/dedupe"
                                 "clojure.zip/lefts"
                                 "clojure.browser.dom/ensure-element"
                                 "cljs.core/defmacro"
                                 "cljs.core/remove"
                                 "cljs.test/test-all-vars"
                                 "cljs.core/set-print-fn!"
                                 "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                 "cljs.core/if-not"
                                 "cljs.core/string-iter"
                                 "cljs.test/assert-any"
                                 "specialrepl/require"
                                 "clojure.zip/path"
                                 "cljs.core/mapcat"
                                 "cljs.core/m3-mix-H1"
                                 "cljs.core/IWatchable"
                                 "cljs.core/PersistentHashMap.fromArray"
                                 "cljs.core/run!"
                                 "cljs.core/IndexedSeqIterator"
                                 "cljs.core/unchecked-inc-int"
                                 "cljs.test/testing-vars-str"
                                 "clojure.zip/rightmost"
                                 "cljs.core/PersistentArrayMap.EMPTY"
                                 "cljs.core/m3-C2"
                                 "cljs.test/compose-fixtures"
                                 "cljs.core/unchecked-subtract"
                                 "cljs.core/->"
                                 "cljs.core/remove-all-methods"
                                 "cljs.core/unchecked-add-int"
                                 "clojure.string/replace-first"
                                 "cljs.core/reduced?"
                                 "clojure.browser.dom/get-value"
                                 "clojure.core.reducers/CollFold"
                                 "cljs.nodejs/process"
                                 "cljs.core/some->>"
                                 "cljs.core/unchecked-inc"
                                 "cljs.core/not="
                                 "cljs.core/unchecked-subtract-int"
                                 "cljs.core/ex-data"
                                 "cljs.core/PersistentTreeMapSeq"
                                 "cljs.core/js-keys"
                                 "clojure.zip/seq-zip"
                                 "cljs.core/lazy-transformer"
                                 "cljs.core/random-sample"
                                 "cljs.core/IVector"
                                 "cljs.core/iter"
                                 "cljs.core/persistent!"
                                 "cljs.core/empty"
                                 "cljs.core/re-matches"
                                 "clojure.browser.dom/DOMBuilder"
                                 "cljs.core/extend-type"
                                 "cljs.core/ISeqable"
                                 "cljs.core/assoc"
                                 "clojure.browser.repl/xpc-connection"
                                 "cljs.core/IDerefWithTimeout"
                                 "cljs.core/multi-stepper"
                                 "clojure.core.reducers/cat"
                                 "cljs.core/unchecked-substract"
                                 "cljs.core/Iteration"
                                 "clojure.browser.repl/start-evaluator"
                                 "clojure.browser.event/unlisten"
                                 "cljs.test/is"
                                 "cljs.test/use-fixtures"
                                 "cljs.core/PersistentHashMap.fromArrays"
                                 "cljs.core/special-symbol?"
                                 "cljs.core/js-debugger"
                                 "cljs.core/format"
                                 "cljs.core/sorted-set"
                                 "cljs.core/fnil"
                                 "cljs.core/update"
                                 "cljs.core/this-as"
                                 "cljs.core/PersistentQueueSeq"
                                 "cljs.core/counted?"
                                 "clojure.string/trimr"
                                 "clojure.core.reducers/take"
                                 "cljs.core/force"
                                 "cljs.core/compare-and-set!"
                                 "cljs.core/set?"
                                 "cljs.core/hash-string"
                                 "cljs.core/unchecked-dec"
                                 "cljs.core/PersistentVector.EMPTY-NODE"
                                 "clojure.string/escape"
                                 "cljs.core/remove-watch"
                                 "cljs.core/m3-hash-unencoded-chars"
                                 "cljs.core/es6-iterator-seq"
                                 "cljs.core/IMultiFn"
                                 "clojure.browser.event/IEventType"
                                 "clojure.zip/end?"
                                 "cljs.test/clear-env!"
                                 "special/try"
                                 "cljs.test/test-all-vars-block"
                                 "clojure.set/superset?"
                                 "clojure.browser.net/IConnection"
                                 "cljs.core/let"
                                 "cljs.core/unchecked-divide-int"
                                 "cljs.core/dorun"
                                 "cljs.core/with-redefs"
                                 "cljs.core/SeqIter"
                                 "cljs.core/unsigned-bit-shift-right"
                                 "cljs.core/iterable?"
                                 "cljs.core/pr-str"
                                 "cljs.core/IPrintable"
                                 "cljs.core/defprotocol"
                                 "cljs.core/ints"
                                 "cljs.core/assert"
                                 "cljs.core/declare"
                                 "cljs.core/PersistentTreeMap.EMPTY"
                                 "cljs.core/fn?"
                                 "cljs.core/associative?"
                                 "cljs.core/IList"
                                 "cljs.core/list*"
                                 "cljs.core/PersistentArrayMap.fromArray"
                                 "cljs.core/reduce"
                                 "clojure.browser.event/has-listener"
                                 "cljs.core/unchecked-dec-int"
                                 "cljs.core/PersistentHashMap.EMPTY"
                                 "cljs.core/compare"
                                 "cljs.core/contains?"
                                 "cljs.core/Stepper"
                                 "cljs.core/prefer-method"
                                 "cljs.core/array-seq"
                                 "cljs.core/to-array-2d"
                                 "cljs.core/ICloneable"
                                 "cljs.core/*print-length*"
                                 "cljs.core/PersistentQueue"
                                 "cljs.core/drop-last"
                                 "cljs.core/array?"
                                 "cljs.core/PersistentVector.fromArray"
                                 "cljs.core/filterv"
                                 "cljs.core/IComparable"
                                 "cljs.reader/read-string"
                                 "cljs.reader/unicode-2-pattern"
                                 "cljs.core/Volatile"
                                 "cljs.core/check-string-hash-cache"
                                 "cljs.core/vector?"
                                 "cljs.core/defmulti"
                                 "cljs.core/Keyword"
                                 "cljs.core/List.EMPTY"
                                 "clojure.browser.event/dispatch-event"
                                 "cljs.core/ns-interns"
                                 "clojure.string/split-lines"
                                 "cljs.test/mapped-line-and-column"
                                 "cljs.core/areduce"
                                 "cljs.core/disj"
                                 "cljs.core/IEditableCollection"
                                 "cljs.core/unchecked-char"
                                 "cljs.core/keyword-identical?"
                                 "clojure.browser.net/event-types"
                                 "clojure.string/lower-case"
                                 "cljs.core/*print-fn*"
                                 "cljs.core/str"
                                 "cljs.core/ISequential"
                                 "cljs.core/key-test"
                                 "cljs.core/set"
                                 "cljs.core/obj-map"
                                 "special/def"
                                 "cljs.core/print"
                                 "cljs.core/ArrayNode"
                                 "cljs.core/type"
                                 "clojure.string/blank?"
                                 "cljs.reader/maybe-read-tagged-type"
                                 "cljs.core/IChunkedSeq"
                                 "clojure.browser.dom/append"
                                 "cljs.core/take-last"
                                 "cljs.core/key->js"
                                 "cljs.core/TransientHashMap"
                                 "clojure.set/intersection"
                                 "cljs.test/async?"
                                 "cljs.core/fnext"
                                 "cljs.core/apply"
                                 "clojure.walk/prewalk"
                                 "cljs.core/flatten"
                                 "cljs.core/get"
                                 "cljs.core/char"
                                 "cljs.core/.."
                                 "cljs.core/floats"
                                 "specialrepl/require-macros"
                                 "cljs.core/Range"
                                 "cljs.core/zero?"
                                 "cljs.core/identity"
                                 "cljs.core/first"
                                 "cljs.reader/ratio-pattern"
                                 "cljs.core/println-str"
                                 "cljs.core/>"
                                 "cljs.core/juxt"
                                 "cljs.core/max"
                                 "cljs.core/completing"
                                 "cljs.core/transduce"
                                 "cljs.test/test-var"
                                 "cljs.core/with-out-str"
                                 "cljs.core/*3"
                                 "cljs.core/memfn"
                                 "cljs.core/IEncodeClojure"
                                 "cljs.core/TransientArrayMap"
                                 "cljs.core/cond->>"
                                 "cljs.core/number?"
                                 "cljs.core/array"
                                 "cljs.core/nthnext"
                                 "cljs.core/re-pattern"
                                 "cljs.core/missing-protocol"
                                 "clojure.browser.dom/set-text"
                                 "cljs.test/js-line-and-column"
                                 "clojure.zip/up"
                                 "cljs.core/IWithMeta"
                                 "cljs.core/bit-and-not"
                                 "clojure.string/triml"
                                 "cljs.core/chunk-append"
                                 "cljs.core/regexp?"
                                 "clojure.string/split"
                                 "cljs.reader/read-4-chars"
                                 "cljs.core/iteration"
                                 "cljs.core/hash-map"
                                 "cljs.core/mapv"
                                 "cljs.core/rem"
                                 "cljs.core/IRecord"
                                 "cljs.core/RangedIterator"
                                 "cljs.core/volatile!"
                                 "cljs.core/constantly"
                                 "cljs.test/*current-env*"
                                 "clojure.browser.dom/get-element"
                                 "cljs.core/UUID"
                                 "clojure.core.reducers/reduce"
                                 "cljs.core/and"
                                 "clojure.browser.repl/wrap-message"
                                 "cljs.reader/deregister-tag-parser!"
                                 "clojure.reflect/print-doc"
                                 "clojure.browser.event/unlisten-by-key"
                                 "cljs.core/try"
                                 "cljs.core/iterate"
                                 "cljs.core/lazy-seq"
                                 "cljs.test/update-current-env!"
                                 "specialrepl/load-file"
                                 "cljs.core/IndexedSeq"
                                 "cljs.core/KeySeq"
                                 "cljs.core/next"
                                 "cljs.core/*print-readably*"
                                 "cljs.core/booleans"
                                 "cljs.core/not-native"
                                 "cljs.core/last"
                                 "cljs.core/pr-str*"
                                 "cljs.core/bit-shift-left"
                                 "clojure.string/reverse"
                                 "cljs.core/min"
                                 "cljs.reader/escape-char"
                                 "cljs.reader/read-raw-string*"
                                 "cljs.core/INext"
                                 "cljs.reader/read-map"
                                 "cljs.core/seq"
                                 "cljs.core/*print-newline*"
                                 "cljs.core/long"
                                 "cljs.core/es6-iterator"
                                 "cljs.core/not-empty"
                                 "cljs.core/println"
                                 "clojure.browser.repl/connect"
                                 "cljs.core/bytes"
                                 "cljs.core/unchecked-byte"
                                 "clojure.browser.dom/insert-at"
                                 "cljs.core/quot"
                                 "clojure.browser.event/get-listener"
                                 "cljs.core/filter"
                                 "cljs.core/RSeq"
                                 "clojure.zip/branch?"
                                 "special/if"
                                 "cljs.core/ObjMap"
                                 "cljs.core/sequence"
                                 "cljs.core/zipmap"
                                 "cljs.core/hash-combine"
                                 "cljs.core/reversible?"
                                 "clojure.core.reducers/flatten"
                                 "cljs.core/max-key"
                                 "clojure.zip/insert-child"
                                 "cljs.core/defrecord"
                                 "cljs.core/eduction"
                                 "cljs.core/ex-info"
                                 "cljs.core/butlast"
                                 "cljs.core/array-iter"
                                 "cljs.core/print-str"
                                 "cljs.core/hash"
                                 "cljs.core/bit-set"
                                 "cljs.core/clj->js"
                                 "cljs.core/concat"
                                 "cljs.test/IAsyncTest"
                                 "cljs.core/conj"
                                 "cljs.core/unchecked-short"
                                 "clojure.set/difference"
                                 "cljs.core/byte"
                                 "cljs.core/when-first"
                                 "cljs.reader/*tag-table*"
                                 "cljs.core/distinct?"
                                 "clojure.core.reducers/filter"
                                 "cljs.core/INamed"
                                 "cljs.core/add-to-string-hash-cache"
                                 "cljs.core/HashCollisionNode"
                                 "cljs.core/m3-mix-K1"
                                 "cljs.core/object?"
                                 "cljs.core/pos?"
                                 "cljs.test/block"
                                 "cljs.core/into-array"
                                 "cljs.core/PersistentVector"
                                 "cljs.core/IHash"
                                 "clojure.reflect/doc"
                                 "cljs.core/is_proto_"
                                 "cljs.core/shorts"
                                 "cljs.core/TransientVector"
                                 "cljs.core/keep-indexed"
                                 "cljs.core/bit-shift-right"
                                 "cljs.core/comparator"
                                 "cljs.core/ES6Iterator"
                                 "cljs.core/PersistentTreeSet"
                                 "clojure.zip/insert-right"
                                 "cljs.core/make-hierarchy"
                                 "cljs.core/repeat"
                                 "cljs.core/array-list"
                                 "cljs.core/prn-str-with-opts"
                                 "cljs.core/MultiFn"
                                 "cljs.test/successful?"
                                 "cljs.core/hash-keyword"
                                 "cljs.test/run-tests-block"
                                 "cljs.core/Reduced"
                                 "cljs.core/not-any?"
                                 "cljs.reader/read-regex"
                                 "clojure.zip/next"
                                 "cljs.test/async"
                                 "cljs.core/IFn"
                                 "cljs.core/aget"
                                 "cljs.core/if-let"
                                 "cljs.core//"
                                 "cljs.core/unchecked-int"
                                 "cljs.core/min-key"
                                 "clojure.zip/root"
                                 "cljs.core/drop-while"
                                 "clojure.browser.repl/evaluate-javascript"
                                 "cljs.core/set-validator!"
                                 "cljs.core/<"
                                 "cljs.core/fn"
                                 "cljs.core/split-with"
                                 "cljs.core/IWriter"
                                 "cljs.core/IReduce"
                                 "cljs.reader/symbol-pattern"
                                 "cljs.core/PersistentHashSet.fromArray"
                                 "cljs.core/repeatedly"
                                 "cljs.reader/read-delimited-list"
                                 "cljs.test/inc-report-counter!"
                                 "cljs.core/undefined?"
                                 "clojure.zip/prev"
                                 "cljs.core/seq?"
                                 "cljs.core/prn-str"
                                 "cljs.core/chunk-buffer"
                                 "cljs.core/odd?"
                                 "cljs.core/cons"
                                 "special/deftype*"
                                 "cljs.reader/read-set"
                                 "cljs.core/descendants"
                                 "special/new"
                                 "cljs.core/take-nth"
                                 "cljs.reader/throwing-reader"
                                 "cljs.core/double"
                                 "cljs.core/even?"
                                 "cljs.core/simple-benchmark"
                                 "cljs.core/persistent-array-map-seq"
                                 "special/fn*"
                                 "clojure.set/subset?"
                                 "cljs.core/flush"
                                 "cljs.core/long-array"
                                 "cljs.reader/reader-error"
                                 "clojure.walk/prewalk-replace"
                                 "cljs.core/*1"
                                 "cljs.core/subseq"
                                 "cljs.core/Eduction"
                                 "cljs.core/Set.EMPTY"
                                 "cljs.reader/read-unicode-char"
                                 "cljs.core/dissoc"
                                 "cljs.core/exists?"
                                 "cljs.core/ffirst"
                                 "clojure.zip/replace"
                                 "cljs.core/vec"
                                 "cljs.core/or"
                                 "cljs.core/doubles"
                                 "cljs.core/mod"
                                 "cljs.core/aset"
                                 "cljs.core/second"
                                 "cljs.core/IChunkedNext"
                                 "cljs.core/bit-count"
                                 "clojure.set/rename"
                                 "cljs.core/m3-hash-int"
                                 "cljs.core/assoc!"
                                 "cljs.test/get-and-clear-env!"
                                 "cljs.core/delay?"
                                 "clojure.zip/left"
                                 "cljs.reader/not-implemented"
                                 "cljs.core/IAssociative"
                                 "cljs.core/ObjMap.EMPTY"
                                 "cljs.core/group-by"
                                 "special/case*"
                                 "cljs.reader/*default-data-reader-fn*"
                                 "cljs.core/*e"
                                 "cljs.core/sorted-map-by"
                                 "cljs.core/symbol"
                                 "cljs.core/volatile?"
                                 "cljs.core/Delay"
                                 "cljs.core/methods"
                                 "cljs.test/test-vars"
                                 "cljs.core/lazy-cat"
                                 "cljs.core/vector"
                                 "cljs.core/rand-int"
                                 "cljs.core/m3-seed"
                                 "cljs.core/PersistentQueue.EMPTY"
                                 "cljs.core/unchecked-float"
                                 "clojure.core.reducers/append!"
                                 "cljs.core/NodeSeq"
                                 "cljs.core/letfn"
                                 "cljs.reader/read-discard"
                                 "cljs.core/gen-apply-to"
                                 "cljs.core/inc"
                                 "cljs.core/name"
                                 "cljs.test/test-ns-block"
                                 "cljs.core/cycle"
                                 "cljs.core/rsubseq"
                                 "cljs.core/divide"
                                 "cljs.core/hash-ordered-coll"
                                 "cljs.core/nil-iter"
                                 "cljs.test/run-all-tests"
                                 "cljs.core/map"
                                 "cljs.core/ChunkBuffer"
                                 "cljs.core/amap"
                                 "clojure.zip/children"
                                 "special/set!"
                                 "cljs.core/when-not"
                                 "clojure.set/index"
                                 "cljs.core/chunked-seq?"
                                 "clojure.browser.dom/log"
                                 "cljs.core/Vector.fromArray"
                                 "cljs.core/make-array"
                                 "cljs.core/sorted-set-by"
                                 "cljs.core/partition-by"
                                 "cljs.core/sort-by"
                                 "cljs.core/with-meta"
                                 "cljs.core/NeverEquiv"
                                 "cljs.core/select-keys"
                                 "special/loop*"
                                 "cljs.core/ISeq"
                                 "cljs.core/disj!"
                                 "cljs.test/try-expr"
                                 "cljs.core/type->str"
                                 "clojure.walk/postwalk-replace"
                                 "cljs.core/ES6SetEntriesIterator"
                                 "cljs.core/pr-with-opts"
                                 "cljs.core/->>"
                                 "cljs.core/defonce"
                                 "cljs.core/nil?"
                                 "cljs.core/load-file*"
                                 "clojure.walk/stringify-keys"
                                 "clojure.browser.repl/order"
                                 "cljs.core/memoize"
                                 "cljs.core/pr-sequential"
                                 "clojure.zip/make-node"
                                 "cljs.core/PersistentVector.EMPTY"
                                 "specialrepl/load-namespace"
                                 "cljs.reader/float-pattern"
                                 "cljs.core/ancestors"
                                 "cljs.core/integer?"
                                 "cljs.core/HashMap.EMPTY"
                                 "cljs.core/Vector.EMPTY"
                                 "clojure.zip/xml-zip"
                                 "clojure.walk/walk"
                                 "cljs.core/ifn?"
                                 "cljs.core/bit-xor"
                                 "clojure.set/union"
                                 "cljs.core/case"
                                 "cljs.reader/PushbackReader"
                                 "cljs.core/isa?"
                                 "cljs.pprint/PrettyFlush"
                                 "clojure.browser.net/xhr-connection"
                                 "cljs.core/as->"
                                 "clojure.core.reducers/reducer"
                                 "cljs.core/subs"
                                 "cljs.core/symbol?"
                                 "clojure.data/Diff"
                                 "clojure.string/replace"
                                 "cljs.core/string?"
                                 "cljs.core/partition-all"
                                 "cljs.core/Var"
                                 "cljs.core/RedNode"
                                 "cljs.core/ExceptionInfo"
                                 "cljs.core/merge-with"
                                 "cljs.core/key"
                                 "clojure.browser.dom/set-properties"
                                 "clojure.data/diff"
                                 "cljs.core/ITransientAssociative"
                                 "cljs.core/trampoline"
                                 "cljs.test/test-ns"
                                 "cljs.core/implements?"
                                 "clojure.browser.repl/send-print"
                                 "cljs.core/ICounted"
                                 "cljs.core/IEquiv"
                                 "cljs.core/reduce-kv"
                                 "cljs.core/js-delete"
                                 "cljs.core/PersistentTreeSet.EMPTY"
                                 "cljs.core/comment"
                                 "cljs.reader/special-symbols"
                                 "cljs.core/BitmapIndexedNode.EMPTY"
                                 "cljs.reader/register-default-tag-parser!"
                                 "cljs.core/alength"
                                 "cljs.core/mk-bound-fn"
                                 "cljs.reader/validate-unicode-escape"
                                 "special/quote"
                                 "cljs.core/VectorNode"
                                 "cljs.core/string-hash-cache-count"
                                 "cljs.core/tree-seq"
                                 "cljs.reader/read-unmatched-delimiter"
                                 "clojure.core.reducers/take-while"
                                 "cljs.reader/register-tag-parser!"
                                 "cljs.core/every-pred"
                                 "special/var"
                                 "cljs.core/PersistentHashSet"
                                 "cljs.repl/doc"
                                 "clojure.set/rename-keys"
                                 "cljs.core/peek"
                                 "cljs.core/pr-str-with-opts"
                                 "cljs.core/IChunk"
                                 "cljs.core/ITransientVector"
                                 "cljs.core/IPrintWithWriter"
                                 "cljs.core/test"
                                 "cljs.core/map?"
                                 "cljs.reader/StringPushbackReader"
                                 "cljs.core/PersistentTreeMap"
                                 "cljs.core/HashMap.fromArrays"
                                 "cljs.core/deref"
                                 "cljs.core/reductions"
                                 "cljs.core/false?"
                                 "cljs.core/bit-flip"
                                 "cljs.test/deftest"
                                 "cljs.core/ISet"
                                 "cljs.core/StringIter"
                                 "cljs.core/LazySeq"
                                 "cljs.core/pop!"
                                 "cljs.reader/parse-timestamp"
                                 "cljs.core/chunk-first"
                                 "cljs.core/ChunkedSeq"
                                 "cljs.test/testing"
                                 "cljs.core/*2"
                                 "cljs.test/ns?"
                                 "clojure.browser.event/total-listener-count"
                                 "cljs.core/MultiStepper"
                                 "cljs.core/alter-meta!"
                                 "clojure.browser.dom/click-element"
                                 "cljs.core/seq-iter"
                                 "cljs.core/unchecked-remainder-int"
                                 "cljs.core/bit-shift-right-zero-fill"
                                 "cljs.core/when-some"
                                 "cljs.reader/read-meta"
                                 "special/try*"
                                 "cljs.test/test-var-block"
                                 "cljs.core/range"
                                 "cljs.core/reify"
                                 "cljs.core/satisfies?"
                                 "cljs.core/nth"
                                 "cljs.core/list"
                                 "cljs.core/defn"
                                 "cljs.core/rand-nth"
                                 "cljs.core/ex-cause"
                                 "cljs.core/atom"
                                 "cljs.reader/read-keyword"
                                 "cljs.core/Vector"
                                 "cljs.reader/skip-line"
                                 "cljs.core/namespace"
                                 "cljs.nodejs/require"
                                 "cljs.core/chunk-rest"
                                 "cljs.core/unchecked-long"
                                 "clojure.browser.event/EventType"
                                 "cljs.core/ranged-iterator"
                                 "cljs.core/merge"
                                 "clojure.core.reducers/remove"
                                 "cljs.core/set-entries-iterator"
                                 "clojure.browser.repl/send-result"
                                 "clojure.walk/keywordize-keys"
                                 "cljs.core/entries-iterator"
                                 "cljs.core/reduced"
                                 "cljs.reader/read-string*"
                                 "cljs.core/ChunkedCons"
                                 "cljs.core/derive"
                                 "clojure.zip/zipper"
                                 "cljs.test/empty-env"
                                 "clojure.core.reducers/mapcat"
                                 "clojure.zip/remove"
                                 "cljs.core/find"
                                 "cljs.core/hash-set"
                                 "cljs.core/*print-dup*"
                                 "cljs.core/set-from-indexed-seq"
                                 "cljs.core/object-array"
                                 "cljs.core/indexed?"
                                 "cljs.core/partial"
                                 "cljs.core/keyword?"
                                 "clojure.browser.event/fire-listeners"
                                 "cljs.core/Iterator"
                                 "cljs.core/vreset!"
                                 "cljs.core/interleave"
                                 "cljs.core/TransientHashSet"
                                 "cljs.core/*flush-on-newline*"
                                 "cljs.core/get-in"
                                 "clojure.browser.dom/element"
                                 "cljs.core/prim-seq"
                                 "cljs.core/<="
                                 "clojure.set/map-invert"
                                 "clojure.browser.event/listen"
                                 "cljs.core/neg?"
                                 "cljs.core/mix-collection-hash"
                                 "clojure.browser.dom/replace-node"
                                 "special/catch"
                                 "cljs.core/reverse"
                                 "cljs.core/realized?"
                                 "cljs.core/ensure-reduced"}},
       :compiler {:changes [{:cljs-version "0.0-927",
                             :cljs-date "2012-01-20",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790",
                             :added #{"cljs.repl.rhino/current-repl-env"
                                      "cljs.repl/evaluate-form"
                                      "cljs.repl/load-stream"
                                      "cljs.repl.browser/read-get"
                                      "cljs.repl.browser/load-javascript"
                                      "cljs.repl.browser/add-in-order"
                                      "cljs.repl/load-namespace"
                                      "cljs.repl.rhino/loaded-libs"
                                      "cljs.repl.browser/run-in-order"
                                      "cljs.repl.browser/compile-client-js"
                                      "cljs.repl.browser/handle-get"
                                      "cljs.repl.browser/stop-server"
                                      "cljs.repl.browser/read-request"
                                      "cljs.repl/load-file"
                                      "cljs.repl.browser/browser-eval"
                                      "cljs.repl.browser/server-state"
                                      "cljs.repl.browser/send-for-eval"
                                      "cljs.repl.browser/constrain-order"
                                      "cljs.repl.rhino/rhino-eval"
                                      "cljs.repl.browser/read-headers"
                                      "cljs.repl/repl"
                                      "cljs.repl.rhino/load-javascript"
                                      "cljs.repl.browser/create-client-js-file"
                                      "cljs.repl/*cljs-verbose*"
                                      "cljs.repl.browser/loaded-libs"
                                      "cljs.repl.browser/repl-client-js"
                                      "cljs.repl.browser/parse-headers"
                                      "cljs.repl.browser/send-404"
                                      "cljs.repl.browser/repl-env"
                                      "cljs.repl.rhino/repl-env"
                                      "cljs.repl.rhino/goog-require"
                                      "cljs.repl.browser/send-repl-client-page"
                                      "cljs.repl.browser/send-and-close"
                                      "cljs.repl.rhino/bootjs"
                                      "cljs.repl/IJavaScriptEnv"
                                      "cljs.repl.browser/handle-connection"
                                      "cljs.repl.rhino/IEval"
                                      "cljs.repl.browser/start-server"
                                      "cljs.repl.browser/server-loop"
                                      "cljs.repl.browser/read-post"
                                      "cljs.repl.rhino/rhino-setup"
                                      "cljs.repl.browser/ordering"}}
                            {:cljs-version "0.0-971",
                             :cljs-date "2012-01-27",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-993",
                             :cljs-date "2012-02-27",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790",
                             :added #{"cljs.repl/default-special-fns"}}
                            {:cljs-version "0.0-1006",
                             :cljs-date "2012-03-30",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-1011",
                             :cljs-date "2012-04-02",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-1211",
                             :cljs-date "2012-05-09",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376",
                             :added #{"cljs.repl.browser/send-static"}}
                            {:cljs-version "0.0-1236",
                             :cljs-date "2012-05-16",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1424",
                             :cljs-date "2012-06-16",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376",
                             :added #{"cljs.repl.browser/preloaded-libs"}}
                            {:cljs-version "0.0-1443",
                             :cljs-date "2012-07-06",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1449",
                             :cljs-date "2012-07-24",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1450",
                             :cljs-date "2012-07-25",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1503",
                             :cljs-date "2012-10-12",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376",
                             :added #{"cljs.repl.server/handlers"
                                      "cljs.repl.server/dispatch-on"
                                      "cljs.repl.server/start"
                                      "cljs.repl.reflect/parse-param"
                                      "cljs.repl/analyze-source"
                                      "cljs.repl.server/state"
                                      "cljs.repl.reflect/macroexpand"
                                      "cljs.repl.server/read-request"
                                      "cljs.repl.server/set-connection"
                                      "cljs.repl.server/read-post"
                                      "cljs.repl.server/parse-headers"
                                      "cljs.repl.server/stop"
                                      "cljs.repl.server/read-get"
                                      "cljs.repl.reflect/read-url-string"
                                      "cljs.repl.browser/browser-state"
                                      "cljs.repl.server/read-headers"
                                      "cljs.repl.server/send-and-close"
                                      "cljs.repl.server/send-404"
                                      "cljs.repl.server/connection"},
                             :removed #{"cljs.repl.browser/read-get"
                                        "cljs.repl.browser/handle-get"
                                        "cljs.repl.browser/stop-server"
                                        "cljs.repl.browser/read-request"
                                        "cljs.repl.browser/server-state"
                                        "cljs.repl.browser/read-headers"
                                        "cljs.repl.browser/parse-headers"
                                        "cljs.repl.browser/send-404"
                                        "cljs.repl.browser/send-and-close"
                                        "cljs.repl.browser/handle-connection"
                                        "cljs.repl.browser/start-server"
                                        "cljs.repl.browser/server-loop"
                                        "cljs.repl.browser/read-post"}}
                            {:cljs-version "0.0-1513",
                             :cljs-date "2012-10-19",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1535",
                             :cljs-date "2012-11-08",
                             :clj-version "1.4.0",
                             :gclosure-lib "20120710-r2029"}
                            {:cljs-version "0.0-1552",
                             :cljs-date "2012-12-03",
                             :clj-version "1.4.0",
                             :gclosure-lib "20120710-r2029"}
                            {:cljs-version "0.0-1576",
                             :cljs-date "2013-01-27",
                             :clj-version "1.4.0",
                             :gclosure-lib "20120710-r2029",
                             :removed #{"cljs.repl.rhino/loaded-libs"}}
                            {:cljs-version "0.0-1586",
                             :cljs-date "2013-02-16",
                             :clj-version "1.4.0",
                             :gclosure-lib "20120710-r2029"}
                            {:cljs-version "0.0-1798",
                             :cljs-date "2013-05-03",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1803",
                             :cljs-date "2013-05-06",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1806",
                             :cljs-date "2013-05-10",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1820",
                             :cljs-date "2013-06-07",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1835",
                             :cljs-date "2013-06-21",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1843",
                             :cljs-date "2013-07-16",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1844",
                             :cljs-date "2013-07-19",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1847",
                             :cljs-date "2013-07-23",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f"}
                            {:cljs-version "0.0-1853",
                             :cljs-date "2013-08-05",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.5"}
                            {:cljs-version "0.0-1859",
                             :cljs-date "2013-08-19",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1877",
                             :cljs-date "2013-09-08",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1878",
                             :cljs-date "2013-09-11",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1885",
                             :cljs-date "2013-09-15",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1886",
                             :cljs-date "2013-09-15",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1889",
                             :cljs-date "2013-09-15",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1895",
                             :cljs-date "2013-09-24",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1896",
                             :cljs-date "2013-09-24",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1909",
                             :cljs-date "2013-09-27",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.8"}
                            {:cljs-version "0.0-1913",
                             :cljs-date "2013-10-05",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.8"}
                            {:cljs-version "0.0-1933",
                             :cljs-date "2013-10-11",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.9"}
                            {:cljs-version "0.0-1934",
                             :cljs-date "2013-10-11",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.9"}
                            {:cljs-version "0.0-1978",
                             :cljs-date "2013-10-28",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2014",
                             :cljs-date "2013-11-06",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2024",
                             :cljs-date "2013-11-08",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2027",
                             :cljs-date "2013-11-08",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2030",
                             :cljs-date "2013-11-08",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2060",
                             :cljs-date "2013-11-21",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2067",
                             :cljs-date "2013-11-22",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2069",
                             :cljs-date "2013-11-22",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2075",
                             :cljs-date "2013-11-23",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2080",
                             :cljs-date "2013-11-23",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2120",
                             :cljs-date "2013-12-13",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2127",
                             :cljs-date "2013-12-20",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2134",
                             :cljs-date "2013-12-30",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2138",
                             :cljs-date "2013-12-31",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2156",
                             :cljs-date "2014-01-29",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2173",
                             :cljs-date "2014-02-22",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2197",
                             :cljs-date "2014-03-26",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2199",
                             :cljs-date "2014-04-01",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2202",
                             :cljs-date "2014-04-02",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2227",
                             :cljs-date "2014-05-22",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2234",
                             :cljs-date "2014-06-13",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2261",
                             :cljs-date "2014-07-02",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140226-71326067",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2268",
                             :cljs-date "2014-07-06",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140226-71326067",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2277",
                             :cljs-date "2014-07-25",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140226-71326067",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2280",
                             :cljs-date "2014-08-01",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2301",
                             :cljs-date "2014-08-07",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2307",
                             :cljs-date "2014-08-07",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2311",
                             :cljs-date "2014-08-09",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2322",
                             :cljs-date "2014-08-27",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2341",
                             :cljs-date "2014-09-18",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2342",
                             :cljs-date "2014-09-18",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.9"}
                            {:cljs-version "0.0-2356",
                             :cljs-date "2014-09-26",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.9"}
                            {:cljs-version "0.0-2371",
                             :cljs-date "2014-10-10",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.9"}
                            {:cljs-version "0.0-2411",
                             :cljs-date "2014-12-05",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2496",
                             :cljs-date "2014-12-17",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.build.api/cljs-dependents-for-macro-namespaces"
                                      "cljs.analyzer.api/find-ns"
                                      "cljs.build.api/target-file-for-cljs-ns"
                                      "cljs.analyzer.api/ns-resolve"
                                      "cljs.build.api/mark-cljs-ns-for-recompile!"
                                      "cljs.analyzer.api/all-ns"
                                      "cljs.repl/doc"
                                      "cljs.analyzer.api/resolve"
                                      "cljs.analyzer.api/ns-interns"}}
                            {:cljs-version "0.0-2498",
                             :cljs-date "2014-12-19",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2505",
                             :cljs-date "2014-12-21",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2511",
                             :cljs-date "2014-12-22",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2629",
                             :cljs-date "2015-01-01",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.build.api/parse-js-ns"
                                      "cljs.repl.node/socket"
                                      "cljs.repl.node/close-socket"
                                      "cljs.repl/repl*"
                                      "cljs.repl.node/load-javascript"
                                      "cljs.repl/update-require-spec"
                                      "cljs.build.api/src-file->target-file"
                                      "cljs.repl/merge-require"
                                      "cljs.repl.node/read-response"
                                      "cljs.repl/merge-spec"
                                      "cljs.repl/spec-sort"
                                      "cljs.build.api/cljs-ns-dependents"
                                      "cljs.analyzer.api/ns-specs"
                                      "cljs.repl.node/repl-env"
                                      "cljs.analyzer.api/in-cljs-user"
                                      "cljs.repl.node/setup"
                                      "cljs.repl.node/node-eval"
                                      "cljs.build.api/src-file->goog-require"
                                      "cljs.repl.node/write"
                                      "cljs.repl.node/repl-env*"},
                             :removed #{"cljs.repl.rhino/current-repl-env"}}
                            {:cljs-version "0.0-2644",
                             :cljs-date "2015-01-02",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2655",
                             :cljs-date "2015-01-03",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :removed #{"cljs.repl/update-require-spec"
                                        "cljs.repl/merge-require"
                                        "cljs.repl/merge-spec"
                                        "cljs.repl/spec-sort"
                                        "cljs.analyzer.api/ns-specs"}}
                            {:cljs-version "0.0-2657",
                             :cljs-date "2015-01-03",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2665",
                             :cljs-date "2015-01-04",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl.browser/setup"}}
                            {:cljs-version "0.0-2719",
                             :cljs-date "2015-01-24",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl/with-read-known"
                                      "cljs.repl/IReplEnvOptions"
                                      "cljs.repl/skip-whitespace"
                                      "cljs.repl/repl-read"
                                      "cljs.repl/skip-if-eol"}}
                            {:cljs-version "0.0-2723",
                             :cljs-date "2015-01-24",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2725",
                             :cljs-date "2015-01-24",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2727",
                             :cljs-date "2015-01-25",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2740",
                             :cljs-date "2015-01-28",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2755",
                             :cljs-date "2015-02-01",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2758",
                             :cljs-date "2015-02-02",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2760",
                             :cljs-date "2015-02-02",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2814",
                             :cljs-date "2015-02-10",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl.nashorn/repl-filename"
                                      "cljs.repl.nashorn/eval-resource"
                                      "cljs.repl/js-src->cljs-src"
                                      "cljs.repl/print-mapped-stacktrace"
                                      "cljs.repl.node/platform-path"
                                      "cljs.repl.nashorn/eval-str"
                                      "cljs.repl.nashorn/create-engine"
                                      "cljs.repl.nashorn/load-ns"
                                      "cljs.repl.nashorn/load-js-file"
                                      "cljs.repl.nashorn/init-engine"
                                      "cljs.repl.nashorn/bootstrap-repl"
                                      "cljs.repl.node/seq->js-array"
                                      "cljs.repl.nashorn/repl-env"
                                      "cljs.repl/mapped-line-and-column"
                                      "cljs.repl/ns-info"
                                      "cljs.repl/read-source-map"}}
                            {:cljs-version "0.0-2816",
                             :cljs-date "2015-02-10",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2843",
                             :cljs-date "2015-02-12",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl/IPrintStacktrace"
                                      "cljs.repl/IParseStacktrace"
                                      "cljs.repl/mapped-stacktrace"}}
                            {:cljs-version "0.0-2850",
                             :cljs-date "2015-02-13",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2911",
                             :cljs-date "2015-02-21",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl/self-require?"
                                      "cljs.repl/repl-prompt"
                                      "cljs.repl/*repl-opts*"
                                      "cljs.repl/repl-caught"},
                             :removed #{"cljs.repl/with-read-known"}}],
                  :symbol-names #{"cljs.repl.nashorn/repl-filename"
                                  "cljs.repl.rhino/current-repl-env"
                                  "cljs.build.api/cljs-dependents-for-macro-namespaces"
                                  "cljs.repl/self-require?"
                                  "cljs.repl/with-read-known"
                                  "cljs.repl/evaluate-form"
                                  "cljs.build.api/parse-js-ns"
                                  "cljs.repl/load-stream"
                                  "cljs.repl/repl-prompt"
                                  "cljs.repl.node/socket"
                                  "cljs.repl.browser/read-get"
                                  "cljs.repl.node/close-socket"
                                  "cljs.repl.browser/load-javascript"
                                  "cljs.repl/repl*"
                                  "cljs.repl.browser/add-in-order"
                                  "cljs.repl.server/handlers"
                                  "cljs.repl.node/load-javascript"
                                  "cljs.repl/load-namespace"
                                  "cljs.analyzer.api/find-ns"
                                  "cljs.repl.rhino/loaded-libs"
                                  "cljs.repl.server/dispatch-on"
                                  "cljs.repl.browser/run-in-order"
                                  "cljs.repl.browser/compile-client-js"
                                  "cljs.repl.server/start"
                                  "cljs.repl.browser/handle-get"
                                  "cljs.repl.nashorn/eval-resource"
                                  "cljs.repl/js-src->cljs-src"
                                  "cljs.repl.reflect/parse-param"
                                  "cljs.repl/print-mapped-stacktrace"
                                  "cljs.repl/analyze-source"
                                  "cljs.repl.browser/stop-server"
                                  "cljs.repl/*repl-opts*"
                                  "cljs.repl.browser/read-request"
                                  "cljs.build.api/target-file-for-cljs-ns"
                                  "cljs.repl.server/state"
                                  "cljs.repl.reflect/macroexpand"
                                  "cljs.repl.node/platform-path"
                                  "cljs.repl.server/read-request"
                                  "cljs.repl/load-file"
                                  "cljs.repl.nashorn/eval-str"
                                  "cljs.repl.browser/browser-eval"
                                  "cljs.repl.browser/server-state"
                                  "cljs.repl.browser/send-for-eval"
                                  "cljs.repl.browser/constrain-order"
                                  "cljs.repl/default-special-fns"
                                  "cljs.repl.rhino/rhino-eval"
                                  "cljs.repl.browser/read-headers"
                                  "cljs.repl/IReplEnvOptions"
                                  "cljs.repl.server/set-connection"
                                  "cljs.analyzer.api/ns-resolve"
                                  "cljs.repl/update-require-spec"
                                  "cljs.repl/repl"
                                  "cljs.repl.nashorn/create-engine"
                                  "cljs.build.api/src-file->target-file"
                                  "cljs.repl.rhino/load-javascript"
                                  "cljs.repl/merge-require"
                                  "cljs.repl.nashorn/load-ns"
                                  "cljs.repl.browser/create-client-js-file"
                                  "cljs.repl/*cljs-verbose*"
                                  "cljs.repl.server/read-post"
                                  "cljs.repl.browser/loaded-libs"
                                  "cljs.repl.nashorn/load-js-file"
                                  "cljs.repl.browser/setup"
                                  "cljs.repl/skip-whitespace"
                                  "cljs.repl/IPrintStacktrace"
                                  "cljs.repl.nashorn/init-engine"
                                  "cljs.repl.server/parse-headers"
                                  "cljs.repl.node/read-response"
                                  "cljs.repl.browser/repl-client-js"
                                  "cljs.repl.browser/parse-headers"
                                  "cljs.repl.browser/send-404"
                                  "cljs.repl.browser/repl-env"
                                  "cljs.repl.nashorn/bootstrap-repl"
                                  "cljs.repl/merge-spec"
                                  "cljs.repl.rhino/repl-env"
                                  "cljs.repl.node/seq->js-array"
                                  "cljs.repl.server/stop"
                                  "cljs.repl.rhino/goog-require"
                                  "cljs.repl/spec-sort"
                                  "cljs.repl.server/read-get"
                                  "cljs.repl.browser/send-repl-client-page"
                                  "cljs.repl.reflect/read-url-string"
                                  "cljs.repl.browser/preloaded-libs"
                                  "cljs.build.api/mark-cljs-ns-for-recompile!"
                                  "cljs.repl.browser/browser-state"
                                  "cljs.repl.browser/send-static"
                                  "cljs.build.api/cljs-ns-dependents"
                                  "cljs.analyzer.api/ns-specs"
                                  "cljs.repl.nashorn/repl-env"
                                  "cljs.repl/mapped-line-and-column"
                                  "cljs.repl.server/read-headers"
                                  "cljs.analyzer.api/all-ns"
                                  "cljs.repl/repl-read"
                                  "cljs.repl/repl-caught"
                                  "cljs.repl.browser/send-and-close"
                                  "cljs.repl/ns-info"
                                  "cljs.repl.node/repl-env"
                                  "cljs.repl/skip-if-eol"
                                  "cljs.analyzer.api/in-cljs-user"
                                  "cljs.repl.rhino/bootjs"
                                  "cljs.repl/IJavaScriptEnv"
                                  "cljs.repl/IParseStacktrace"
                                  "cljs.repl.browser/handle-connection"
                                  "cljs.repl.node/setup"
                                  "cljs.repl/doc"
                                  "cljs.repl.node/node-eval"
                                  "cljs.repl/mapped-stacktrace"
                                  "cljs.repl.rhino/IEval"
                                  "cljs.analyzer.api/resolve"
                                  "cljs.repl.browser/start-server"
                                  "cljs.repl.server/send-and-close"
                                  "cljs.repl.browser/server-loop"
                                  "cljs.repl.server/send-404"
                                  "cljs.repl.browser/read-post"
                                  "cljs.repl.server/connection"
                                  "cljs.repl.rhino/rhino-setup"
                                  "cljs.build.api/src-file->goog-require"
                                  "cljs.repl.node/write"
                                  "cljs.repl/read-source-map"
                                  "cljs.repl.node/repl-env*"
                                  "cljs.analyzer.api/ns-interns"
                                  "cljs.repl.browser/ordering"}}}}
